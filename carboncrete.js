var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJSMin = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), __copyProps = (e, a, s, c) => {
	if (a && typeof a == "object" || typeof a == "function") for (var l = __getOwnPropNames(a), u = 0, d = l.length, f; u < d; u++) f = l[u], !__hasOwnProp.call(e, f) && f !== s && __defProp(e, f, {
		get: ((e) => a[e]).bind(null, f),
		enumerable: !(c = __getOwnPropDesc(a, f)) || c.enumerable
	});
	return e;
}, __toESM = (n, i, o) => (o = n == null ? {} : __create(__getProtoOf(n)), __copyProps(i || !n || !n.__esModule ? __defProp(o, "default", {
	value: n,
	enumerable: !0
}) : o, n)), require_react_production = /* @__PURE__ */ __commonJSMin(((e) => {
	var t = Symbol.for("react.transitional.element"), n = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), c = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), p = Symbol.for("react.activity"), m = Symbol.iterator;
	function h(e) {
		return typeof e != "object" || !e ? null : (e = m && e[m] || e["@@iterator"], typeof e == "function" ? e : null);
	}
	var g = {
		isMounted: function() {
			return !1;
		},
		enqueueForceUpdate: function() {},
		enqueueReplaceState: function() {},
		enqueueSetState: function() {}
	}, _ = Object.assign, v = {};
	function y(e, t, n) {
		this.props = e, this.context = t, this.refs = v, this.updater = n || g;
	}
	y.prototype.isReactComponent = {}, y.prototype.setState = function(e, t) {
		if (typeof e != "object" && typeof e != "function" && e != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
		this.updater.enqueueSetState(this, e, t, "setState");
	}, y.prototype.forceUpdate = function(e) {
		this.updater.enqueueForceUpdate(this, e, "forceUpdate");
	};
	function b() {}
	b.prototype = y.prototype;
	function x(e, t, n) {
		this.props = e, this.context = t, this.refs = v, this.updater = n || g;
	}
	var S = x.prototype = new b();
	S.constructor = x, _(S, y.prototype), S.isPureReactComponent = !0;
	var C = Array.isArray;
	function w() {}
	var T = {
		H: null,
		A: null,
		T: null,
		S: null
	}, E = Object.prototype.hasOwnProperty;
	function O(e, n, i) {
		var a = i.ref;
		return {
			$$typeof: t,
			type: e,
			key: n,
			ref: a === void 0 ? null : a,
			props: i
		};
	}
	function k(e, t) {
		return O(e.type, t, e.props);
	}
	function A(e) {
		return typeof e == "object" && !!e && e.$$typeof === t;
	}
	function j(e) {
		var t = {
			"=": "=0",
			":": "=2"
		};
		return "$" + e.replace(/[=:]/g, function(e) {
			return t[e];
		});
	}
	var M = /\/+/g;
	function N(e, t) {
		return typeof e == "object" && e && e.key != null ? j("" + e.key) : t.toString(36);
	}
	function P(e) {
		switch (e.status) {
			case "fulfilled": return e.value;
			case "rejected": throw e.reason;
			default: switch (typeof e.status == "string" ? e.then(w, w) : (e.status = "pending", e.then(function(t) {
				e.status === "pending" && (e.status = "fulfilled", e.value = t);
			}, function(t) {
				e.status === "pending" && (e.status = "rejected", e.reason = t);
			})), e.status) {
				case "fulfilled": return e.value;
				case "rejected": throw e.reason;
			}
		}
		throw e;
	}
	function F(e, i, a, o, s) {
		var c = typeof e;
		(c === "undefined" || c === "boolean") && (e = null);
		var l = !1;
		if (e === null) l = !0;
		else switch (c) {
			case "bigint":
			case "string":
			case "number":
				l = !0;
				break;
			case "object": switch (e.$$typeof) {
				case t:
				case n:
					l = !0;
					break;
				case f: return l = e._init, F(l(e._payload), i, a, o, s);
			}
		}
		if (l) return s = s(e), l = o === "" ? "." + N(e, 0) : o, C(s) ? (a = "", l != null && (a = l.replace(M, "$&/") + "/"), F(s, i, a, "", function(e) {
			return e;
		})) : s != null && (A(s) && (s = k(s, a + (s.key == null || e && e.key === s.key ? "" : ("" + s.key).replace(M, "$&/") + "/") + l)), i.push(s)), 1;
		l = 0;
		var u = o === "" ? "." : o + ":";
		if (C(e)) for (var d = 0; d < e.length; d++) o = e[d], c = u + N(o, d), l += F(o, i, a, c, s);
		else if (d = h(e), typeof d == "function") for (e = d.call(e), d = 0; !(o = e.next()).done;) o = o.value, c = u + N(o, d++), l += F(o, i, a, c, s);
		else if (c === "object") {
			if (typeof e.then == "function") return F(P(e), i, a, o, s);
			throw i = String(e), Error("Objects are not valid as a React child (found: " + (i === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : i) + "). If you meant to render a collection of children, use an array instead.");
		}
		return l;
	}
	function I(e, t, n) {
		if (e == null) return e;
		var i = [], a = 0;
		return F(e, i, "", "", function(e) {
			return t.call(n, e, a++);
		}), i;
	}
	function ee(e) {
		if (e._status === -1) {
			var t = e._result;
			t = t(), t.then(function(t) {
				(e._status === 0 || e._status === -1) && (e._status = 1, e._result = t);
			}, function(t) {
				(e._status === 0 || e._status === -1) && (e._status = 2, e._result = t);
			}), e._status === -1 && (e._status = 0, e._result = t);
		}
		if (e._status === 1) return e._result.default;
		throw e._result;
	}
	var L = typeof reportError == "function" ? reportError : function(e) {
		if (typeof window == "object" && typeof window.ErrorEvent == "function") {
			var t = new window.ErrorEvent("error", {
				bubbles: !0,
				cancelable: !0,
				message: typeof e == "object" && e && typeof e.message == "string" ? String(e.message) : String(e),
				error: e
			});
			if (!window.dispatchEvent(t)) return;
		} else if (typeof process == "object" && typeof process.emit == "function") {
			process.emit("uncaughtException", e);
			return;
		}
		console.error(e);
	}, R = {
		map: I,
		forEach: function(e, t, n) {
			I(e, function() {
				t.apply(this, arguments);
			}, n);
		},
		count: function(e) {
			var t = 0;
			return I(e, function() {
				t++;
			}), t;
		},
		toArray: function(e) {
			return I(e, function(e) {
				return e;
			}) || [];
		},
		only: function(e) {
			if (!A(e)) throw Error("React.Children.only expected to receive a single React element child.");
			return e;
		}
	};
	e.Activity = p, e.Children = R, e.Component = y, e.Fragment = i, e.Profiler = o, e.PureComponent = x, e.StrictMode = a, e.Suspense = u, e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = T, e.__COMPILER_RUNTIME = {
		__proto__: null,
		c: function(e) {
			return T.H.useMemoCache(e);
		}
	}, e.cache = function(e) {
		return function() {
			return e.apply(null, arguments);
		};
	}, e.cacheSignal = function() {
		return null;
	}, e.cloneElement = function(e, t, n) {
		if (e == null) throw Error("The argument must be a React element, but you passed " + e + ".");
		var i = _({}, e.props), a = e.key;
		if (t != null) for (o in t.key !== void 0 && (a = "" + t.key), t) !E.call(t, o) || o === "key" || o === "__self" || o === "__source" || o === "ref" && t.ref === void 0 || (i[o] = t[o]);
		var o = arguments.length - 2;
		if (o === 1) i.children = n;
		else if (1 < o) {
			for (var s = Array(o), c = 0; c < o; c++) s[c] = arguments[c + 2];
			i.children = s;
		}
		return O(e.type, a, i);
	}, e.createContext = function(e) {
		return e = {
			$$typeof: c,
			_currentValue: e,
			_currentValue2: e,
			_threadCount: 0,
			Provider: null,
			Consumer: null
		}, e.Provider = e, e.Consumer = {
			$$typeof: s,
			_context: e
		}, e;
	}, e.createElement = function(e, t, n) {
		var i, a = {}, o = null;
		if (t != null) for (i in t.key !== void 0 && (o = "" + t.key), t) E.call(t, i) && i !== "key" && i !== "__self" && i !== "__source" && (a[i] = t[i]);
		var s = arguments.length - 2;
		if (s === 1) a.children = n;
		else if (1 < s) {
			for (var c = Array(s), l = 0; l < s; l++) c[l] = arguments[l + 2];
			a.children = c;
		}
		if (e && e.defaultProps) for (i in s = e.defaultProps, s) a[i] === void 0 && (a[i] = s[i]);
		return O(e, o, a);
	}, e.createRef = function() {
		return { current: null };
	}, e.forwardRef = function(e) {
		return {
			$$typeof: l,
			render: e
		};
	}, e.isValidElement = A, e.lazy = function(e) {
		return {
			$$typeof: f,
			_payload: {
				_status: -1,
				_result: e
			},
			_init: ee
		};
	}, e.memo = function(e, t) {
		return {
			$$typeof: d,
			type: e,
			compare: t === void 0 ? null : t
		};
	}, e.startTransition = function(e) {
		var t = T.T, n = {};
		T.T = n;
		try {
			var i = e(), a = T.S;
			a !== null && a(n, i), typeof i == "object" && i && typeof i.then == "function" && i.then(w, L);
		} catch (e) {
			L(e);
		} finally {
			t !== null && n.types !== null && (t.types = n.types), T.T = t;
		}
	}, e.unstable_useCacheRefresh = function() {
		return T.H.useCacheRefresh();
	}, e.use = function(e) {
		return T.H.use(e);
	}, e.useActionState = function(e, t, n) {
		return T.H.useActionState(e, t, n);
	}, e.useCallback = function(e, t) {
		return T.H.useCallback(e, t);
	}, e.useContext = function(e) {
		return T.H.useContext(e);
	}, e.useDebugValue = function() {}, e.useDeferredValue = function(e, t) {
		return T.H.useDeferredValue(e, t);
	}, e.useEffect = function(e, t) {
		return T.H.useEffect(e, t);
	}, e.useEffectEvent = function(e) {
		return T.H.useEffectEvent(e);
	}, e.useId = function() {
		return T.H.useId();
	}, e.useImperativeHandle = function(e, t, n) {
		return T.H.useImperativeHandle(e, t, n);
	}, e.useInsertionEffect = function(e, t) {
		return T.H.useInsertionEffect(e, t);
	}, e.useLayoutEffect = function(e, t) {
		return T.H.useLayoutEffect(e, t);
	}, e.useMemo = function(e, t) {
		return T.H.useMemo(e, t);
	}, e.useOptimistic = function(e, t) {
		return T.H.useOptimistic(e, t);
	}, e.useReducer = function(e, t, n) {
		return T.H.useReducer(e, t, n);
	}, e.useRef = function(e) {
		return T.H.useRef(e);
	}, e.useState = function(e) {
		return T.H.useState(e);
	}, e.useSyncExternalStore = function(e, t, n) {
		return T.H.useSyncExternalStore(e, t, n);
	}, e.useTransition = function() {
		return T.H.useTransition();
	}, e.version = "19.2.0";
})), require_react_development = /* @__PURE__ */ __commonJSMin(((e, t) => {
	process.env.NODE_ENV !== "production" && (function() {
		function n(e, t) {
			Object.defineProperty(o.prototype, e, { get: function() {
				console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", t[0], t[1]);
			} });
		}
		function i(e) {
			return typeof e != "object" || !e ? null : (e = de && e[de] || e["@@iterator"], typeof e == "function" ? e : null);
		}
		function a(e, t) {
			e = (e = e.constructor) && (e.displayName || e.name) || "ReactClass";
			var n = e + "." + t;
			fe[n] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", t, e), fe[n] = !0);
		}
		function o(e, t, n) {
			this.props = e, this.context = t, this.refs = me, this.updater = n || pe;
		}
		function s() {}
		function c(e, t, n) {
			this.props = e, this.context = t, this.refs = me, this.updater = n || pe;
		}
		function l() {}
		function u(e) {
			return "" + e;
		}
		function d(e) {
			try {
				u(e);
				var t = !1;
			} catch {
				t = !0;
			}
			if (t) {
				t = console;
				var n = t.error, i = typeof Symbol == "function" && Symbol.toStringTag && e[Symbol.toStringTag] || e.constructor.name || "Object";
				return n.call(t, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", i), u(e);
			}
		}
		function f(e) {
			if (e == null) return null;
			if (typeof e == "function") return e.$$typeof === _e ? null : e.displayName || e.name || null;
			if (typeof e == "string") return e;
			switch (e) {
				case R: return "Fragment";
				case ne: return "Profiler";
				case te: return "StrictMode";
				case z: return "Suspense";
				case se: return "SuspenseList";
				case ue: return "Activity";
			}
			if (typeof e == "object") switch (typeof e.tag == "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), e.$$typeof) {
				case L: return "Portal";
				case ae: return e.displayName || "Context";
				case ie: return (e._context.displayName || "Context") + ".Consumer";
				case oe:
					var t = e.render;
					return e = e.displayName, e ||= (e = t.displayName || t.name || "", e === "" ? "ForwardRef" : "ForwardRef(" + e + ")"), e;
				case ce: return t = e.displayName || null, t === null ? f(e.type) || "Memo" : t;
				case le:
					t = e._payload, e = e._init;
					try {
						return f(e(t));
					} catch {}
			}
			return null;
		}
		function p(e) {
			if (e === R) return "<>";
			if (typeof e == "object" && e && e.$$typeof === le) return "<...>";
			try {
				var t = f(e);
				return t ? "<" + t + ">" : "<...>";
			} catch {
				return "<...>";
			}
		}
		function m() {
			var e = H.A;
			return e === null ? null : e.getOwner();
		}
		function h() {
			return Error("react-stack-top-frame");
		}
		function g(e) {
			if (ve.call(e, "key")) {
				var t = Object.getOwnPropertyDescriptor(e, "key").get;
				if (t && t.isReactWarning) return !1;
			}
			return e.key !== void 0;
		}
		function _(e, t) {
			function n() {
				be || (be = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", t));
			}
			n.isReactWarning = !0, Object.defineProperty(e, "key", {
				get: n,
				configurable: !0
			});
		}
		function v() {
			var e = f(this.type);
			return Se[e] || (Se[e] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")), e = this.props.ref, e === void 0 ? null : e;
		}
		function y(e, t, n, i, a, o) {
			var s = n.ref;
			return e = {
				$$typeof: ee,
				type: e,
				key: t,
				props: n,
				_owner: i
			}, (s === void 0 ? null : s) === null ? Object.defineProperty(e, "ref", {
				enumerable: !1,
				value: null
			}) : Object.defineProperty(e, "ref", {
				enumerable: !1,
				get: v
			}), e._store = {}, Object.defineProperty(e._store, "validated", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: 0
			}), Object.defineProperty(e, "_debugInfo", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: null
			}), Object.defineProperty(e, "_debugStack", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: a
			}), Object.defineProperty(e, "_debugTask", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: o
			}), Object.freeze && (Object.freeze(e.props), Object.freeze(e)), e;
		}
		function b(e, t) {
			return t = y(e.type, t, e.props, e._owner, e._debugStack, e._debugTask), e._store && (t._store.validated = e._store.validated), t;
		}
		function x(e) {
			S(e) ? e._store && (e._store.validated = 1) : typeof e == "object" && e && e.$$typeof === le && (e._payload.status === "fulfilled" ? S(e._payload.value) && e._payload.value._store && (e._payload.value._store.validated = 1) : e._store && (e._store.validated = 1));
		}
		function S(e) {
			return typeof e == "object" && !!e && e.$$typeof === ee;
		}
		function C(e) {
			var t = {
				"=": "=0",
				":": "=2"
			};
			return "$" + e.replace(/[=:]/g, function(e) {
				return t[e];
			});
		}
		function w(e, t) {
			return typeof e == "object" && e && e.key != null ? (d(e.key), C("" + e.key)) : t.toString(36);
		}
		function T(e) {
			switch (e.status) {
				case "fulfilled": return e.value;
				case "rejected": throw e.reason;
				default: switch (typeof e.status == "string" ? e.then(l, l) : (e.status = "pending", e.then(function(t) {
					e.status === "pending" && (e.status = "fulfilled", e.value = t);
				}, function(t) {
					e.status === "pending" && (e.status = "rejected", e.reason = t);
				})), e.status) {
					case "fulfilled": return e.value;
					case "rejected": throw e.reason;
				}
			}
			throw e;
		}
		function E(e, t, n, a, o) {
			var s = typeof e;
			(s === "undefined" || s === "boolean") && (e = null);
			var c = !1;
			if (e === null) c = !0;
			else switch (s) {
				case "bigint":
				case "string":
				case "number":
					c = !0;
					break;
				case "object": switch (e.$$typeof) {
					case ee:
					case L:
						c = !0;
						break;
					case le: return c = e._init, E(c(e._payload), t, n, a, o);
				}
			}
			if (c) {
				c = e, o = o(c);
				var l = a === "" ? "." + w(c, 0) : a;
				return ge(o) ? (n = "", l != null && (n = l.replace(Ee, "$&/") + "/"), E(o, t, n, "", function(e) {
					return e;
				})) : o != null && (S(o) && (o.key != null && (c && c.key === o.key || d(o.key)), n = b(o, n + (o.key == null || c && c.key === o.key ? "" : ("" + o.key).replace(Ee, "$&/") + "/") + l), a !== "" && c != null && S(c) && c.key == null && c._store && !c._store.validated && (n._store.validated = 2), o = n), t.push(o)), 1;
			}
			if (c = 0, l = a === "" ? "." : a + ":", ge(e)) for (var u = 0; u < e.length; u++) a = e[u], s = l + w(a, u), c += E(a, t, n, s, o);
			else if (u = i(e), typeof u == "function") for (u === e.entries && (Te || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Te = !0), e = u.call(e), u = 0; !(a = e.next()).done;) a = a.value, s = l + w(a, u++), c += E(a, t, n, s, o);
			else if (s === "object") {
				if (typeof e.then == "function") return E(T(e), t, n, a, o);
				throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
			}
			return c;
		}
		function O(e, t, n) {
			if (e == null) return e;
			var i = [], a = 0;
			return E(e, i, "", "", function(e) {
				return t.call(n, e, a++);
			}), i;
		}
		function k(e) {
			if (e._status === -1) {
				var t = e._ioInfo;
				t != null && (t.start = t.end = performance.now()), t = e._result;
				var n = t();
				if (n.then(function(t) {
					if (e._status === 0 || e._status === -1) {
						e._status = 1, e._result = t;
						var i = e._ioInfo;
						i != null && (i.end = performance.now()), n.status === void 0 && (n.status = "fulfilled", n.value = t);
					}
				}, function(t) {
					if (e._status === 0 || e._status === -1) {
						e._status = 2, e._result = t;
						var i = e._ioInfo;
						i != null && (i.end = performance.now()), n.status === void 0 && (n.status = "rejected", n.reason = t);
					}
				}), t = e._ioInfo, t != null) {
					t.value = n;
					var i = n.displayName;
					typeof i == "string" && (t.name = i);
				}
				e._status === -1 && (e._status = 0, e._result = n);
			}
			if (e._status === 1) return t = e._result, t === void 0 && console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", t), "default" in t || console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", t), t.default;
			throw e._result;
		}
		function A() {
			var e = H.H;
			return e === null && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."), e;
		}
		function j() {
			H.asyncTransitions--;
		}
		function M(e) {
			if (ke === null) try {
				var n = ("require" + Math.random()).slice(0, 7);
				ke = (t && t[n]).call(t, "timers").setImmediate;
			} catch {
				ke = function(e) {
					!1 === Oe && (Oe = !0, typeof MessageChannel > "u" && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
					var t = new MessageChannel();
					t.port1.onmessage = e, t.port2.postMessage(void 0);
				};
			}
			return ke(e);
		}
		function N(e) {
			return 1 < e.length && typeof AggregateError == "function" ? AggregateError(e) : e[0];
		}
		function P(e, t) {
			t !== Ae - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Ae = t;
		}
		function F(e, t, n) {
			var i = H.actQueue;
			if (i !== null) if (i.length !== 0) try {
				I(i), M(function() {
					return F(e, t, n);
				});
				return;
			} catch (e) {
				H.thrownErrors.push(e);
			}
			else H.actQueue = null;
			0 < H.thrownErrors.length ? (i = N(H.thrownErrors), H.thrownErrors.length = 0, n(i)) : t(e);
		}
		function I(e) {
			if (!Me) {
				Me = !0;
				var t = 0;
				try {
					for (; t < e.length; t++) {
						var n = e[t];
						do {
							H.didUsePromise = !1;
							var i = n(!1);
							if (i !== null) {
								if (H.didUsePromise) {
									e[t] = n, e.splice(0, t);
									return;
								}
								n = i;
							} else break;
						} while (1);
					}
					e.length = 0;
				} catch (n) {
					e.splice(0, t + 1), H.thrownErrors.push(n);
				} finally {
					Me = !1;
				}
			}
		}
		typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var ee = Symbol.for("react.transitional.element"), L = Symbol.for("react.portal"), R = Symbol.for("react.fragment"), te = Symbol.for("react.strict_mode"), ne = Symbol.for("react.profiler"), ie = Symbol.for("react.consumer"), ae = Symbol.for("react.context"), oe = Symbol.for("react.forward_ref"), z = Symbol.for("react.suspense"), se = Symbol.for("react.suspense_list"), ce = Symbol.for("react.memo"), le = Symbol.for("react.lazy"), ue = Symbol.for("react.activity"), de = Symbol.iterator, fe = {}, pe = {
			isMounted: function() {
				return !1;
			},
			enqueueForceUpdate: function(e) {
				a(e, "forceUpdate");
			},
			enqueueReplaceState: function(e) {
				a(e, "replaceState");
			},
			enqueueSetState: function(e) {
				a(e, "setState");
			}
		}, V = Object.assign, me = {};
		Object.freeze(me), o.prototype.isReactComponent = {}, o.prototype.setState = function(e, t) {
			if (typeof e != "object" && typeof e != "function" && e != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
			this.updater.enqueueSetState(this, e, t, "setState");
		}, o.prototype.forceUpdate = function(e) {
			this.updater.enqueueForceUpdate(this, e, "forceUpdate");
		};
		var he = {
			isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
			replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
		};
		for (U in he) he.hasOwnProperty(U) && n(U, he[U]);
		s.prototype = o.prototype, he = c.prototype = new s(), he.constructor = c, V(he, o.prototype), he.isPureReactComponent = !0;
		var ge = Array.isArray, _e = Symbol.for("react.client.reference"), H = {
			H: null,
			A: null,
			T: null,
			S: null,
			actQueue: null,
			asyncTransitions: 0,
			isBatchingLegacy: !1,
			didScheduleLegacyUpdate: !1,
			didUsePromise: !1,
			thrownErrors: [],
			getCurrentStack: null,
			recentlyCreatedOwnerStacks: 0
		}, ve = Object.prototype.hasOwnProperty, ye = console.createTask ? console.createTask : function() {
			return null;
		};
		he = { react_stack_bottom_frame: function(e) {
			return e();
		} };
		var be, xe, Se = {}, Ce = he.react_stack_bottom_frame.bind(he, h)(), we = ye(p(h)), Te = !1, Ee = /\/+/g, De = typeof reportError == "function" ? reportError : function(e) {
			if (typeof window == "object" && typeof window.ErrorEvent == "function") {
				var t = new window.ErrorEvent("error", {
					bubbles: !0,
					cancelable: !0,
					message: typeof e == "object" && e && typeof e.message == "string" ? String(e.message) : String(e),
					error: e
				});
				if (!window.dispatchEvent(t)) return;
			} else if (typeof process == "object" && typeof process.emit == "function") {
				process.emit("uncaughtException", e);
				return;
			}
			console.error(e);
		}, Oe = !1, ke = null, Ae = 0, je = !1, Me = !1, Ne = typeof queueMicrotask == "function" ? function(e) {
			queueMicrotask(function() {
				return queueMicrotask(e);
			});
		} : M;
		he = Object.freeze({
			__proto__: null,
			c: function(e) {
				return A().useMemoCache(e);
			}
		});
		var U = {
			map: O,
			forEach: function(e, t, n) {
				O(e, function() {
					t.apply(this, arguments);
				}, n);
			},
			count: function(e) {
				var t = 0;
				return O(e, function() {
					t++;
				}), t;
			},
			toArray: function(e) {
				return O(e, function(e) {
					return e;
				}) || [];
			},
			only: function(e) {
				if (!S(e)) throw Error("React.Children.only expected to receive a single React element child.");
				return e;
			}
		};
		e.Activity = ue, e.Children = U, e.Component = o, e.Fragment = R, e.Profiler = ne, e.PureComponent = c, e.StrictMode = te, e.Suspense = z, e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = H, e.__COMPILER_RUNTIME = he, e.act = function(e) {
			var t = H.actQueue, n = Ae;
			Ae++;
			var i = H.actQueue = t === null ? [] : t, a = !1;
			try {
				var o = e();
			} catch (e) {
				H.thrownErrors.push(e);
			}
			if (0 < H.thrownErrors.length) throw P(t, n), e = N(H.thrownErrors), H.thrownErrors.length = 0, e;
			if (typeof o == "object" && o && typeof o.then == "function") {
				var s = o;
				return Ne(function() {
					a || je || (je = !0, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
				}), { then: function(e, o) {
					a = !0, s.then(function(a) {
						if (P(t, n), n === 0) {
							try {
								I(i), M(function() {
									return F(a, e, o);
								});
							} catch (e) {
								H.thrownErrors.push(e);
							}
							if (0 < H.thrownErrors.length) {
								var s = N(H.thrownErrors);
								H.thrownErrors.length = 0, o(s);
							}
						} else e(a);
					}, function(e) {
						P(t, n), 0 < H.thrownErrors.length ? (e = N(H.thrownErrors), H.thrownErrors.length = 0, o(e)) : o(e);
					});
				} };
			}
			var c = o;
			if (P(t, n), n === 0 && (I(i), i.length !== 0 && Ne(function() {
				a || je || (je = !0, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
			}), H.actQueue = null), 0 < H.thrownErrors.length) throw e = N(H.thrownErrors), H.thrownErrors.length = 0, e;
			return { then: function(e, t) {
				a = !0, n === 0 ? (H.actQueue = i, M(function() {
					return F(c, e, t);
				})) : e(c);
			} };
		}, e.cache = function(e) {
			return function() {
				return e.apply(null, arguments);
			};
		}, e.cacheSignal = function() {
			return null;
		}, e.captureOwnerStack = function() {
			var e = H.getCurrentStack;
			return e === null ? null : e();
		}, e.cloneElement = function(e, t, n) {
			if (e == null) throw Error("The argument must be a React element, but you passed " + e + ".");
			var i = V({}, e.props), a = e.key, o = e._owner;
			if (t != null) {
				var s;
				a: {
					if (ve.call(t, "ref") && (s = Object.getOwnPropertyDescriptor(t, "ref").get) && s.isReactWarning) {
						s = !1;
						break a;
					}
					s = t.ref !== void 0;
				}
				for (c in s && (o = m()), g(t) && (d(t.key), a = "" + t.key), t) !ve.call(t, c) || c === "key" || c === "__self" || c === "__source" || c === "ref" && t.ref === void 0 || (i[c] = t[c]);
			}
			var c = arguments.length - 2;
			if (c === 1) i.children = n;
			else if (1 < c) {
				s = Array(c);
				for (var l = 0; l < c; l++) s[l] = arguments[l + 2];
				i.children = s;
			}
			for (i = y(e.type, a, i, o, e._debugStack, e._debugTask), a = 2; a < arguments.length; a++) x(arguments[a]);
			return i;
		}, e.createContext = function(e) {
			return e = {
				$$typeof: ae,
				_currentValue: e,
				_currentValue2: e,
				_threadCount: 0,
				Provider: null,
				Consumer: null
			}, e.Provider = e, e.Consumer = {
				$$typeof: ie,
				_context: e
			}, e._currentRenderer = null, e._currentRenderer2 = null, e;
		}, e.createElement = function(e, t, n) {
			for (var i = 2; i < arguments.length; i++) x(arguments[i]);
			i = {};
			var a = null;
			if (t != null) for (l in xe || !("__self" in t) || "key" in t || (xe = !0, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), g(t) && (d(t.key), a = "" + t.key), t) ve.call(t, l) && l !== "key" && l !== "__self" && l !== "__source" && (i[l] = t[l]);
			var o = arguments.length - 2;
			if (o === 1) i.children = n;
			else if (1 < o) {
				for (var s = Array(o), c = 0; c < o; c++) s[c] = arguments[c + 2];
				Object.freeze && Object.freeze(s), i.children = s;
			}
			if (e && e.defaultProps) for (l in o = e.defaultProps, o) i[l] === void 0 && (i[l] = o[l]);
			a && _(i, typeof e == "function" ? e.displayName || e.name || "Unknown" : e);
			var l = 1e4 > H.recentlyCreatedOwnerStacks++;
			return y(e, a, i, m(), l ? Error("react-stack-top-frame") : Ce, l ? ye(p(e)) : we);
		}, e.createRef = function() {
			var e = { current: null };
			return Object.seal(e), e;
		}, e.forwardRef = function(e) {
			e != null && e.$$typeof === ce ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof e == "function" ? e.length !== 0 && e.length !== 2 && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", e.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.") : console.error("forwardRef requires a render function but was given %s.", e === null ? "null" : typeof e), e != null && e.defaultProps != null && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
			var t = {
				$$typeof: oe,
				render: e
			}, n;
			return Object.defineProperty(t, "displayName", {
				enumerable: !1,
				configurable: !0,
				get: function() {
					return n;
				},
				set: function(t) {
					n = t, e.name || e.displayName || (Object.defineProperty(e, "name", { value: t }), e.displayName = t);
				}
			}), t;
		}, e.isValidElement = S, e.lazy = function(e) {
			e = {
				_status: -1,
				_result: e
			};
			var t = {
				$$typeof: le,
				_payload: e,
				_init: k
			}, n = {
				name: "lazy",
				start: -1,
				end: -1,
				value: null,
				owner: null,
				debugStack: Error("react-stack-top-frame"),
				debugTask: console.createTask ? console.createTask("lazy()") : null
			};
			return e._ioInfo = n, t._debugInfo = [{ awaited: n }], t;
		}, e.memo = function(e, t) {
			e ?? console.error("memo: The first argument must be a component. Instead received: %s", e === null ? "null" : typeof e), t = {
				$$typeof: ce,
				type: e,
				compare: t === void 0 ? null : t
			};
			var n;
			return Object.defineProperty(t, "displayName", {
				enumerable: !1,
				configurable: !0,
				get: function() {
					return n;
				},
				set: function(t) {
					n = t, e.name || e.displayName || (Object.defineProperty(e, "name", { value: t }), e.displayName = t);
				}
			}), t;
		}, e.startTransition = function(e) {
			var t = H.T, n = {};
			n._updatedFibers = /* @__PURE__ */ new Set(), H.T = n;
			try {
				var i = e(), a = H.S;
				a !== null && a(n, i), typeof i == "object" && i && typeof i.then == "function" && (H.asyncTransitions++, i.then(j, j), i.then(l, De));
			} catch (e) {
				De(e);
			} finally {
				t === null && n._updatedFibers && (e = n._updatedFibers.size, n._updatedFibers.clear(), 10 < e && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), t !== null && n.types !== null && (t.types !== null && t.types !== n.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), t.types = n.types), H.T = t;
			}
		}, e.unstable_useCacheRefresh = function() {
			return A().useCacheRefresh();
		}, e.use = function(e) {
			return A().use(e);
		}, e.useActionState = function(e, t, n) {
			return A().useActionState(e, t, n);
		}, e.useCallback = function(e, t) {
			return A().useCallback(e, t);
		}, e.useContext = function(e) {
			var t = A();
			return e.$$typeof === ie && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"), t.useContext(e);
		}, e.useDebugValue = function(e, t) {
			return A().useDebugValue(e, t);
		}, e.useDeferredValue = function(e, t) {
			return A().useDeferredValue(e, t);
		}, e.useEffect = function(e, t) {
			return e ?? console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"), A().useEffect(e, t);
		}, e.useEffectEvent = function(e) {
			return A().useEffectEvent(e);
		}, e.useId = function() {
			return A().useId();
		}, e.useImperativeHandle = function(e, t, n) {
			return A().useImperativeHandle(e, t, n);
		}, e.useInsertionEffect = function(e, t) {
			return e ?? console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"), A().useInsertionEffect(e, t);
		}, e.useLayoutEffect = function(e, t) {
			return e ?? console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"), A().useLayoutEffect(e, t);
		}, e.useMemo = function(e, t) {
			return A().useMemo(e, t);
		}, e.useOptimistic = function(e, t) {
			return A().useOptimistic(e, t);
		}, e.useReducer = function(e, t, n) {
			return A().useReducer(e, t, n);
		}, e.useRef = function(e) {
			return A().useRef(e);
		}, e.useState = function(e) {
			return A().useState(e);
		}, e.useSyncExternalStore = function(e, t, n) {
			return A().useSyncExternalStore(e, t, n);
		}, e.useTransition = function() {
			return A().useTransition();
		}, e.version = "19.2.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
})), require_react = /* @__PURE__ */ __commonJSMin(((e, t) => {
	process.env.NODE_ENV === "production" ? t.exports = require_react_production() : t.exports = require_react_development();
})), require_scheduler_production = /* @__PURE__ */ __commonJSMin(((e) => {
	function t(e, t) {
		var n = e.length;
		e.push(t);
		a: for (; 0 < n;) {
			var i = n - 1 >>> 1, o = e[i];
			if (0 < a(o, t)) e[i] = t, e[n] = o, n = i;
			else break a;
		}
	}
	function n(e) {
		return e.length === 0 ? null : e[0];
	}
	function i(e) {
		if (e.length === 0) return null;
		var t = e[0], n = e.pop();
		if (n !== t) {
			e[0] = n;
			a: for (var i = 0, o = e.length, s = o >>> 1; i < s;) {
				var c = 2 * (i + 1) - 1, l = e[c], u = c + 1, d = e[u];
				if (0 > a(l, n)) u < o && 0 > a(d, l) ? (e[i] = d, e[u] = n, i = u) : (e[i] = l, e[c] = n, i = c);
				else if (u < o && 0 > a(d, n)) e[i] = d, e[u] = n, i = u;
				else break a;
			}
		}
		return t;
	}
	function a(e, t) {
		var n = e.sortIndex - t.sortIndex;
		return n === 0 ? e.id - t.id : n;
	}
	if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
		var o = performance;
		e.unstable_now = function() {
			return o.now();
		};
	} else {
		var s = Date, c = s.now();
		e.unstable_now = function() {
			return s.now() - c;
		};
	}
	var l = [], u = [], d = 1, f = null, p = 3, m = !1, h = !1, g = !1, _ = !1, v = typeof setTimeout == "function" ? setTimeout : null, y = typeof clearTimeout == "function" ? clearTimeout : null, b = typeof setImmediate < "u" ? setImmediate : null;
	function x(e) {
		for (var a = n(u); a !== null;) {
			if (a.callback === null) i(u);
			else if (a.startTime <= e) i(u), a.sortIndex = a.expirationTime, t(l, a);
			else break;
			a = n(u);
		}
	}
	function S(e) {
		if (g = !1, x(e), !h) if (n(l) !== null) h = !0, C || (C = !0, A());
		else {
			var t = n(u);
			t !== null && N(S, t.startTime - e);
		}
	}
	var C = !1, w = -1, T = 5, E = -1;
	function O() {
		return _ ? !0 : !(e.unstable_now() - E < T);
	}
	function k() {
		if (_ = !1, C) {
			var t = e.unstable_now();
			E = t;
			var a = !0;
			try {
				a: {
					h = !1, g && (g = !1, y(w), w = -1), m = !0;
					var o = p;
					try {
						b: {
							for (x(t), f = n(l); f !== null && !(f.expirationTime > t && O());) {
								var s = f.callback;
								if (typeof s == "function") {
									f.callback = null, p = f.priorityLevel;
									var c = s(f.expirationTime <= t);
									if (t = e.unstable_now(), typeof c == "function") {
										f.callback = c, x(t), a = !0;
										break b;
									}
									f === n(l) && i(l), x(t);
								} else i(l);
								f = n(l);
							}
							if (f !== null) a = !0;
							else {
								var d = n(u);
								d !== null && N(S, d.startTime - t), a = !1;
							}
						}
						break a;
					} finally {
						f = null, p = o, m = !1;
					}
					a = void 0;
				}
			} finally {
				a ? A() : C = !1;
			}
		}
	}
	var A;
	if (typeof b == "function") A = function() {
		b(k);
	};
	else if (typeof MessageChannel < "u") {
		var j = new MessageChannel(), M = j.port2;
		j.port1.onmessage = k, A = function() {
			M.postMessage(null);
		};
	} else A = function() {
		v(k, 0);
	};
	function N(t, n) {
		w = v(function() {
			t(e.unstable_now());
		}, n);
	}
	e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(e) {
		e.callback = null;
	}, e.unstable_forceFrameRate = function(e) {
		0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : T = 0 < e ? Math.floor(1e3 / e) : 5;
	}, e.unstable_getCurrentPriorityLevel = function() {
		return p;
	}, e.unstable_next = function(e) {
		switch (p) {
			case 1:
			case 2:
			case 3:
				var t = 3;
				break;
			default: t = p;
		}
		var n = p;
		p = t;
		try {
			return e();
		} finally {
			p = n;
		}
	}, e.unstable_requestPaint = function() {
		_ = !0;
	}, e.unstable_runWithPriority = function(e, t) {
		switch (e) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5: break;
			default: e = 3;
		}
		var n = p;
		p = e;
		try {
			return t();
		} finally {
			p = n;
		}
	}, e.unstable_scheduleCallback = function(i, a, o) {
		var s = e.unstable_now();
		switch (typeof o == "object" && o ? (o = o.delay, o = typeof o == "number" && 0 < o ? s + o : s) : o = s, i) {
			case 1:
				var c = -1;
				break;
			case 2:
				c = 250;
				break;
			case 5:
				c = 1073741823;
				break;
			case 4:
				c = 1e4;
				break;
			default: c = 5e3;
		}
		return c = o + c, i = {
			id: d++,
			callback: a,
			priorityLevel: i,
			startTime: o,
			expirationTime: c,
			sortIndex: -1
		}, o > s ? (i.sortIndex = o, t(u, i), n(l) === null && i === n(u) && (g ? (y(w), w = -1) : g = !0, N(S, o - s))) : (i.sortIndex = c, t(l, i), h || m || (h = !0, C || (C = !0, A()))), i;
	}, e.unstable_shouldYield = O, e.unstable_wrapCallback = function(e) {
		var t = p;
		return function() {
			var n = p;
			p = t;
			try {
				return e.apply(this, arguments);
			} finally {
				p = n;
			}
		};
	};
})), require_scheduler_development = /* @__PURE__ */ __commonJSMin(((e) => {
	process.env.NODE_ENV !== "production" && (function() {
		function t() {
			if (S = !1, E) {
				var t = e.unstable_now();
				A = t;
				var n = !0;
				try {
					a: {
						b = !1, x && (x = !1, w(O), O = -1), y = !0;
						var o = v;
						try {
							b: {
								for (s(t), _ = i(m); _ !== null && !(_.expirationTime > t && l());) {
									var d = _.callback;
									if (typeof d == "function") {
										_.callback = null, v = _.priorityLevel;
										var f = d(_.expirationTime <= t);
										if (t = e.unstable_now(), typeof f == "function") {
											_.callback = f, s(t), n = !0;
											break b;
										}
										_ === i(m) && a(m), s(t);
									} else a(m);
									_ = i(m);
								}
								if (_ !== null) n = !0;
								else {
									var p = i(h);
									p !== null && u(c, p.startTime - t), n = !1;
								}
							}
							break a;
						} finally {
							_ = null, v = o, y = !1;
						}
						n = void 0;
					}
				} finally {
					n ? j() : E = !1;
				}
			}
		}
		function n(e, t) {
			var n = e.length;
			e.push(t);
			a: for (; 0 < n;) {
				var i = n - 1 >>> 1, a = e[i];
				if (0 < o(a, t)) e[i] = t, e[n] = a, n = i;
				else break a;
			}
		}
		function i(e) {
			return e.length === 0 ? null : e[0];
		}
		function a(e) {
			if (e.length === 0) return null;
			var t = e[0], n = e.pop();
			if (n !== t) {
				e[0] = n;
				a: for (var i = 0, a = e.length, s = a >>> 1; i < s;) {
					var c = 2 * (i + 1) - 1, l = e[c], u = c + 1, d = e[u];
					if (0 > o(l, n)) u < a && 0 > o(d, l) ? (e[i] = d, e[u] = n, i = u) : (e[i] = l, e[c] = n, i = c);
					else if (u < a && 0 > o(d, n)) e[i] = d, e[u] = n, i = u;
					else break a;
				}
			}
			return t;
		}
		function o(e, t) {
			var n = e.sortIndex - t.sortIndex;
			return n === 0 ? e.id - t.id : n;
		}
		function s(e) {
			for (var t = i(h); t !== null;) {
				if (t.callback === null) a(h);
				else if (t.startTime <= e) a(h), t.sortIndex = t.expirationTime, n(m, t);
				else break;
				t = i(h);
			}
		}
		function c(e) {
			if (x = !1, s(e), !b) if (i(m) !== null) b = !0, E || (E = !0, j());
			else {
				var t = i(h);
				t !== null && u(c, t.startTime - e);
			}
		}
		function l() {
			return S ? !0 : !(e.unstable_now() - A < k);
		}
		function u(t, n) {
			O = C(function() {
				t(e.unstable_now());
			}, n);
		}
		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error()), e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
			var d = performance;
			e.unstable_now = function() {
				return d.now();
			};
		} else {
			var f = Date, p = f.now();
			e.unstable_now = function() {
				return f.now() - p;
			};
		}
		var m = [], h = [], g = 1, _ = null, v = 3, y = !1, b = !1, x = !1, S = !1, C = typeof setTimeout == "function" ? setTimeout : null, w = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null, E = !1, O = -1, k = 5, A = -1;
		if (typeof T == "function") var j = function() {
			T(t);
		};
		else if (typeof MessageChannel < "u") {
			var M = new MessageChannel(), N = M.port2;
			M.port1.onmessage = t, j = function() {
				N.postMessage(null);
			};
		} else j = function() {
			C(t, 0);
		};
		e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(e) {
			e.callback = null;
		}, e.unstable_forceFrameRate = function(e) {
			0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : k = 0 < e ? Math.floor(1e3 / e) : 5;
		}, e.unstable_getCurrentPriorityLevel = function() {
			return v;
		}, e.unstable_next = function(e) {
			switch (v) {
				case 1:
				case 2:
				case 3:
					var t = 3;
					break;
				default: t = v;
			}
			var n = v;
			v = t;
			try {
				return e();
			} finally {
				v = n;
			}
		}, e.unstable_requestPaint = function() {
			S = !0;
		}, e.unstable_runWithPriority = function(e, t) {
			switch (e) {
				case 1:
				case 2:
				case 3:
				case 4:
				case 5: break;
				default: e = 3;
			}
			var n = v;
			v = e;
			try {
				return t();
			} finally {
				v = n;
			}
		}, e.unstable_scheduleCallback = function(t, a, o) {
			var s = e.unstable_now();
			switch (typeof o == "object" && o ? (o = o.delay, o = typeof o == "number" && 0 < o ? s + o : s) : o = s, t) {
				case 1:
					var l = -1;
					break;
				case 2:
					l = 250;
					break;
				case 5:
					l = 1073741823;
					break;
				case 4:
					l = 1e4;
					break;
				default: l = 5e3;
			}
			return l = o + l, t = {
				id: g++,
				callback: a,
				priorityLevel: t,
				startTime: o,
				expirationTime: l,
				sortIndex: -1
			}, o > s ? (t.sortIndex = o, n(h, t), i(m) === null && t === i(h) && (x ? (w(O), O = -1) : x = !0, u(c, o - s))) : (t.sortIndex = l, n(m, t), b || y || (b = !0, E || (E = !0, j()))), t;
		}, e.unstable_shouldYield = l, e.unstable_wrapCallback = function(e) {
			var t = v;
			return function() {
				var n = v;
				v = t;
				try {
					return e.apply(this, arguments);
				} finally {
					v = n;
				}
			};
		}, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
})), require_scheduler = /* @__PURE__ */ __commonJSMin(((e, t) => {
	process.env.NODE_ENV === "production" ? t.exports = require_scheduler_production() : t.exports = require_scheduler_development();
})), require_react_dom_production = /* @__PURE__ */ __commonJSMin(((e) => {
	var t = require_react();
	function n(e) {
		var t = "https://react.dev/errors/" + e;
		if (1 < arguments.length) {
			t += "?args[]=" + encodeURIComponent(arguments[1]);
			for (var n = 2; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
		}
		return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}
	function i() {}
	var a = {
		d: {
			f: i,
			r: function() {
				throw Error(n(522));
			},
			D: i,
			C: i,
			L: i,
			m: i,
			X: i,
			S: i,
			M: i
		},
		p: 0,
		findDOMNode: null
	}, o = Symbol.for("react.portal");
	function s(e, t, n) {
		var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
		return {
			$$typeof: o,
			key: i == null ? null : "" + i,
			children: e,
			containerInfo: t,
			implementation: n
		};
	}
	var c = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
	function l(e, t) {
		if (e === "font") return "";
		if (typeof t == "string") return t === "use-credentials" ? t : "";
	}
	e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = a, e.createPortal = function(e, t) {
		var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
		if (!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) throw Error(n(299));
		return s(e, t, null, i);
	}, e.flushSync = function(e) {
		var t = c.T, n = a.p;
		try {
			if (c.T = null, a.p = 2, e) return e();
		} finally {
			c.T = t, a.p = n, a.d.f();
		}
	}, e.preconnect = function(e, t) {
		typeof e == "string" && (t ? (t = t.crossOrigin, t = typeof t == "string" ? t === "use-credentials" ? t : "" : void 0) : t = null, a.d.C(e, t));
	}, e.prefetchDNS = function(e) {
		typeof e == "string" && a.d.D(e);
	}, e.preinit = function(e, t) {
		if (typeof e == "string" && t && typeof t.as == "string") {
			var n = t.as, i = l(n, t.crossOrigin), o = typeof t.integrity == "string" ? t.integrity : void 0, s = typeof t.fetchPriority == "string" ? t.fetchPriority : void 0;
			n === "style" ? a.d.S(e, typeof t.precedence == "string" ? t.precedence : void 0, {
				crossOrigin: i,
				integrity: o,
				fetchPriority: s
			}) : n === "script" && a.d.X(e, {
				crossOrigin: i,
				integrity: o,
				fetchPriority: s,
				nonce: typeof t.nonce == "string" ? t.nonce : void 0
			});
		}
	}, e.preinitModule = function(e, t) {
		if (typeof e == "string") if (typeof t == "object" && t) {
			if (t.as == null || t.as === "script") {
				var n = l(t.as, t.crossOrigin);
				a.d.M(e, {
					crossOrigin: n,
					integrity: typeof t.integrity == "string" ? t.integrity : void 0,
					nonce: typeof t.nonce == "string" ? t.nonce : void 0
				});
			}
		} else t ?? a.d.M(e);
	}, e.preload = function(e, t) {
		if (typeof e == "string" && typeof t == "object" && t && typeof t.as == "string") {
			var n = t.as, i = l(n, t.crossOrigin);
			a.d.L(e, n, {
				crossOrigin: i,
				integrity: typeof t.integrity == "string" ? t.integrity : void 0,
				nonce: typeof t.nonce == "string" ? t.nonce : void 0,
				type: typeof t.type == "string" ? t.type : void 0,
				fetchPriority: typeof t.fetchPriority == "string" ? t.fetchPriority : void 0,
				referrerPolicy: typeof t.referrerPolicy == "string" ? t.referrerPolicy : void 0,
				imageSrcSet: typeof t.imageSrcSet == "string" ? t.imageSrcSet : void 0,
				imageSizes: typeof t.imageSizes == "string" ? t.imageSizes : void 0,
				media: typeof t.media == "string" ? t.media : void 0
			});
		}
	}, e.preloadModule = function(e, t) {
		if (typeof e == "string") if (t) {
			var n = l(t.as, t.crossOrigin);
			a.d.m(e, {
				as: typeof t.as == "string" && t.as !== "script" ? t.as : void 0,
				crossOrigin: n,
				integrity: typeof t.integrity == "string" ? t.integrity : void 0
			});
		} else a.d.m(e);
	}, e.requestFormReset = function(e) {
		a.d.r(e);
	}, e.unstable_batchedUpdates = function(e, t) {
		return e(t);
	}, e.useFormState = function(e, t, n) {
		return c.H.useFormState(e, t, n);
	}, e.useFormStatus = function() {
		return c.H.useHostTransitionStatus();
	}, e.version = "19.2.0";
})), require_react_dom_development = /* @__PURE__ */ __commonJSMin(((e) => {
	process.env.NODE_ENV !== "production" && (function() {
		function t() {}
		function n(e) {
			return "" + e;
		}
		function i(e, t, i) {
			var a = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
			try {
				n(a);
				var o = !1;
			} catch {
				o = !0;
			}
			return o && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", typeof Symbol == "function" && Symbol.toStringTag && a[Symbol.toStringTag] || a.constructor.name || "Object"), n(a)), {
				$$typeof: d,
				key: a == null ? null : "" + a,
				children: e,
				containerInfo: t,
				implementation: i
			};
		}
		function a(e, t) {
			if (e === "font") return "";
			if (typeof t == "string") return t === "use-credentials" ? t : "";
		}
		function o(e) {
			return e === null ? "`null`" : e === void 0 ? "`undefined`" : e === "" ? "an empty string" : "something with type \"" + typeof e + "\"";
		}
		function s(e) {
			return e === null ? "`null`" : e === void 0 ? "`undefined`" : e === "" ? "an empty string" : typeof e == "string" ? JSON.stringify(e) : typeof e == "number" ? "`" + e + "`" : "something with type \"" + typeof e + "\"";
		}
		function c() {
			var e = p.H;
			return e === null && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."), e;
		}
		typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var l = require_react(), u = {
			d: {
				f: t,
				r: function() {
					throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
				},
				D: t,
				C: t,
				L: t,
				m: t,
				X: t,
				S: t,
				M: t
			},
			p: 0,
			findDOMNode: null
		}, d = Symbol.for("react.portal"), p = l.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
		typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = u, e.createPortal = function(e, t) {
			var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
			if (!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) throw Error("Target container is not a DOM element.");
			return i(e, t, null, n);
		}, e.flushSync = function(e) {
			var t = p.T, n = u.p;
			try {
				if (p.T = null, u.p = 2, e) return e();
			} finally {
				p.T = t, u.p = n, u.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
			}
		}, e.preconnect = function(e, t) {
			typeof e == "string" && e ? t != null && typeof t != "object" ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", s(t)) : t != null && typeof t.crossOrigin != "string" && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", o(t.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", o(e)), typeof e == "string" && (t ? (t = t.crossOrigin, t = typeof t == "string" ? t === "use-credentials" ? t : "" : void 0) : t = null, u.d.C(e, t));
		}, e.prefetchDNS = function(e) {
			if (typeof e != "string" || !e) console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", o(e));
			else if (1 < arguments.length) {
				var t = arguments[1];
				typeof t == "object" && t.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", s(t)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", s(t));
			}
			typeof e == "string" && u.d.D(e);
		}, e.preinit = function(e, t) {
			if (typeof e == "string" && e ? typeof t != "object" || !t ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", s(t)) : t.as !== "style" && t.as !== "script" && console.error("ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are \"style\" and \"script\".", s(t.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", o(e)), typeof e == "string" && t && typeof t.as == "string") {
				var n = t.as, i = a(n, t.crossOrigin), c = typeof t.integrity == "string" ? t.integrity : void 0, l = typeof t.fetchPriority == "string" ? t.fetchPriority : void 0;
				n === "style" ? u.d.S(e, typeof t.precedence == "string" ? t.precedence : void 0, {
					crossOrigin: i,
					integrity: c,
					fetchPriority: l
				}) : n === "script" && u.d.X(e, {
					crossOrigin: i,
					integrity: c,
					fetchPriority: l,
					nonce: typeof t.nonce == "string" ? t.nonce : void 0
				});
			}
		}, e.preinitModule = function(e, t) {
			var n = "";
			if (typeof e == "string" && e || (n += " The `href` argument encountered was " + o(e) + "."), t !== void 0 && typeof t != "object" ? n += " The `options` argument encountered was " + o(t) + "." : t && "as" in t && t.as !== "script" && (n += " The `as` option encountered was " + s(t.as) + "."), n) console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", n);
			else switch (n = t && typeof t.as == "string" ? t.as : "script", n) {
				case "script": break;
				default: n = s(n), console.error("ReactDOM.preinitModule(): Currently the only supported \"as\" type for this function is \"script\" but received \"%s\" instead. This warning was generated for `href` \"%s\". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)", n, e);
			}
			typeof e == "string" && (typeof t == "object" && t ? (t.as == null || t.as === "script") && (n = a(t.as, t.crossOrigin), u.d.M(e, {
				crossOrigin: n,
				integrity: typeof t.integrity == "string" ? t.integrity : void 0,
				nonce: typeof t.nonce == "string" ? t.nonce : void 0
			})) : t ?? u.d.M(e));
		}, e.preload = function(e, t) {
			var n = "";
			if (typeof e == "string" && e || (n += " The `href` argument encountered was " + o(e) + "."), typeof t != "object" || !t ? n += " The `options` argument encountered was " + o(t) + "." : typeof t.as == "string" && t.as || (n += " The `as` option encountered was " + o(t.as) + "."), n && console.error("ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel=\"preload\" as=\"...\" />` tag.%s", n), typeof e == "string" && typeof t == "object" && t && typeof t.as == "string") {
				n = t.as;
				var i = a(n, t.crossOrigin);
				u.d.L(e, n, {
					crossOrigin: i,
					integrity: typeof t.integrity == "string" ? t.integrity : void 0,
					nonce: typeof t.nonce == "string" ? t.nonce : void 0,
					type: typeof t.type == "string" ? t.type : void 0,
					fetchPriority: typeof t.fetchPriority == "string" ? t.fetchPriority : void 0,
					referrerPolicy: typeof t.referrerPolicy == "string" ? t.referrerPolicy : void 0,
					imageSrcSet: typeof t.imageSrcSet == "string" ? t.imageSrcSet : void 0,
					imageSizes: typeof t.imageSizes == "string" ? t.imageSizes : void 0,
					media: typeof t.media == "string" ? t.media : void 0
				});
			}
		}, e.preloadModule = function(e, t) {
			var n = "";
			typeof e == "string" && e || (n += " The `href` argument encountered was " + o(e) + "."), t !== void 0 && typeof t != "object" ? n += " The `options` argument encountered was " + o(t) + "." : t && "as" in t && typeof t.as != "string" && (n += " The `as` option encountered was " + o(t.as) + "."), n && console.error("ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel=\"modulepreload\" as=\"...\" />` tag.%s", n), typeof e == "string" && (t ? (n = a(t.as, t.crossOrigin), u.d.m(e, {
				as: typeof t.as == "string" && t.as !== "script" ? t.as : void 0,
				crossOrigin: n,
				integrity: typeof t.integrity == "string" ? t.integrity : void 0
			})) : u.d.m(e));
		}, e.requestFormReset = function(e) {
			u.d.r(e);
		}, e.unstable_batchedUpdates = function(e, t) {
			return e(t);
		}, e.useFormState = function(e, t, n) {
			return c().useFormState(e, t, n);
		}, e.useFormStatus = function() {
			return c().useHostTransitionStatus();
		}, e.version = "19.2.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
})), require_react_dom = /* @__PURE__ */ __commonJSMin(((e, t) => {
	function n() {
		if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
			if (process.env.NODE_ENV !== "production") throw Error("^_^");
			try {
				__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
			} catch (e) {
				console.error(e);
			}
		}
	}
	process.env.NODE_ENV === "production" ? (n(), t.exports = require_react_dom_production()) : t.exports = require_react_dom_development();
})), require_react_dom_client_production = /* @__PURE__ */ __commonJSMin(((e) => {
	var t = require_scheduler(), n = require_react(), i = require_react_dom();
	function a(e) {
		var t = "https://react.dev/errors/" + e;
		if (1 < arguments.length) {
			t += "?args[]=" + encodeURIComponent(arguments[1]);
			for (var n = 2; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
		}
		return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
	}
	function o(e) {
		return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
	}
	function s(e) {
		var t = e, n = e;
		if (e.alternate) for (; t.return;) t = t.return;
		else {
			e = t;
			do
				t = e, t.flags & 4098 && (n = t.return), e = t.return;
			while (e);
		}
		return t.tag === 3 ? n : null;
	}
	function c(e) {
		if (e.tag === 13) {
			var t = e.memoizedState;
			if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
		}
		return null;
	}
	function l(e) {
		if (e.tag === 31) {
			var t = e.memoizedState;
			if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
		}
		return null;
	}
	function u(e) {
		if (s(e) !== e) throw Error(a(188));
	}
	function d(e) {
		var t = e.alternate;
		if (!t) {
			if (t = s(e), t === null) throw Error(a(188));
			return t === e ? e : null;
		}
		for (var n = e, i = t;;) {
			var o = n.return;
			if (o === null) break;
			var c = o.alternate;
			if (c === null) {
				if (i = o.return, i !== null) {
					n = i;
					continue;
				}
				break;
			}
			if (o.child === c.child) {
				for (c = o.child; c;) {
					if (c === n) return u(o), e;
					if (c === i) return u(o), t;
					c = c.sibling;
				}
				throw Error(a(188));
			}
			if (n.return !== i.return) n = o, i = c;
			else {
				for (var l = !1, d = o.child; d;) {
					if (d === n) {
						l = !0, n = o, i = c;
						break;
					}
					if (d === i) {
						l = !0, i = o, n = c;
						break;
					}
					d = d.sibling;
				}
				if (!l) {
					for (d = c.child; d;) {
						if (d === n) {
							l = !0, n = c, i = o;
							break;
						}
						if (d === i) {
							l = !0, i = c, n = o;
							break;
						}
						d = d.sibling;
					}
					if (!l) throw Error(a(189));
				}
			}
			if (n.alternate !== i) throw Error(a(190));
		}
		if (n.tag !== 3) throw Error(a(188));
		return n.stateNode.current === n ? e : t;
	}
	function p(e) {
		var t = e.tag;
		if (t === 5 || t === 26 || t === 27 || t === 6) return e;
		for (e = e.child; e !== null;) {
			if (t = p(e), t !== null) return t;
			e = e.sibling;
		}
		return null;
	}
	var m = Object.assign, g = Symbol.for("react.element"), _ = Symbol.for("react.transitional.element"), y = Symbol.for("react.portal"), b = Symbol.for("react.fragment"), x = Symbol.for("react.strict_mode"), S = Symbol.for("react.profiler"), C = Symbol.for("react.consumer"), w = Symbol.for("react.context"), T = Symbol.for("react.forward_ref"), E = Symbol.for("react.suspense"), O = Symbol.for("react.suspense_list"), k = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), j = Symbol.for("react.activity"), M = Symbol.for("react.memo_cache_sentinel"), N = Symbol.iterator;
	function P(e) {
		return typeof e != "object" || !e ? null : (e = N && e[N] || e["@@iterator"], typeof e == "function" ? e : null);
	}
	var F = Symbol.for("react.client.reference");
	function I(e) {
		if (e == null) return null;
		if (typeof e == "function") return e.$$typeof === F ? null : e.displayName || e.name || null;
		if (typeof e == "string") return e;
		switch (e) {
			case b: return "Fragment";
			case S: return "Profiler";
			case x: return "StrictMode";
			case E: return "Suspense";
			case O: return "SuspenseList";
			case j: return "Activity";
		}
		if (typeof e == "object") switch (e.$$typeof) {
			case y: return "Portal";
			case w: return e.displayName || "Context";
			case C: return (e._context.displayName || "Context") + ".Consumer";
			case T:
				var t = e.render;
				return e = e.displayName, e ||= (e = t.displayName || t.name || "", e === "" ? "ForwardRef" : "ForwardRef(" + e + ")"), e;
			case k: return t = e.displayName || null, t === null ? I(e.type) || "Memo" : t;
			case A:
				t = e._payload, e = e._init;
				try {
					return I(e(t));
				} catch {}
		}
		return null;
	}
	var ee = Array.isArray, L = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, R = i.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, te = {
		pending: !1,
		data: null,
		method: null,
		action: null
	}, ne = [], ie = -1;
	function ae(e) {
		return { current: e };
	}
	function oe(e) {
		0 > ie || (e.current = ne[ie], ne[ie] = null, ie--);
	}
	function z(e, t) {
		ie++, ne[ie] = e.current, e.current = t;
	}
	var se = ae(null), ce = ae(null), le = ae(null), ue = ae(null);
	function de(e, t) {
		switch (z(le, t), z(ce, e), z(se, null), t.nodeType) {
			case 9:
			case 11:
				e = (e = t.documentElement) && (e = e.namespaceURI) ? ff(e) : 0;
				break;
			default: if (e = t.tagName, t = t.namespaceURI) t = ff(t), e = pf(t, e);
			else switch (e) {
				case "svg":
					e = 1;
					break;
				case "math":
					e = 2;
					break;
				default: e = 0;
			}
		}
		oe(se), z(se, e);
	}
	function fe() {
		oe(se), oe(ce), oe(le);
	}
	function pe(e) {
		e.memoizedState !== null && z(ue, e);
		var t = se.current, n = pf(t, e.type);
		t !== n && (z(ce, e), z(se, n));
	}
	function V(e) {
		ce.current === e && (oe(se), oe(ce)), ue.current === e && (oe(ue), xp._currentValue = te);
	}
	var me, he;
	function ge(e) {
		if (me === void 0) try {
			throw Error();
		} catch (e) {
			var t = e.stack.trim().match(/\n( *(at )?)/);
			me = t && t[1] || "", he = -1 < e.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e.stack.indexOf("@") ? "@unknown:0:0" : "";
		}
		return "\n" + me + e + he;
	}
	var _e = !1;
	function H(e, t) {
		if (!e || _e) return "";
		_e = !0;
		var n = Error.prepareStackTrace;
		Error.prepareStackTrace = void 0;
		try {
			var i = { DetermineComponentFrameRoot: function() {
				try {
					if (t) {
						var n = function() {
							throw Error();
						};
						if (Object.defineProperty(n.prototype, "props", { set: function() {
							throw Error();
						} }), typeof Reflect == "object" && Reflect.construct) {
							try {
								Reflect.construct(n, []);
							} catch (e) {
								var i = e;
							}
							Reflect.construct(e, [], n);
						} else {
							try {
								n.call();
							} catch (e) {
								i = e;
							}
							e.call(n.prototype);
						}
					} else {
						try {
							throw Error();
						} catch (e) {
							i = e;
						}
						(n = e()) && typeof n.catch == "function" && n.catch(function() {});
					}
				} catch (e) {
					if (e && i && typeof e.stack == "string") return [e.stack, i.stack];
				}
				return [null, null];
			} };
			i.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
			var a = Object.getOwnPropertyDescriptor(i.DetermineComponentFrameRoot, "name");
			a && a.configurable && Object.defineProperty(i.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
			var o = i.DetermineComponentFrameRoot(), s = o[0], c = o[1];
			if (s && c) {
				var l = s.split("\n"), u = c.split("\n");
				for (a = i = 0; i < l.length && !l[i].includes("DetermineComponentFrameRoot");) i++;
				for (; a < u.length && !u[a].includes("DetermineComponentFrameRoot");) a++;
				if (i === l.length || a === u.length) for (i = l.length - 1, a = u.length - 1; 1 <= i && 0 <= a && l[i] !== u[a];) a--;
				for (; 1 <= i && 0 <= a; i--, a--) if (l[i] !== u[a]) {
					if (i !== 1 || a !== 1) do
						if (i--, a--, 0 > a || l[i] !== u[a]) {
							var d = "\n" + l[i].replace(" at new ", " at ");
							return e.displayName && d.includes("<anonymous>") && (d = d.replace("<anonymous>", e.displayName)), d;
						}
					while (1 <= i && 0 <= a);
					break;
				}
			}
		} finally {
			_e = !1, Error.prepareStackTrace = n;
		}
		return (n = e ? e.displayName || e.name : "") ? ge(n) : "";
	}
	function ve(e, t) {
		switch (e.tag) {
			case 26:
			case 27:
			case 5: return ge(e.type);
			case 16: return ge("Lazy");
			case 13: return e.child !== t && t !== null ? ge("Suspense Fallback") : ge("Suspense");
			case 19: return ge("SuspenseList");
			case 0:
			case 15: return H(e.type, !1);
			case 11: return H(e.type.render, !1);
			case 1: return H(e.type, !0);
			case 31: return ge("Activity");
			default: return "";
		}
	}
	function ye(e) {
		try {
			var t = "", n = null;
			do
				t += ve(e, n), n = e, e = e.return;
			while (e);
			return t;
		} catch (e) {
			return "\nError generating stack: " + e.message + "\n" + e.stack;
		}
	}
	var be = Object.prototype.hasOwnProperty, xe = t.unstable_scheduleCallback, Se = t.unstable_cancelCallback, Ce = t.unstable_shouldYield, we = t.unstable_requestPaint, Te = t.unstable_now, Ee = t.unstable_getCurrentPriorityLevel, De = t.unstable_ImmediatePriority, Oe = t.unstable_UserBlockingPriority, ke = t.unstable_NormalPriority, Ae = t.unstable_LowPriority, je = t.unstable_IdlePriority, Me = t.log, Ne = t.unstable_setDisableYieldValue, U = null, Pe = null;
	function Fe(e) {
		if (typeof Me == "function" && Ne(e), Pe && typeof Pe.setStrictMode == "function") try {
			Pe.setStrictMode(U, e);
		} catch {}
	}
	var Ie = Math.clz32 ? Math.clz32 : ze, Le = Math.log, Re = Math.LN2;
	function ze(e) {
		return e >>>= 0, e === 0 ? 32 : 31 - (Le(e) / Re | 0) | 0;
	}
	var Be = 256, Ve = 262144, He = 4194304;
	function Ue(e) {
		var t = e & 42;
		if (t !== 0) return t;
		switch (e & -e) {
			case 1: return 1;
			case 2: return 2;
			case 4: return 4;
			case 8: return 8;
			case 16: return 16;
			case 32: return 32;
			case 64: return 64;
			case 128: return 128;
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072: return e & 261888;
			case 262144:
			case 524288:
			case 1048576:
			case 2097152: return e & 3932160;
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432: return e & 62914560;
			case 67108864: return 67108864;
			case 134217728: return 134217728;
			case 268435456: return 268435456;
			case 536870912: return 536870912;
			case 1073741824: return 0;
			default: return e;
		}
	}
	function We(e, t, n) {
		var i = e.pendingLanes;
		if (i === 0) return 0;
		var a = 0, o = e.suspendedLanes, s = e.pingedLanes;
		e = e.warmLanes;
		var c = i & 134217727;
		return c === 0 ? (c = i & ~o, c === 0 ? s === 0 ? n || (n = i & ~e, n !== 0 && (a = Ue(n))) : a = Ue(s) : a = Ue(c)) : (i = c & ~o, i === 0 ? (s &= c, s === 0 ? n || (n = c & ~e, n !== 0 && (a = Ue(n))) : a = Ue(s)) : a = Ue(i)), a === 0 ? 0 : t !== 0 && t !== a && (t & o) === 0 && (o = a & -a, n = t & -t, o >= n || o === 32 && n & 4194048) ? t : a;
	}
	function W(e, t) {
		return (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & t) === 0;
	}
	function Ge(e, t) {
		switch (e) {
			case 1:
			case 2:
			case 4:
			case 8:
			case 64: return t + 250;
			case 16:
			case 32:
			case 128:
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072:
			case 262144:
			case 524288:
			case 1048576:
			case 2097152: return t + 5e3;
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432: return -1;
			case 67108864:
			case 134217728:
			case 268435456:
			case 536870912:
			case 1073741824: return -1;
			default: return -1;
		}
	}
	function Ke() {
		var e = He;
		return He <<= 1, !(He & 62914560) && (He = 4194304), e;
	}
	function qe(e) {
		for (var t = [], n = 0; 31 > n; n++) t.push(e);
		return t;
	}
	function Je(e, t) {
		e.pendingLanes |= t, t !== 268435456 && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0);
	}
	function G(e, t, n, i, a, o) {
		var s = e.pendingLanes;
		e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= n, e.entangledLanes &= n, e.errorRecoveryDisabledLanes &= n, e.shellSuspendCounter = 0;
		var c = e.entanglements, l = e.expirationTimes, u = e.hiddenUpdates;
		for (n = s & ~n; 0 < n;) {
			var d = 31 - Ie(n), f = 1 << d;
			c[d] = 0, l[d] = -1;
			var p = u[d];
			if (p !== null) for (u[d] = null, d = 0; d < p.length; d++) {
				var m = p[d];
				m !== null && (m.lane &= -536870913);
			}
			n &= ~f;
		}
		i !== 0 && Ye(e, i, 0), o !== 0 && a === 0 && e.tag !== 0 && (e.suspendedLanes |= o & ~(s & ~t));
	}
	function Ye(e, t, n) {
		e.pendingLanes |= t, e.suspendedLanes &= ~t;
		var i = 31 - Ie(t);
		e.entangledLanes |= t, e.entanglements[i] = e.entanglements[i] | 1073741824 | n & 261930;
	}
	function Xe(e, t) {
		var n = e.entangledLanes |= t;
		for (e = e.entanglements; n;) {
			var i = 31 - Ie(n), a = 1 << i;
			a & t | e[i] & t && (e[i] |= t), n &= ~a;
		}
	}
	function Ze(e, t) {
		var n = t & -t;
		return n = n & 42 ? 1 : Qe(n), (n & (e.suspendedLanes | t)) === 0 ? n : 0;
	}
	function Qe(e) {
		switch (e) {
			case 2:
				e = 1;
				break;
			case 8:
				e = 4;
				break;
			case 32:
				e = 16;
				break;
			case 256:
			case 512:
			case 1024:
			case 2048:
			case 4096:
			case 8192:
			case 16384:
			case 32768:
			case 65536:
			case 131072:
			case 262144:
			case 524288:
			case 1048576:
			case 2097152:
			case 4194304:
			case 8388608:
			case 16777216:
			case 33554432:
				e = 128;
				break;
			case 268435456:
				e = 134217728;
				break;
			default: e = 0;
		}
		return e;
	}
	function $e(e) {
		return e &= -e, 2 < e ? 8 < e ? e & 134217727 ? 32 : 268435456 : 8 : 2;
	}
	function et() {
		var e = R.p;
		return e === 0 ? (e = window.event, e === void 0 ? 32 : Lp(e.type)) : e;
	}
	function tt(e, t) {
		var n = R.p;
		try {
			return R.p = e, t();
		} finally {
			R.p = n;
		}
	}
	var nt = Math.random().toString(36).slice(2), rt = "__reactFiber$" + nt, it = "__reactProps$" + nt, at = "__reactContainer$" + nt, ot = "__reactEvents$" + nt, st = "__reactListeners$" + nt, ct = "__reactHandles$" + nt, lt = "__reactResources$" + nt, ut = "__reactMarker$" + nt;
	function dt(e) {
		delete e[rt], delete e[it], delete e[ot], delete e[st], delete e[ct];
	}
	function ft(e) {
		var t = e[rt];
		if (t) return t;
		for (var n = e.parentNode; n;) {
			if (t = n[at] || n[rt]) {
				if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Ff(e); e !== null;) {
					if (n = e[rt]) return n;
					e = Ff(e);
				}
				return t;
			}
			e = n, n = e.parentNode;
		}
		return null;
	}
	function pt(e) {
		if (e = e[rt] || e[at]) {
			var t = e.tag;
			if (t === 5 || t === 6 || t === 13 || t === 31 || t === 26 || t === 27 || t === 3) return e;
		}
		return null;
	}
	function mt(e) {
		var t = e.tag;
		if (t === 5 || t === 26 || t === 27 || t === 6) return e.stateNode;
		throw Error(a(33));
	}
	function ht(e) {
		var t = e[lt];
		return t ||= e[lt] = {
			hoistableStyles: /* @__PURE__ */ new Map(),
			hoistableScripts: /* @__PURE__ */ new Map()
		}, t;
	}
	function gt(e) {
		e[ut] = !0;
	}
	var _t = /* @__PURE__ */ new Set(), vt = {};
	function yt(e, t) {
		bt(e, t), bt(e + "Capture", t);
	}
	function bt(e, t) {
		for (vt[e] = t, e = 0; e < t.length; e++) _t.add(t[e]);
	}
	var xt = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), St = {}, Ct = {};
	function wt(e) {
		return be.call(Ct, e) ? !0 : be.call(St, e) ? !1 : xt.test(e) ? Ct[e] = !0 : (St[e] = !0, !1);
	}
	function Tt(e, t, n) {
		if (wt(t)) if (n === null) e.removeAttribute(t);
		else {
			switch (typeof n) {
				case "undefined":
				case "function":
				case "symbol":
					e.removeAttribute(t);
					return;
				case "boolean":
					var i = t.toLowerCase().slice(0, 5);
					if (i !== "data-" && i !== "aria-") {
						e.removeAttribute(t);
						return;
					}
			}
			e.setAttribute(t, "" + n);
		}
	}
	function Et(e, t, n) {
		if (n === null) e.removeAttribute(t);
		else {
			switch (typeof n) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean":
					e.removeAttribute(t);
					return;
			}
			e.setAttribute(t, "" + n);
		}
	}
	function Dt(e, t, n, i) {
		if (i === null) e.removeAttribute(n);
		else {
			switch (typeof i) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean":
					e.removeAttribute(n);
					return;
			}
			e.setAttributeNS(t, n, "" + i);
		}
	}
	function Ot(e) {
		switch (typeof e) {
			case "bigint":
			case "boolean":
			case "number":
			case "string":
			case "undefined": return e;
			case "object": return e;
			default: return "";
		}
	}
	function kt(e) {
		var t = e.type;
		return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
	}
	function At(e, t, n) {
		var i = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);
		if (!e.hasOwnProperty(t) && i !== void 0 && typeof i.get == "function" && typeof i.set == "function") {
			var a = i.get, o = i.set;
			return Object.defineProperty(e, t, {
				configurable: !0,
				get: function() {
					return a.call(this);
				},
				set: function(e) {
					n = "" + e, o.call(this, e);
				}
			}), Object.defineProperty(e, t, { enumerable: i.enumerable }), {
				getValue: function() {
					return n;
				},
				setValue: function(e) {
					n = "" + e;
				},
				stopTracking: function() {
					e._valueTracker = null, delete e[t];
				}
			};
		}
	}
	function jt(e) {
		if (!e._valueTracker) {
			var t = kt(e) ? "checked" : "value";
			e._valueTracker = At(e, t, "" + e[t]);
		}
	}
	function Mt(e) {
		if (!e) return !1;
		var t = e._valueTracker;
		if (!t) return !0;
		var n = t.getValue(), i = "";
		return e && (i = kt(e) ? e.checked ? "true" : "false" : e.value), e = i, e === n ? !1 : (t.setValue(e), !0);
	}
	function Nt(e) {
		if (e ||= typeof document < "u" ? document : void 0, e === void 0) return null;
		try {
			return e.activeElement || e.body;
		} catch {
			return e.body;
		}
	}
	var Pt = /[\n"\\]/g;
	function Ft(e) {
		return e.replace(Pt, function(e) {
			return "\\" + e.charCodeAt(0).toString(16) + " ";
		});
	}
	function It(e, t, n, i, a, o, s, c) {
		e.name = "", s != null && typeof s != "function" && typeof s != "symbol" && typeof s != "boolean" ? e.type = s : e.removeAttribute("type"), t == null ? s !== "submit" && s !== "reset" || e.removeAttribute("value") : s === "number" ? (t === 0 && e.value === "" || e.value != t) && (e.value = "" + Ot(t)) : e.value !== "" + Ot(t) && (e.value = "" + Ot(t)), t == null ? n == null ? i != null && e.removeAttribute("value") : Rt(e, s, Ot(n)) : Rt(e, s, Ot(t)), a == null && o != null && (e.defaultChecked = !!o), a != null && (e.checked = a && typeof a != "function" && typeof a != "symbol"), c != null && typeof c != "function" && typeof c != "symbol" && typeof c != "boolean" ? e.name = "" + Ot(c) : e.removeAttribute("name");
	}
	function Lt(e, t, n, i, a, o, s, c) {
		if (o != null && typeof o != "function" && typeof o != "symbol" && typeof o != "boolean" && (e.type = o), t != null || n != null) {
			if (!(o !== "submit" && o !== "reset" || t != null)) {
				jt(e);
				return;
			}
			n = n == null ? "" : "" + Ot(n), t = t == null ? n : "" + Ot(t), c || t === e.value || (e.value = t), e.defaultValue = t;
		}
		i ??= a, i = typeof i != "function" && typeof i != "symbol" && !!i, e.checked = c ? e.checked : !!i, e.defaultChecked = !!i, s != null && typeof s != "function" && typeof s != "symbol" && typeof s != "boolean" && (e.name = s), jt(e);
	}
	function Rt(e, t, n) {
		t === "number" && Nt(e.ownerDocument) === e || e.defaultValue === "" + n || (e.defaultValue = "" + n);
	}
	function zt(e, t, n, i) {
		if (e = e.options, t) {
			t = {};
			for (var a = 0; a < n.length; a++) t["$" + n[a]] = !0;
			for (n = 0; n < e.length; n++) a = t.hasOwnProperty("$" + e[n].value), e[n].selected !== a && (e[n].selected = a), a && i && (e[n].defaultSelected = !0);
		} else {
			for (n = "" + Ot(n), t = null, a = 0; a < e.length; a++) {
				if (e[a].value === n) {
					e[a].selected = !0, i && (e[a].defaultSelected = !0);
					return;
				}
				t !== null || e[a].disabled || (t = e[a]);
			}
			t !== null && (t.selected = !0);
		}
	}
	function Bt(e, t, n) {
		if (t != null && (t = "" + Ot(t), t !== e.value && (e.value = t), n == null)) {
			e.defaultValue !== t && (e.defaultValue = t);
			return;
		}
		e.defaultValue = n == null ? "" : "" + Ot(n);
	}
	function Vt(e, t, n, i) {
		if (t == null) {
			if (i != null) {
				if (n != null) throw Error(a(92));
				if (ee(i)) {
					if (1 < i.length) throw Error(a(93));
					i = i[0];
				}
				n = i;
			}
			n ??= "", t = n;
		}
		n = Ot(t), e.defaultValue = n, i = e.textContent, i === n && i !== "" && i !== null && (e.value = i), jt(e);
	}
	function Ht(e, t) {
		if (t) {
			var n = e.firstChild;
			if (n && n === e.lastChild && n.nodeType === 3) {
				n.nodeValue = t;
				return;
			}
		}
		e.textContent = t;
	}
	var Ut = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
	function Wt(e, t, n) {
		var i = t.indexOf("--") === 0;
		n == null || typeof n == "boolean" || n === "" ? i ? e.setProperty(t, "") : t === "float" ? e.cssFloat = "" : e[t] = "" : i ? e.setProperty(t, n) : typeof n != "number" || n === 0 || Ut.has(t) ? t === "float" ? e.cssFloat = n : e[t] = ("" + n).trim() : e[t] = n + "px";
	}
	function Gt(e, t, n) {
		if (t != null && typeof t != "object") throw Error(a(62));
		if (e = e.style, n != null) {
			for (var i in n) !n.hasOwnProperty(i) || t != null && t.hasOwnProperty(i) || (i.indexOf("--") === 0 ? e.setProperty(i, "") : i === "float" ? e.cssFloat = "" : e[i] = "");
			for (var o in t) i = t[o], t.hasOwnProperty(o) && n[o] !== i && Wt(e, o, i);
		} else for (var s in t) t.hasOwnProperty(s) && Wt(e, s, t[s]);
	}
	function Kt(e) {
		if (e.indexOf("-") === -1) return !1;
		switch (e) {
			case "annotation-xml":
			case "color-profile":
			case "font-face":
			case "font-face-src":
			case "font-face-uri":
			case "font-face-format":
			case "font-face-name":
			case "missing-glyph": return !1;
			default: return !0;
		}
	}
	var qt = new Map([
		["acceptCharset", "accept-charset"],
		["htmlFor", "for"],
		["httpEquiv", "http-equiv"],
		["crossOrigin", "crossorigin"],
		["accentHeight", "accent-height"],
		["alignmentBaseline", "alignment-baseline"],
		["arabicForm", "arabic-form"],
		["baselineShift", "baseline-shift"],
		["capHeight", "cap-height"],
		["clipPath", "clip-path"],
		["clipRule", "clip-rule"],
		["colorInterpolation", "color-interpolation"],
		["colorInterpolationFilters", "color-interpolation-filters"],
		["colorProfile", "color-profile"],
		["colorRendering", "color-rendering"],
		["dominantBaseline", "dominant-baseline"],
		["enableBackground", "enable-background"],
		["fillOpacity", "fill-opacity"],
		["fillRule", "fill-rule"],
		["floodColor", "flood-color"],
		["floodOpacity", "flood-opacity"],
		["fontFamily", "font-family"],
		["fontSize", "font-size"],
		["fontSizeAdjust", "font-size-adjust"],
		["fontStretch", "font-stretch"],
		["fontStyle", "font-style"],
		["fontVariant", "font-variant"],
		["fontWeight", "font-weight"],
		["glyphName", "glyph-name"],
		["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
		["glyphOrientationVertical", "glyph-orientation-vertical"],
		["horizAdvX", "horiz-adv-x"],
		["horizOriginX", "horiz-origin-x"],
		["imageRendering", "image-rendering"],
		["letterSpacing", "letter-spacing"],
		["lightingColor", "lighting-color"],
		["markerEnd", "marker-end"],
		["markerMid", "marker-mid"],
		["markerStart", "marker-start"],
		["overlinePosition", "overline-position"],
		["overlineThickness", "overline-thickness"],
		["paintOrder", "paint-order"],
		["panose-1", "panose-1"],
		["pointerEvents", "pointer-events"],
		["renderingIntent", "rendering-intent"],
		["shapeRendering", "shape-rendering"],
		["stopColor", "stop-color"],
		["stopOpacity", "stop-opacity"],
		["strikethroughPosition", "strikethrough-position"],
		["strikethroughThickness", "strikethrough-thickness"],
		["strokeDasharray", "stroke-dasharray"],
		["strokeDashoffset", "stroke-dashoffset"],
		["strokeLinecap", "stroke-linecap"],
		["strokeLinejoin", "stroke-linejoin"],
		["strokeMiterlimit", "stroke-miterlimit"],
		["strokeOpacity", "stroke-opacity"],
		["strokeWidth", "stroke-width"],
		["textAnchor", "text-anchor"],
		["textDecoration", "text-decoration"],
		["textRendering", "text-rendering"],
		["transformOrigin", "transform-origin"],
		["underlinePosition", "underline-position"],
		["underlineThickness", "underline-thickness"],
		["unicodeBidi", "unicode-bidi"],
		["unicodeRange", "unicode-range"],
		["unitsPerEm", "units-per-em"],
		["vAlphabetic", "v-alphabetic"],
		["vHanging", "v-hanging"],
		["vIdeographic", "v-ideographic"],
		["vMathematical", "v-mathematical"],
		["vectorEffect", "vector-effect"],
		["vertAdvY", "vert-adv-y"],
		["vertOriginX", "vert-origin-x"],
		["vertOriginY", "vert-origin-y"],
		["wordSpacing", "word-spacing"],
		["writingMode", "writing-mode"],
		["xmlnsXlink", "xmlns:xlink"],
		["xHeight", "x-height"]
	]), Jt = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
	function Yt(e) {
		return Jt.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e;
	}
	function Xt() {}
	var Zt = null;
	function Qt(e) {
		return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
	}
	var K = null, $t = null;
	function en(e) {
		var t = pt(e);
		if (t && (e = t.stateNode)) {
			var n = e[it] || null;
			a: switch (e = t.stateNode, t.type) {
				case "input":
					if (It(e, n.value, n.defaultValue, n.defaultValue, n.checked, n.defaultChecked, n.type, n.name), t = n.name, n.type === "radio" && t != null) {
						for (n = e; n.parentNode;) n = n.parentNode;
						for (n = n.querySelectorAll("input[name=\"" + Ft("" + t) + "\"][type=\"radio\"]"), t = 0; t < n.length; t++) {
							var i = n[t];
							if (i !== e && i.form === e.form) {
								var o = i[it] || null;
								if (!o) throw Error(a(90));
								It(i, o.value, o.defaultValue, o.defaultValue, o.checked, o.defaultChecked, o.type, o.name);
							}
						}
						for (t = 0; t < n.length; t++) i = n[t], i.form === e.form && Mt(i);
					}
					break a;
				case "textarea":
					Bt(e, n.value, n.defaultValue);
					break a;
				case "select": t = n.value, t != null && zt(e, !!n.multiple, t, !1);
			}
		}
	}
	var tn = !1;
	function nn(e, t, n) {
		if (tn) return e(t, n);
		tn = !0;
		try {
			return e(t);
		} finally {
			if (tn = !1, (K !== null || $t !== null) && (Ru(), K && (t = K, e = $t, $t = K = null, en(t), e))) for (t = 0; t < e.length; t++) en(e[t]);
		}
	}
	function rn(e, t) {
		var n = e.stateNode;
		if (n === null) return null;
		var i = n[it] || null;
		if (i === null) return null;
		n = i[t];
		a: switch (t) {
			case "onClick":
			case "onClickCapture":
			case "onDoubleClick":
			case "onDoubleClickCapture":
			case "onMouseDown":
			case "onMouseDownCapture":
			case "onMouseMove":
			case "onMouseMoveCapture":
			case "onMouseUp":
			case "onMouseUpCapture":
			case "onMouseEnter":
				(i = !i.disabled) || (e = e.type, i = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !i;
				break a;
			default: e = !1;
		}
		if (e) return null;
		if (n && typeof n != "function") throw Error(a(231, t, typeof n));
		return n;
	}
	var an = !(typeof window > "u" || window.document === void 0 || window.document.createElement === void 0), on = !1;
	if (an) try {
		var sn = {};
		Object.defineProperty(sn, "passive", { get: function() {
			on = !0;
		} }), window.addEventListener("test", sn, sn), window.removeEventListener("test", sn, sn);
	} catch {
		on = !1;
	}
	var ln = null, un = null, dn = null;
	function fn() {
		if (dn) return dn;
		var e, t = un, n = t.length, i, a = "value" in ln ? ln.value : ln.textContent, o = a.length;
		for (e = 0; e < n && t[e] === a[e]; e++);
		var s = n - e;
		for (i = 1; i <= s && t[n - i] === a[o - i]; i++);
		return dn = a.slice(e, 1 < i ? 1 - i : void 0);
	}
	function pn(e) {
		var t = e.keyCode;
		return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
	}
	function mn() {
		return !0;
	}
	function hn() {
		return !1;
	}
	function gn(e) {
		function t(t, n, i, a, o) {
			for (var s in this._reactName = t, this._targetInst = i, this.type = n, this.nativeEvent = a, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(s) && (t = e[s], this[s] = t ? t(a) : a[s]);
			return this.isDefaultPrevented = (a.defaultPrevented == null ? !1 === a.returnValue : a.defaultPrevented) ? mn : hn, this.isPropagationStopped = hn, this;
		}
		return m(t.prototype, {
			preventDefault: function() {
				this.defaultPrevented = !0;
				var e = this.nativeEvent;
				e && (e.preventDefault ? e.preventDefault() : typeof e.returnValue != "unknown" && (e.returnValue = !1), this.isDefaultPrevented = mn);
			},
			stopPropagation: function() {
				var e = this.nativeEvent;
				e && (e.stopPropagation ? e.stopPropagation() : typeof e.cancelBubble != "unknown" && (e.cancelBubble = !0), this.isPropagationStopped = mn);
			},
			persist: function() {},
			isPersistent: mn
		}), t;
	}
	var _n = {
		eventPhase: 0,
		bubbles: 0,
		cancelable: 0,
		timeStamp: function(e) {
			return e.timeStamp || Date.now();
		},
		defaultPrevented: 0,
		isTrusted: 0
	}, vn = gn(_n), yn = m({}, _n, {
		view: 0,
		detail: 0
	}), bn = gn(yn), xn, Sn, Cn, wn = m({}, yn, {
		screenX: 0,
		screenY: 0,
		clientX: 0,
		clientY: 0,
		pageX: 0,
		pageY: 0,
		ctrlKey: 0,
		shiftKey: 0,
		altKey: 0,
		metaKey: 0,
		getModifierState: Bn,
		button: 0,
		buttons: 0,
		relatedTarget: function(e) {
			return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
		},
		movementX: function(e) {
			return "movementX" in e ? e.movementX : (e !== Cn && (Cn && e.type === "mousemove" ? (xn = e.screenX - Cn.screenX, Sn = e.screenY - Cn.screenY) : Sn = xn = 0, Cn = e), xn);
		},
		movementY: function(e) {
			return "movementY" in e ? e.movementY : Sn;
		}
	}), Tn = gn(wn), En = m({}, wn, { dataTransfer: 0 }), Dn = gn(En), On = m({}, yn, { relatedTarget: 0 }), kn = gn(On), An = m({}, _n, {
		animationName: 0,
		elapsedTime: 0,
		pseudoElement: 0
	}), jn = gn(An), Mn = m({}, _n, { clipboardData: function(e) {
		return "clipboardData" in e ? e.clipboardData : window.clipboardData;
	} }), Nn = gn(Mn), Pn = m({}, _n, { data: 0 }), Fn = gn(Pn), In = {
		Esc: "Escape",
		Spacebar: " ",
		Left: "ArrowLeft",
		Up: "ArrowUp",
		Right: "ArrowRight",
		Down: "ArrowDown",
		Del: "Delete",
		Win: "OS",
		Menu: "ContextMenu",
		Apps: "ContextMenu",
		Scroll: "ScrollLock",
		MozPrintableKey: "Unidentified"
	}, Ln = {
		8: "Backspace",
		9: "Tab",
		12: "Clear",
		13: "Enter",
		16: "Shift",
		17: "Control",
		18: "Alt",
		19: "Pause",
		20: "CapsLock",
		27: "Escape",
		32: " ",
		33: "PageUp",
		34: "PageDown",
		35: "End",
		36: "Home",
		37: "ArrowLeft",
		38: "ArrowUp",
		39: "ArrowRight",
		40: "ArrowDown",
		45: "Insert",
		46: "Delete",
		112: "F1",
		113: "F2",
		114: "F3",
		115: "F4",
		116: "F5",
		117: "F6",
		118: "F7",
		119: "F8",
		120: "F9",
		121: "F10",
		122: "F11",
		123: "F12",
		144: "NumLock",
		145: "ScrollLock",
		224: "Meta"
	}, Rn = {
		Alt: "altKey",
		Control: "ctrlKey",
		Meta: "metaKey",
		Shift: "shiftKey"
	};
	function zn(e) {
		var t = this.nativeEvent;
		return t.getModifierState ? t.getModifierState(e) : (e = Rn[e]) ? !!t[e] : !1;
	}
	function Bn() {
		return zn;
	}
	var Vn = m({}, yn, {
		key: function(e) {
			if (e.key) {
				var t = In[e.key] || e.key;
				if (t !== "Unidentified") return t;
			}
			return e.type === "keypress" ? (e = pn(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Ln[e.keyCode] || "Unidentified" : "";
		},
		code: 0,
		location: 0,
		ctrlKey: 0,
		shiftKey: 0,
		altKey: 0,
		metaKey: 0,
		repeat: 0,
		locale: 0,
		getModifierState: Bn,
		charCode: function(e) {
			return e.type === "keypress" ? pn(e) : 0;
		},
		keyCode: function(e) {
			return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
		},
		which: function(e) {
			return e.type === "keypress" ? pn(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
		}
	}), Hn = gn(Vn), Un = m({}, wn, {
		pointerId: 0,
		width: 0,
		height: 0,
		pressure: 0,
		tangentialPressure: 0,
		tiltX: 0,
		tiltY: 0,
		twist: 0,
		pointerType: 0,
		isPrimary: 0
	}), Wn = gn(Un), Gn = m({}, yn, {
		touches: 0,
		targetTouches: 0,
		changedTouches: 0,
		altKey: 0,
		metaKey: 0,
		ctrlKey: 0,
		shiftKey: 0,
		getModifierState: Bn
	}), Kn = gn(Gn), qn = m({}, _n, {
		propertyName: 0,
		elapsedTime: 0,
		pseudoElement: 0
	}), Jn = gn(qn), Yn = m({}, wn, {
		deltaX: function(e) {
			return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
		},
		deltaY: function(e) {
			return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
		},
		deltaZ: 0,
		deltaMode: 0
	}), Xn = gn(Yn), Zn = m({}, _n, {
		newState: 0,
		oldState: 0
	}), Qn = gn(Zn), $n = [
		9,
		13,
		27,
		32
	], er = an && "CompositionEvent" in window, tr = null;
	an && "documentMode" in document && (tr = document.documentMode);
	var nr = an && "TextEvent" in window && !tr, rr = an && (!er || tr && 8 < tr && 11 >= tr), ir = " ", ar = !1;
	function or(e, t) {
		switch (e) {
			case "keyup": return $n.indexOf(t.keyCode) !== -1;
			case "keydown": return t.keyCode !== 229;
			case "keypress":
			case "mousedown":
			case "focusout": return !0;
			default: return !1;
		}
	}
	function sr(e) {
		return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
	}
	var cr = !1;
	function lr(e, t) {
		switch (e) {
			case "compositionend": return sr(t);
			case "keypress": return t.which === 32 ? (ar = !0, ir) : null;
			case "textInput": return e = t.data, e === ir && ar ? null : e;
			default: return null;
		}
	}
	function ur(e, t) {
		if (cr) return e === "compositionend" || !er && or(e, t) ? (e = fn(), dn = un = ln = null, cr = !1, e) : null;
		switch (e) {
			case "paste": return null;
			case "keypress":
				if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
					if (t.char && 1 < t.char.length) return t.char;
					if (t.which) return String.fromCharCode(t.which);
				}
				return null;
			case "compositionend": return rr && t.locale !== "ko" ? null : t.data;
			default: return null;
		}
	}
	var dr = {
		color: !0,
		date: !0,
		datetime: !0,
		"datetime-local": !0,
		email: !0,
		month: !0,
		number: !0,
		password: !0,
		range: !0,
		search: !0,
		tel: !0,
		text: !0,
		time: !0,
		url: !0,
		week: !0
	};
	function fr(e) {
		var t = e && e.nodeName && e.nodeName.toLowerCase();
		return t === "input" ? !!dr[e.type] : t === "textarea";
	}
	function pr(e, t, n, i) {
		K ? $t ? $t.push(i) : $t = [i] : K = i, t = Jd(t, "onChange"), 0 < t.length && (n = new vn("onChange", "change", null, n, i), e.push({
			event: n,
			listeners: t
		}));
	}
	var mr = null, hr = null;
	function gr(e) {
		Bd(e, 0);
	}
	function _r(e) {
		var t = mt(e);
		if (Mt(t)) return e;
	}
	function vr(e, t) {
		if (e === "change") return t;
	}
	var yr = !1;
	if (an) {
		var br;
		if (an) {
			var xr = "oninput" in document;
			if (!xr) {
				var Sr = document.createElement("div");
				Sr.setAttribute("oninput", "return;"), xr = typeof Sr.oninput == "function";
			}
			br = xr;
		} else br = !1;
		yr = br && (!document.documentMode || 9 < document.documentMode);
	}
	function Cr() {
		mr && (mr.detachEvent("onpropertychange", wr), hr = mr = null);
	}
	function wr(e) {
		if (e.propertyName === "value" && _r(hr)) {
			var t = [];
			pr(t, hr, e, Qt(e)), nn(gr, t);
		}
	}
	function Tr(e, t, n) {
		e === "focusin" ? (Cr(), mr = t, hr = n, mr.attachEvent("onpropertychange", wr)) : e === "focusout" && Cr();
	}
	function Er(e) {
		if (e === "selectionchange" || e === "keyup" || e === "keydown") return _r(hr);
	}
	function Dr(e, t) {
		if (e === "click") return _r(t);
	}
	function Or(e, t) {
		if (e === "input" || e === "change") return _r(t);
	}
	function kr(e, t) {
		return e === t && (e !== 0 || 1 / e == 1 / t) || e !== e && t !== t;
	}
	var Ar = typeof Object.is == "function" ? Object.is : kr;
	function jr(e, t) {
		if (Ar(e, t)) return !0;
		if (typeof e != "object" || !e || typeof t != "object" || !t) return !1;
		var n = Object.keys(e), i = Object.keys(t);
		if (n.length !== i.length) return !1;
		for (i = 0; i < n.length; i++) {
			var a = n[i];
			if (!be.call(t, a) || !Ar(e[a], t[a])) return !1;
		}
		return !0;
	}
	function Mr(e) {
		for (; e && e.firstChild;) e = e.firstChild;
		return e;
	}
	function Nr(e, t) {
		var n = Mr(e);
		e = 0;
		for (var i; n;) {
			if (n.nodeType === 3) {
				if (i = e + n.textContent.length, e <= t && i >= t) return {
					node: n,
					offset: t - e
				};
				e = i;
			}
			a: {
				for (; n;) {
					if (n.nextSibling) {
						n = n.nextSibling;
						break a;
					}
					n = n.parentNode;
				}
				n = void 0;
			}
			n = Mr(n);
		}
	}
	function Pr(e, t) {
		return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Pr(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1;
	}
	function Fr(e) {
		e = e != null && e.ownerDocument != null && e.ownerDocument.defaultView != null ? e.ownerDocument.defaultView : window;
		for (var t = Nt(e.document); t instanceof e.HTMLIFrameElement;) {
			try {
				var n = typeof t.contentWindow.location.href == "string";
			} catch {
				n = !1;
			}
			if (n) e = t.contentWindow;
			else break;
			t = Nt(e.document);
		}
		return t;
	}
	function Ir(e) {
		var t = e && e.nodeName && e.nodeName.toLowerCase();
		return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
	}
	var Lr = an && "documentMode" in document && 11 >= document.documentMode, Rr = null, zr = null, Br = null, Vr = !1;
	function Hr(e, t, n) {
		var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
		Vr || Rr == null || Rr !== Nt(i) || (i = Rr, "selectionStart" in i && Ir(i) ? i = {
			start: i.selectionStart,
			end: i.selectionEnd
		} : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = {
			anchorNode: i.anchorNode,
			anchorOffset: i.anchorOffset,
			focusNode: i.focusNode,
			focusOffset: i.focusOffset
		}), Br && jr(Br, i) || (Br = i, i = Jd(zr, "onSelect"), 0 < i.length && (t = new vn("onSelect", "select", null, t, n), e.push({
			event: t,
			listeners: i
		}), t.target = Rr)));
	}
	function Ur(e, t) {
		var n = {};
		return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n;
	}
	var Wr = {
		animationend: Ur("Animation", "AnimationEnd"),
		animationiteration: Ur("Animation", "AnimationIteration"),
		animationstart: Ur("Animation", "AnimationStart"),
		transitionrun: Ur("Transition", "TransitionRun"),
		transitionstart: Ur("Transition", "TransitionStart"),
		transitioncancel: Ur("Transition", "TransitionCancel"),
		transitionend: Ur("Transition", "TransitionEnd")
	}, Gr = {}, Kr = {};
	an && (Kr = document.createElement("div").style, "AnimationEvent" in window || (delete Wr.animationend.animation, delete Wr.animationiteration.animation, delete Wr.animationstart.animation), "TransitionEvent" in window || delete Wr.transitionend.transition);
	function qr(e) {
		if (Gr[e]) return Gr[e];
		if (!Wr[e]) return e;
		var t = Wr[e], n;
		for (n in t) if (t.hasOwnProperty(n) && n in Kr) return Gr[e] = t[n];
		return e;
	}
	var Jr = qr("animationend"), Yr = qr("animationiteration"), Xr = qr("animationstart"), Zr = qr("transitionrun"), Qr = qr("transitionstart"), $r = qr("transitioncancel"), ei = qr("transitionend"), ti = /* @__PURE__ */ new Map(), ni = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
	ni.push("scrollEnd");
	function ri(e, t) {
		ti.set(e, t), yt(t, [e]);
	}
	var ii = typeof reportError == "function" ? reportError : function(e) {
		if (typeof window == "object" && typeof window.ErrorEvent == "function") {
			var t = new window.ErrorEvent("error", {
				bubbles: !0,
				cancelable: !0,
				message: typeof e == "object" && e && typeof e.message == "string" ? String(e.message) : String(e),
				error: e
			});
			if (!window.dispatchEvent(t)) return;
		} else if (typeof process == "object" && typeof process.emit == "function") {
			process.emit("uncaughtException", e);
			return;
		}
		console.error(e);
	}, ai = [], oi = 0, si = 0;
	function ci() {
		for (var e = oi, t = si = oi = 0; t < e;) {
			var n = ai[t];
			ai[t++] = null;
			var i = ai[t];
			ai[t++] = null;
			var a = ai[t];
			ai[t++] = null;
			var o = ai[t];
			if (ai[t++] = null, i !== null && a !== null) {
				var s = i.pending;
				s === null ? a.next = a : (a.next = s.next, s.next = a), i.pending = a;
			}
			o !== 0 && fi(n, a, o);
		}
	}
	function li(e, t, n, i) {
		ai[oi++] = e, ai[oi++] = t, ai[oi++] = n, ai[oi++] = i, si |= i, e.lanes |= i, e = e.alternate, e !== null && (e.lanes |= i);
	}
	function ui(e, t, n, i) {
		return li(e, t, n, i), pi(e);
	}
	function di(e, t) {
		return li(e, null, null, t), pi(e);
	}
	function fi(e, t, n) {
		e.lanes |= n;
		var i = e.alternate;
		i !== null && (i.lanes |= n);
		for (var a = !1, o = e.return; o !== null;) o.childLanes |= n, i = o.alternate, i !== null && (i.childLanes |= n), o.tag === 22 && (e = o.stateNode, e === null || e._visibility & 1 || (a = !0)), e = o, o = o.return;
		return e.tag === 3 ? (o = e.stateNode, a && t !== null && (a = 31 - Ie(n), e = o.hiddenUpdates, i = e[a], i === null ? e[a] = [t] : i.push(t), t.lane = n | 536870912), o) : null;
	}
	function pi(e) {
		if (50 < ku) throw ku = 0, Au = null, Error(a(185));
		for (var t = e.return; t !== null;) e = t, t = e.return;
		return e.tag === 3 ? e.stateNode : null;
	}
	var mi = {};
	function hi(e, t, n, i) {
		this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
	}
	function gi(e, t, n, i) {
		return new hi(e, t, n, i);
	}
	function _i(e) {
		return e = e.prototype, !(!e || !e.isReactComponent);
	}
	function vi(e, t) {
		var n = e.alternate;
		return n === null ? (n = gi(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 65011712, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : {
			lanes: t.lanes,
			firstContext: t.firstContext
		}, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n.refCleanup = e.refCleanup, n;
	}
	function yi(e, t) {
		e.flags &= 65011714;
		var n = e.alternate;
		return n === null ? (e.childLanes = 0, e.lanes = t, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null) : (e.childLanes = n.childLanes, e.lanes = n.lanes, e.child = n.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = n.memoizedProps, e.memoizedState = n.memoizedState, e.updateQueue = n.updateQueue, e.type = n.type, t = n.dependencies, e.dependencies = t === null ? null : {
			lanes: t.lanes,
			firstContext: t.firstContext
		}), e;
	}
	function bi(e, t, n, i, o, s) {
		var c = 0;
		if (i = e, typeof e == "function") _i(e) && (c = 1);
		else if (typeof e == "string") c = fp(e, n, se.current) ? 26 : e === "html" || e === "head" || e === "body" ? 27 : 5;
		else a: switch (e) {
			case j: return e = gi(31, n, t, o), e.elementType = j, e.lanes = s, e;
			case b: return xi(n.children, o, s, t);
			case x:
				c = 8, o |= 24;
				break;
			case S: return e = gi(12, n, t, o | 2), e.elementType = S, e.lanes = s, e;
			case E: return e = gi(13, n, t, o), e.elementType = E, e.lanes = s, e;
			case O: return e = gi(19, n, t, o), e.elementType = O, e.lanes = s, e;
			default:
				if (typeof e == "object" && e) switch (e.$$typeof) {
					case w:
						c = 10;
						break a;
					case C:
						c = 9;
						break a;
					case T:
						c = 11;
						break a;
					case k:
						c = 14;
						break a;
					case A:
						c = 16, i = null;
						break a;
				}
				c = 29, n = Error(a(130, e === null ? "null" : typeof e, "")), i = null;
		}
		return t = gi(c, n, t, o), t.elementType = e, t.type = i, t.lanes = s, t;
	}
	function xi(e, t, n, i) {
		return e = gi(7, e, i, t), e.lanes = n, e;
	}
	function Si(e, t, n) {
		return e = gi(6, e, null, t), e.lanes = n, e;
	}
	function Ci(e) {
		var t = gi(18, null, null, 0);
		return t.stateNode = e, t;
	}
	function wi(e, t, n) {
		return t = gi(4, e.children === null ? [] : e.children, e.key, t), t.lanes = n, t.stateNode = {
			containerInfo: e.containerInfo,
			pendingChildren: null,
			implementation: e.implementation
		}, t;
	}
	var Ti = /* @__PURE__ */ new WeakMap();
	function Ei(e, t) {
		if (typeof e == "object" && e) {
			var n = Ti.get(e);
			return n === void 0 ? (t = {
				value: e,
				source: t,
				stack: ye(t)
			}, Ti.set(e, t), t) : n;
		}
		return {
			value: e,
			source: t,
			stack: ye(t)
		};
	}
	var Di = [], Oi = 0, ki = null, Ai = 0, ji = [], Mi = 0, Ni = null, Pi = 1, Fi = "";
	function Ii(e, t) {
		Di[Oi++] = Ai, Di[Oi++] = ki, ki = e, Ai = t;
	}
	function Li(e, t, n) {
		ji[Mi++] = Pi, ji[Mi++] = Fi, ji[Mi++] = Ni, Ni = e;
		var i = Pi;
		e = Fi;
		var a = 32 - Ie(i) - 1;
		i &= ~(1 << a), n += 1;
		var o = 32 - Ie(t) + a;
		if (30 < o) {
			var s = a - a % 5;
			o = (i & (1 << s) - 1).toString(32), i >>= s, a -= s, Pi = 1 << 32 - Ie(t) + a | n << a | i, Fi = o + e;
		} else Pi = 1 << o | n << a | i, Fi = e;
	}
	function Ri(e) {
		e.return !== null && (Ii(e, 1), Li(e, 1, 0));
	}
	function zi(e) {
		for (; e === ki;) ki = Di[--Oi], Di[Oi] = null, Ai = Di[--Oi], Di[Oi] = null;
		for (; e === Ni;) Ni = ji[--Mi], ji[Mi] = null, Fi = ji[--Mi], ji[Mi] = null, Pi = ji[--Mi], ji[Mi] = null;
	}
	function Bi(e, t) {
		ji[Mi++] = Pi, ji[Mi++] = Fi, ji[Mi++] = Ni, Pi = t.id, Fi = t.overflow, Ni = e;
	}
	var Vi = null, Hi = null, Ui = !1, Wi = null, Gi = !1, Ki = Error(a(519));
	function qi(e) {
		var t = Error(a(418, 1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML", ""));
		throw $i(Ei(t, e)), Ki;
	}
	function Ji(e) {
		var t = e.stateNode, n = e.type, i = e.memoizedProps;
		switch (t[rt] = e, t[it] = i, n) {
			case "dialog":
				Vd("cancel", t), Vd("close", t);
				break;
			case "iframe":
			case "object":
			case "embed":
				Vd("load", t);
				break;
			case "video":
			case "audio":
				for (n = 0; n < Rd.length; n++) Vd(Rd[n], t);
				break;
			case "source":
				Vd("error", t);
				break;
			case "img":
			case "image":
			case "link":
				Vd("error", t), Vd("load", t);
				break;
			case "details":
				Vd("toggle", t);
				break;
			case "input":
				Vd("invalid", t), Lt(t, i.value, i.defaultValue, i.checked, i.defaultChecked, i.type, i.name, !0);
				break;
			case "select":
				Vd("invalid", t);
				break;
			case "textarea": Vd("invalid", t), Vt(t, i.value, i.defaultValue, i.children);
		}
		n = i.children, typeof n != "string" && typeof n != "number" && typeof n != "bigint" || t.textContent === "" + n || !0 === i.suppressHydrationWarning || ef(t.textContent, n) ? (i.popover != null && (Vd("beforetoggle", t), Vd("toggle", t)), i.onScroll != null && Vd("scroll", t), i.onScrollEnd != null && Vd("scrollend", t), i.onClick != null && (t.onclick = Xt), t = !0) : t = !1, t || qi(e, !0);
	}
	function Yi(e) {
		for (Vi = e.return; Vi;) switch (Vi.tag) {
			case 5:
			case 31:
			case 13:
				Gi = !1;
				return;
			case 27:
			case 3:
				Gi = !0;
				return;
			default: Vi = Vi.return;
		}
	}
	function Xi(e) {
		if (e !== Vi) return !1;
		if (!Ui) return Yi(e), Ui = !0, !1;
		var t = e.tag, n;
		if ((n = t !== 3 && t !== 27) && ((n = t === 5) && (n = e.type, n = !(n !== "form" && n !== "button") || mf(e.type, e.memoizedProps)), n = !n), n && Hi && qi(e), Yi(e), t === 13) {
			if (e = e.memoizedState, e = e === null ? null : e.dehydrated, !e) throw Error(a(317));
			Hi = Pf(e);
		} else if (t === 31) {
			if (e = e.memoizedState, e = e === null ? null : e.dehydrated, !e) throw Error(a(317));
			Hi = Pf(e);
		} else t === 27 ? (t = Hi, Sf(e.type) ? (e = Nf, Nf = null, Hi = e) : Hi = t) : Hi = Vi ? Mf(e.stateNode.nextSibling) : null;
		return !0;
	}
	function Zi() {
		Hi = Vi = null, Ui = !1;
	}
	function Qi() {
		var e = Wi;
		return e !== null && (hu === null ? hu = e : hu.push.apply(hu, e), Wi = null), e;
	}
	function $i(e) {
		Wi === null ? Wi = [e] : Wi.push(e);
	}
	var ea = ae(null), ta = null, na = null;
	function ra(e, t, n) {
		z(ea, t._currentValue), t._currentValue = n;
	}
	function ia(e) {
		e._currentValue = ea.current, oe(ea);
	}
	function aa(e, t, n) {
		for (; e !== null;) {
			var i = e.alternate;
			if ((e.childLanes & t) === t ? i !== null && (i.childLanes & t) !== t && (i.childLanes |= t) : (e.childLanes |= t, i !== null && (i.childLanes |= t)), e === n) break;
			e = e.return;
		}
	}
	function oa(e, t, n, i) {
		var o = e.child;
		for (o !== null && (o.return = e); o !== null;) {
			var s = o.dependencies;
			if (s !== null) {
				var c = o.child;
				s = s.firstContext;
				a: for (; s !== null;) {
					var l = s;
					s = o;
					for (var u = 0; u < t.length; u++) if (l.context === t[u]) {
						s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), aa(s.return, n, e), i || (c = null);
						break a;
					}
					s = l.next;
				}
			} else if (o.tag === 18) {
				if (c = o.return, c === null) throw Error(a(341));
				c.lanes |= n, s = c.alternate, s !== null && (s.lanes |= n), aa(c, n, e), c = null;
			} else c = o.child;
			if (c !== null) c.return = o;
			else for (c = o; c !== null;) {
				if (c === e) {
					c = null;
					break;
				}
				if (o = c.sibling, o !== null) {
					o.return = c.return, c = o;
					break;
				}
				c = c.return;
			}
			o = c;
		}
	}
	function sa(e, t, n, i) {
		e = null;
		for (var o = t, s = !1; o !== null;) {
			if (!s) {
				if (o.flags & 524288) s = !0;
				else if (o.flags & 262144) break;
			}
			if (o.tag === 10) {
				var c = o.alternate;
				if (c === null) throw Error(a(387));
				if (c = c.memoizedProps, c !== null) {
					var l = o.type;
					Ar(o.pendingProps.value, c.value) || (e === null ? e = [l] : e.push(l));
				}
			} else if (o === ue.current) {
				if (c = o.alternate, c === null) throw Error(a(387));
				c.memoizedState.memoizedState !== o.memoizedState.memoizedState && (e === null ? e = [xp] : e.push(xp));
			}
			o = o.return;
		}
		e !== null && oa(t, e, n, i), t.flags |= 262144;
	}
	function ca(e) {
		for (e = e.firstContext; e !== null;) {
			if (!Ar(e.context._currentValue, e.memoizedValue)) return !0;
			e = e.next;
		}
		return !1;
	}
	function la(e) {
		ta = e, na = null, e = e.dependencies, e !== null && (e.firstContext = null);
	}
	function q(e) {
		return da(ta, e);
	}
	function ua(e, t) {
		return ta === null && la(e), da(e, t);
	}
	function da(e, t) {
		var n = t._currentValue;
		if (t = {
			context: t,
			memoizedValue: n,
			next: null
		}, na === null) {
			if (e === null) throw Error(a(308));
			na = t, e.dependencies = {
				lanes: 0,
				firstContext: t
			}, e.flags |= 524288;
		} else na = na.next = t;
		return n;
	}
	var fa = typeof AbortController < "u" ? AbortController : function() {
		var e = [], t = this.signal = {
			aborted: !1,
			addEventListener: function(t, n) {
				e.push(n);
			}
		};
		this.abort = function() {
			t.aborted = !0, e.forEach(function(e) {
				return e();
			});
		};
	}, pa = t.unstable_scheduleCallback, ma = t.unstable_NormalPriority, ha = {
		$$typeof: w,
		Consumer: null,
		Provider: null,
		_currentValue: null,
		_currentValue2: null,
		_threadCount: 0
	};
	function ga() {
		return {
			controller: new fa(),
			data: /* @__PURE__ */ new Map(),
			refCount: 0
		};
	}
	function _a(e) {
		e.refCount--, e.refCount === 0 && pa(ma, function() {
			e.controller.abort();
		});
	}
	var J = null, va = 0, ya = 0, ba = null;
	function xa(e, t) {
		if (J === null) {
			var n = J = [];
			va = 0, ya = Ad(), ba = {
				status: "pending",
				value: void 0,
				then: function(e) {
					n.push(e);
				}
			};
		}
		return va++, t.then(Sa, Sa), t;
	}
	function Sa() {
		if (--va === 0 && J !== null) {
			ba !== null && (ba.status = "fulfilled");
			var e = J;
			J = null, ya = 0, ba = null;
			for (var t = 0; t < e.length; t++) (0, e[t])();
		}
	}
	function Ca(e, t) {
		var n = [], i = {
			status: "pending",
			value: null,
			reason: null,
			then: function(e) {
				n.push(e);
			}
		};
		return e.then(function() {
			i.status = "fulfilled", i.value = t;
			for (var e = 0; e < n.length; e++) (0, n[e])(t);
		}, function(e) {
			for (i.status = "rejected", i.reason = e, e = 0; e < n.length; e++) (0, n[e])(void 0);
		}), i;
	}
	var wa = L.S;
	L.S = function(e, t) {
		vu = Te(), typeof t == "object" && t && typeof t.then == "function" && xa(e, t), wa !== null && wa(e, t);
	};
	var Ta = ae(null);
	function Ea() {
		var e = Ta.current;
		return e === null ? $l.pooledCache : e;
	}
	function Da(e, t) {
		t === null ? z(Ta, Ta.current) : z(Ta, t.pool);
	}
	function Oa() {
		var e = Ea();
		return e === null ? null : {
			parent: ha._currentValue,
			pool: e
		};
	}
	var ka = Error(a(460)), Aa = Error(a(474)), ja = Error(a(542)), Ma = { then: function() {} };
	function Na(e) {
		return e = e.status, e === "fulfilled" || e === "rejected";
	}
	function Pa(e, t, n) {
		switch (n = e[n], n === void 0 ? e.push(t) : n !== t && (t.then(Xt, Xt), t = n), t.status) {
			case "fulfilled": return t.value;
			case "rejected": throw e = t.reason, Ra(e), e;
			default:
				if (typeof t.status == "string") t.then(Xt, Xt);
				else {
					if (e = $l, e !== null && 100 < e.shellSuspendCounter) throw Error(a(482));
					e = t, e.status = "pending", e.then(function(e) {
						if (t.status === "pending") {
							var n = t;
							n.status = "fulfilled", n.value = e;
						}
					}, function(e) {
						if (t.status === "pending") {
							var n = t;
							n.status = "rejected", n.reason = e;
						}
					});
				}
				switch (t.status) {
					case "fulfilled": return t.value;
					case "rejected": throw e = t.reason, Ra(e), e;
				}
				throw Ia = t, ka;
		}
	}
	function Fa(e) {
		try {
			var t = e._init;
			return t(e._payload);
		} catch (e) {
			throw typeof e == "object" && e && typeof e.then == "function" ? (Ia = e, ka) : e;
		}
	}
	var Ia = null;
	function La() {
		if (Ia === null) throw Error(a(459));
		var e = Ia;
		return Ia = null, e;
	}
	function Ra(e) {
		if (e === ka || e === ja) throw Error(a(483));
	}
	var za = null, Ba = 0;
	function Va(e) {
		var t = Ba;
		return Ba += 1, za === null && (za = []), Pa(za, e, t);
	}
	function Ha(e, t) {
		t = t.props.ref, e.ref = t === void 0 ? null : t;
	}
	function Ua(e, t) {
		throw t.$$typeof === g ? Error(a(525)) : (e = Object.prototype.toString.call(t), Error(a(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)));
	}
	function Wa(e) {
		function t(t, n) {
			if (e) {
				var i = t.deletions;
				i === null ? (t.deletions = [n], t.flags |= 16) : i.push(n);
			}
		}
		function n(n, i) {
			if (!e) return null;
			for (; i !== null;) t(n, i), i = i.sibling;
			return null;
		}
		function i(e) {
			for (var t = /* @__PURE__ */ new Map(); e !== null;) e.key === null ? t.set(e.index, e) : t.set(e.key, e), e = e.sibling;
			return t;
		}
		function o(e, t) {
			return e = vi(e, t), e.index = 0, e.sibling = null, e;
		}
		function s(t, n, i) {
			return t.index = i, e ? (i = t.alternate, i === null ? (t.flags |= 67108866, n) : (i = i.index, i < n ? (t.flags |= 67108866, n) : i)) : (t.flags |= 1048576, n);
		}
		function c(t) {
			return e && t.alternate === null && (t.flags |= 67108866), t;
		}
		function l(e, t, n, i) {
			return t === null || t.tag !== 6 ? (t = Si(n, e.mode, i), t.return = e, t) : (t = o(t, n), t.return = e, t);
		}
		function u(e, t, n, i) {
			var a = n.type;
			return a === b ? f(e, t, n.props.children, i, n.key) : t !== null && (t.elementType === a || typeof a == "object" && a && a.$$typeof === A && Fa(a) === t.type) ? (t = o(t, n.props), Ha(t, n), t.return = e, t) : (t = bi(n.type, n.key, n.props, null, e.mode, i), Ha(t, n), t.return = e, t);
		}
		function d(e, t, n, i) {
			return t === null || t.tag !== 4 || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? (t = wi(n, e.mode, i), t.return = e, t) : (t = o(t, n.children || []), t.return = e, t);
		}
		function f(e, t, n, i, a) {
			return t === null || t.tag !== 7 ? (t = xi(n, e.mode, i, a), t.return = e, t) : (t = o(t, n), t.return = e, t);
		}
		function p(e, t, n) {
			if (typeof t == "string" && t !== "" || typeof t == "number" || typeof t == "bigint") return t = Si("" + t, e.mode, n), t.return = e, t;
			if (typeof t == "object" && t) {
				switch (t.$$typeof) {
					case _: return n = bi(t.type, t.key, t.props, null, e.mode, n), Ha(n, t), n.return = e, n;
					case y: return t = wi(t, e.mode, n), t.return = e, t;
					case A: return t = Fa(t), p(e, t, n);
				}
				if (ee(t) || P(t)) return t = xi(t, e.mode, n, null), t.return = e, t;
				if (typeof t.then == "function") return p(e, Va(t), n);
				if (t.$$typeof === w) return p(e, ua(e, t), n);
				Ua(e, t);
			}
			return null;
		}
		function m(e, t, n, i) {
			var a = t === null ? null : t.key;
			if (typeof n == "string" && n !== "" || typeof n == "number" || typeof n == "bigint") return a === null ? l(e, t, "" + n, i) : null;
			if (typeof n == "object" && n) {
				switch (n.$$typeof) {
					case _: return n.key === a ? u(e, t, n, i) : null;
					case y: return n.key === a ? d(e, t, n, i) : null;
					case A: return n = Fa(n), m(e, t, n, i);
				}
				if (ee(n) || P(n)) return a === null ? f(e, t, n, i, null) : null;
				if (typeof n.then == "function") return m(e, t, Va(n), i);
				if (n.$$typeof === w) return m(e, t, ua(e, n), i);
				Ua(e, n);
			}
			return null;
		}
		function h(e, t, n, i, a) {
			if (typeof i == "string" && i !== "" || typeof i == "number" || typeof i == "bigint") return e = e.get(n) || null, l(t, e, "" + i, a);
			if (typeof i == "object" && i) {
				switch (i.$$typeof) {
					case _: return e = e.get(i.key === null ? n : i.key) || null, u(t, e, i, a);
					case y: return e = e.get(i.key === null ? n : i.key) || null, d(t, e, i, a);
					case A: return i = Fa(i), h(e, t, n, i, a);
				}
				if (ee(i) || P(i)) return e = e.get(n) || null, f(t, e, i, a, null);
				if (typeof i.then == "function") return h(e, t, n, Va(i), a);
				if (i.$$typeof === w) return h(e, t, n, ua(t, i), a);
				Ua(t, i);
			}
			return null;
		}
		function g(a, o, c, l) {
			for (var u = null, d = null, f = o, g = o = 0, _ = null; f !== null && g < c.length; g++) {
				f.index > g ? (_ = f, f = null) : _ = f.sibling;
				var v = m(a, f, c[g], l);
				if (v === null) {
					f === null && (f = _);
					break;
				}
				e && f && v.alternate === null && t(a, f), o = s(v, o, g), d === null ? u = v : d.sibling = v, d = v, f = _;
			}
			if (g === c.length) return n(a, f), Ui && Ii(a, g), u;
			if (f === null) {
				for (; g < c.length; g++) f = p(a, c[g], l), f !== null && (o = s(f, o, g), d === null ? u = f : d.sibling = f, d = f);
				return Ui && Ii(a, g), u;
			}
			for (f = i(f); g < c.length; g++) _ = h(f, a, g, c[g], l), _ !== null && (e && _.alternate !== null && f.delete(_.key === null ? g : _.key), o = s(_, o, g), d === null ? u = _ : d.sibling = _, d = _);
			return e && f.forEach(function(e) {
				return t(a, e);
			}), Ui && Ii(a, g), u;
		}
		function v(o, c, l, u) {
			if (l == null) throw Error(a(151));
			for (var d = null, f = null, g = c, _ = c = 0, v = null, y = l.next(); g !== null && !y.done; _++, y = l.next()) {
				g.index > _ ? (v = g, g = null) : v = g.sibling;
				var b = m(o, g, y.value, u);
				if (b === null) {
					g === null && (g = v);
					break;
				}
				e && g && b.alternate === null && t(o, g), c = s(b, c, _), f === null ? d = b : f.sibling = b, f = b, g = v;
			}
			if (y.done) return n(o, g), Ui && Ii(o, _), d;
			if (g === null) {
				for (; !y.done; _++, y = l.next()) y = p(o, y.value, u), y !== null && (c = s(y, c, _), f === null ? d = y : f.sibling = y, f = y);
				return Ui && Ii(o, _), d;
			}
			for (g = i(g); !y.done; _++, y = l.next()) y = h(g, o, _, y.value, u), y !== null && (e && y.alternate !== null && g.delete(y.key === null ? _ : y.key), c = s(y, c, _), f === null ? d = y : f.sibling = y, f = y);
			return e && g.forEach(function(e) {
				return t(o, e);
			}), Ui && Ii(o, _), d;
		}
		function x(e, i, s, l) {
			if (typeof s == "object" && s && s.type === b && s.key === null && (s = s.props.children), typeof s == "object" && s) {
				switch (s.$$typeof) {
					case _:
						a: {
							for (var u = s.key; i !== null;) {
								if (i.key === u) {
									if (u = s.type, u === b) {
										if (i.tag === 7) {
											n(e, i.sibling), l = o(i, s.props.children), l.return = e, e = l;
											break a;
										}
									} else if (i.elementType === u || typeof u == "object" && u && u.$$typeof === A && Fa(u) === i.type) {
										n(e, i.sibling), l = o(i, s.props), Ha(l, s), l.return = e, e = l;
										break a;
									}
									n(e, i);
									break;
								} else t(e, i);
								i = i.sibling;
							}
							s.type === b ? (l = xi(s.props.children, e.mode, l, s.key), l.return = e, e = l) : (l = bi(s.type, s.key, s.props, null, e.mode, l), Ha(l, s), l.return = e, e = l);
						}
						return c(e);
					case y:
						a: {
							for (u = s.key; i !== null;) {
								if (i.key === u) if (i.tag === 4 && i.stateNode.containerInfo === s.containerInfo && i.stateNode.implementation === s.implementation) {
									n(e, i.sibling), l = o(i, s.children || []), l.return = e, e = l;
									break a;
								} else {
									n(e, i);
									break;
								}
								else t(e, i);
								i = i.sibling;
							}
							l = wi(s, e.mode, l), l.return = e, e = l;
						}
						return c(e);
					case A: return s = Fa(s), x(e, i, s, l);
				}
				if (ee(s)) return g(e, i, s, l);
				if (P(s)) {
					if (u = P(s), typeof u != "function") throw Error(a(150));
					return s = u.call(s), v(e, i, s, l);
				}
				if (typeof s.then == "function") return x(e, i, Va(s), l);
				if (s.$$typeof === w) return x(e, i, ua(e, s), l);
				Ua(e, s);
			}
			return typeof s == "string" && s !== "" || typeof s == "number" || typeof s == "bigint" ? (s = "" + s, i !== null && i.tag === 6 ? (n(e, i.sibling), l = o(i, s), l.return = e, e = l) : (n(e, i), l = Si(s, e.mode, l), l.return = e, e = l), c(e)) : n(e, i);
		}
		return function(e, t, n, i) {
			try {
				Ba = 0;
				var a = x(e, t, n, i);
				return za = null, a;
			} catch (t) {
				if (t === ka || t === ja) throw t;
				var o = gi(29, t, null, e.mode);
				return o.lanes = i, o.return = e, o;
			}
		};
	}
	var Ga = Wa(!0), Ka = Wa(!1), qa = !1;
	function Y(e) {
		e.updateQueue = {
			baseState: e.memoizedState,
			firstBaseUpdate: null,
			lastBaseUpdate: null,
			shared: {
				pending: null,
				lanes: 0,
				hiddenCallbacks: null
			},
			callbacks: null
		};
	}
	function Z(e, t) {
		e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
			baseState: e.baseState,
			firstBaseUpdate: e.firstBaseUpdate,
			lastBaseUpdate: e.lastBaseUpdate,
			shared: e.shared,
			callbacks: null
		});
	}
	function Ja(e) {
		return {
			lane: e,
			tag: 0,
			payload: null,
			callback: null,
			next: null
		};
	}
	function Ya(e, t, n) {
		var i = e.updateQueue;
		if (i === null) return null;
		if (i = i.shared, Ql & 2) {
			var a = i.pending;
			return a === null ? t.next = t : (t.next = a.next, a.next = t), i.pending = t, t = pi(e), fi(e, null, n), t;
		}
		return li(e, i, t, n), pi(e);
	}
	function Xa(e, t, n) {
		if (t = t.updateQueue, t !== null && (t = t.shared, n & 4194048)) {
			var i = t.lanes;
			i &= e.pendingLanes, n |= i, t.lanes = n, Xe(e, n);
		}
	}
	function Za(e, t) {
		var n = e.updateQueue, i = e.alternate;
		if (i !== null && (i = i.updateQueue, n === i)) {
			var a = null, o = null;
			if (n = n.firstBaseUpdate, n !== null) {
				do {
					var s = {
						lane: n.lane,
						tag: n.tag,
						payload: n.payload,
						callback: null,
						next: null
					};
					o === null ? a = o = s : o = o.next = s, n = n.next;
				} while (n !== null);
				o === null ? a = o = t : o = o.next = t;
			} else a = o = t;
			n = {
				baseState: i.baseState,
				firstBaseUpdate: a,
				lastBaseUpdate: o,
				shared: i.shared,
				callbacks: i.callbacks
			}, e.updateQueue = n;
			return;
		}
		e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t;
	}
	var Qa = !1;
	function $a() {
		if (Qa) {
			var e = ba;
			if (e !== null) throw e;
		}
	}
	function eo(e, t, n, i) {
		Qa = !1;
		var a = e.updateQueue;
		qa = !1;
		var o = a.firstBaseUpdate, s = a.lastBaseUpdate, c = a.shared.pending;
		if (c !== null) {
			a.shared.pending = null;
			var l = c, u = l.next;
			l.next = null, s === null ? o = u : s.next = u, s = l;
			var d = e.alternate;
			d !== null && (d = d.updateQueue, c = d.lastBaseUpdate, c !== s && (c === null ? d.firstBaseUpdate = u : c.next = u, d.lastBaseUpdate = l));
		}
		if (o !== null) {
			var f = a.baseState;
			s = 0, d = u = l = null, c = o;
			do {
				var p = c.lane & -536870913, h = p !== c.lane;
				if (h ? (tu & p) === p : (i & p) === p) {
					p !== 0 && p === ya && (Qa = !0), d !== null && (d = d.next = {
						lane: 0,
						tag: c.tag,
						payload: c.payload,
						callback: null,
						next: null
					});
					a: {
						var g = e, _ = c;
						p = t;
						var v = n;
						switch (_.tag) {
							case 1:
								if (g = _.payload, typeof g == "function") {
									f = g.call(v, f, p);
									break a;
								}
								f = g;
								break a;
							case 3: g.flags = g.flags & -65537 | 128;
							case 0:
								if (g = _.payload, p = typeof g == "function" ? g.call(v, f, p) : g, p == null) break a;
								f = m({}, f, p);
								break a;
							case 2: qa = !0;
						}
					}
					p = c.callback, p !== null && (e.flags |= 64, h && (e.flags |= 8192), h = a.callbacks, h === null ? a.callbacks = [p] : h.push(p));
				} else h = {
					lane: p,
					tag: c.tag,
					payload: c.payload,
					callback: c.callback,
					next: null
				}, d === null ? (u = d = h, l = f) : d = d.next = h, s |= p;
				if (c = c.next, c === null) {
					if (c = a.shared.pending, c === null) break;
					h = c, c = h.next, h.next = null, a.lastBaseUpdate = h, a.shared.pending = null;
				}
			} while (1);
			d === null && (l = f), a.baseState = l, a.firstBaseUpdate = u, a.lastBaseUpdate = d, o === null && (a.shared.lanes = 0), lu |= s, e.lanes = s, e.memoizedState = f;
		}
	}
	function to(e, t) {
		if (typeof e != "function") throw Error(a(191, e));
		e.call(t);
	}
	function no(e, t) {
		var n = e.callbacks;
		if (n !== null) for (e.callbacks = null, e = 0; e < n.length; e++) to(n[e], t);
	}
	var ro = ae(null), io = ae(0);
	function ao(e, t) {
		e = su, z(io, e), z(ro, t), su = e | t.baseLanes;
	}
	function oo() {
		z(io, su), z(ro, ro.current);
	}
	function so() {
		su = io.current, oe(ro), oe(io);
	}
	var co = ae(null), lo = null;
	function uo(e) {
		var t = e.alternate;
		z(go, go.current & 1), z(co, e), lo === null && (t === null || ro.current !== null || t.memoizedState !== null) && (lo = e);
	}
	function fo(e) {
		z(go, go.current), z(co, e), lo === null && (lo = e);
	}
	function po(e) {
		e.tag === 22 ? (z(go, go.current), z(co, e), lo === null && (lo = e)) : mo(e);
	}
	function mo() {
		z(go, go.current), z(co, co.current);
	}
	function ho(e) {
		oe(co), lo === e && (lo = null), oe(go);
	}
	var go = ae(0);
	function _o(e) {
		for (var t = e; t !== null;) {
			if (t.tag === 13) {
				var n = t.memoizedState;
				if (n !== null && (n = n.dehydrated, n === null || kf(n) || Af(n))) return t;
			} else if (t.tag === 19 && (t.memoizedProps.revealOrder === "forwards" || t.memoizedProps.revealOrder === "backwards" || t.memoizedProps.revealOrder === "unstable_legacy-backwards" || t.memoizedProps.revealOrder === "together")) {
				if (t.flags & 128) return t;
			} else if (t.child !== null) {
				t.child.return = t, t = t.child;
				continue;
			}
			if (t === e) break;
			for (; t.sibling === null;) {
				if (t.return === null || t.return === e) return null;
				t = t.return;
			}
			t.sibling.return = t.return, t = t.sibling;
		}
		return null;
	}
	var vo = 0, yo = null, bo = null, xo = null, So = !1, Co = !1, wo = !1, To = 0, Eo = 0, Do = null, Oo = 0;
	function ko() {
		throw Error(a(321));
	}
	function Ao(e, t) {
		if (t === null) return !1;
		for (var n = 0; n < t.length && n < e.length; n++) if (!Ar(e[n], t[n])) return !1;
		return !0;
	}
	function jo(e, t, n, i, a, o) {
		return vo = o, yo = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, L.H = e === null || e.memoizedState === null ? Xs : Zs, wo = !1, o = n(i, a), wo = !1, Co && (o = No(t, n, i, a)), Mo(e), o;
	}
	function Mo(e) {
		L.H = Ys;
		var t = bo !== null && bo.next !== null;
		if (vo = 0, xo = bo = yo = null, So = !1, Eo = 0, Do = null, t) throw Error(a(300));
		e === null || mc || (e = e.dependencies, e !== null && ca(e) && (mc = !0));
	}
	function No(e, t, n, i) {
		yo = e;
		var o = 0;
		do {
			if (Co && (Do = null), Eo = 0, Co = !1, 25 <= o) throw Error(a(301));
			if (o += 1, xo = bo = null, e.updateQueue != null) {
				var s = e.updateQueue;
				s.lastEffect = null, s.events = null, s.stores = null, s.memoCache != null && (s.memoCache.index = 0);
			}
			L.H = Qs, s = t(n, i);
		} while (Co);
		return s;
	}
	function Po() {
		var e = L.H, t = e.useState()[0];
		return t = typeof t.then == "function" ? Vo(t) : t, e = e.useState()[0], (bo === null ? null : bo.memoizedState) !== e && (yo.flags |= 1024), t;
	}
	function Fo() {
		var e = To !== 0;
		return To = 0, e;
	}
	function Io(e, t, n) {
		t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~n;
	}
	function Lo(e) {
		if (So) {
			for (e = e.memoizedState; e !== null;) {
				var t = e.queue;
				t !== null && (t.pending = null), e = e.next;
			}
			So = !1;
		}
		vo = 0, xo = bo = yo = null, Co = !1, Eo = To = 0, Do = null;
	}
	function Ro() {
		var e = {
			memoizedState: null,
			baseState: null,
			baseQueue: null,
			queue: null,
			next: null
		};
		return xo === null ? yo.memoizedState = xo = e : xo = xo.next = e, xo;
	}
	function zo() {
		if (bo === null) {
			var e = yo.alternate;
			e = e === null ? null : e.memoizedState;
		} else e = bo.next;
		var t = xo === null ? yo.memoizedState : xo.next;
		if (t !== null) xo = t, bo = e;
		else {
			if (e === null) throw yo.alternate === null ? Error(a(467)) : Error(a(310));
			bo = e, e = {
				memoizedState: bo.memoizedState,
				baseState: bo.baseState,
				baseQueue: bo.baseQueue,
				queue: bo.queue,
				next: null
			}, xo === null ? yo.memoizedState = xo = e : xo = xo.next = e;
		}
		return xo;
	}
	function Bo() {
		return {
			lastEffect: null,
			events: null,
			stores: null,
			memoCache: null
		};
	}
	function Vo(e) {
		var t = Eo;
		return Eo += 1, Do === null && (Do = []), e = Pa(Do, e, t), t = yo, (xo === null ? t.memoizedState : xo.next) === null && (t = t.alternate, L.H = t === null || t.memoizedState === null ? Xs : Zs), e;
	}
	function Ho(e) {
		if (typeof e == "object" && e) {
			if (typeof e.then == "function") return Vo(e);
			if (e.$$typeof === w) return q(e);
		}
		throw Error(a(438, String(e)));
	}
	function Uo(e) {
		var t = null, n = yo.updateQueue;
		if (n !== null && (t = n.memoCache), t == null) {
			var i = yo.alternate;
			i !== null && (i = i.updateQueue, i !== null && (i = i.memoCache, i != null && (t = {
				data: i.data.map(function(e) {
					return e.slice();
				}),
				index: 0
			})));
		}
		if (t ??= {
			data: [],
			index: 0
		}, n === null && (n = Bo(), yo.updateQueue = n), n.memoCache = t, n = t.data[t.index], n === void 0) for (n = t.data[t.index] = Array(e), i = 0; i < e; i++) n[i] = M;
		return t.index++, n;
	}
	function Wo(e, t) {
		return typeof t == "function" ? t(e) : t;
	}
	function Go(e) {
		var t = zo();
		return Ko(t, bo, e);
	}
	function Ko(e, t, n) {
		var i = e.queue;
		if (i === null) throw Error(a(311));
		i.lastRenderedReducer = n;
		var o = e.baseQueue, s = i.pending;
		if (s !== null) {
			if (o !== null) {
				var c = o.next;
				o.next = s.next, s.next = c;
			}
			t.baseQueue = o = s, i.pending = null;
		}
		if (s = e.baseState, o === null) e.memoizedState = s;
		else {
			t = o.next;
			var l = c = null, u = null, d = t, f = !1;
			do {
				var p = d.lane & -536870913;
				if (p === d.lane ? (vo & p) === p : (tu & p) === p) {
					var m = d.revertLane;
					if (m === 0) u !== null && (u = u.next = {
						lane: 0,
						revertLane: 0,
						gesture: null,
						action: d.action,
						hasEagerState: d.hasEagerState,
						eagerState: d.eagerState,
						next: null
					}), p === ya && (f = !0);
					else if ((vo & m) === m) {
						d = d.next, m === ya && (f = !0);
						continue;
					} else p = {
						lane: 0,
						revertLane: d.revertLane,
						gesture: null,
						action: d.action,
						hasEagerState: d.hasEagerState,
						eagerState: d.eagerState,
						next: null
					}, u === null ? (l = u = p, c = s) : u = u.next = p, yo.lanes |= m, lu |= m;
					p = d.action, wo && n(s, p), s = d.hasEagerState ? d.eagerState : n(s, p);
				} else m = {
					lane: p,
					revertLane: d.revertLane,
					gesture: d.gesture,
					action: d.action,
					hasEagerState: d.hasEagerState,
					eagerState: d.eagerState,
					next: null
				}, u === null ? (l = u = m, c = s) : u = u.next = m, yo.lanes |= p, lu |= p;
				d = d.next;
			} while (d !== null && d !== t);
			if (u === null ? c = s : u.next = l, !Ar(s, e.memoizedState) && (mc = !0, f && (n = ba, n !== null))) throw n;
			e.memoizedState = s, e.baseState = c, e.baseQueue = u, i.lastRenderedState = s;
		}
		return o === null && (i.lanes = 0), [e.memoizedState, i.dispatch];
	}
	function qo(e) {
		var t = zo(), n = t.queue;
		if (n === null) throw Error(a(311));
		n.lastRenderedReducer = e;
		var i = n.dispatch, o = n.pending, s = t.memoizedState;
		if (o !== null) {
			n.pending = null;
			var c = o = o.next;
			do
				s = e(s, c.action), c = c.next;
			while (c !== o);
			Ar(s, t.memoizedState) || (mc = !0), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), n.lastRenderedState = s;
		}
		return [s, i];
	}
	function Jo(e, t, n) {
		var i = yo, o = zo(), s = Ui;
		if (s) {
			if (n === void 0) throw Error(a(407));
			n = n();
		} else n = t();
		var c = !Ar((bo || o).memoizedState, n);
		if (c && (o.memoizedState = n, mc = !0), o = o.queue, xs(Zo.bind(null, i, o, e), [e]), o.getSnapshot !== t || c || xo !== null && xo.memoizedState.tag & 1) {
			if (i.flags |= 2048, gs(9, { destroy: void 0 }, Xo.bind(null, i, o, n, t), null), $l === null) throw Error(a(349));
			s || vo & 127 || Yo(i, t, n);
		}
		return n;
	}
	function Yo(e, t, n) {
		e.flags |= 16384, e = {
			getSnapshot: t,
			value: n
		}, t = yo.updateQueue, t === null ? (t = Bo(), yo.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e));
	}
	function Xo(e, t, n, i) {
		t.value = n, t.getSnapshot = i, Qo(t) && $o(e);
	}
	function Zo(e, t, n) {
		return n(function() {
			Qo(t) && $o(e);
		});
	}
	function Qo(e) {
		var t = e.getSnapshot;
		e = e.value;
		try {
			var n = t();
			return !Ar(e, n);
		} catch {
			return !0;
		}
	}
	function $o(e) {
		var t = di(e, 2);
		t !== null && Nu(t, e, 2);
	}
	function es(e) {
		var t = Ro();
		if (typeof e == "function") {
			var n = e;
			if (e = n(), wo) {
				Fe(!0);
				try {
					n();
				} finally {
					Fe(!1);
				}
			}
		}
		return t.memoizedState = t.baseState = e, t.queue = {
			pending: null,
			lanes: 0,
			dispatch: null,
			lastRenderedReducer: Wo,
			lastRenderedState: e
		}, t;
	}
	function ts(e, t, n, i) {
		return e.baseState = n, Ko(e, bo, typeof i == "function" ? i : Wo);
	}
	function ns(e, t, n, i, o) {
		if (Ks(e)) throw Error(a(485));
		if (e = t.action, e !== null) {
			var s = {
				payload: o,
				action: e,
				next: null,
				isTransition: !0,
				status: "pending",
				value: null,
				reason: null,
				listeners: [],
				then: function(e) {
					s.listeners.push(e);
				}
			};
			L.T === null ? s.isTransition = !1 : n(!0), i(s), n = t.pending, n === null ? (s.next = t.pending = s, rs(t, s)) : (s.next = n.next, t.pending = n.next = s);
		}
	}
	function rs(e, t) {
		var n = t.action, i = t.payload, a = e.state;
		if (t.isTransition) {
			var o = L.T, s = {};
			L.T = s;
			try {
				var c = n(a, i), l = L.S;
				l !== null && l(s, c), os(e, t, c);
			} catch (n) {
				cs(e, t, n);
			} finally {
				o !== null && s.types !== null && (o.types = s.types), L.T = o;
			}
		} else try {
			o = n(a, i), os(e, t, o);
		} catch (n) {
			cs(e, t, n);
		}
	}
	function os(e, t, n) {
		typeof n == "object" && n && typeof n.then == "function" ? n.then(function(n) {
			ss(e, t, n);
		}, function(n) {
			return cs(e, t, n);
		}) : ss(e, t, n);
	}
	function ss(e, t, n) {
		t.status = "fulfilled", t.value = n, ls(t), e.state = n, t = e.pending, t !== null && (n = t.next, n === t ? e.pending = null : (n = n.next, t.next = n, rs(e, n)));
	}
	function cs(e, t, n) {
		var i = e.pending;
		if (e.pending = null, i !== null) {
			i = i.next;
			do
				t.status = "rejected", t.reason = n, ls(t), t = t.next;
			while (t !== i);
		}
		e.action = null;
	}
	function ls(e) {
		e = e.listeners;
		for (var t = 0; t < e.length; t++) (0, e[t])();
	}
	function us(e, t) {
		return t;
	}
	function ds(e, t) {
		if (Ui) {
			var n = $l.formState;
			if (n !== null) {
				a: {
					var i = yo;
					if (Ui) {
						if (Hi) {
							b: {
								for (var a = Hi, o = Gi; a.nodeType !== 8;) {
									if (!o) {
										a = null;
										break b;
									}
									if (a = Mf(a.nextSibling), a === null) {
										a = null;
										break b;
									}
								}
								o = a.data, a = o === "F!" || o === "F" ? a : null;
							}
							if (a) {
								Hi = Mf(a.nextSibling), i = a.data === "F!";
								break a;
							}
						}
						qi(i);
					}
					i = !1;
				}
				i && (t = n[0]);
			}
		}
		return n = Ro(), n.memoizedState = n.baseState = t, i = {
			pending: null,
			lanes: 0,
			dispatch: null,
			lastRenderedReducer: us,
			lastRenderedState: t
		}, n.queue = i, n = Us.bind(null, yo, i), i.dispatch = n, i = es(!1), o = Gs.bind(null, yo, !1, i.queue), i = Ro(), a = {
			state: t,
			dispatch: null,
			action: e,
			pending: null
		}, i.queue = a, n = ns.bind(null, yo, a, o, n), a.dispatch = n, i.memoizedState = e, [
			t,
			n,
			!1
		];
	}
	function fs(e) {
		var t = zo();
		return ps(t, bo, e);
	}
	function ps(e, t, n) {
		if (t = Ko(e, t, us)[0], e = Go(Wo)[0], typeof t == "object" && t && typeof t.then == "function") try {
			var i = Vo(t);
		} catch (e) {
			throw e === ka ? ja : e;
		}
		else i = t;
		t = zo();
		var a = t.queue, o = a.dispatch;
		return n !== t.memoizedState && (yo.flags |= 2048, gs(9, { destroy: void 0 }, ms.bind(null, a, n), null)), [
			i,
			o,
			e
		];
	}
	function ms(e, t) {
		e.action = t;
	}
	function hs(e) {
		var t = zo(), n = bo;
		if (n !== null) return ps(t, n, e);
		zo(), t = t.memoizedState, n = zo();
		var i = n.queue.dispatch;
		return n.memoizedState = e, [
			t,
			i,
			!1
		];
	}
	function gs(e, t, n, i) {
		return e = {
			tag: e,
			create: n,
			deps: i,
			inst: t,
			next: null
		}, t = yo.updateQueue, t === null && (t = Bo(), yo.updateQueue = t), n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (i = n.next, n.next = e, e.next = i, t.lastEffect = e), e;
	}
	function _s() {
		return zo().memoizedState;
	}
	function vs(e, t, n, i) {
		var a = Ro();
		yo.flags |= e, a.memoizedState = gs(1 | t, { destroy: void 0 }, n, i === void 0 ? null : i);
	}
	function ys(e, t, n, i) {
		var a = zo();
		i = i === void 0 ? null : i;
		var o = a.memoizedState.inst;
		bo !== null && i !== null && Ao(i, bo.memoizedState.deps) ? a.memoizedState = gs(t, o, n, i) : (yo.flags |= e, a.memoizedState = gs(1 | t, o, n, i));
	}
	function bs(e, t) {
		vs(8390656, 8, e, t);
	}
	function xs(e, t) {
		ys(2048, 8, e, t);
	}
	function Ss(e) {
		yo.flags |= 4;
		var t = yo.updateQueue;
		if (t === null) t = Bo(), yo.updateQueue = t, t.events = [e];
		else {
			var n = t.events;
			n === null ? t.events = [e] : n.push(e);
		}
	}
	function Cs(e) {
		var t = zo().memoizedState;
		return Ss({
			ref: t,
			nextImpl: e
		}), function() {
			if (Ql & 2) throw Error(a(440));
			return t.impl.apply(void 0, arguments);
		};
	}
	function ws(e, t) {
		return ys(4, 2, e, t);
	}
	function Ts(e, t) {
		return ys(4, 4, e, t);
	}
	function Es(e, t) {
		if (typeof t == "function") {
			e = e();
			var n = t(e);
			return function() {
				typeof n == "function" ? n() : t(null);
			};
		}
		if (t != null) return e = e(), t.current = e, function() {
			t.current = null;
		};
	}
	function Ds(e, t, n) {
		n = n == null ? null : n.concat([e]), ys(4, 4, Es.bind(null, t, e), n);
	}
	function Os() {}
	function ks(e, t) {
		var n = zo();
		t = t === void 0 ? null : t;
		var i = n.memoizedState;
		return t !== null && Ao(t, i[1]) ? i[0] : (n.memoizedState = [e, t], e);
	}
	function As(e, t) {
		var n = zo();
		t = t === void 0 ? null : t;
		var i = n.memoizedState;
		if (t !== null && Ao(t, i[1])) return i[0];
		if (i = e(), wo) {
			Fe(!0);
			try {
				e();
			} finally {
				Fe(!1);
			}
		}
		return n.memoizedState = [i, t], i;
	}
	function js(e, t, n) {
		return n === void 0 || vo & 1073741824 && !(tu & 261930) ? e.memoizedState = t : (e.memoizedState = n, e = Mu(), yo.lanes |= e, lu |= e, n);
	}
	function Ms(e, t, n, i) {
		return Ar(n, t) ? n : ro.current === null ? !(vo & 42) || vo & 1073741824 && !(tu & 261930) ? (mc = !0, e.memoizedState = n) : (e = Mu(), yo.lanes |= e, lu |= e, t) : (e = js(e, n, i), Ar(e, t) || (mc = !0), e);
	}
	function Ns(e, t, n, i, a) {
		var o = R.p;
		R.p = o !== 0 && 8 > o ? o : 8;
		var s = L.T, c = {};
		L.T = c, Gs(e, !1, t, n);
		try {
			var l = a(), u = L.S;
			if (u !== null && u(c, l), typeof l == "object" && l && typeof l.then == "function") {
				var d = Ca(l, i);
				Ws(e, t, d, ju(e));
			} else Ws(e, t, i, ju(e));
		} catch (n) {
			Ws(e, t, {
				then: function() {},
				status: "rejected",
				reason: n
			}, ju());
		} finally {
			R.p = o, s !== null && c.types !== null && (s.types = c.types), L.T = s;
		}
	}
	function Ps() {}
	function Fs(e, t, n, i) {
		if (e.tag !== 5) throw Error(a(476));
		var o = Is(e).queue;
		Ns(e, o, t, te, n === null ? Ps : function() {
			return Ls(e), n(i);
		});
	}
	function Is(e) {
		var t = e.memoizedState;
		if (t !== null) return t;
		t = {
			memoizedState: te,
			baseState: te,
			baseQueue: null,
			queue: {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: Wo,
				lastRenderedState: te
			},
			next: null
		};
		var n = {};
		return t.next = {
			memoizedState: n,
			baseState: n,
			baseQueue: null,
			queue: {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: Wo,
				lastRenderedState: n
			},
			next: null
		}, e.memoizedState = t, e = e.alternate, e !== null && (e.memoizedState = t), t;
	}
	function Ls(e) {
		var t = Is(e);
		t.next === null && (t = e.alternate.memoizedState), Ws(e, t.next.queue, {}, ju());
	}
	function Rs() {
		return q(xp);
	}
	function zs() {
		return zo().memoizedState;
	}
	function Bs() {
		return zo().memoizedState;
	}
	function Vs(e) {
		for (var t = e.return; t !== null;) {
			switch (t.tag) {
				case 24:
				case 3:
					var n = ju();
					e = Ja(n);
					var i = Ya(t, e, n);
					i !== null && (Nu(i, t, n), Xa(i, t, n)), t = { cache: ga() }, e.payload = t;
					return;
			}
			t = t.return;
		}
	}
	function Hs(e, t, n) {
		var i = ju();
		n = {
			lane: i,
			revertLane: 0,
			gesture: null,
			action: n,
			hasEagerState: !1,
			eagerState: null,
			next: null
		}, Ks(e) ? qs(t, n) : (n = ui(e, t, n, i), n !== null && (Nu(n, e, i), Js(n, t, i)));
	}
	function Us(e, t, n) {
		var i = ju();
		Ws(e, t, n, i);
	}
	function Ws(e, t, n, i) {
		var a = {
			lane: i,
			revertLane: 0,
			gesture: null,
			action: n,
			hasEagerState: !1,
			eagerState: null,
			next: null
		};
		if (Ks(e)) qs(t, a);
		else {
			var o = e.alternate;
			if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try {
				var s = t.lastRenderedState, c = o(s, n);
				if (a.hasEagerState = !0, a.eagerState = c, Ar(c, s)) return li(e, t, a, 0), $l === null && ci(), !1;
			} catch {}
			if (n = ui(e, t, a, i), n !== null) return Nu(n, e, i), Js(n, t, i), !0;
		}
		return !1;
	}
	function Gs(e, t, n, i) {
		if (i = {
			lane: 2,
			revertLane: Ad(),
			gesture: null,
			action: i,
			hasEagerState: !1,
			eagerState: null,
			next: null
		}, Ks(e)) {
			if (t) throw Error(a(479));
		} else t = ui(e, n, i, 2), t !== null && Nu(t, e, 2);
	}
	function Ks(e) {
		var t = e.alternate;
		return e === yo || t !== null && t === yo;
	}
	function qs(e, t) {
		Co = So = !0;
		var n = e.pending;
		n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t;
	}
	function Js(e, t, n) {
		if (n & 4194048) {
			var i = t.lanes;
			i &= e.pendingLanes, n |= i, t.lanes = n, Xe(e, n);
		}
	}
	var Ys = {
		readContext: q,
		use: Ho,
		useCallback: ko,
		useContext: ko,
		useEffect: ko,
		useImperativeHandle: ko,
		useLayoutEffect: ko,
		useInsertionEffect: ko,
		useMemo: ko,
		useReducer: ko,
		useRef: ko,
		useState: ko,
		useDebugValue: ko,
		useDeferredValue: ko,
		useTransition: ko,
		useSyncExternalStore: ko,
		useId: ko,
		useHostTransitionStatus: ko,
		useFormState: ko,
		useActionState: ko,
		useOptimistic: ko,
		useMemoCache: ko,
		useCacheRefresh: ko
	};
	Ys.useEffectEvent = ko;
	var Xs = {
		readContext: q,
		use: Ho,
		useCallback: function(e, t) {
			return Ro().memoizedState = [e, t === void 0 ? null : t], e;
		},
		useContext: q,
		useEffect: bs,
		useImperativeHandle: function(e, t, n) {
			n = n == null ? null : n.concat([e]), vs(4194308, 4, Es.bind(null, t, e), n);
		},
		useLayoutEffect: function(e, t) {
			return vs(4194308, 4, e, t);
		},
		useInsertionEffect: function(e, t) {
			vs(4, 2, e, t);
		},
		useMemo: function(e, t) {
			var n = Ro();
			t = t === void 0 ? null : t;
			var i = e();
			if (wo) {
				Fe(!0);
				try {
					e();
				} finally {
					Fe(!1);
				}
			}
			return n.memoizedState = [i, t], i;
		},
		useReducer: function(e, t, n) {
			var i = Ro();
			if (n !== void 0) {
				var a = n(t);
				if (wo) {
					Fe(!0);
					try {
						n(t);
					} finally {
						Fe(!1);
					}
				}
			} else a = t;
			return i.memoizedState = i.baseState = a, e = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: e,
				lastRenderedState: a
			}, i.queue = e, e = e.dispatch = Hs.bind(null, yo, e), [i.memoizedState, e];
		},
		useRef: function(e) {
			var t = Ro();
			return e = { current: e }, t.memoizedState = e;
		},
		useState: function(e) {
			e = es(e);
			var t = e.queue, n = Us.bind(null, yo, t);
			return t.dispatch = n, [e.memoizedState, n];
		},
		useDebugValue: Os,
		useDeferredValue: function(e, t) {
			var n = Ro();
			return js(n, e, t);
		},
		useTransition: function() {
			var e = es(!1);
			return e = Ns.bind(null, yo, e.queue, !0, !1), Ro().memoizedState = e, [!1, e];
		},
		useSyncExternalStore: function(e, t, n) {
			var i = yo, o = Ro();
			if (Ui) {
				if (n === void 0) throw Error(a(407));
				n = n();
			} else {
				if (n = t(), $l === null) throw Error(a(349));
				tu & 127 || Yo(i, t, n);
			}
			o.memoizedState = n;
			var s = {
				value: n,
				getSnapshot: t
			};
			return o.queue = s, bs(Zo.bind(null, i, s, e), [e]), i.flags |= 2048, gs(9, { destroy: void 0 }, Xo.bind(null, i, s, n, t), null), n;
		},
		useId: function() {
			var e = Ro(), t = $l.identifierPrefix;
			if (Ui) {
				var n = Fi, i = Pi;
				n = (i & ~(1 << 32 - Ie(i) - 1)).toString(32) + n, t = "_" + t + "R_" + n, n = To++, 0 < n && (t += "H" + n.toString(32)), t += "_";
			} else n = Oo++, t = "_" + t + "r_" + n.toString(32) + "_";
			return e.memoizedState = t;
		},
		useHostTransitionStatus: Rs,
		useFormState: ds,
		useActionState: ds,
		useOptimistic: function(e) {
			var t = Ro();
			t.memoizedState = t.baseState = e;
			var n = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: null,
				lastRenderedState: null
			};
			return t.queue = n, t = Gs.bind(null, yo, !0, n), n.dispatch = t, [e, t];
		},
		useMemoCache: Uo,
		useCacheRefresh: function() {
			return Ro().memoizedState = Vs.bind(null, yo);
		},
		useEffectEvent: function(e) {
			var t = Ro(), n = { impl: e };
			return t.memoizedState = n, function() {
				if (Ql & 2) throw Error(a(440));
				return n.impl.apply(void 0, arguments);
			};
		}
	}, Zs = {
		readContext: q,
		use: Ho,
		useCallback: ks,
		useContext: q,
		useEffect: xs,
		useImperativeHandle: Ds,
		useInsertionEffect: ws,
		useLayoutEffect: Ts,
		useMemo: As,
		useReducer: Go,
		useRef: _s,
		useState: function() {
			return Go(Wo);
		},
		useDebugValue: Os,
		useDeferredValue: function(e, t) {
			var n = zo();
			return Ms(n, bo.memoizedState, e, t);
		},
		useTransition: function() {
			var e = Go(Wo)[0], t = zo().memoizedState;
			return [typeof e == "boolean" ? e : Vo(e), t];
		},
		useSyncExternalStore: Jo,
		useId: zs,
		useHostTransitionStatus: Rs,
		useFormState: fs,
		useActionState: fs,
		useOptimistic: function(e, t) {
			var n = zo();
			return ts(n, bo, e, t);
		},
		useMemoCache: Uo,
		useCacheRefresh: Bs
	};
	Zs.useEffectEvent = Cs;
	var Qs = {
		readContext: q,
		use: Ho,
		useCallback: ks,
		useContext: q,
		useEffect: xs,
		useImperativeHandle: Ds,
		useInsertionEffect: ws,
		useLayoutEffect: Ts,
		useMemo: As,
		useReducer: qo,
		useRef: _s,
		useState: function() {
			return qo(Wo);
		},
		useDebugValue: Os,
		useDeferredValue: function(e, t) {
			var n = zo();
			return bo === null ? js(n, e, t) : Ms(n, bo.memoizedState, e, t);
		},
		useTransition: function() {
			var e = qo(Wo)[0], t = zo().memoizedState;
			return [typeof e == "boolean" ? e : Vo(e), t];
		},
		useSyncExternalStore: Jo,
		useId: zs,
		useHostTransitionStatus: Rs,
		useFormState: hs,
		useActionState: hs,
		useOptimistic: function(e, t) {
			var n = zo();
			return bo === null ? (n.baseState = e, [e, n.queue.dispatch]) : ts(n, bo, e, t);
		},
		useMemoCache: Uo,
		useCacheRefresh: Bs
	};
	Qs.useEffectEvent = Cs;
	function $s(e, t, n, i) {
		t = e.memoizedState, n = n(i, t), n = n == null ? t : m({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n);
	}
	var ec = {
		enqueueSetState: function(e, t, n) {
			e = e._reactInternals;
			var i = ju(), a = Ja(i);
			a.payload = t, n != null && (a.callback = n), t = Ya(e, a, i), t !== null && (Nu(t, e, i), Xa(t, e, i));
		},
		enqueueReplaceState: function(e, t, n) {
			e = e._reactInternals;
			var i = ju(), a = Ja(i);
			a.tag = 1, a.payload = t, n != null && (a.callback = n), t = Ya(e, a, i), t !== null && (Nu(t, e, i), Xa(t, e, i));
		},
		enqueueForceUpdate: function(e, t) {
			e = e._reactInternals;
			var n = ju(), i = Ja(n);
			i.tag = 2, t != null && (i.callback = t), t = Ya(e, i, n), t !== null && (Nu(t, e, n), Xa(t, e, n));
		}
	};
	function tc(e, t, n, i, a, o, s) {
		return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(i, o, s) : t.prototype && t.prototype.isPureReactComponent ? !jr(n, i) || !jr(a, o) : !0;
	}
	function nc(e, t, n, i) {
		e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, i), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, i), t.state !== e && ec.enqueueReplaceState(t, t.state, null);
	}
	function rc(e, t) {
		var n = t;
		if ("ref" in t) for (var i in n = {}, t) i !== "ref" && (n[i] = t[i]);
		if (e = e.defaultProps) for (var a in n === t && (n = m({}, n)), e) n[a] === void 0 && (n[a] = e[a]);
		return n;
	}
	function ic(e) {
		ii(e);
	}
	function ac(e) {
		console.error(e);
	}
	function oc(e) {
		ii(e);
	}
	function sc(e, t) {
		try {
			var n = e.onUncaughtError;
			n(t.value, { componentStack: t.stack });
		} catch (e) {
			setTimeout(function() {
				throw e;
			});
		}
	}
	function cc(e, t, n) {
		try {
			var i = e.onCaughtError;
			i(n.value, {
				componentStack: n.stack,
				errorBoundary: t.tag === 1 ? t.stateNode : null
			});
		} catch (e) {
			setTimeout(function() {
				throw e;
			});
		}
	}
	function lc(e, t, n) {
		return n = Ja(n), n.tag = 3, n.payload = { element: null }, n.callback = function() {
			sc(e, t);
		}, n;
	}
	function uc(e) {
		return e = Ja(e), e.tag = 3, e;
	}
	function dc(e, t, n, i) {
		var a = n.type.getDerivedStateFromError;
		if (typeof a == "function") {
			var o = i.value;
			e.payload = function() {
				return a(o);
			}, e.callback = function() {
				cc(t, n, i);
			};
		}
		var s = n.stateNode;
		s !== null && typeof s.componentDidCatch == "function" && (e.callback = function() {
			cc(t, n, i), typeof a != "function" && (xu === null ? xu = new Set([this]) : xu.add(this));
			var e = i.stack;
			this.componentDidCatch(i.value, { componentStack: e === null ? "" : e });
		});
	}
	function fc(e, t, n, i, o) {
		if (n.flags |= 32768, typeof i == "object" && i && typeof i.then == "function") {
			if (t = n.alternate, t !== null && sa(t, n, o, !0), n = co.current, n !== null) {
				switch (n.tag) {
					case 31:
					case 13: return lo === null ? Gu() : n.alternate === null && cu === 0 && (cu = 3), n.flags &= -257, n.flags |= 65536, n.lanes = o, i === Ma ? n.flags |= 16384 : (t = n.updateQueue, t === null ? n.updateQueue = new Set([i]) : t.add(i), ud(e, i, o)), !1;
					case 22: return n.flags |= 65536, i === Ma ? n.flags |= 16384 : (t = n.updateQueue, t === null ? (t = {
						transitions: null,
						markerInstances: null,
						retryQueue: new Set([i])
					}, n.updateQueue = t) : (n = t.retryQueue, n === null ? t.retryQueue = new Set([i]) : n.add(i)), ud(e, i, o)), !1;
				}
				throw Error(a(435, n.tag));
			}
			return ud(e, i, o), Gu(), !1;
		}
		if (Ui) return t = co.current, t === null ? (i !== Ki && (t = Error(a(423), { cause: i }), $i(Ei(t, n))), e = e.current.alternate, e.flags |= 65536, o &= -o, e.lanes |= o, i = Ei(i, n), o = lc(e.stateNode, i, o), Za(e, o), cu !== 4 && (cu = 2)) : (!(t.flags & 65536) && (t.flags |= 256), t.flags |= 65536, t.lanes = o, i !== Ki && (e = Error(a(422), { cause: i }), $i(Ei(e, n)))), !1;
		var s = Error(a(520), { cause: i });
		if (s = Ei(s, n), mu === null ? mu = [s] : mu.push(s), cu !== 4 && (cu = 2), t === null) return !0;
		i = Ei(i, n), n = t;
		do {
			switch (n.tag) {
				case 3: return n.flags |= 65536, e = o & -o, n.lanes |= e, e = lc(n.stateNode, i, e), Za(n, e), !1;
				case 1: if (t = n.type, s = n.stateNode, !(n.flags & 128) && (typeof t.getDerivedStateFromError == "function" || s !== null && typeof s.componentDidCatch == "function" && (xu === null || !xu.has(s)))) return n.flags |= 65536, o &= -o, n.lanes |= o, o = uc(o), dc(o, e, n, i), Za(n, o), !1;
			}
			n = n.return;
		} while (n !== null);
		return !1;
	}
	var pc = Error(a(461)), mc = !1;
	function hc(e, t, n, i) {
		t.child = e === null ? Ka(t, null, n, i) : Ga(t, e.child, n, i);
	}
	function gc(e, t, n, i, a) {
		n = n.render;
		var o = t.ref;
		if ("ref" in i) {
			var s = {};
			for (var c in i) c !== "ref" && (s[c] = i[c]);
		} else s = i;
		return la(t), i = jo(e, t, n, s, o, a), c = Fo(), e !== null && !mc ? (Io(e, t, a), Bc(e, t, a)) : (Ui && c && Ri(t), t.flags |= 1, hc(e, t, i, a), t.child);
	}
	function _c(e, t, n, i, a) {
		if (e === null) {
			var o = n.type;
			return typeof o == "function" && !_i(o) && o.defaultProps === void 0 && n.compare === null ? (t.tag = 15, t.type = o, vc(e, t, o, i, a)) : (e = bi(n.type, null, i, t, t.mode, a), e.ref = t.ref, e.return = t, t.child = e);
		}
		if (o = e.child, !Vc(e, a)) {
			var s = o.memoizedProps;
			if (n = n.compare, n = n === null ? jr : n, n(s, i) && e.ref === t.ref) return Bc(e, t, a);
		}
		return t.flags |= 1, e = vi(o, i), e.ref = t.ref, e.return = t, t.child = e;
	}
	function vc(e, t, n, i, a) {
		if (e !== null) {
			var o = e.memoizedProps;
			if (jr(o, i) && e.ref === t.ref) if (mc = !1, t.pendingProps = i = o, Vc(e, a)) e.flags & 131072 && (mc = !0);
			else return t.lanes = e.lanes, Bc(e, t, a);
		}
		return Ec(e, t, n, i, a);
	}
	function yc(e, t, n, i) {
		var a = i.children, o = e === null ? null : e.memoizedState;
		if (e === null && t.stateNode === null && (t.stateNode = {
			_visibility: 1,
			_pendingMarkers: null,
			_retryCache: null,
			_transitions: null
		}), i.mode === "hidden") {
			if (t.flags & 128) {
				if (o = o === null ? n : o.baseLanes | n, e !== null) {
					for (i = t.child = e.child, a = 0; i !== null;) a = a | i.lanes | i.childLanes, i = i.sibling;
					i = a & ~o;
				} else i = 0, t.child = null;
				return xc(e, t, o, n, i);
			}
			if (n & 536870912) t.memoizedState = {
				baseLanes: 0,
				cachePool: null
			}, e !== null && Da(t, o === null ? null : o.cachePool), o === null ? oo() : ao(t, o), po(t);
			else return i = t.lanes = 536870912, xc(e, t, o === null ? n : o.baseLanes | n, n, i);
		} else o === null ? (e !== null && Da(t, null), oo(), mo(t)) : (Da(t, o.cachePool), ao(t, o), mo(t), t.memoizedState = null);
		return hc(e, t, a, n), t.child;
	}
	function bc(e, t) {
		return e !== null && e.tag === 22 || t.stateNode !== null || (t.stateNode = {
			_visibility: 1,
			_pendingMarkers: null,
			_retryCache: null,
			_transitions: null
		}), t.sibling;
	}
	function xc(e, t, n, i, a) {
		var o = Ea();
		return o = o === null ? null : {
			parent: ha._currentValue,
			pool: o
		}, t.memoizedState = {
			baseLanes: n,
			cachePool: o
		}, e !== null && Da(t, null), oo(), po(t), e !== null && sa(e, t, i, !0), t.childLanes = a, null;
	}
	function Sc(e, t) {
		return t = Fc({
			mode: t.mode,
			children: t.children
		}, e.mode), t.ref = e.ref, e.child = t, t.return = e, t;
	}
	function Cc(e, t, n) {
		return Ga(t, e.child, null, n), e = Sc(t, t.pendingProps), e.flags |= 2, ho(t), t.memoizedState = null, e;
	}
	function wc(e, t, n) {
		var i = t.pendingProps, o = (t.flags & 128) != 0;
		if (t.flags &= -129, e === null) {
			if (Ui) {
				if (i.mode === "hidden") return e = Sc(t, i), t.lanes = 536870912, bc(null, e);
				if (fo(t), (e = Hi) ? (e = Of(e, Gi), e = e !== null && e.data === "&" ? e : null, e !== null && (t.memoizedState = {
					dehydrated: e,
					treeContext: Ni === null ? null : {
						id: Pi,
						overflow: Fi
					},
					retryLane: 536870912,
					hydrationErrors: null
				}, n = Ci(e), n.return = t, t.child = n, Vi = t, Hi = null)) : e = null, e === null) throw qi(t);
				return t.lanes = 536870912, null;
			}
			return Sc(t, i);
		}
		var s = e.memoizedState;
		if (s !== null) {
			var c = s.dehydrated;
			if (fo(t), o) if (t.flags & 256) t.flags &= -257, t = Cc(e, t, n);
			else if (t.memoizedState !== null) t.child = e.child, t.flags |= 128, t = null;
			else throw Error(a(558));
			else if (mc || sa(e, t, n, !1), o = (n & e.childLanes) !== 0, mc || o) {
				if (i = $l, i !== null && (c = Ze(i, n), c !== 0 && c !== s.retryLane)) throw s.retryLane = c, di(e, c), Nu(i, e, c), pc;
				Gu(), t = Cc(e, t, n);
			} else e = s.treeContext, Hi = Mf(c.nextSibling), Vi = t, Ui = !0, Wi = null, Gi = !1, e !== null && Bi(t, e), t = Sc(t, i), t.flags |= 4096;
			return t;
		}
		return e = vi(e.child, {
			mode: i.mode,
			children: i.children
		}), e.ref = t.ref, t.child = e, e.return = t, e;
	}
	function Tc(e, t) {
		var n = t.ref;
		if (n === null) e !== null && e.ref !== null && (t.flags |= 4194816);
		else {
			if (typeof n != "function" && typeof n != "object") throw Error(a(284));
			(e === null || e.ref !== n) && (t.flags |= 4194816);
		}
	}
	function Ec(e, t, n, i, a) {
		return la(t), n = jo(e, t, n, i, void 0, a), i = Fo(), e !== null && !mc ? (Io(e, t, a), Bc(e, t, a)) : (Ui && i && Ri(t), t.flags |= 1, hc(e, t, n, a), t.child);
	}
	function Dc(e, t, n, i, a, o) {
		return la(t), t.updateQueue = null, n = No(t, i, n, a), Mo(e), i = Fo(), e !== null && !mc ? (Io(e, t, o), Bc(e, t, o)) : (Ui && i && Ri(t), t.flags |= 1, hc(e, t, n, o), t.child);
	}
	function Oc(e, t, n, i, a) {
		if (la(t), t.stateNode === null) {
			var o = mi, s = n.contextType;
			typeof s == "object" && s && (o = q(s)), o = new n(i, o), t.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null, o.updater = ec, t.stateNode = o, o._reactInternals = t, o = t.stateNode, o.props = i, o.state = t.memoizedState, o.refs = {}, Y(t), s = n.contextType, o.context = typeof s == "object" && s ? q(s) : mi, o.state = t.memoizedState, s = n.getDerivedStateFromProps, typeof s == "function" && ($s(t, n, s, i), o.state = t.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof o.getSnapshotBeforeUpdate == "function" || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (s = o.state, typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), s !== o.state && ec.enqueueReplaceState(o, o.state, null), eo(t, i, o, a), $a(), o.state = t.memoizedState), typeof o.componentDidMount == "function" && (t.flags |= 4194308), i = !0;
		} else if (e === null) {
			o = t.stateNode;
			var c = t.memoizedProps, l = rc(n, c);
			o.props = l;
			var u = o.context, d = n.contextType;
			s = mi, typeof d == "object" && d && (s = q(d));
			var f = n.getDerivedStateFromProps;
			d = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function", c = t.pendingProps !== c, d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (c || u !== s) && nc(t, o, i, s), qa = !1;
			var p = t.memoizedState;
			o.state = p, eo(t, i, o, a), $a(), u = t.memoizedState, c || p !== u || qa ? (typeof f == "function" && ($s(t, n, f, i), u = t.memoizedState), (l = qa || tc(t, n, l, i, p, u, s)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = i, t.memoizedState = u), o.props = i, o.state = u, o.context = s, i = l) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), i = !1);
		} else {
			o = t.stateNode, Z(e, t), s = t.memoizedProps, d = rc(n, s), o.props = d, f = t.pendingProps, p = o.context, u = n.contextType, l = mi, typeof u == "object" && u && (l = q(u)), c = n.getDerivedStateFromProps, (u = typeof c == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (s !== f || p !== l) && nc(t, o, i, l), qa = !1, p = t.memoizedState, o.state = p, eo(t, i, o, a), $a();
			var m = t.memoizedState;
			s !== f || p !== m || qa || e !== null && e.dependencies !== null && ca(e.dependencies) ? (typeof c == "function" && ($s(t, n, c, i), m = t.memoizedState), (d = qa || tc(t, n, d, i, p, m, l) || e !== null && e.dependencies !== null && ca(e.dependencies)) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, m, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, m, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || s === e.memoizedProps && p === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || s === e.memoizedProps && p === e.memoizedState || (t.flags |= 1024), t.memoizedProps = i, t.memoizedState = m), o.props = i, o.state = m, o.context = l, i = d) : (typeof o.componentDidUpdate != "function" || s === e.memoizedProps && p === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || s === e.memoizedProps && p === e.memoizedState || (t.flags |= 1024), i = !1);
		}
		return o = i, Tc(e, t), i = (t.flags & 128) != 0, o || i ? (o = t.stateNode, n = i && typeof n.getDerivedStateFromError != "function" ? null : o.render(), t.flags |= 1, e !== null && i ? (t.child = Ga(t, e.child, null, a), t.child = Ga(t, null, n, a)) : hc(e, t, n, a), t.memoizedState = o.state, e = t.child) : e = Bc(e, t, a), e;
	}
	function kc(e, t, n, i) {
		return Zi(), t.flags |= 256, hc(e, t, n, i), t.child;
	}
	var Ac = {
		dehydrated: null,
		treeContext: null,
		retryLane: 0,
		hydrationErrors: null
	};
	function jc(e) {
		return {
			baseLanes: e,
			cachePool: Oa()
		};
	}
	function Mc(e, t, n) {
		return e = e === null ? 0 : e.childLanes & ~n, t && (e |= fu), e;
	}
	function Nc(e, t, n) {
		var i = t.pendingProps, o = !1, s = (t.flags & 128) != 0, c;
		if ((c = s) || (c = e !== null && e.memoizedState === null ? !1 : (go.current & 2) != 0), c && (o = !0, t.flags &= -129), c = (t.flags & 32) != 0, t.flags &= -33, e === null) {
			if (Ui) {
				if (o ? uo(t) : mo(t), (e = Hi) ? (e = Of(e, Gi), e = e !== null && e.data !== "&" ? e : null, e !== null && (t.memoizedState = {
					dehydrated: e,
					treeContext: Ni === null ? null : {
						id: Pi,
						overflow: Fi
					},
					retryLane: 536870912,
					hydrationErrors: null
				}, n = Ci(e), n.return = t, t.child = n, Vi = t, Hi = null)) : e = null, e === null) throw qi(t);
				return Af(e) ? t.lanes = 32 : t.lanes = 536870912, null;
			}
			var l = i.children;
			return i = i.fallback, o ? (mo(t), o = t.mode, l = Fc({
				mode: "hidden",
				children: l
			}, o), i = xi(i, o, n, null), l.return = t, i.return = t, l.sibling = i, t.child = l, i = t.child, i.memoizedState = jc(n), i.childLanes = Mc(e, c, n), t.memoizedState = Ac, bc(null, i)) : (uo(t), Pc(t, l));
		}
		var u = e.memoizedState;
		if (u !== null && (l = u.dehydrated, l !== null)) {
			if (s) t.flags & 256 ? (uo(t), t.flags &= -257, t = Ic(e, t, n)) : t.memoizedState === null ? (mo(t), l = i.fallback, o = t.mode, i = Fc({
				mode: "visible",
				children: i.children
			}, o), l = xi(l, o, n, null), l.flags |= 2, i.return = t, l.return = t, i.sibling = l, t.child = i, Ga(t, e.child, null, n), i = t.child, i.memoizedState = jc(n), i.childLanes = Mc(e, c, n), t.memoizedState = Ac, t = bc(null, i)) : (mo(t), t.child = e.child, t.flags |= 128, t = null);
			else if (uo(t), Af(l)) {
				if (c = l.nextSibling && l.nextSibling.dataset, c) var d = c.dgst;
				c = d, i = Error(a(419)), i.stack = "", i.digest = c, $i({
					value: i,
					source: null,
					stack: null
				}), t = Ic(e, t, n);
			} else if (mc || sa(e, t, n, !1), c = (n & e.childLanes) !== 0, mc || c) {
				if (c = $l, c !== null && (i = Ze(c, n), i !== 0 && i !== u.retryLane)) throw u.retryLane = i, di(e, i), Nu(c, e, i), pc;
				kf(l) || Gu(), t = Ic(e, t, n);
			} else kf(l) ? (t.flags |= 192, t.child = e.child, t = null) : (e = u.treeContext, Hi = Mf(l.nextSibling), Vi = t, Ui = !0, Wi = null, Gi = !1, e !== null && Bi(t, e), t = Pc(t, i.children), t.flags |= 4096);
			return t;
		}
		return o ? (mo(t), l = i.fallback, o = t.mode, u = e.child, d = u.sibling, i = vi(u, {
			mode: "hidden",
			children: i.children
		}), i.subtreeFlags = u.subtreeFlags & 65011712, d === null ? (l = xi(l, o, n, null), l.flags |= 2) : l = vi(d, l), l.return = t, i.return = t, i.sibling = l, t.child = i, bc(null, i), i = t.child, l = e.child.memoizedState, l === null ? l = jc(n) : (o = l.cachePool, o === null ? o = Oa() : (u = ha._currentValue, o = o.parent === u ? o : {
			parent: u,
			pool: u
		}), l = {
			baseLanes: l.baseLanes | n,
			cachePool: o
		}), i.memoizedState = l, i.childLanes = Mc(e, c, n), t.memoizedState = Ac, bc(e.child, i)) : (uo(t), n = e.child, e = n.sibling, n = vi(n, {
			mode: "visible",
			children: i.children
		}), n.return = t, n.sibling = null, e !== null && (c = t.deletions, c === null ? (t.deletions = [e], t.flags |= 16) : c.push(e)), t.child = n, t.memoizedState = null, n);
	}
	function Pc(e, t) {
		return t = Fc({
			mode: "visible",
			children: t
		}, e.mode), t.return = e, e.child = t;
	}
	function Fc(e, t) {
		return e = gi(22, e, null, t), e.lanes = 0, e;
	}
	function Ic(e, t, n) {
		return Ga(t, e.child, null, n), e = Pc(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e;
	}
	function Lc(e, t, n) {
		e.lanes |= t;
		var i = e.alternate;
		i !== null && (i.lanes |= t), aa(e.return, t, n);
	}
	function Rc(e, t, n, i, a, o) {
		var s = e.memoizedState;
		s === null ? e.memoizedState = {
			isBackwards: t,
			rendering: null,
			renderingStartTime: 0,
			last: i,
			tail: n,
			tailMode: a,
			treeForkCount: o
		} : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = n, s.tailMode = a, s.treeForkCount = o);
	}
	function zc(e, t, n) {
		var i = t.pendingProps, a = i.revealOrder, o = i.tail;
		i = i.children;
		var s = go.current, c = (s & 2) != 0;
		if (c ? (s = s & 1 | 2, t.flags |= 128) : s &= 1, z(go, s), hc(e, t, i, n), i = Ui ? Ai : 0, !c && e !== null && e.flags & 128) a: for (e = t.child; e !== null;) {
			if (e.tag === 13) e.memoizedState !== null && Lc(e, n, t);
			else if (e.tag === 19) Lc(e, n, t);
			else if (e.child !== null) {
				e.child.return = e, e = e.child;
				continue;
			}
			if (e === t) break a;
			for (; e.sibling === null;) {
				if (e.return === null || e.return === t) break a;
				e = e.return;
			}
			e.sibling.return = e.return, e = e.sibling;
		}
		switch (a) {
			case "forwards":
				for (n = t.child, a = null; n !== null;) e = n.alternate, e !== null && _o(e) === null && (a = n), n = n.sibling;
				n = a, n === null ? (a = t.child, t.child = null) : (a = n.sibling, n.sibling = null), Rc(t, !1, a, n, o, i);
				break;
			case "backwards":
			case "unstable_legacy-backwards":
				for (n = null, a = t.child, t.child = null; a !== null;) {
					if (e = a.alternate, e !== null && _o(e) === null) {
						t.child = a;
						break;
					}
					e = a.sibling, a.sibling = n, n = a, a = e;
				}
				Rc(t, !0, n, null, o, i);
				break;
			case "together":
				Rc(t, !1, null, null, void 0, i);
				break;
			default: t.memoizedState = null;
		}
		return t.child;
	}
	function Bc(e, t, n) {
		if (e !== null && (t.dependencies = e.dependencies), lu |= t.lanes, (n & t.childLanes) === 0) if (e !== null) {
			if (sa(e, t, n, !1), (n & t.childLanes) === 0) return null;
		} else return null;
		if (e !== null && t.child !== e.child) throw Error(a(153));
		if (t.child !== null) {
			for (e = t.child, n = vi(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;) e = e.sibling, n = n.sibling = vi(e, e.pendingProps), n.return = t;
			n.sibling = null;
		}
		return t.child;
	}
	function Vc(e, t) {
		return (e.lanes & t) === 0 ? (e = e.dependencies, !!(e !== null && ca(e))) : !0;
	}
	function Hc(e, t, n) {
		switch (t.tag) {
			case 3:
				de(t, t.stateNode.containerInfo), ra(t, ha, e.memoizedState.cache), Zi();
				break;
			case 27:
			case 5:
				pe(t);
				break;
			case 4:
				de(t, t.stateNode.containerInfo);
				break;
			case 10:
				ra(t, t.type, t.memoizedProps.value);
				break;
			case 31:
				if (t.memoizedState !== null) return t.flags |= 128, fo(t), null;
				break;
			case 13:
				var i = t.memoizedState;
				if (i !== null) return i.dehydrated === null ? (n & t.child.childLanes) === 0 ? (uo(t), e = Bc(e, t, n), e === null ? null : e.sibling) : Nc(e, t, n) : (uo(t), t.flags |= 128, null);
				uo(t);
				break;
			case 19:
				var a = (e.flags & 128) != 0;
				if (i = (n & t.childLanes) !== 0, i ||= (sa(e, t, n, !1), (n & t.childLanes) !== 0), a) {
					if (i) return zc(e, t, n);
					t.flags |= 128;
				}
				if (a = t.memoizedState, a !== null && (a.rendering = null, a.tail = null, a.lastEffect = null), z(go, go.current), i) break;
				return null;
			case 22: return t.lanes = 0, yc(e, t, n, t.pendingProps);
			case 24: ra(t, ha, e.memoizedState.cache);
		}
		return Bc(e, t, n);
	}
	function Uc(e, t, n) {
		if (e !== null) if (e.memoizedProps !== t.pendingProps) mc = !0;
		else {
			if (!Vc(e, n) && !(t.flags & 128)) return mc = !1, Hc(e, t, n);
			mc = !!(e.flags & 131072);
		}
		else mc = !1, Ui && t.flags & 1048576 && Li(t, Ai, t.index);
		switch (t.lanes = 0, t.tag) {
			case 16:
				a: {
					var i = t.pendingProps;
					if (e = Fa(t.elementType), t.type = e, typeof e == "function") _i(e) ? (i = rc(e, i), t.tag = 1, t = Oc(null, t, e, i, n)) : (t.tag = 0, t = Ec(null, t, e, i, n));
					else {
						if (e != null) {
							var o = e.$$typeof;
							if (o === T) {
								t.tag = 11, t = gc(null, t, e, i, n);
								break a;
							} else if (o === k) {
								t.tag = 14, t = _c(null, t, e, i, n);
								break a;
							}
						}
						throw t = I(e) || e, Error(a(306, t, ""));
					}
				}
				return t;
			case 0: return Ec(e, t, t.type, t.pendingProps, n);
			case 1: return i = t.type, o = rc(i, t.pendingProps), Oc(e, t, i, o, n);
			case 3:
				a: {
					if (de(t, t.stateNode.containerInfo), e === null) throw Error(a(387));
					i = t.pendingProps;
					var s = t.memoizedState;
					o = s.element, Z(e, t), eo(t, i, null, n);
					var c = t.memoizedState;
					if (i = c.cache, ra(t, ha, i), i !== s.cache && oa(t, [ha], n, !0), $a(), i = c.element, s.isDehydrated) if (s = {
						element: i,
						isDehydrated: !1,
						cache: c.cache
					}, t.updateQueue.baseState = s, t.memoizedState = s, t.flags & 256) {
						t = kc(e, t, i, n);
						break a;
					} else if (i !== o) {
						o = Ei(Error(a(424)), t), $i(o), t = kc(e, t, i, n);
						break a;
					} else {
						switch (e = t.stateNode.containerInfo, e.nodeType) {
							case 9:
								e = e.body;
								break;
							default: e = e.nodeName === "HTML" ? e.ownerDocument.body : e;
						}
						for (Hi = Mf(e.firstChild), Vi = t, Ui = !0, Wi = null, Gi = !0, n = Ka(t, null, i, n), t.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
					}
					else {
						if (Zi(), i === o) {
							t = Bc(e, t, n);
							break a;
						}
						hc(e, t, i, n);
					}
					t = t.child;
				}
				return t;
			case 26: return Tc(e, t), e === null ? (n = Qf(t.type, null, t.pendingProps, null)) ? t.memoizedState = n : Ui || (n = t.type, e = t.pendingProps, i = df(le.current).createElement(n), i[rt] = t, i[it] = e, rf(i, n, e), gt(i), t.stateNode = i) : t.memoizedState = Qf(t.type, e.memoizedProps, t.pendingProps, e.memoizedState), null;
			case 27: return pe(t), e === null && Ui && (i = t.stateNode = If(t.type, t.pendingProps, le.current), Vi = t, Gi = !0, o = Hi, Sf(t.type) ? (Nf = o, Hi = Mf(i.firstChild)) : Hi = o), hc(e, t, t.pendingProps.children, n), Tc(e, t), e === null && (t.flags |= 4194304), t.child;
			case 5: return e === null && Ui && ((o = i = Hi) && (i = Ef(i, t.type, t.pendingProps, Gi), i === null ? o = !1 : (t.stateNode = i, Vi = t, Hi = Mf(i.firstChild), Gi = !1, o = !0)), o || qi(t)), pe(t), o = t.type, s = t.pendingProps, c = e === null ? null : e.memoizedProps, i = s.children, mf(o, s) ? i = null : c !== null && mf(o, c) && (t.flags |= 32), t.memoizedState !== null && (o = jo(e, t, Po, null, null, n), xp._currentValue = o), Tc(e, t), hc(e, t, i, n), t.child;
			case 6: return e === null && Ui && ((e = n = Hi) && (n = Df(n, t.pendingProps, Gi), n === null ? e = !1 : (t.stateNode = n, Vi = t, Hi = null, e = !0)), e || qi(t)), null;
			case 13: return Nc(e, t, n);
			case 4: return de(t, t.stateNode.containerInfo), i = t.pendingProps, e === null ? t.child = Ga(t, null, i, n) : hc(e, t, i, n), t.child;
			case 11: return gc(e, t, t.type, t.pendingProps, n);
			case 7: return hc(e, t, t.pendingProps, n), t.child;
			case 8: return hc(e, t, t.pendingProps.children, n), t.child;
			case 12: return hc(e, t, t.pendingProps.children, n), t.child;
			case 10: return i = t.pendingProps, ra(t, t.type, i.value), hc(e, t, i.children, n), t.child;
			case 9: return o = t.type._context, i = t.pendingProps.children, la(t), o = q(o), i = i(o), t.flags |= 1, hc(e, t, i, n), t.child;
			case 14: return _c(e, t, t.type, t.pendingProps, n);
			case 15: return vc(e, t, t.type, t.pendingProps, n);
			case 19: return zc(e, t, n);
			case 31: return wc(e, t, n);
			case 22: return yc(e, t, n, t.pendingProps);
			case 24: return la(t), i = q(ha), e === null ? (o = Ea(), o === null && (o = $l, s = ga(), o.pooledCache = s, s.refCount++, s !== null && (o.pooledCacheLanes |= n), o = s), t.memoizedState = {
				parent: i,
				cache: o
			}, Y(t), ra(t, ha, o)) : ((e.lanes & n) !== 0 && (Z(e, t), eo(t, null, null, n), $a()), o = e.memoizedState, s = t.memoizedState, o.parent === i ? (i = s.cache, ra(t, ha, i), i !== o.cache && oa(t, [ha], n, !0)) : (o = {
				parent: i,
				cache: i
			}, t.memoizedState = o, t.lanes === 0 && (t.memoizedState = t.updateQueue.baseState = o), ra(t, ha, i))), hc(e, t, t.pendingProps.children, n), t.child;
			case 29: throw t.pendingProps;
		}
		throw Error(a(156, t.tag));
	}
	function Wc(e) {
		e.flags |= 4;
	}
	function Gc(e, t, n, i, a) {
		if ((t = (e.mode & 32) != 0) && (t = !1), t) {
			if (e.flags |= 16777216, (a & 335544128) === a) if (e.stateNode.complete) e.flags |= 8192;
			else if (Hu()) e.flags |= 8192;
			else throw Ia = Ma, Aa;
		} else e.flags &= -16777217;
	}
	function Kc(e, t) {
		if (t.type !== "stylesheet" || t.state.loading & 4) e.flags &= -16777217;
		else if (e.flags |= 16777216, !pp(t)) if (Hu()) e.flags |= 8192;
		else throw Ia = Ma, Aa;
	}
	function qc(e, t) {
		t !== null && (e.flags |= 4), e.flags & 16384 && (t = e.tag === 22 ? 536870912 : Ke(), e.lanes |= t, pu |= t);
	}
	function Jc(e, t) {
		if (!Ui) switch (e.tailMode) {
			case "hidden":
				t = e.tail;
				for (var n = null; t !== null;) t.alternate !== null && (n = t), t = t.sibling;
				n === null ? e.tail = null : n.sibling = null;
				break;
			case "collapsed":
				n = e.tail;
				for (var i = null; n !== null;) n.alternate !== null && (i = n), n = n.sibling;
				i === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : i.sibling = null;
		}
	}
	function Yc(e) {
		var t = e.alternate !== null && e.alternate.child === e.child, n = 0, i = 0;
		if (t) for (var a = e.child; a !== null;) n |= a.lanes | a.childLanes, i |= a.subtreeFlags & 65011712, i |= a.flags & 65011712, a.return = e, a = a.sibling;
		else for (a = e.child; a !== null;) n |= a.lanes | a.childLanes, i |= a.subtreeFlags, i |= a.flags, a.return = e, a = a.sibling;
		return e.subtreeFlags |= i, e.childLanes = n, t;
	}
	function Xc(e, t, n) {
		var i = t.pendingProps;
		switch (zi(t), t.tag) {
			case 16:
			case 15:
			case 0:
			case 11:
			case 7:
			case 8:
			case 12:
			case 9:
			case 14: return Yc(t), null;
			case 1: return Yc(t), null;
			case 3: return n = t.stateNode, i = null, e !== null && (i = e.memoizedState.cache), t.memoizedState.cache !== i && (t.flags |= 2048), ia(ha), fe(), n.pendingContext &&= (n.context = n.pendingContext, null), (e === null || e.child === null) && (Xi(t) ? Wc(t) : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Qi())), Yc(t), null;
			case 26:
				var o = t.type, s = t.memoizedState;
				return e === null ? (Wc(t), s === null ? (Yc(t), Gc(t, o, null, i, n)) : (Yc(t), Kc(t, s))) : s ? s === e.memoizedState ? (Yc(t), t.flags &= -16777217) : (Wc(t), Yc(t), Kc(t, s)) : (e = e.memoizedProps, e !== i && Wc(t), Yc(t), Gc(t, o, e, i, n)), null;
			case 27:
				if (V(t), n = le.current, o = t.type, e !== null && t.stateNode != null) e.memoizedProps !== i && Wc(t);
				else {
					if (!i) {
						if (t.stateNode === null) throw Error(a(166));
						return Yc(t), null;
					}
					e = se.current, Xi(t) ? Ji(t, e) : (e = If(o, i, n), t.stateNode = e, Wc(t));
				}
				return Yc(t), null;
			case 5:
				if (V(t), o = t.type, e !== null && t.stateNode != null) e.memoizedProps !== i && Wc(t);
				else {
					if (!i) {
						if (t.stateNode === null) throw Error(a(166));
						return Yc(t), null;
					}
					if (s = se.current, Xi(t)) Ji(t, s);
					else {
						var c = df(le.current);
						switch (s) {
							case 1:
								s = c.createElementNS("http://www.w3.org/2000/svg", o);
								break;
							case 2:
								s = c.createElementNS("http://www.w3.org/1998/Math/MathML", o);
								break;
							default: switch (o) {
								case "svg":
									s = c.createElementNS("http://www.w3.org/2000/svg", o);
									break;
								case "math":
									s = c.createElementNS("http://www.w3.org/1998/Math/MathML", o);
									break;
								case "script":
									s = c.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild);
									break;
								case "select":
									s = typeof i.is == "string" ? c.createElement("select", { is: i.is }) : c.createElement("select"), i.multiple ? s.multiple = !0 : i.size && (s.size = i.size);
									break;
								default: s = typeof i.is == "string" ? c.createElement(o, { is: i.is }) : c.createElement(o);
							}
						}
						s[rt] = t, s[it] = i;
						a: for (c = t.child; c !== null;) {
							if (c.tag === 5 || c.tag === 6) s.appendChild(c.stateNode);
							else if (c.tag !== 4 && c.tag !== 27 && c.child !== null) {
								c.child.return = c, c = c.child;
								continue;
							}
							if (c === t) break a;
							for (; c.sibling === null;) {
								if (c.return === null || c.return === t) break a;
								c = c.return;
							}
							c.sibling.return = c.return, c = c.sibling;
						}
						t.stateNode = s;
						a: switch (rf(s, o, i), o) {
							case "button":
							case "input":
							case "select":
							case "textarea":
								i = !!i.autoFocus;
								break a;
							case "img":
								i = !0;
								break a;
							default: i = !1;
						}
						i && Wc(t);
					}
				}
				return Yc(t), Gc(t, t.type, e === null ? null : e.memoizedProps, t.pendingProps, n), null;
			case 6:
				if (e && t.stateNode != null) e.memoizedProps !== i && Wc(t);
				else {
					if (typeof i != "string" && t.stateNode === null) throw Error(a(166));
					if (e = le.current, Xi(t)) {
						if (e = t.stateNode, n = t.memoizedProps, i = null, o = Vi, o !== null) switch (o.tag) {
							case 27:
							case 5: i = o.memoizedProps;
						}
						e[rt] = t, e = !!(e.nodeValue === n || i !== null && !0 === i.suppressHydrationWarning || ef(e.nodeValue, n)), e || qi(t, !0);
					} else e = df(e).createTextNode(i), e[rt] = t, t.stateNode = e;
				}
				return Yc(t), null;
			case 31:
				if (n = t.memoizedState, e === null || e.memoizedState !== null) {
					if (i = Xi(t), n !== null) {
						if (e === null) {
							if (!i) throw Error(a(318));
							if (e = t.memoizedState, e = e === null ? null : e.dehydrated, !e) throw Error(a(557));
							e[rt] = t;
						} else Zi(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
						Yc(t), e = !1;
					} else n = Qi(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = n), e = !0;
					if (!e) return t.flags & 256 ? (ho(t), t) : (ho(t), null);
					if (t.flags & 128) throw Error(a(558));
				}
				return Yc(t), null;
			case 13:
				if (i = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
					if (o = Xi(t), i !== null && i.dehydrated !== null) {
						if (e === null) {
							if (!o) throw Error(a(318));
							if (o = t.memoizedState, o = o === null ? null : o.dehydrated, !o) throw Error(a(317));
							o[rt] = t;
						} else Zi(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
						Yc(t), o = !1;
					} else o = Qi(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = o), o = !0;
					if (!o) return t.flags & 256 ? (ho(t), t) : (ho(t), null);
				}
				return ho(t), t.flags & 128 ? (t.lanes = n, t) : (n = i !== null, e = e !== null && e.memoizedState !== null, n && (i = t.child, o = null, i.alternate !== null && i.alternate.memoizedState !== null && i.alternate.memoizedState.cachePool !== null && (o = i.alternate.memoizedState.cachePool.pool), s = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (s = i.memoizedState.cachePool.pool), s !== o && (i.flags |= 2048)), n !== e && n && (t.child.flags |= 8192), qc(t, t.updateQueue), Yc(t), null);
			case 4: return fe(), e === null && Wd(t.stateNode.containerInfo), Yc(t), null;
			case 10: return ia(t.type), Yc(t), null;
			case 19:
				if (oe(go), i = t.memoizedState, i === null) return Yc(t), null;
				if (o = (t.flags & 128) != 0, s = i.rendering, s === null) if (o) Jc(i, !1);
				else {
					if (cu !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) {
						if (s = _o(e), s !== null) {
							for (t.flags |= 128, Jc(i, !1), e = s.updateQueue, t.updateQueue = e, qc(t, e), t.subtreeFlags = 0, e = n, n = t.child; n !== null;) yi(n, e), n = n.sibling;
							return z(go, go.current & 1 | 2), Ui && Ii(t, i.treeForkCount), t.child;
						}
						e = e.sibling;
					}
					i.tail !== null && Te() > yu && (t.flags |= 128, o = !0, Jc(i, !1), t.lanes = 4194304);
				}
				else {
					if (!o) if (e = _o(s), e !== null) {
						if (t.flags |= 128, o = !0, e = e.updateQueue, t.updateQueue = e, qc(t, e), Jc(i, !0), i.tail === null && i.tailMode === "hidden" && !s.alternate && !Ui) return Yc(t), null;
					} else 2 * Te() - i.renderingStartTime > yu && n !== 536870912 && (t.flags |= 128, o = !0, Jc(i, !1), t.lanes = 4194304);
					i.isBackwards ? (s.sibling = t.child, t.child = s) : (e = i.last, e === null ? t.child = s : e.sibling = s, i.last = s);
				}
				return i.tail === null ? (Yc(t), null) : (e = i.tail, i.rendering = e, i.tail = e.sibling, i.renderingStartTime = Te(), e.sibling = null, n = go.current, z(go, o ? n & 1 | 2 : n & 1), Ui && Ii(t, i.treeForkCount), e);
			case 22:
			case 23: return ho(t), so(), i = t.memoizedState !== null, e === null ? i && (t.flags |= 8192) : e.memoizedState !== null !== i && (t.flags |= 8192), i ? n & 536870912 && !(t.flags & 128) && (Yc(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Yc(t), n = t.updateQueue, n !== null && qc(t, n.retryQueue), n = null, e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), i = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (i = t.memoizedState.cachePool.pool), i !== n && (t.flags |= 2048), e !== null && oe(Ta), null;
			case 24: return n = null, e !== null && (n = e.memoizedState.cache), t.memoizedState.cache !== n && (t.flags |= 2048), ia(ha), Yc(t), null;
			case 25: return null;
			case 30: return null;
		}
		throw Error(a(156, t.tag));
	}
	function Zc(e, t) {
		switch (zi(t), t.tag) {
			case 1: return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
			case 3: return ia(ha), fe(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
			case 26:
			case 27:
			case 5: return V(t), null;
			case 31:
				if (t.memoizedState !== null) {
					if (ho(t), t.alternate === null) throw Error(a(340));
					Zi();
				}
				return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
			case 13:
				if (ho(t), e = t.memoizedState, e !== null && e.dehydrated !== null) {
					if (t.alternate === null) throw Error(a(340));
					Zi();
				}
				return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
			case 19: return oe(go), null;
			case 4: return fe(), null;
			case 10: return ia(t.type), null;
			case 22:
			case 23: return ho(t), so(), e !== null && oe(Ta), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
			case 24: return ia(ha), null;
			case 25: return null;
			default: return null;
		}
	}
	function Qc(e, t) {
		switch (zi(t), t.tag) {
			case 3:
				ia(ha), fe();
				break;
			case 26:
			case 27:
			case 5:
				V(t);
				break;
			case 4:
				fe();
				break;
			case 31:
				t.memoizedState !== null && ho(t);
				break;
			case 13:
				ho(t);
				break;
			case 19:
				oe(go);
				break;
			case 10:
				ia(t.type);
				break;
			case 22:
			case 23:
				ho(t), so(), e !== null && oe(Ta);
				break;
			case 24: ia(ha);
		}
	}
	function $c(e, t) {
		try {
			var n = t.updateQueue, i = n === null ? null : n.lastEffect;
			if (i !== null) {
				var a = i.next;
				n = a;
				do {
					if ((n.tag & e) === e) {
						i = void 0;
						var o = n.create, s = n.inst;
						i = o(), s.destroy = i;
					}
					n = n.next;
				} while (n !== a);
			}
		} catch (e) {
			ld(t, t.return, e);
		}
	}
	function el(e, t, n) {
		try {
			var i = t.updateQueue, a = i === null ? null : i.lastEffect;
			if (a !== null) {
				var o = a.next;
				i = o;
				do {
					if ((i.tag & e) === e) {
						var s = i.inst, c = s.destroy;
						if (c !== void 0) {
							s.destroy = void 0, a = t;
							var l = n, u = c;
							try {
								u();
							} catch (e) {
								ld(a, l, e);
							}
						}
					}
					i = i.next;
				} while (i !== o);
			}
		} catch (e) {
			ld(t, t.return, e);
		}
	}
	function tl(e) {
		var t = e.updateQueue;
		if (t !== null) {
			var n = e.stateNode;
			try {
				no(t, n);
			} catch (t) {
				ld(e, e.return, t);
			}
		}
	}
	function nl(e, t, n) {
		n.props = rc(e.type, e.memoizedProps), n.state = e.memoizedState;
		try {
			n.componentWillUnmount();
		} catch (n) {
			ld(e, t, n);
		}
	}
	function rl(e, t) {
		try {
			var n = e.ref;
			if (n !== null) {
				switch (e.tag) {
					case 26:
					case 27:
					case 5:
						var i = e.stateNode;
						break;
					case 30:
						i = e.stateNode;
						break;
					default: i = e.stateNode;
				}
				typeof n == "function" ? e.refCleanup = n(i) : n.current = i;
			}
		} catch (n) {
			ld(e, t, n);
		}
	}
	function il(e, t) {
		var n = e.ref, i = e.refCleanup;
		if (n !== null) if (typeof i == "function") try {
			i();
		} catch (n) {
			ld(e, t, n);
		} finally {
			e.refCleanup = null, e = e.alternate, e != null && (e.refCleanup = null);
		}
		else if (typeof n == "function") try {
			n(null);
		} catch (n) {
			ld(e, t, n);
		}
		else n.current = null;
	}
	function al(e) {
		var t = e.type, n = e.memoizedProps, i = e.stateNode;
		try {
			a: switch (t) {
				case "button":
				case "input":
				case "select":
				case "textarea":
					n.autoFocus && i.focus();
					break a;
				case "img": n.src ? i.src = n.src : n.srcSet && (i.srcset = n.srcSet);
			}
		} catch (t) {
			ld(e, e.return, t);
		}
	}
	function ol(e, t, n) {
		try {
			var i = e.stateNode;
			af(i, e.type, n, t), i[it] = t;
		} catch (t) {
			ld(e, e.return, t);
		}
	}
	function sl(e) {
		return e.tag === 5 || e.tag === 3 || e.tag === 26 || e.tag === 27 && Sf(e.type) || e.tag === 4;
	}
	function cl(e) {
		a: for (;;) {
			for (; e.sibling === null;) {
				if (e.return === null || sl(e.return)) return null;
				e = e.return;
			}
			for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) {
				if (e.tag === 27 && Sf(e.type) || e.flags & 2 || e.child === null || e.tag === 4) continue a;
				e.child.return = e, e = e.child;
			}
			if (!(e.flags & 2)) return e.stateNode;
		}
	}
	function ll(e, t, n) {
		var i = e.tag;
		if (i === 5 || i === 6) e = e.stateNode, t ? (n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n).insertBefore(e, t) : (t = n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n, t.appendChild(e), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Xt));
		else if (i !== 4 && (i === 27 && Sf(e.type) && (n = e.stateNode, t = null), e = e.child, e !== null)) for (ll(e, t, n), e = e.sibling; e !== null;) ll(e, t, n), e = e.sibling;
	}
	function ul(e, t, n) {
		var i = e.tag;
		if (i === 5 || i === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
		else if (i !== 4 && (i === 27 && Sf(e.type) && (n = e.stateNode), e = e.child, e !== null)) for (ul(e, t, n), e = e.sibling; e !== null;) ul(e, t, n), e = e.sibling;
	}
	function dl(e) {
		var t = e.stateNode, n = e.memoizedProps;
		try {
			for (var i = e.type, a = t.attributes; a.length;) t.removeAttributeNode(a[0]);
			rf(t, i, n), t[rt] = e, t[it] = n;
		} catch (t) {
			ld(e, e.return, t);
		}
	}
	var fl = !1, pl = !1, ml = !1, hl = typeof WeakSet == "function" ? WeakSet : Set, gl = null;
	function _l(e, t) {
		if (e = e.containerInfo, lf = Ap, e = Fr(e), Ir(e)) {
			if ("selectionStart" in e) var n = {
				start: e.selectionStart,
				end: e.selectionEnd
			};
			else a: {
				n = (n = e.ownerDocument) && n.defaultView || window;
				var i = n.getSelection && n.getSelection();
				if (i && i.rangeCount !== 0) {
					n = i.anchorNode;
					var o = i.anchorOffset, s = i.focusNode;
					i = i.focusOffset;
					try {
						n.nodeType, s.nodeType;
					} catch {
						n = null;
						break a;
					}
					var c = 0, l = -1, u = -1, d = 0, f = 0, p = e, m = null;
					b: for (;;) {
						for (var h; p !== n || o !== 0 && p.nodeType !== 3 || (l = c + o), p !== s || i !== 0 && p.nodeType !== 3 || (u = c + i), p.nodeType === 3 && (c += p.nodeValue.length), (h = p.firstChild) !== null;) m = p, p = h;
						for (;;) {
							if (p === e) break b;
							if (m === n && ++d === o && (l = c), m === s && ++f === i && (u = c), (h = p.nextSibling) !== null) break;
							p = m, m = p.parentNode;
						}
						p = h;
					}
					n = l === -1 || u === -1 ? null : {
						start: l,
						end: u
					};
				} else n = null;
			}
			n ||= {
				start: 0,
				end: 0
			};
		} else n = null;
		for (uf = {
			focusedElem: e,
			selectionRange: n
		}, Ap = !1, gl = t; gl !== null;) if (t = gl, e = t.child, t.subtreeFlags & 1028 && e !== null) e.return = t, gl = e;
		else for (; gl !== null;) {
			switch (t = gl, s = t.alternate, e = t.flags, t.tag) {
				case 0:
					if (e & 4 && (e = t.updateQueue, e = e === null ? null : e.events, e !== null)) for (n = 0; n < e.length; n++) o = e[n], o.ref.impl = o.nextImpl;
					break;
				case 11:
				case 15: break;
				case 1:
					if (e & 1024 && s !== null) {
						e = void 0, n = t, o = s.memoizedProps, s = s.memoizedState, i = n.stateNode;
						try {
							var g = rc(n.type, o);
							e = i.getSnapshotBeforeUpdate(g, s), i.__reactInternalSnapshotBeforeUpdate = e;
						} catch (e) {
							ld(n, n.return, e);
						}
					}
					break;
				case 3:
					if (e & 1024) {
						if (e = t.stateNode.containerInfo, n = e.nodeType, n === 9) Tf(e);
						else if (n === 1) switch (e.nodeName) {
							case "HEAD":
							case "HTML":
							case "BODY":
								Tf(e);
								break;
							default: e.textContent = "";
						}
					}
					break;
				case 5:
				case 26:
				case 27:
				case 6:
				case 4:
				case 17: break;
				default: if (e & 1024) throw Error(a(163));
			}
			if (e = t.sibling, e !== null) {
				e.return = t.return, gl = e;
				break;
			}
			gl = t.return;
		}
	}
	function vl(e, t, n) {
		var i = n.flags;
		switch (n.tag) {
			case 0:
			case 11:
			case 15:
				Nl(e, n), i & 4 && $c(5, n);
				break;
			case 1:
				if (Nl(e, n), i & 4) if (e = n.stateNode, t === null) try {
					e.componentDidMount();
				} catch (e) {
					ld(n, n.return, e);
				}
				else {
					var a = rc(n.type, t.memoizedProps);
					t = t.memoizedState;
					try {
						e.componentDidUpdate(a, t, e.__reactInternalSnapshotBeforeUpdate);
					} catch (e) {
						ld(n, n.return, e);
					}
				}
				i & 64 && tl(n), i & 512 && rl(n, n.return);
				break;
			case 3:
				if (Nl(e, n), i & 64 && (e = n.updateQueue, e !== null)) {
					if (t = null, n.child !== null) switch (n.child.tag) {
						case 27:
						case 5:
							t = n.child.stateNode;
							break;
						case 1: t = n.child.stateNode;
					}
					try {
						no(e, t);
					} catch (e) {
						ld(n, n.return, e);
					}
				}
				break;
			case 27: t === null && i & 4 && dl(n);
			case 26:
			case 5:
				Nl(e, n), t === null && i & 4 && al(n), i & 512 && rl(n, n.return);
				break;
			case 12:
				Nl(e, n);
				break;
			case 31:
				Nl(e, n), i & 4 && wl(e, n);
				break;
			case 13:
				Nl(e, n), i & 4 && Tl(e, n), i & 64 && (e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null && (n = pd.bind(null, n), jf(e, n))));
				break;
			case 22:
				if (i = n.memoizedState !== null || fl, !i) {
					t = t !== null && t.memoizedState !== null || pl, a = fl;
					var o = pl;
					fl = i, (pl = t) && !o ? Fl(e, n, (n.subtreeFlags & 8772) != 0) : Nl(e, n), fl = a, pl = o;
				}
				break;
			case 30: break;
			default: Nl(e, n);
		}
	}
	function yl(e) {
		var t = e.alternate;
		t !== null && (e.alternate = null, yl(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && dt(t)), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
	}
	var bl = null, xl = !1;
	function Sl(e, t, n) {
		for (n = n.child; n !== null;) Cl(e, t, n), n = n.sibling;
	}
	function Cl(e, t, n) {
		if (Pe && typeof Pe.onCommitFiberUnmount == "function") try {
			Pe.onCommitFiberUnmount(U, n);
		} catch {}
		switch (n.tag) {
			case 26:
				pl || il(n, t), Sl(e, t, n), n.memoizedState ? n.memoizedState.count-- : n.stateNode && (n = n.stateNode, n.parentNode.removeChild(n));
				break;
			case 27:
				pl || il(n, t);
				var i = bl, a = xl;
				Sf(n.type) && (bl = n.stateNode, xl = !1), Sl(e, t, n), Lf(n.stateNode), bl = i, xl = a;
				break;
			case 5: pl || il(n, t);
			case 6:
				if (i = bl, a = xl, bl = null, Sl(e, t, n), bl = i, xl = a, bl !== null) if (xl) try {
					(bl.nodeType === 9 ? bl.body : bl.nodeName === "HTML" ? bl.ownerDocument.body : bl).removeChild(n.stateNode);
				} catch (e) {
					ld(n, t, e);
				}
				else try {
					bl.removeChild(n.stateNode);
				} catch (e) {
					ld(n, t, e);
				}
				break;
			case 18:
				bl !== null && (xl ? (e = bl, Cf(e.nodeType === 9 ? e.body : e.nodeName === "HTML" ? e.ownerDocument.body : e, n.stateNode), nm(e)) : Cf(bl, n.stateNode));
				break;
			case 4:
				i = bl, a = xl, bl = n.stateNode.containerInfo, xl = !0, Sl(e, t, n), bl = i, xl = a;
				break;
			case 0:
			case 11:
			case 14:
			case 15:
				el(2, n, t), pl || el(4, n, t), Sl(e, t, n);
				break;
			case 1:
				pl || (il(n, t), i = n.stateNode, typeof i.componentWillUnmount == "function" && nl(n, t, i)), Sl(e, t, n);
				break;
			case 21:
				Sl(e, t, n);
				break;
			case 22:
				pl = (i = pl) || n.memoizedState !== null, Sl(e, t, n), pl = i;
				break;
			default: Sl(e, t, n);
		}
	}
	function wl(e, t) {
		if (t.memoizedState === null && (e = t.alternate, e !== null && (e = e.memoizedState, e !== null))) {
			e = e.dehydrated;
			try {
				nm(e);
			} catch (e) {
				ld(t, t.return, e);
			}
		}
	}
	function Tl(e, t) {
		if (t.memoizedState === null && (e = t.alternate, e !== null && (e = e.memoizedState, e !== null && (e = e.dehydrated, e !== null)))) try {
			nm(e);
		} catch (e) {
			ld(t, t.return, e);
		}
	}
	function El(e) {
		switch (e.tag) {
			case 31:
			case 13:
			case 19:
				var t = e.stateNode;
				return t === null && (t = e.stateNode = new hl()), t;
			case 22: return e = e.stateNode, t = e._retryCache, t === null && (t = e._retryCache = new hl()), t;
			default: throw Error(a(435, e.tag));
		}
	}
	function Dl(e, t) {
		var n = El(e);
		t.forEach(function(t) {
			if (!n.has(t)) {
				n.add(t);
				var i = md.bind(null, e, t);
				t.then(i, i);
			}
		});
	}
	function Ol(e, t) {
		var n = t.deletions;
		if (n !== null) for (var i = 0; i < n.length; i++) {
			var o = n[i], s = e, c = t, l = c;
			a: for (; l !== null;) {
				switch (l.tag) {
					case 27:
						if (Sf(l.type)) {
							bl = l.stateNode, xl = !1;
							break a;
						}
						break;
					case 5:
						bl = l.stateNode, xl = !1;
						break a;
					case 3:
					case 4:
						bl = l.stateNode.containerInfo, xl = !0;
						break a;
				}
				l = l.return;
			}
			if (bl === null) throw Error(a(160));
			Cl(s, c, o), bl = null, xl = !1, s = o.alternate, s !== null && (s.return = null), o.return = null;
		}
		if (t.subtreeFlags & 13886) for (t = t.child; t !== null;) Al(t, e), t = t.sibling;
	}
	var kl = null;
	function Al(e, t) {
		var n = e.alternate, i = e.flags;
		switch (e.tag) {
			case 0:
			case 11:
			case 14:
			case 15:
				Ol(t, e), jl(e), i & 4 && (el(3, e, e.return), $c(3, e), el(5, e, e.return));
				break;
			case 1:
				Ol(t, e), jl(e), i & 512 && (pl || n === null || il(n, n.return)), i & 64 && fl && (e = e.updateQueue, e !== null && (i = e.callbacks, i !== null && (n = e.shared.hiddenCallbacks, e.shared.hiddenCallbacks = n === null ? i : n.concat(i))));
				break;
			case 26:
				var o = kl;
				if (Ol(t, e), jl(e), i & 512 && (pl || n === null || il(n, n.return)), i & 4) {
					var s = n === null ? null : n.memoizedState;
					if (i = e.memoizedState, n === null) if (i === null) if (e.stateNode === null) {
						a: {
							i = e.type, n = e.memoizedProps, o = o.ownerDocument || o;
							b: switch (i) {
								case "title":
									s = o.getElementsByTagName("title")[0], (!s || s[ut] || s[rt] || s.namespaceURI === "http://www.w3.org/2000/svg" || s.hasAttribute("itemprop")) && (s = o.createElement(i), o.head.insertBefore(s, o.querySelector("head > title"))), rf(s, i, n), s[rt] = e, gt(s), i = s;
									break a;
								case "link":
									var c = up("link", "href", o).get(i + (n.href || ""));
									if (c) {
										for (var l = 0; l < c.length; l++) if (s = c[l], s.getAttribute("href") === (n.href == null || n.href === "" ? null : n.href) && s.getAttribute("rel") === (n.rel == null ? null : n.rel) && s.getAttribute("title") === (n.title == null ? null : n.title) && s.getAttribute("crossorigin") === (n.crossOrigin == null ? null : n.crossOrigin)) {
											c.splice(l, 1);
											break b;
										}
									}
									s = o.createElement(i), rf(s, i, n), o.head.appendChild(s);
									break;
								case "meta":
									if (c = up("meta", "content", o).get(i + (n.content || ""))) {
										for (l = 0; l < c.length; l++) if (s = c[l], s.getAttribute("content") === (n.content == null ? null : "" + n.content) && s.getAttribute("name") === (n.name == null ? null : n.name) && s.getAttribute("property") === (n.property == null ? null : n.property) && s.getAttribute("http-equiv") === (n.httpEquiv == null ? null : n.httpEquiv) && s.getAttribute("charset") === (n.charSet == null ? null : n.charSet)) {
											c.splice(l, 1);
											break b;
										}
									}
									s = o.createElement(i), rf(s, i, n), o.head.appendChild(s);
									break;
								default: throw Error(a(468, i));
							}
							s[rt] = e, gt(s), i = s;
						}
						e.stateNode = i;
					} else dp(o, e.type, e.stateNode);
					else e.stateNode = ap(o, i, e.memoizedProps);
					else s === i ? i === null && e.stateNode !== null && ol(e, e.memoizedProps, n.memoizedProps) : (s === null ? n.stateNode !== null && (n = n.stateNode, n.parentNode.removeChild(n)) : s.count--, i === null ? dp(o, e.type, e.stateNode) : ap(o, i, e.memoizedProps));
				}
				break;
			case 27:
				Ol(t, e), jl(e), i & 512 && (pl || n === null || il(n, n.return)), n !== null && i & 4 && ol(e, e.memoizedProps, n.memoizedProps);
				break;
			case 5:
				if (Ol(t, e), jl(e), i & 512 && (pl || n === null || il(n, n.return)), e.flags & 32) {
					o = e.stateNode;
					try {
						Ht(o, "");
					} catch (t) {
						ld(e, e.return, t);
					}
				}
				i & 4 && e.stateNode != null && (o = e.memoizedProps, ol(e, o, n === null ? o : n.memoizedProps)), i & 1024 && (ml = !0);
				break;
			case 6:
				if (Ol(t, e), jl(e), i & 4) {
					if (e.stateNode === null) throw Error(a(162));
					i = e.memoizedProps, n = e.stateNode;
					try {
						n.nodeValue = i;
					} catch (t) {
						ld(e, e.return, t);
					}
				}
				break;
			case 3:
				if (lp = null, o = kl, kl = Bf(t.containerInfo), Ol(t, e), kl = o, jl(e), i & 4 && n !== null && n.memoizedState.isDehydrated) try {
					nm(t.containerInfo);
				} catch (t) {
					ld(e, e.return, t);
				}
				ml && (ml = !1, Ml(e));
				break;
			case 4:
				i = kl, kl = Bf(e.stateNode.containerInfo), Ol(t, e), jl(e), kl = i;
				break;
			case 12:
				Ol(t, e), jl(e);
				break;
			case 31:
				Ol(t, e), jl(e), i & 4 && (i = e.updateQueue, i !== null && (e.updateQueue = null, Dl(e, i)));
				break;
			case 13:
				Ol(t, e), jl(e), e.child.flags & 8192 && e.memoizedState !== null != (n !== null && n.memoizedState !== null) && (_u = Te()), i & 4 && (i = e.updateQueue, i !== null && (e.updateQueue = null, Dl(e, i)));
				break;
			case 22:
				o = e.memoizedState !== null;
				var u = n !== null && n.memoizedState !== null, d = fl, f = pl;
				if (fl = d || o, pl = f || u, Ol(t, e), pl = f, fl = d, jl(e), i & 8192) a: for (t = e.stateNode, t._visibility = o ? t._visibility & -2 : t._visibility | 1, o && (n === null || u || fl || pl || Pl(e)), n = null, t = e;;) {
					if (t.tag === 5 || t.tag === 26) {
						if (n === null) {
							u = n = t;
							try {
								if (s = u.stateNode, o) c = s.style, typeof c.setProperty == "function" ? c.setProperty("display", "none", "important") : c.display = "none";
								else {
									l = u.stateNode;
									var p = u.memoizedProps.style, m = p != null && p.hasOwnProperty("display") ? p.display : null;
									l.style.display = m == null || typeof m == "boolean" ? "" : ("" + m).trim();
								}
							} catch (e) {
								ld(u, u.return, e);
							}
						}
					} else if (t.tag === 6) {
						if (n === null) {
							u = t;
							try {
								u.stateNode.nodeValue = o ? "" : u.memoizedProps;
							} catch (e) {
								ld(u, u.return, e);
							}
						}
					} else if (t.tag === 18) {
						if (n === null) {
							u = t;
							try {
								var h = u.stateNode;
								o ? wf(h, !0) : wf(u.stateNode, !1);
							} catch (e) {
								ld(u, u.return, e);
							}
						}
					} else if ((t.tag !== 22 && t.tag !== 23 || t.memoizedState === null || t === e) && t.child !== null) {
						t.child.return = t, t = t.child;
						continue;
					}
					if (t === e) break a;
					for (; t.sibling === null;) {
						if (t.return === null || t.return === e) break a;
						n === t && (n = null), t = t.return;
					}
					n === t && (n = null), t.sibling.return = t.return, t = t.sibling;
				}
				i & 4 && (i = e.updateQueue, i !== null && (n = i.retryQueue, n !== null && (i.retryQueue = null, Dl(e, n))));
				break;
			case 19:
				Ol(t, e), jl(e), i & 4 && (i = e.updateQueue, i !== null && (e.updateQueue = null, Dl(e, i)));
				break;
			case 30: break;
			case 21: break;
			default: Ol(t, e), jl(e);
		}
	}
	function jl(e) {
		var t = e.flags;
		if (t & 2) {
			try {
				for (var n, i = e.return; i !== null;) {
					if (sl(i)) {
						n = i;
						break;
					}
					i = i.return;
				}
				if (n == null) throw Error(a(160));
				switch (n.tag) {
					case 27:
						var o = n.stateNode, s = cl(e);
						ul(e, s, o);
						break;
					case 5:
						var c = n.stateNode;
						n.flags & 32 && (Ht(c, ""), n.flags &= -33);
						var l = cl(e);
						ul(e, l, c);
						break;
					case 3:
					case 4:
						var u = n.stateNode.containerInfo, d = cl(e);
						ll(e, d, u);
						break;
					default: throw Error(a(161));
				}
			} catch (t) {
				ld(e, e.return, t);
			}
			e.flags &= -3;
		}
		t & 4096 && (e.flags &= -4097);
	}
	function Ml(e) {
		if (e.subtreeFlags & 1024) for (e = e.child; e !== null;) {
			var t = e;
			Ml(t), t.tag === 5 && t.flags & 1024 && t.stateNode.reset(), e = e.sibling;
		}
	}
	function Nl(e, t) {
		if (t.subtreeFlags & 8772) for (t = t.child; t !== null;) vl(e, t.alternate, t), t = t.sibling;
	}
	function Pl(e) {
		for (e = e.child; e !== null;) {
			var t = e;
			switch (t.tag) {
				case 0:
				case 11:
				case 14:
				case 15:
					el(4, t, t.return), Pl(t);
					break;
				case 1:
					il(t, t.return);
					var n = t.stateNode;
					typeof n.componentWillUnmount == "function" && nl(t, t.return, n), Pl(t);
					break;
				case 27: Lf(t.stateNode);
				case 26:
				case 5:
					il(t, t.return), Pl(t);
					break;
				case 22:
					t.memoizedState === null && Pl(t);
					break;
				case 30:
					Pl(t);
					break;
				default: Pl(t);
			}
			e = e.sibling;
		}
	}
	function Fl(e, t, n) {
		for (n &&= (t.subtreeFlags & 8772) != 0, t = t.child; t !== null;) {
			var i = t.alternate, a = e, o = t, s = o.flags;
			switch (o.tag) {
				case 0:
				case 11:
				case 15:
					Fl(a, o, n), $c(4, o);
					break;
				case 1:
					if (Fl(a, o, n), i = o, a = i.stateNode, typeof a.componentDidMount == "function") try {
						a.componentDidMount();
					} catch (e) {
						ld(i, i.return, e);
					}
					if (i = o, a = i.updateQueue, a !== null) {
						var c = i.stateNode;
						try {
							var l = a.shared.hiddenCallbacks;
							if (l !== null) for (a.shared.hiddenCallbacks = null, a = 0; a < l.length; a++) to(l[a], c);
						} catch (e) {
							ld(i, i.return, e);
						}
					}
					n && s & 64 && tl(o), rl(o, o.return);
					break;
				case 27: dl(o);
				case 26:
				case 5:
					Fl(a, o, n), n && i === null && s & 4 && al(o), rl(o, o.return);
					break;
				case 12:
					Fl(a, o, n);
					break;
				case 31:
					Fl(a, o, n), n && s & 4 && wl(a, o);
					break;
				case 13:
					Fl(a, o, n), n && s & 4 && Tl(a, o);
					break;
				case 22:
					o.memoizedState === null && Fl(a, o, n), rl(o, o.return);
					break;
				case 30: break;
				default: Fl(a, o, n);
			}
			t = t.sibling;
		}
	}
	function Il(e, t) {
		var n = null;
		e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), e = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (e = t.memoizedState.cachePool.pool), e !== n && (e != null && e.refCount++, n != null && _a(n));
	}
	function Ll(e, t) {
		e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (t.refCount++, e != null && _a(e));
	}
	function Rl(e, t, n, i) {
		if (t.subtreeFlags & 10256) for (t = t.child; t !== null;) zl(e, t, n, i), t = t.sibling;
	}
	function zl(e, t, n, i) {
		var a = t.flags;
		switch (t.tag) {
			case 0:
			case 11:
			case 15:
				Rl(e, t, n, i), a & 2048 && $c(9, t);
				break;
			case 1:
				Rl(e, t, n, i);
				break;
			case 3:
				Rl(e, t, n, i), a & 2048 && (e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (t.refCount++, e != null && _a(e)));
				break;
			case 12:
				if (a & 2048) {
					Rl(e, t, n, i), e = t.stateNode;
					try {
						var o = t.memoizedProps, s = o.id, c = o.onPostCommit;
						typeof c == "function" && c(s, t.alternate === null ? "mount" : "update", e.passiveEffectDuration, -0);
					} catch (e) {
						ld(t, t.return, e);
					}
				} else Rl(e, t, n, i);
				break;
			case 31:
				Rl(e, t, n, i);
				break;
			case 13:
				Rl(e, t, n, i);
				break;
			case 23: break;
			case 22:
				o = t.stateNode, s = t.alternate, t.memoizedState === null ? o._visibility & 2 ? Rl(e, t, n, i) : (o._visibility |= 2, Bl(e, t, n, i, (t.subtreeFlags & 10256) != 0 || !1)) : o._visibility & 2 ? Rl(e, t, n, i) : Vl(e, t), a & 2048 && Il(s, t);
				break;
			case 24:
				Rl(e, t, n, i), a & 2048 && Ll(t.alternate, t);
				break;
			default: Rl(e, t, n, i);
		}
	}
	function Bl(e, t, n, i, a) {
		for (a &&= (t.subtreeFlags & 10256) != 0 || !1, t = t.child; t !== null;) {
			var o = e, s = t, c = n, l = i, u = s.flags;
			switch (s.tag) {
				case 0:
				case 11:
				case 15:
					Bl(o, s, c, l, a), $c(8, s);
					break;
				case 23: break;
				case 22:
					var d = s.stateNode;
					s.memoizedState === null ? (d._visibility |= 2, Bl(o, s, c, l, a)) : d._visibility & 2 ? Bl(o, s, c, l, a) : Vl(o, s), a && u & 2048 && Il(s.alternate, s);
					break;
				case 24:
					Bl(o, s, c, l, a), a && u & 2048 && Ll(s.alternate, s);
					break;
				default: Bl(o, s, c, l, a);
			}
			t = t.sibling;
		}
	}
	function Vl(e, t) {
		if (t.subtreeFlags & 10256) for (t = t.child; t !== null;) {
			var n = e, i = t, a = i.flags;
			switch (i.tag) {
				case 22:
					Vl(n, i), a & 2048 && Il(i.alternate, i);
					break;
				case 24:
					Vl(n, i), a & 2048 && Ll(i.alternate, i);
					break;
				default: Vl(n, i);
			}
			t = t.sibling;
		}
	}
	var Hl = 8192;
	function Ul(e, t, n) {
		if (e.subtreeFlags & Hl) for (e = e.child; e !== null;) Wl(e, t, n), e = e.sibling;
	}
	function Wl(e, t, n) {
		switch (e.tag) {
			case 26:
				Ul(e, t, n), e.flags & Hl && e.memoizedState !== null && mp(n, kl, e.memoizedState, e.memoizedProps);
				break;
			case 5:
				Ul(e, t, n);
				break;
			case 3:
			case 4:
				var i = kl;
				kl = Bf(e.stateNode.containerInfo), Ul(e, t, n), kl = i;
				break;
			case 22:
				e.memoizedState === null && (i = e.alternate, i !== null && i.memoizedState !== null ? (i = Hl, Hl = 16777216, Ul(e, t, n), Hl = i) : Ul(e, t, n));
				break;
			default: Ul(e, t, n);
		}
	}
	function Gl(e) {
		var t = e.alternate;
		if (t !== null && (e = t.child, e !== null)) {
			t.child = null;
			do
				t = e.sibling, e.sibling = null, e = t;
			while (e !== null);
		}
	}
	function Kl(e) {
		var t = e.deletions;
		if (e.flags & 16) {
			if (t !== null) for (var n = 0; n < t.length; n++) {
				var i = t[n];
				gl = i, Yl(i, e);
			}
			Gl(e);
		}
		if (e.subtreeFlags & 10256) for (e = e.child; e !== null;) ql(e), e = e.sibling;
	}
	function ql(e) {
		switch (e.tag) {
			case 0:
			case 11:
			case 15:
				Kl(e), e.flags & 2048 && el(9, e, e.return);
				break;
			case 3:
				Kl(e);
				break;
			case 12:
				Kl(e);
				break;
			case 22:
				var t = e.stateNode;
				e.memoizedState !== null && t._visibility & 2 && (e.return === null || e.return.tag !== 13) ? (t._visibility &= -3, Jl(e)) : Kl(e);
				break;
			default: Kl(e);
		}
	}
	function Jl(e) {
		var t = e.deletions;
		if (e.flags & 16) {
			if (t !== null) for (var n = 0; n < t.length; n++) {
				var i = t[n];
				gl = i, Yl(i, e);
			}
			Gl(e);
		}
		for (e = e.child; e !== null;) {
			switch (t = e, t.tag) {
				case 0:
				case 11:
				case 15:
					el(8, t, t.return), Jl(t);
					break;
				case 22:
					n = t.stateNode, n._visibility & 2 && (n._visibility &= -3, Jl(t));
					break;
				default: Jl(t);
			}
			e = e.sibling;
		}
	}
	function Yl(e, t) {
		for (; gl !== null;) {
			var n = gl;
			switch (n.tag) {
				case 0:
				case 11:
				case 15:
					el(8, n, t);
					break;
				case 23:
				case 22:
					if (n.memoizedState !== null && n.memoizedState.cachePool !== null) {
						var i = n.memoizedState.cachePool.pool;
						i != null && i.refCount++;
					}
					break;
				case 24: _a(n.memoizedState.cache);
			}
			if (i = n.child, i !== null) i.return = n, gl = i;
			else a: for (n = e; gl !== null;) {
				i = gl;
				var a = i.sibling, o = i.return;
				if (yl(i), i === n) {
					gl = null;
					break a;
				}
				if (a !== null) {
					a.return = o, gl = a;
					break a;
				}
				gl = o;
			}
		}
	}
	var Xl = {
		getCacheForType: function(e) {
			var t = q(ha), n = t.data.get(e);
			return n === void 0 && (n = e(), t.data.set(e, n)), n;
		},
		cacheSignal: function() {
			return q(ha).controller.signal;
		}
	}, Zl = typeof WeakMap == "function" ? WeakMap : Map, Ql = 0, $l = null, eu = null, tu = 0, nu = 0, ru = null, iu = !1, au = !1, ou = !1, su = 0, cu = 0, lu = 0, uu = 0, du = 0, fu = 0, pu = 0, mu = null, hu = null, gu = !1, _u = 0, vu = 0, yu = Infinity, bu = null, xu = null, Su = 0, Cu = null, wu = null, Tu = 0, Eu = 0, Du = null, Ou = null, ku = 0, Au = null;
	function ju() {
		return Ql & 2 && tu !== 0 ? tu & -tu : L.T === null ? et() : Ad();
	}
	function Mu() {
		if (fu === 0) if (!(tu & 536870912) || Ui) {
			var e = Ve;
			Ve <<= 1, !(Ve & 3932160) && (Ve = 262144), fu = e;
		} else fu = 536870912;
		return e = co.current, e !== null && (e.flags |= 32), fu;
	}
	function Nu(e, t, n) {
		(e === $l && (nu === 2 || nu === 9) || e.cancelPendingCommit !== null) && (Bu(e, 0), Lu(e, tu, fu, !1)), Je(e, n), (!(Ql & 2) || e !== $l) && (e === $l && (!(Ql & 2) && (uu |= n), cu === 4 && Lu(e, tu, fu, !1)), Sd(e));
	}
	function Pu(e, t, n) {
		if (Ql & 6) throw Error(a(327));
		var i = !n && (t & 127) == 0 && (t & e.expiredLanes) === 0 || W(e, t), o = i ? Ju(e, t) : Ku(e, t, !0), s = i;
		do {
			if (o === 0) {
				au && !i && Lu(e, t, 0, !1);
				break;
			} else {
				if (n = e.current.alternate, s && !Iu(n)) {
					o = Ku(e, t, !1), s = !1;
					continue;
				}
				if (o === 2) {
					if (s = t, e.errorRecoveryDisabledLanes & s) var c = 0;
					else c = e.pendingLanes & -536870913, c = c === 0 ? c & 536870912 ? 536870912 : 0 : c;
					if (c !== 0) {
						t = c;
						a: {
							var l = e;
							o = mu;
							var u = l.current.memoizedState.isDehydrated;
							if (u && (Bu(l, c).flags |= 256), c = Ku(l, c, !1), c !== 2) {
								if (ou && !u) {
									l.errorRecoveryDisabledLanes |= s, uu |= s, o = 4;
									break a;
								}
								s = hu, hu = o, s !== null && (hu === null ? hu = s : hu.push.apply(hu, s));
							}
							o = c;
						}
						if (s = !1, o !== 2) continue;
					}
				}
				if (o === 1) {
					Bu(e, 0), Lu(e, t, 0, !0);
					break;
				}
				a: {
					switch (i = e, s = o, s) {
						case 0:
						case 1: throw Error(a(345));
						case 4: if ((t & 4194048) !== t) break;
						case 6:
							Lu(i, t, fu, !iu);
							break a;
						case 2:
							hu = null;
							break;
						case 3:
						case 5: break;
						default: throw Error(a(329));
					}
					if ((t & 62914560) === t && (o = _u + 300 - Te(), 10 < o)) {
						if (Lu(i, t, fu, !iu), We(i, 0, !0) !== 0) break a;
						Tu = t, i.timeoutHandle = _f(Fu.bind(null, i, n, hu, bu, gu, t, fu, uu, pu, iu, s, "Throttled", -0, 0), o);
						break a;
					}
					Fu(i, n, hu, bu, gu, t, fu, uu, pu, iu, s, null, -0, 0);
				}
			}
			break;
		} while (1);
		Sd(e);
	}
	function Fu(e, t, n, i, a, o, s, c, l, u, d, f, p, m) {
		if (e.timeoutHandle = -1, f = t.subtreeFlags, f & 8192 || (f & 16785408) == 16785408) {
			f = {
				stylesheets: null,
				count: 0,
				imgCount: 0,
				imgBytes: 0,
				suspenseyImages: [],
				waitingForImages: !0,
				waitingForViewTransition: !1,
				unsuspend: Xt
			}, Wl(t, o, f);
			var h = (o & 62914560) === o ? _u - Te() : (o & 4194048) === o ? vu - Te() : 0;
			if (h = gp(f, h), h !== null) {
				Tu = o, e.cancelPendingCommit = h(td.bind(null, e, t, o, n, i, a, s, c, l, d, f, null, p, m)), Lu(e, o, s, !u);
				return;
			}
		}
		td(e, t, o, n, i, a, s, c, l);
	}
	function Iu(e) {
		for (var t = e;;) {
			var n = t.tag;
			if ((n === 0 || n === 11 || n === 15) && t.flags & 16384 && (n = t.updateQueue, n !== null && (n = n.stores, n !== null))) for (var i = 0; i < n.length; i++) {
				var a = n[i], o = a.getSnapshot;
				a = a.value;
				try {
					if (!Ar(o(), a)) return !1;
				} catch {
					return !1;
				}
			}
			if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n;
			else {
				if (t === e) break;
				for (; t.sibling === null;) {
					if (t.return === null || t.return === e) return !0;
					t = t.return;
				}
				t.sibling.return = t.return, t = t.sibling;
			}
		}
		return !0;
	}
	function Lu(e, t, n, i) {
		t &= ~du, t &= ~uu, e.suspendedLanes |= t, e.pingedLanes &= ~t, i && (e.warmLanes |= t), i = e.expirationTimes;
		for (var a = t; 0 < a;) {
			var o = 31 - Ie(a), s = 1 << o;
			i[o] = -1, a &= ~s;
		}
		n !== 0 && Ye(e, n, t);
	}
	function Ru() {
		return Ql & 6 ? !0 : (Cd(0, !1), !1);
	}
	function zu() {
		if (eu !== null) {
			if (nu === 0) var e = eu.return;
			else e = eu, na = ta = null, Lo(e), za = null, Ba = 0, e = eu;
			for (; e !== null;) Qc(e.alternate, e), e = e.return;
			eu = null;
		}
	}
	function Bu(e, t) {
		var n = e.timeoutHandle;
		n !== -1 && (e.timeoutHandle = -1, vf(n)), n = e.cancelPendingCommit, n !== null && (e.cancelPendingCommit = null, n()), Tu = 0, zu(), $l = e, eu = n = vi(e.current, null), tu = t, nu = 0, ru = null, iu = !1, au = W(e, t), ou = !1, pu = fu = du = uu = lu = cu = 0, hu = mu = null, gu = !1, t & 8 && (t |= t & 32);
		var i = e.entangledLanes;
		if (i !== 0) for (e = e.entanglements, i &= t; 0 < i;) {
			var a = 31 - Ie(i), o = 1 << a;
			t |= e[a], i &= ~o;
		}
		return su = t, ci(), n;
	}
	function Vu(e, t) {
		yo = null, L.H = Ys, t === ka || t === ja ? (t = La(), nu = 3) : t === Aa ? (t = La(), nu = 4) : nu = t === pc ? 8 : typeof t == "object" && t && typeof t.then == "function" ? 6 : 1, ru = t, eu === null && (cu = 1, sc(e, Ei(t, e.current)));
	}
	function Hu() {
		var e = co.current;
		return e === null ? !0 : (tu & 4194048) === tu ? lo === null : (tu & 62914560) === tu || tu & 536870912 ? e === lo : !1;
	}
	function Uu() {
		var e = L.H;
		return L.H = Ys, e === null ? Ys : e;
	}
	function Wu() {
		var e = L.A;
		return L.A = Xl, e;
	}
	function Gu() {
		cu = 4, iu || (tu & 4194048) !== tu && co.current !== null || (au = !0), !(lu & 134217727) && !(uu & 134217727) || $l === null || Lu($l, tu, fu, !1);
	}
	function Ku(e, t, n) {
		var i = Ql;
		Ql |= 2;
		var a = Uu(), o = Wu();
		($l !== e || tu !== t) && (bu = null, Bu(e, t)), t = !1;
		var s = cu;
		a: do
			try {
				if (nu !== 0 && eu !== null) {
					var c = eu, l = ru;
					switch (nu) {
						case 8:
							zu(), s = 6;
							break a;
						case 3:
						case 2:
						case 9:
						case 6:
							co.current === null && (t = !0);
							var u = nu;
							if (nu = 0, ru = null, Qu(e, c, l, u), n && au) {
								s = 0;
								break a;
							}
							break;
						default: u = nu, nu = 0, ru = null, Qu(e, c, l, u);
					}
				}
				qu(), s = cu;
				break;
			} catch (t) {
				Vu(e, t);
			}
		while (1);
		return t && e.shellSuspendCounter++, na = ta = null, Ql = i, L.H = a, L.A = o, eu === null && ($l = null, tu = 0, ci()), s;
	}
	function qu() {
		for (; eu !== null;) Xu(eu);
	}
	function Ju(e, t) {
		var n = Ql;
		Ql |= 2;
		var i = Uu(), o = Wu();
		$l !== e || tu !== t ? (bu = null, yu = Te() + 500, Bu(e, t)) : au = W(e, t);
		a: do
			try {
				if (nu !== 0 && eu !== null) {
					t = eu;
					var s = ru;
					b: switch (nu) {
						case 1:
							nu = 0, ru = null, Qu(e, t, s, 1);
							break;
						case 2:
						case 9:
							if (Na(s)) {
								nu = 0, ru = null, Zu(t);
								break;
							}
							t = function() {
								nu !== 2 && nu !== 9 || $l !== e || (nu = 7), Sd(e);
							}, s.then(t, t);
							break a;
						case 3:
							nu = 7;
							break a;
						case 4:
							nu = 5;
							break a;
						case 7:
							Na(s) ? (nu = 0, ru = null, Zu(t)) : (nu = 0, ru = null, Qu(e, t, s, 7));
							break;
						case 5:
							var c = null;
							switch (eu.tag) {
								case 26: c = eu.memoizedState;
								case 5:
								case 27:
									var l = eu;
									if (c ? pp(c) : l.stateNode.complete) {
										nu = 0, ru = null;
										var u = l.sibling;
										if (u !== null) eu = u;
										else {
											var d = l.return;
											d === null ? eu = null : (eu = d, $u(d));
										}
										break b;
									}
							}
							nu = 0, ru = null, Qu(e, t, s, 5);
							break;
						case 6:
							nu = 0, ru = null, Qu(e, t, s, 6);
							break;
						case 8:
							zu(), cu = 6;
							break a;
						default: throw Error(a(462));
					}
				}
				Yu();
				break;
			} catch (t) {
				Vu(e, t);
			}
		while (1);
		return na = ta = null, L.H = i, L.A = o, Ql = n, eu === null ? ($l = null, tu = 0, ci(), cu) : 0;
	}
	function Yu() {
		for (; eu !== null && !Ce();) Xu(eu);
	}
	function Xu(e) {
		var t = Uc(e.alternate, e, su);
		e.memoizedProps = e.pendingProps, t === null ? $u(e) : eu = t;
	}
	function Zu(e) {
		var t = e, n = t.alternate;
		switch (t.tag) {
			case 15:
			case 0:
				t = Dc(n, t, t.pendingProps, t.type, void 0, tu);
				break;
			case 11:
				t = Dc(n, t, t.pendingProps, t.type.render, t.ref, tu);
				break;
			case 5: Lo(t);
			default: Qc(n, t), t = eu = yi(t, su), t = Uc(n, t, su);
		}
		e.memoizedProps = e.pendingProps, t === null ? $u(e) : eu = t;
	}
	function Qu(e, t, n, i) {
		na = ta = null, Lo(t), za = null, Ba = 0;
		var a = t.return;
		try {
			if (fc(e, a, t, n, tu)) {
				cu = 1, sc(e, Ei(n, e.current)), eu = null;
				return;
			}
		} catch (t) {
			if (a !== null) throw eu = a, t;
			cu = 1, sc(e, Ei(n, e.current)), eu = null;
			return;
		}
		t.flags & 32768 ? (Ui || i === 1 ? e = !0 : au || tu & 536870912 ? e = !1 : (iu = e = !0, (i === 2 || i === 9 || i === 3 || i === 6) && (i = co.current, i !== null && i.tag === 13 && (i.flags |= 16384))), ed(t, e)) : $u(t);
	}
	function $u(e) {
		var t = e;
		do {
			if (t.flags & 32768) {
				ed(t, iu);
				return;
			}
			e = t.return;
			var n = Xc(t.alternate, t, su);
			if (n !== null) {
				eu = n;
				return;
			}
			if (t = t.sibling, t !== null) {
				eu = t;
				return;
			}
			eu = t = e;
		} while (t !== null);
		cu === 0 && (cu = 5);
	}
	function ed(e, t) {
		do {
			var n = Zc(e.alternate, e);
			if (n !== null) {
				n.flags &= 32767, eu = n;
				return;
			}
			if (n = e.return, n !== null && (n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null), !t && (e = e.sibling, e !== null)) {
				eu = e;
				return;
			}
			eu = e = n;
		} while (e !== null);
		cu = 6, eu = null;
	}
	function td(e, t, n, i, o, s, c, l, u) {
		e.cancelPendingCommit = null;
		do
			od();
		while (Su !== 0);
		if (Ql & 6) throw Error(a(327));
		if (t !== null) {
			if (t === e.current) throw Error(a(177));
			if (s = t.lanes | t.childLanes, s |= si, G(e, n, s, c, l, u), e === $l && (eu = $l = null, tu = 0), wu = t, Cu = e, Tu = n, Eu = s, Du = o, Ou = i, t.subtreeFlags & 10256 || t.flags & 10256 ? (e.callbackNode = null, e.callbackPriority = 0, hd(ke, function() {
				return sd(), null;
			})) : (e.callbackNode = null, e.callbackPriority = 0), i = (t.flags & 13878) != 0, t.subtreeFlags & 13878 || i) {
				i = L.T, L.T = null, o = R.p, R.p = 2, c = Ql, Ql |= 4;
				try {
					_l(e, t, n);
				} finally {
					Ql = c, R.p = o, L.T = i;
				}
			}
			Su = 1, nd(), rd(), id();
		}
	}
	function nd() {
		if (Su === 1) {
			Su = 0;
			var e = Cu, t = wu, n = (t.flags & 13878) != 0;
			if (t.subtreeFlags & 13878 || n) {
				n = L.T, L.T = null;
				var i = R.p;
				R.p = 2;
				var a = Ql;
				Ql |= 4;
				try {
					Al(t, e);
					var o = uf, s = Fr(e.containerInfo), c = o.focusedElem, l = o.selectionRange;
					if (s !== c && c && c.ownerDocument && Pr(c.ownerDocument.documentElement, c)) {
						if (l !== null && Ir(c)) {
							var u = l.start, d = l.end;
							if (d === void 0 && (d = u), "selectionStart" in c) c.selectionStart = u, c.selectionEnd = Math.min(d, c.value.length);
							else {
								var f = c.ownerDocument || document, p = f && f.defaultView || window;
								if (p.getSelection) {
									var m = p.getSelection(), h = c.textContent.length, g = Math.min(l.start, h), _ = l.end === void 0 ? g : Math.min(l.end, h);
									!m.extend && g > _ && (s = _, _ = g, g = s);
									var v = Nr(c, g), y = Nr(c, _);
									if (v && y && (m.rangeCount !== 1 || m.anchorNode !== v.node || m.anchorOffset !== v.offset || m.focusNode !== y.node || m.focusOffset !== y.offset)) {
										var b = f.createRange();
										b.setStart(v.node, v.offset), m.removeAllRanges(), g > _ ? (m.addRange(b), m.extend(y.node, y.offset)) : (b.setEnd(y.node, y.offset), m.addRange(b));
									}
								}
							}
						}
						for (f = [], m = c; m = m.parentNode;) m.nodeType === 1 && f.push({
							element: m,
							left: m.scrollLeft,
							top: m.scrollTop
						});
						for (typeof c.focus == "function" && c.focus(), c = 0; c < f.length; c++) {
							var x = f[c];
							x.element.scrollLeft = x.left, x.element.scrollTop = x.top;
						}
					}
					Ap = !!lf, uf = lf = null;
				} finally {
					Ql = a, R.p = i, L.T = n;
				}
			}
			e.current = t, Su = 2;
		}
	}
	function rd() {
		if (Su === 2) {
			Su = 0;
			var e = Cu, t = wu, n = (t.flags & 8772) != 0;
			if (t.subtreeFlags & 8772 || n) {
				n = L.T, L.T = null;
				var i = R.p;
				R.p = 2;
				var a = Ql;
				Ql |= 4;
				try {
					vl(e, t.alternate, t);
				} finally {
					Ql = a, R.p = i, L.T = n;
				}
			}
			Su = 3;
		}
	}
	function id() {
		if (Su === 4 || Su === 3) {
			Su = 0, we();
			var e = Cu, t = wu, n = Tu, i = Ou;
			t.subtreeFlags & 10256 || t.flags & 10256 ? Su = 5 : (Su = 0, wu = Cu = null, ad(e, e.pendingLanes));
			var a = e.pendingLanes;
			if (a === 0 && (xu = null), $e(n), t = t.stateNode, Pe && typeof Pe.onCommitFiberRoot == "function") try {
				Pe.onCommitFiberRoot(U, t, void 0, (t.current.flags & 128) == 128);
			} catch {}
			if (i !== null) {
				t = L.T, a = R.p, R.p = 2, L.T = null;
				try {
					for (var o = e.onRecoverableError, s = 0; s < i.length; s++) {
						var c = i[s];
						o(c.value, { componentStack: c.stack });
					}
				} finally {
					L.T = t, R.p = a;
				}
			}
			Tu & 3 && od(), Sd(e), a = e.pendingLanes, n & 261930 && a & 42 ? e === Au ? ku++ : (ku = 0, Au = e) : ku = 0, Cd(0, !1);
		}
	}
	function ad(e, t) {
		(e.pooledCacheLanes &= t) === 0 && (t = e.pooledCache, t != null && (e.pooledCache = null, _a(t)));
	}
	function od() {
		return nd(), rd(), id(), sd();
	}
	function sd() {
		if (Su !== 5) return !1;
		var e = Cu, t = Eu;
		Eu = 0;
		var n = $e(Tu), i = L.T, o = R.p;
		try {
			R.p = 32 > n ? 32 : n, L.T = null, n = Du, Du = null;
			var s = Cu, c = Tu;
			if (Su = 0, wu = Cu = null, Tu = 0, Ql & 6) throw Error(a(331));
			var l = Ql;
			if (Ql |= 4, ql(s.current), zl(s, s.current, c, n), Ql = l, Cd(0, !1), Pe && typeof Pe.onPostCommitFiberRoot == "function") try {
				Pe.onPostCommitFiberRoot(U, s);
			} catch {}
			return !0;
		} finally {
			R.p = o, L.T = i, ad(e, t);
		}
	}
	function cd(e, t, n) {
		t = Ei(n, t), t = lc(e.stateNode, t, 2), e = Ya(e, t, 2), e !== null && (Je(e, 2), Sd(e));
	}
	function ld(e, t, n) {
		if (e.tag === 3) cd(e, e, n);
		else for (; t !== null;) {
			if (t.tag === 3) {
				cd(t, e, n);
				break;
			} else if (t.tag === 1) {
				var i = t.stateNode;
				if (typeof t.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (xu === null || !xu.has(i))) {
					e = Ei(n, e), n = uc(2), i = Ya(t, n, 2), i !== null && (dc(n, i, t, e), Je(i, 2), Sd(i));
					break;
				}
			}
			t = t.return;
		}
	}
	function ud(e, t, n) {
		var i = e.pingCache;
		if (i === null) {
			i = e.pingCache = new Zl();
			var a = /* @__PURE__ */ new Set();
			i.set(t, a);
		} else a = i.get(t), a === void 0 && (a = /* @__PURE__ */ new Set(), i.set(t, a));
		a.has(n) || (ou = !0, a.add(n), e = dd.bind(null, e, t, n), t.then(e, e));
	}
	function dd(e, t, n) {
		var i = e.pingCache;
		i !== null && i.delete(t), e.pingedLanes |= e.suspendedLanes & n, e.warmLanes &= ~n, $l === e && (tu & n) === n && (cu === 4 || cu === 3 && (tu & 62914560) === tu && 300 > Te() - _u ? !(Ql & 2) && Bu(e, 0) : du |= n, pu === tu && (pu = 0)), Sd(e);
	}
	function fd(e, t) {
		t === 0 && (t = Ke()), e = di(e, t), e !== null && (Je(e, t), Sd(e));
	}
	function pd(e) {
		var t = e.memoizedState, n = 0;
		t !== null && (n = t.retryLane), fd(e, n);
	}
	function md(e, t) {
		var n = 0;
		switch (e.tag) {
			case 31:
			case 13:
				var i = e.stateNode, o = e.memoizedState;
				o !== null && (n = o.retryLane);
				break;
			case 19:
				i = e.stateNode;
				break;
			case 22:
				i = e.stateNode._retryCache;
				break;
			default: throw Error(a(314));
		}
		i !== null && i.delete(t), fd(e, n);
	}
	function hd(e, t) {
		return xe(e, t);
	}
	var gd = null, _d = null, vd = !1, yd = !1, bd = !1, xd = 0;
	function Sd(e) {
		e !== _d && e.next === null && (_d === null ? gd = _d = e : _d = _d.next = e), yd = !0, vd || (vd = !0, kd());
	}
	function Cd(e, t) {
		if (!bd && yd) {
			bd = !0;
			do
				for (var n = !1, i = gd; i !== null;) {
					if (!t) if (e !== 0) {
						var a = i.pendingLanes;
						if (a === 0) var o = 0;
						else {
							var s = i.suspendedLanes, c = i.pingedLanes;
							o = (1 << 31 - Ie(42 | e) + 1) - 1, o &= a & ~(s & ~c), o = o & 201326741 ? o & 201326741 | 1 : o ? o | 2 : 0;
						}
						o !== 0 && (n = !0, Od(i, o));
					} else o = tu, o = We(i, i === $l ? o : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1), !(o & 3) || W(i, o) || (n = !0, Od(i, o));
					i = i.next;
				}
			while (n);
			bd = !1;
		}
	}
	function wd() {
		Td();
	}
	function Td() {
		yd = vd = !1;
		var e = 0;
		xd !== 0 && gf() && (e = xd);
		for (var t = Te(), n = null, i = gd; i !== null;) {
			var a = i.next, o = Ed(i, t);
			o === 0 ? (i.next = null, n === null ? gd = a : n.next = a, a === null && (_d = n)) : (n = i, (e !== 0 || o & 3) && (yd = !0)), i = a;
		}
		Su !== 0 && Su !== 5 || Cd(e, !1), xd !== 0 && (xd = 0);
	}
	function Ed(e, t) {
		for (var n = e.suspendedLanes, i = e.pingedLanes, a = e.expirationTimes, o = e.pendingLanes & -62914561; 0 < o;) {
			var s = 31 - Ie(o), c = 1 << s, l = a[s];
			l === -1 ? ((c & n) === 0 || (c & i) !== 0) && (a[s] = Ge(c, t)) : l <= t && (e.expiredLanes |= c), o &= ~c;
		}
		if (t = $l, n = tu, n = We(e, e === t ? n : 0, e.cancelPendingCommit !== null || e.timeoutHandle !== -1), i = e.callbackNode, n === 0 || e === t && (nu === 2 || nu === 9) || e.cancelPendingCommit !== null) return i !== null && i !== null && Se(i), e.callbackNode = null, e.callbackPriority = 0;
		if (!(n & 3) || W(e, n)) {
			if (t = n & -n, t === e.callbackPriority) return t;
			switch (i !== null && Se(i), $e(n)) {
				case 2:
				case 8:
					n = Oe;
					break;
				case 32:
					n = ke;
					break;
				case 268435456:
					n = je;
					break;
				default: n = ke;
			}
			return i = Dd.bind(null, e), n = xe(n, i), e.callbackPriority = t, e.callbackNode = n, t;
		}
		return i !== null && i !== null && Se(i), e.callbackPriority = 2, e.callbackNode = null, 2;
	}
	function Dd(e, t) {
		if (Su !== 0 && Su !== 5) return e.callbackNode = null, e.callbackPriority = 0, null;
		var n = e.callbackNode;
		if (od() && e.callbackNode !== n) return null;
		var i = tu;
		return i = We(e, e === $l ? i : 0, e.cancelPendingCommit !== null || e.timeoutHandle !== -1), i === 0 ? null : (Pu(e, i, t), Ed(e, Te()), e.callbackNode != null && e.callbackNode === n ? Dd.bind(null, e) : null);
	}
	function Od(e, t) {
		if (od()) return null;
		Pu(e, t, !0);
	}
	function kd() {
		bf(function() {
			Ql & 6 ? xe(De, wd) : Td();
		});
	}
	function Ad() {
		if (xd === 0) {
			var e = ya;
			e === 0 && (e = Be, Be <<= 1, !(Be & 261888) && (Be = 256)), xd = e;
		}
		return xd;
	}
	function jd(e) {
		return e == null || typeof e == "symbol" || typeof e == "boolean" ? null : typeof e == "function" ? e : Yt("" + e);
	}
	function Md(e, t) {
		var n = t.ownerDocument.createElement("input");
		return n.name = t.name, n.value = t.value, e.id && n.setAttribute("form", e.id), t.parentNode.insertBefore(n, t), e = new FormData(e), n.parentNode.removeChild(n), e;
	}
	function Nd(e, t, n, i, a) {
		if (t === "submit" && n && n.stateNode === a) {
			var o = jd((a[it] || null).action), s = i.submitter;
			s && (t = (t = s[it] || null) ? jd(t.formAction) : s.getAttribute("formAction"), t !== null && (o = t, s = null));
			var c = new vn("action", "action", null, i, a);
			e.push({
				event: c,
				listeners: [{
					instance: null,
					listener: function() {
						if (i.defaultPrevented) {
							if (xd !== 0) {
								var e = s ? Md(a, s) : new FormData(a);
								Fs(n, {
									pending: !0,
									data: e,
									method: a.method,
									action: o
								}, null, e);
							}
						} else typeof o == "function" && (c.preventDefault(), e = s ? Md(a, s) : new FormData(a), Fs(n, {
							pending: !0,
							data: e,
							method: a.method,
							action: o
						}, o, e));
					},
					currentTarget: a
				}]
			});
		}
	}
	for (var Pd = 0; Pd < ni.length; Pd++) {
		var Fd = ni[Pd], Id = Fd.toLowerCase(), Ld = Fd[0].toUpperCase() + Fd.slice(1);
		ri(Id, "on" + Ld);
	}
	ri(Jr, "onAnimationEnd"), ri(Yr, "onAnimationIteration"), ri(Xr, "onAnimationStart"), ri("dblclick", "onDoubleClick"), ri("focusin", "onFocus"), ri("focusout", "onBlur"), ri(Zr, "onTransitionRun"), ri(Qr, "onTransitionStart"), ri($r, "onTransitionCancel"), ri(ei, "onTransitionEnd"), bt("onMouseEnter", ["mouseout", "mouseover"]), bt("onMouseLeave", ["mouseout", "mouseover"]), bt("onPointerEnter", ["pointerout", "pointerover"]), bt("onPointerLeave", ["pointerout", "pointerover"]), yt("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), yt("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), yt("onBeforeInput", [
		"compositionend",
		"keypress",
		"textInput",
		"paste"
	]), yt("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), yt("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), yt("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
	var Rd = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), zd = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Rd));
	function Bd(e, t) {
		t = (t & 4) != 0;
		for (var n = 0; n < e.length; n++) {
			var i = e[n], a = i.event;
			i = i.listeners;
			a: {
				var o = void 0;
				if (t) for (var s = i.length - 1; 0 <= s; s--) {
					var c = i[s], l = c.instance, u = c.currentTarget;
					if (c = c.listener, l !== o && a.isPropagationStopped()) break a;
					o = c, a.currentTarget = u;
					try {
						o(a);
					} catch (e) {
						ii(e);
					}
					a.currentTarget = null, o = l;
				}
				else for (s = 0; s < i.length; s++) {
					if (c = i[s], l = c.instance, u = c.currentTarget, c = c.listener, l !== o && a.isPropagationStopped()) break a;
					o = c, a.currentTarget = u;
					try {
						o(a);
					} catch (e) {
						ii(e);
					}
					a.currentTarget = null, o = l;
				}
			}
		}
	}
	function Vd(e, t) {
		var n = t[ot];
		n === void 0 && (n = t[ot] = /* @__PURE__ */ new Set());
		var i = e + "__bubble";
		n.has(i) || (Gd(t, e, 2, !1), n.add(i));
	}
	function Hd(e, t, n) {
		var i = 0;
		t && (i |= 4), Gd(n, e, i, t);
	}
	var Ud = "_reactListening" + Math.random().toString(36).slice(2);
	function Wd(e) {
		if (!e[Ud]) {
			e[Ud] = !0, _t.forEach(function(t) {
				t !== "selectionchange" && (zd.has(t) || Hd(t, !1, e), Hd(t, !0, e));
			});
			var t = e.nodeType === 9 ? e : e.ownerDocument;
			t === null || t[Ud] || (t[Ud] = !0, Hd("selectionchange", !1, t));
		}
	}
	function Gd(e, t, n, i) {
		switch (Lp(t)) {
			case 2:
				var a = jp;
				break;
			case 8:
				a = Mp;
				break;
			default: a = Np;
		}
		n = a.bind(null, t, n, e), a = void 0, !on || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (a = !0), i ? a === void 0 ? e.addEventListener(t, n, !0) : e.addEventListener(t, n, {
			capture: !0,
			passive: a
		}) : a === void 0 ? e.addEventListener(t, n, !1) : e.addEventListener(t, n, { passive: a });
	}
	function Kd(e, t, n, i, a) {
		var o = i;
		if (!(t & 1) && !(t & 2) && i !== null) a: for (;;) {
			if (i === null) return;
			var c = i.tag;
			if (c === 3 || c === 4) {
				var l = i.stateNode.containerInfo;
				if (l === a) break;
				if (c === 4) for (c = i.return; c !== null;) {
					var u = c.tag;
					if ((u === 3 || u === 4) && c.stateNode.containerInfo === a) return;
					c = c.return;
				}
				for (; l !== null;) {
					if (c = ft(l), c === null) return;
					if (u = c.tag, u === 5 || u === 6 || u === 26 || u === 27) {
						i = o = c;
						continue a;
					}
					l = l.parentNode;
				}
			}
			i = i.return;
		}
		nn(function() {
			var i = o, a = Qt(n), c = [];
			a: {
				var l = ti.get(e);
				if (l !== void 0) {
					var u = vn, d = e;
					switch (e) {
						case "keypress": if (pn(n) === 0) break a;
						case "keydown":
						case "keyup":
							u = Hn;
							break;
						case "focusin":
							d = "focus", u = kn;
							break;
						case "focusout":
							d = "blur", u = kn;
							break;
						case "beforeblur":
						case "afterblur":
							u = kn;
							break;
						case "click": if (n.button === 2) break a;
						case "auxclick":
						case "dblclick":
						case "mousedown":
						case "mousemove":
						case "mouseup":
						case "mouseout":
						case "mouseover":
						case "contextmenu":
							u = Tn;
							break;
						case "drag":
						case "dragend":
						case "dragenter":
						case "dragexit":
						case "dragleave":
						case "dragover":
						case "dragstart":
						case "drop":
							u = Dn;
							break;
						case "touchcancel":
						case "touchend":
						case "touchmove":
						case "touchstart":
							u = Kn;
							break;
						case Jr:
						case Yr:
						case Xr:
							u = jn;
							break;
						case ei:
							u = Jn;
							break;
						case "scroll":
						case "scrollend":
							u = bn;
							break;
						case "wheel":
							u = Xn;
							break;
						case "copy":
						case "cut":
						case "paste":
							u = Nn;
							break;
						case "gotpointercapture":
						case "lostpointercapture":
						case "pointercancel":
						case "pointerdown":
						case "pointermove":
						case "pointerout":
						case "pointerover":
						case "pointerup":
							u = Wn;
							break;
						case "toggle":
						case "beforetoggle": u = Qn;
					}
					var f = (t & 4) != 0, p = !f && (e === "scroll" || e === "scrollend"), m = f ? l === null ? null : l + "Capture" : l;
					f = [];
					for (var h = i, g; h !== null;) {
						var _ = h;
						if (g = _.stateNode, _ = _.tag, _ !== 5 && _ !== 26 && _ !== 27 || g === null || m === null || (_ = rn(h, m), _ != null && f.push(qd(h, _, g))), p) break;
						h = h.return;
					}
					0 < f.length && (l = new u(l, d, null, n, a), c.push({
						event: l,
						listeners: f
					}));
				}
			}
			if (!(t & 7)) {
				a: {
					if (l = e === "mouseover" || e === "pointerover", u = e === "mouseout" || e === "pointerout", l && n !== Zt && (d = n.relatedTarget || n.fromElement) && (ft(d) || d[at])) break a;
					if ((u || l) && (l = a.window === a ? a : (l = a.ownerDocument) ? l.defaultView || l.parentWindow : window, u ? (d = n.relatedTarget || n.toElement, u = i, d = d ? ft(d) : null, d !== null && (p = s(d), f = d.tag, d !== p || f !== 5 && f !== 27 && f !== 6) && (d = null)) : (u = null, d = i), u !== d)) {
						if (f = Tn, _ = "onMouseLeave", m = "onMouseEnter", h = "mouse", (e === "pointerout" || e === "pointerover") && (f = Wn, _ = "onPointerLeave", m = "onPointerEnter", h = "pointer"), p = u == null ? l : mt(u), g = d == null ? l : mt(d), l = new f(_, h + "leave", u, n, a), l.target = p, l.relatedTarget = g, _ = null, ft(a) === i && (f = new f(m, h + "enter", d, n, a), f.target = g, f.relatedTarget = p, _ = f), p = _, u && d) b: {
							for (f = Yd, m = u, h = d, g = 0, _ = m; _; _ = f(_)) g++;
							_ = 0;
							for (var v = h; v; v = f(v)) _++;
							for (; 0 < g - _;) m = f(m), g--;
							for (; 0 < _ - g;) h = f(h), _--;
							for (; g--;) {
								if (m === h || h !== null && m === h.alternate) {
									f = m;
									break b;
								}
								m = f(m), h = f(h);
							}
							f = null;
						}
						else f = null;
						u !== null && Xd(c, l, u, f, !1), d !== null && p !== null && Xd(c, p, d, f, !0);
					}
				}
				a: {
					if (l = i ? mt(i) : window, u = l.nodeName && l.nodeName.toLowerCase(), u === "select" || u === "input" && l.type === "file") var y = vr;
					else if (fr(l)) if (yr) y = Or;
					else {
						y = Er;
						var b = Tr;
					}
					else u = l.nodeName, !u || u.toLowerCase() !== "input" || l.type !== "checkbox" && l.type !== "radio" ? i && Kt(i.elementType) && (y = vr) : y = Dr;
					if (y &&= y(e, i)) {
						pr(c, y, n, a);
						break a;
					}
					b && b(e, l, i), e === "focusout" && i && l.type === "number" && i.memoizedProps.value != null && Rt(l, "number", l.value);
				}
				switch (b = i ? mt(i) : window, e) {
					case "focusin":
						(fr(b) || b.contentEditable === "true") && (Rr = b, zr = i, Br = null);
						break;
					case "focusout":
						Br = zr = Rr = null;
						break;
					case "mousedown":
						Vr = !0;
						break;
					case "contextmenu":
					case "mouseup":
					case "dragend":
						Vr = !1, Hr(c, n, a);
						break;
					case "selectionchange": if (Lr) break;
					case "keydown":
					case "keyup": Hr(c, n, a);
				}
				var x;
				if (er) b: {
					switch (e) {
						case "compositionstart":
							var S = "onCompositionStart";
							break b;
						case "compositionend":
							S = "onCompositionEnd";
							break b;
						case "compositionupdate":
							S = "onCompositionUpdate";
							break b;
					}
					S = void 0;
				}
				else cr ? or(e, n) && (S = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (S = "onCompositionStart");
				S && (rr && n.locale !== "ko" && (cr || S !== "onCompositionStart" ? S === "onCompositionEnd" && cr && (x = fn()) : (ln = a, un = "value" in ln ? ln.value : ln.textContent, cr = !0)), b = Jd(i, S), 0 < b.length && (S = new Fn(S, e, null, n, a), c.push({
					event: S,
					listeners: b
				}), x ? S.data = x : (x = sr(n), x !== null && (S.data = x)))), (x = nr ? lr(e, n) : ur(e, n)) && (S = Jd(i, "onBeforeInput"), 0 < S.length && (b = new Fn("onBeforeInput", "beforeinput", null, n, a), c.push({
					event: b,
					listeners: S
				}), b.data = x)), Nd(c, e, i, n, a);
			}
			Bd(c, t);
		});
	}
	function qd(e, t, n) {
		return {
			instance: e,
			listener: t,
			currentTarget: n
		};
	}
	function Jd(e, t) {
		for (var n = t + "Capture", i = []; e !== null;) {
			var a = e, o = a.stateNode;
			if (a = a.tag, a !== 5 && a !== 26 && a !== 27 || o === null || (a = rn(e, n), a != null && i.unshift(qd(e, a, o)), a = rn(e, t), a != null && i.push(qd(e, a, o))), e.tag === 3) return i;
			e = e.return;
		}
		return [];
	}
	function Yd(e) {
		if (e === null) return null;
		do
			e = e.return;
		while (e && e.tag !== 5 && e.tag !== 27);
		return e || null;
	}
	function Xd(e, t, n, i, a) {
		for (var o = t._reactName, s = []; n !== null && n !== i;) {
			var c = n, l = c.alternate, u = c.stateNode;
			if (c = c.tag, l !== null && l === i) break;
			c !== 5 && c !== 26 && c !== 27 || u === null || (l = u, a ? (u = rn(n, o), u != null && s.unshift(qd(n, u, l))) : a || (u = rn(n, o), u != null && s.push(qd(n, u, l)))), n = n.return;
		}
		s.length !== 0 && e.push({
			event: t,
			listeners: s
		});
	}
	var Zd = /\r\n?/g, Qd = /\u0000|\uFFFD/g;
	function $d(e) {
		return (typeof e == "string" ? e : "" + e).replace(Zd, "\n").replace(Qd, "");
	}
	function ef(e, t) {
		return t = $d(t), $d(e) === t;
	}
	function tf(e, t, n, i, o, s) {
		switch (n) {
			case "children":
				typeof i == "string" ? t === "body" || t === "textarea" && i === "" || Ht(e, i) : (typeof i == "number" || typeof i == "bigint") && t !== "body" && Ht(e, "" + i);
				break;
			case "className":
				Et(e, "class", i);
				break;
			case "tabIndex":
				Et(e, "tabindex", i);
				break;
			case "dir":
			case "role":
			case "viewBox":
			case "width":
			case "height":
				Et(e, n, i);
				break;
			case "style":
				Gt(e, i, s);
				break;
			case "data": if (t !== "object") {
				Et(e, "data", i);
				break;
			}
			case "src":
			case "href":
				if (i === "" && (t !== "a" || n !== "href")) {
					e.removeAttribute(n);
					break;
				}
				if (i == null || typeof i == "function" || typeof i == "symbol" || typeof i == "boolean") {
					e.removeAttribute(n);
					break;
				}
				i = Yt("" + i), e.setAttribute(n, i);
				break;
			case "action":
			case "formAction":
				if (typeof i == "function") {
					e.setAttribute(n, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
					break;
				} else typeof s == "function" && (n === "formAction" ? (t !== "input" && tf(e, t, "name", o.name, o, null), tf(e, t, "formEncType", o.formEncType, o, null), tf(e, t, "formMethod", o.formMethod, o, null), tf(e, t, "formTarget", o.formTarget, o, null)) : (tf(e, t, "encType", o.encType, o, null), tf(e, t, "method", o.method, o, null), tf(e, t, "target", o.target, o, null)));
				if (i == null || typeof i == "symbol" || typeof i == "boolean") {
					e.removeAttribute(n);
					break;
				}
				i = Yt("" + i), e.setAttribute(n, i);
				break;
			case "onClick":
				i != null && (e.onclick = Xt);
				break;
			case "onScroll":
				i != null && Vd("scroll", e);
				break;
			case "onScrollEnd":
				i != null && Vd("scrollend", e);
				break;
			case "dangerouslySetInnerHTML":
				if (i != null) {
					if (typeof i != "object" || !("__html" in i)) throw Error(a(61));
					if (n = i.__html, n != null) {
						if (o.children != null) throw Error(a(60));
						e.innerHTML = n;
					}
				}
				break;
			case "multiple":
				e.multiple = i && typeof i != "function" && typeof i != "symbol";
				break;
			case "muted":
				e.muted = i && typeof i != "function" && typeof i != "symbol";
				break;
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "defaultValue":
			case "defaultChecked":
			case "innerHTML":
			case "ref": break;
			case "autoFocus": break;
			case "xlinkHref":
				if (i == null || typeof i == "function" || typeof i == "boolean" || typeof i == "symbol") {
					e.removeAttribute("xlink:href");
					break;
				}
				n = Yt("" + i), e.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", n);
				break;
			case "contentEditable":
			case "spellCheck":
			case "draggable":
			case "value":
			case "autoReverse":
			case "externalResourcesRequired":
			case "focusable":
			case "preserveAlpha":
				i != null && typeof i != "function" && typeof i != "symbol" ? e.setAttribute(n, "" + i) : e.removeAttribute(n);
				break;
			case "inert":
			case "allowFullScreen":
			case "async":
			case "autoPlay":
			case "controls":
			case "default":
			case "defer":
			case "disabled":
			case "disablePictureInPicture":
			case "disableRemotePlayback":
			case "formNoValidate":
			case "hidden":
			case "loop":
			case "noModule":
			case "noValidate":
			case "open":
			case "playsInline":
			case "readOnly":
			case "required":
			case "reversed":
			case "scoped":
			case "seamless":
			case "itemScope":
				i && typeof i != "function" && typeof i != "symbol" ? e.setAttribute(n, "") : e.removeAttribute(n);
				break;
			case "capture":
			case "download":
				!0 === i ? e.setAttribute(n, "") : !1 !== i && i != null && typeof i != "function" && typeof i != "symbol" ? e.setAttribute(n, i) : e.removeAttribute(n);
				break;
			case "cols":
			case "rows":
			case "size":
			case "span":
				i != null && typeof i != "function" && typeof i != "symbol" && !isNaN(i) && 1 <= i ? e.setAttribute(n, i) : e.removeAttribute(n);
				break;
			case "rowSpan":
			case "start":
				i == null || typeof i == "function" || typeof i == "symbol" || isNaN(i) ? e.removeAttribute(n) : e.setAttribute(n, i);
				break;
			case "popover":
				Vd("beforetoggle", e), Vd("toggle", e), Tt(e, "popover", i);
				break;
			case "xlinkActuate":
				Dt(e, "http://www.w3.org/1999/xlink", "xlink:actuate", i);
				break;
			case "xlinkArcrole":
				Dt(e, "http://www.w3.org/1999/xlink", "xlink:arcrole", i);
				break;
			case "xlinkRole":
				Dt(e, "http://www.w3.org/1999/xlink", "xlink:role", i);
				break;
			case "xlinkShow":
				Dt(e, "http://www.w3.org/1999/xlink", "xlink:show", i);
				break;
			case "xlinkTitle":
				Dt(e, "http://www.w3.org/1999/xlink", "xlink:title", i);
				break;
			case "xlinkType":
				Dt(e, "http://www.w3.org/1999/xlink", "xlink:type", i);
				break;
			case "xmlBase":
				Dt(e, "http://www.w3.org/XML/1998/namespace", "xml:base", i);
				break;
			case "xmlLang":
				Dt(e, "http://www.w3.org/XML/1998/namespace", "xml:lang", i);
				break;
			case "xmlSpace":
				Dt(e, "http://www.w3.org/XML/1998/namespace", "xml:space", i);
				break;
			case "is":
				Tt(e, "is", i);
				break;
			case "innerText":
			case "textContent": break;
			default: (!(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (n = qt.get(n) || n, Tt(e, n, i));
		}
	}
	function nf(e, t, n, i, o, s) {
		switch (n) {
			case "style":
				Gt(e, i, s);
				break;
			case "dangerouslySetInnerHTML":
				if (i != null) {
					if (typeof i != "object" || !("__html" in i)) throw Error(a(61));
					if (n = i.__html, n != null) {
						if (o.children != null) throw Error(a(60));
						e.innerHTML = n;
					}
				}
				break;
			case "children":
				typeof i == "string" ? Ht(e, i) : (typeof i == "number" || typeof i == "bigint") && Ht(e, "" + i);
				break;
			case "onScroll":
				i != null && Vd("scroll", e);
				break;
			case "onScrollEnd":
				i != null && Vd("scrollend", e);
				break;
			case "onClick":
				i != null && (e.onclick = Xt);
				break;
			case "suppressContentEditableWarning":
			case "suppressHydrationWarning":
			case "innerHTML":
			case "ref": break;
			case "innerText":
			case "textContent": break;
			default: if (!vt.hasOwnProperty(n)) a: {
				if (n[0] === "o" && n[1] === "n" && (o = n.endsWith("Capture"), t = n.slice(2, o ? n.length - 7 : void 0), s = e[it] || null, s = s == null ? null : s[n], typeof s == "function" && e.removeEventListener(t, s, o), typeof i == "function")) {
					typeof s != "function" && s !== null && (n in e ? e[n] = null : e.hasAttribute(n) && e.removeAttribute(n)), e.addEventListener(t, i, o);
					break a;
				}
				n in e ? e[n] = i : !0 === i ? e.setAttribute(n, "") : Tt(e, n, i);
			}
		}
	}
	function rf(e, t, n) {
		switch (t) {
			case "div":
			case "span":
			case "svg":
			case "path":
			case "a":
			case "g":
			case "p":
			case "li": break;
			case "img":
				Vd("error", e), Vd("load", e);
				var i = !1, o = !1, s;
				for (s in n) if (n.hasOwnProperty(s)) {
					var c = n[s];
					if (c != null) switch (s) {
						case "src":
							i = !0;
							break;
						case "srcSet":
							o = !0;
							break;
						case "children":
						case "dangerouslySetInnerHTML": throw Error(a(137, t));
						default: tf(e, t, s, c, n, null);
					}
				}
				o && tf(e, t, "srcSet", n.srcSet, n, null), i && tf(e, t, "src", n.src, n, null);
				return;
			case "input":
				Vd("invalid", e);
				var l = s = c = o = null, u = null, d = null;
				for (i in n) if (n.hasOwnProperty(i)) {
					var f = n[i];
					if (f != null) switch (i) {
						case "name":
							o = f;
							break;
						case "type":
							c = f;
							break;
						case "checked":
							u = f;
							break;
						case "defaultChecked":
							d = f;
							break;
						case "value":
							s = f;
							break;
						case "defaultValue":
							l = f;
							break;
						case "children":
						case "dangerouslySetInnerHTML":
							if (f != null) throw Error(a(137, t));
							break;
						default: tf(e, t, i, f, n, null);
					}
				}
				Lt(e, s, l, u, d, c, o, !1);
				return;
			case "select":
				for (o in Vd("invalid", e), i = c = s = null, n) if (n.hasOwnProperty(o) && (l = n[o], l != null)) switch (o) {
					case "value":
						s = l;
						break;
					case "defaultValue":
						c = l;
						break;
					case "multiple": i = l;
					default: tf(e, t, o, l, n, null);
				}
				t = s, n = c, e.multiple = !!i, t == null ? n != null && zt(e, !!i, n, !0) : zt(e, !!i, t, !1);
				return;
			case "textarea":
				for (c in Vd("invalid", e), s = o = i = null, n) if (n.hasOwnProperty(c) && (l = n[c], l != null)) switch (c) {
					case "value":
						i = l;
						break;
					case "defaultValue":
						o = l;
						break;
					case "children":
						s = l;
						break;
					case "dangerouslySetInnerHTML":
						if (l != null) throw Error(a(91));
						break;
					default: tf(e, t, c, l, n, null);
				}
				Vt(e, i, o, s);
				return;
			case "option":
				for (u in n) if (n.hasOwnProperty(u) && (i = n[u], i != null)) switch (u) {
					case "selected":
						e.selected = i && typeof i != "function" && typeof i != "symbol";
						break;
					default: tf(e, t, u, i, n, null);
				}
				return;
			case "dialog":
				Vd("beforetoggle", e), Vd("toggle", e), Vd("cancel", e), Vd("close", e);
				break;
			case "iframe":
			case "object":
				Vd("load", e);
				break;
			case "video":
			case "audio":
				for (i = 0; i < Rd.length; i++) Vd(Rd[i], e);
				break;
			case "image":
				Vd("error", e), Vd("load", e);
				break;
			case "details":
				Vd("toggle", e);
				break;
			case "embed":
			case "source":
			case "link": Vd("error", e), Vd("load", e);
			case "area":
			case "base":
			case "br":
			case "col":
			case "hr":
			case "keygen":
			case "meta":
			case "param":
			case "track":
			case "wbr":
			case "menuitem":
				for (d in n) if (n.hasOwnProperty(d) && (i = n[d], i != null)) switch (d) {
					case "children":
					case "dangerouslySetInnerHTML": throw Error(a(137, t));
					default: tf(e, t, d, i, n, null);
				}
				return;
			default: if (Kt(t)) {
				for (f in n) n.hasOwnProperty(f) && (i = n[f], i !== void 0 && nf(e, t, f, i, n, void 0));
				return;
			}
		}
		for (l in n) n.hasOwnProperty(l) && (i = n[l], i != null && tf(e, t, l, i, n, null));
	}
	function af(e, t, n, i) {
		switch (t) {
			case "div":
			case "span":
			case "svg":
			case "path":
			case "a":
			case "g":
			case "p":
			case "li": break;
			case "input":
				var o = null, s = null, c = null, l = null, u = null, d = null, f = null;
				for (h in n) {
					var p = n[h];
					if (n.hasOwnProperty(h) && p != null) switch (h) {
						case "checked": break;
						case "value": break;
						case "defaultValue": u = p;
						default: i.hasOwnProperty(h) || tf(e, t, h, null, i, p);
					}
				}
				for (var m in i) {
					var h = i[m];
					if (p = n[m], i.hasOwnProperty(m) && (h != null || p != null)) switch (m) {
						case "type":
							s = h;
							break;
						case "name":
							o = h;
							break;
						case "checked":
							d = h;
							break;
						case "defaultChecked":
							f = h;
							break;
						case "value":
							c = h;
							break;
						case "defaultValue":
							l = h;
							break;
						case "children":
						case "dangerouslySetInnerHTML":
							if (h != null) throw Error(a(137, t));
							break;
						default: h !== p && tf(e, t, m, h, i, p);
					}
				}
				It(e, c, l, u, d, f, s, o);
				return;
			case "select":
				for (s in h = c = l = m = null, n) if (u = n[s], n.hasOwnProperty(s) && u != null) switch (s) {
					case "value": break;
					case "multiple": h = u;
					default: i.hasOwnProperty(s) || tf(e, t, s, null, i, u);
				}
				for (o in i) if (s = i[o], u = n[o], i.hasOwnProperty(o) && (s != null || u != null)) switch (o) {
					case "value":
						m = s;
						break;
					case "defaultValue":
						l = s;
						break;
					case "multiple": c = s;
					default: s !== u && tf(e, t, o, s, i, u);
				}
				t = l, n = c, i = h, m == null ? !!i != !!n && (t == null ? zt(e, !!n, n ? [] : "", !1) : zt(e, !!n, t, !0)) : zt(e, !!n, m, !1);
				return;
			case "textarea":
				for (l in h = m = null, n) if (o = n[l], n.hasOwnProperty(l) && o != null && !i.hasOwnProperty(l)) switch (l) {
					case "value": break;
					case "children": break;
					default: tf(e, t, l, null, i, o);
				}
				for (c in i) if (o = i[c], s = n[c], i.hasOwnProperty(c) && (o != null || s != null)) switch (c) {
					case "value":
						m = o;
						break;
					case "defaultValue":
						h = o;
						break;
					case "children": break;
					case "dangerouslySetInnerHTML":
						if (o != null) throw Error(a(91));
						break;
					default: o !== s && tf(e, t, c, o, i, s);
				}
				Bt(e, m, h);
				return;
			case "option":
				for (var g in n) if (m = n[g], n.hasOwnProperty(g) && m != null && !i.hasOwnProperty(g)) switch (g) {
					case "selected":
						e.selected = !1;
						break;
					default: tf(e, t, g, null, i, m);
				}
				for (u in i) if (m = i[u], h = n[u], i.hasOwnProperty(u) && m !== h && (m != null || h != null)) switch (u) {
					case "selected":
						e.selected = m && typeof m != "function" && typeof m != "symbol";
						break;
					default: tf(e, t, u, m, i, h);
				}
				return;
			case "img":
			case "link":
			case "area":
			case "base":
			case "br":
			case "col":
			case "embed":
			case "hr":
			case "keygen":
			case "meta":
			case "param":
			case "source":
			case "track":
			case "wbr":
			case "menuitem":
				for (var _ in n) m = n[_], n.hasOwnProperty(_) && m != null && !i.hasOwnProperty(_) && tf(e, t, _, null, i, m);
				for (d in i) if (m = i[d], h = n[d], i.hasOwnProperty(d) && m !== h && (m != null || h != null)) switch (d) {
					case "children":
					case "dangerouslySetInnerHTML":
						if (m != null) throw Error(a(137, t));
						break;
					default: tf(e, t, d, m, i, h);
				}
				return;
			default: if (Kt(t)) {
				for (var v in n) m = n[v], n.hasOwnProperty(v) && m !== void 0 && !i.hasOwnProperty(v) && nf(e, t, v, void 0, i, m);
				for (f in i) m = i[f], h = n[f], !i.hasOwnProperty(f) || m === h || m === void 0 && h === void 0 || nf(e, t, f, m, i, h);
				return;
			}
		}
		for (var y in n) m = n[y], n.hasOwnProperty(y) && m != null && !i.hasOwnProperty(y) && tf(e, t, y, null, i, m);
		for (p in i) m = i[p], h = n[p], !i.hasOwnProperty(p) || m === h || m == null && h == null || tf(e, t, p, m, i, h);
	}
	function sf(e) {
		switch (e) {
			case "css":
			case "script":
			case "font":
			case "img":
			case "image":
			case "input":
			case "link": return !0;
			default: return !1;
		}
	}
	function cf() {
		if (typeof performance.getEntriesByType == "function") {
			for (var e = 0, t = 0, n = performance.getEntriesByType("resource"), i = 0; i < n.length; i++) {
				var a = n[i], o = a.transferSize, s = a.initiatorType, c = a.duration;
				if (o && c && sf(s)) {
					for (s = 0, c = a.responseEnd, i += 1; i < n.length; i++) {
						var l = n[i], u = l.startTime;
						if (u > c) break;
						var d = l.transferSize, f = l.initiatorType;
						d && sf(f) && (l = l.responseEnd, s += d * (l < c ? 1 : (c - u) / (l - u)));
					}
					if (--i, t += 8 * (o + s) / (a.duration / 1e3), e++, 10 < e) break;
				}
			}
			if (0 < e) return t / e / 1e6;
		}
		return navigator.connection && (e = navigator.connection.downlink, typeof e == "number") ? e : 5;
	}
	var lf = null, uf = null;
	function df(e) {
		return e.nodeType === 9 ? e : e.ownerDocument;
	}
	function ff(e) {
		switch (e) {
			case "http://www.w3.org/2000/svg": return 1;
			case "http://www.w3.org/1998/Math/MathML": return 2;
			default: return 0;
		}
	}
	function pf(e, t) {
		if (e === 0) switch (t) {
			case "svg": return 1;
			case "math": return 2;
			default: return 0;
		}
		return e === 1 && t === "foreignObject" ? 0 : e;
	}
	function mf(e, t) {
		return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.children == "bigint" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
	}
	var hf = null;
	function gf() {
		var e = window.event;
		return e && e.type === "popstate" ? e === hf ? !1 : (hf = e, !0) : (hf = null, !1);
	}
	var _f = typeof setTimeout == "function" ? setTimeout : void 0, vf = typeof clearTimeout == "function" ? clearTimeout : void 0, yf = typeof Promise == "function" ? Promise : void 0, bf = typeof queueMicrotask == "function" ? queueMicrotask : yf === void 0 ? _f : function(e) {
		return yf.resolve(null).then(e).catch(xf);
	};
	function xf(e) {
		setTimeout(function() {
			throw e;
		});
	}
	function Sf(e) {
		return e === "head";
	}
	function Cf(e, t) {
		var n = t, i = 0;
		do {
			var a = n.nextSibling;
			if (e.removeChild(n), a && a.nodeType === 8) if (n = a.data, n === "/$" || n === "/&") {
				if (i === 0) {
					e.removeChild(a), nm(t);
					return;
				}
				i--;
			} else if (n === "$" || n === "$?" || n === "$~" || n === "$!" || n === "&") i++;
			else if (n === "html") Lf(e.ownerDocument.documentElement);
			else if (n === "head") {
				n = e.ownerDocument.head, Lf(n);
				for (var o = n.firstChild; o;) {
					var s = o.nextSibling, c = o.nodeName;
					o[ut] || c === "SCRIPT" || c === "STYLE" || c === "LINK" && o.rel.toLowerCase() === "stylesheet" || n.removeChild(o), o = s;
				}
			} else n === "body" && Lf(e.ownerDocument.body);
			n = a;
		} while (n);
		nm(t);
	}
	function wf(e, t) {
		var n = e;
		e = 0;
		do {
			var i = n.nextSibling;
			if (n.nodeType === 1 ? t ? (n._stashedDisplay = n.style.display, n.style.display = "none") : (n.style.display = n._stashedDisplay || "", n.getAttribute("style") === "" && n.removeAttribute("style")) : n.nodeType === 3 && (t ? (n._stashedText = n.nodeValue, n.nodeValue = "") : n.nodeValue = n._stashedText || ""), i && i.nodeType === 8) if (n = i.data, n === "/$") {
				if (e === 0) break;
				e--;
			} else n !== "$" && n !== "$?" && n !== "$~" && n !== "$!" || e++;
			n = i;
		} while (n);
	}
	function Tf(e) {
		var t = e.firstChild;
		for (t && t.nodeType === 10 && (t = t.nextSibling); t;) {
			var n = t;
			switch (t = t.nextSibling, n.nodeName) {
				case "HTML":
				case "HEAD":
				case "BODY":
					Tf(n), dt(n);
					continue;
				case "SCRIPT":
				case "STYLE": continue;
				case "LINK": if (n.rel.toLowerCase() === "stylesheet") continue;
			}
			e.removeChild(n);
		}
	}
	function Ef(e, t, n, i) {
		for (; e.nodeType === 1;) {
			var a = n;
			if (e.nodeName.toLowerCase() !== t.toLowerCase()) {
				if (!i && (e.nodeName !== "INPUT" || e.type !== "hidden")) break;
			} else if (i) {
				if (!e[ut]) switch (t) {
					case "meta":
						if (!e.hasAttribute("itemprop")) break;
						return e;
					case "link":
						if (o = e.getAttribute("rel"), o === "stylesheet" && e.hasAttribute("data-precedence") || o !== a.rel || e.getAttribute("href") !== (a.href == null || a.href === "" ? null : a.href) || e.getAttribute("crossorigin") !== (a.crossOrigin == null ? null : a.crossOrigin) || e.getAttribute("title") !== (a.title == null ? null : a.title)) break;
						return e;
					case "style":
						if (e.hasAttribute("data-precedence")) break;
						return e;
					case "script":
						if (o = e.getAttribute("src"), (o !== (a.src == null ? null : a.src) || e.getAttribute("type") !== (a.type == null ? null : a.type) || e.getAttribute("crossorigin") !== (a.crossOrigin == null ? null : a.crossOrigin)) && o && e.hasAttribute("async") && !e.hasAttribute("itemprop")) break;
						return e;
					default: return e;
				}
			} else if (t === "input" && e.type === "hidden") {
				var o = a.name == null ? null : "" + a.name;
				if (a.type === "hidden" && e.getAttribute("name") === o) return e;
			} else return e;
			if (e = Mf(e.nextSibling), e === null) break;
		}
		return null;
	}
	function Df(e, t, n) {
		if (t === "") return null;
		for (; e.nodeType !== 3;) if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !n || (e = Mf(e.nextSibling), e === null)) return null;
		return e;
	}
	function Of(e, t) {
		for (; e.nodeType !== 8;) if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !t || (e = Mf(e.nextSibling), e === null)) return null;
		return e;
	}
	function kf(e) {
		return e.data === "$?" || e.data === "$~";
	}
	function Af(e) {
		return e.data === "$!" || e.data === "$?" && e.ownerDocument.readyState !== "loading";
	}
	function jf(e, t) {
		var n = e.ownerDocument;
		if (e.data === "$~") e._reactRetry = t;
		else if (e.data !== "$?" || n.readyState !== "loading") t();
		else {
			var i = function() {
				t(), n.removeEventListener("DOMContentLoaded", i);
			};
			n.addEventListener("DOMContentLoaded", i), e._reactRetry = i;
		}
	}
	function Mf(e) {
		for (; e != null; e = e.nextSibling) {
			var t = e.nodeType;
			if (t === 1 || t === 3) break;
			if (t === 8) {
				if (t = e.data, t === "$" || t === "$!" || t === "$?" || t === "$~" || t === "&" || t === "F!" || t === "F") break;
				if (t === "/$" || t === "/&") return null;
			}
		}
		return e;
	}
	var Nf = null;
	function Pf(e) {
		e = e.nextSibling;
		for (var t = 0; e;) {
			if (e.nodeType === 8) {
				var n = e.data;
				if (n === "/$" || n === "/&") {
					if (t === 0) return Mf(e.nextSibling);
					t--;
				} else n !== "$" && n !== "$!" && n !== "$?" && n !== "$~" && n !== "&" || t++;
			}
			e = e.nextSibling;
		}
		return null;
	}
	function Ff(e) {
		e = e.previousSibling;
		for (var t = 0; e;) {
			if (e.nodeType === 8) {
				var n = e.data;
				if (n === "$" || n === "$!" || n === "$?" || n === "$~" || n === "&") {
					if (t === 0) return e;
					t--;
				} else n !== "/$" && n !== "/&" || t++;
			}
			e = e.previousSibling;
		}
		return null;
	}
	function If(e, t, n) {
		switch (t = df(n), e) {
			case "html":
				if (e = t.documentElement, !e) throw Error(a(452));
				return e;
			case "head":
				if (e = t.head, !e) throw Error(a(453));
				return e;
			case "body":
				if (e = t.body, !e) throw Error(a(454));
				return e;
			default: throw Error(a(451));
		}
	}
	function Lf(e) {
		for (var t = e.attributes; t.length;) e.removeAttributeNode(t[0]);
		dt(e);
	}
	var Rf = /* @__PURE__ */ new Map(), zf = /* @__PURE__ */ new Set();
	function Bf(e) {
		return typeof e.getRootNode == "function" ? e.getRootNode() : e.nodeType === 9 ? e : e.ownerDocument;
	}
	var Vf = R.d;
	R.d = {
		f: Hf,
		r: Uf,
		D: Q,
		C: Kf,
		L: qf,
		m: Jf,
		X: Xf,
		S: Yf,
		M: Zf
	};
	function Hf() {
		var e = Vf.f(), t = Ru();
		return e || t;
	}
	function Uf(e) {
		var t = pt(e);
		t !== null && t.tag === 5 && t.type === "form" ? Ls(t) : Vf.r(e);
	}
	var Wf = typeof document > "u" ? null : document;
	function Gf(e, t, n) {
		var i = Wf;
		if (i && typeof t == "string" && t) {
			var a = Ft(t);
			a = "link[rel=\"" + e + "\"][href=\"" + a + "\"]", typeof n == "string" && (a += "[crossorigin=\"" + n + "\"]"), zf.has(a) || (zf.add(a), e = {
				rel: e,
				crossOrigin: n,
				href: t
			}, i.querySelector(a) === null && (t = i.createElement("link"), rf(t, "link", e), gt(t), i.head.appendChild(t)));
		}
	}
	function Q(e) {
		Vf.D(e), Gf("dns-prefetch", e, null);
	}
	function Kf(e, t) {
		Vf.C(e, t), Gf("preconnect", e, t);
	}
	function qf(e, t, n) {
		Vf.L(e, t, n);
		var i = Wf;
		if (i && e && t) {
			var a = "link[rel=\"preload\"][as=\"" + Ft(t) + "\"]";
			t === "image" && n && n.imageSrcSet ? (a += "[imagesrcset=\"" + Ft(n.imageSrcSet) + "\"]", typeof n.imageSizes == "string" && (a += "[imagesizes=\"" + Ft(n.imageSizes) + "\"]")) : a += "[href=\"" + Ft(e) + "\"]";
			var o = a;
			switch (t) {
				case "style":
					o = $f(e);
					break;
				case "script": o = rp(e);
			}
			Rf.has(o) || (e = m({
				rel: "preload",
				href: t === "image" && n && n.imageSrcSet ? void 0 : e,
				as: t
			}, n), Rf.set(o, e), i.querySelector(a) !== null || t === "style" && i.querySelector(ep(o)) || t === "script" && i.querySelector(ip(o)) || (t = i.createElement("link"), rf(t, "link", e), gt(t), i.head.appendChild(t)));
		}
	}
	function Jf(e, t) {
		Vf.m(e, t);
		var n = Wf;
		if (n && e) {
			var i = t && typeof t.as == "string" ? t.as : "script", a = "link[rel=\"modulepreload\"][as=\"" + Ft(i) + "\"][href=\"" + Ft(e) + "\"]", o = a;
			switch (i) {
				case "audioworklet":
				case "paintworklet":
				case "serviceworker":
				case "sharedworker":
				case "worker":
				case "script": o = rp(e);
			}
			if (!Rf.has(o) && (e = m({
				rel: "modulepreload",
				href: e
			}, t), Rf.set(o, e), n.querySelector(a) === null)) {
				switch (i) {
					case "audioworklet":
					case "paintworklet":
					case "serviceworker":
					case "sharedworker":
					case "worker":
					case "script": if (n.querySelector(ip(o))) return;
				}
				i = n.createElement("link"), rf(i, "link", e), gt(i), n.head.appendChild(i);
			}
		}
	}
	function Yf(e, t, n) {
		Vf.S(e, t, n);
		var i = Wf;
		if (i && e) {
			var a = ht(i).hoistableStyles, o = $f(e);
			t ||= "default";
			var s = a.get(o);
			if (!s) {
				var c = {
					loading: 0,
					preload: null
				};
				if (s = i.querySelector(ep(o))) c.loading = 5;
				else {
					e = m({
						rel: "stylesheet",
						href: e,
						"data-precedence": t
					}, n), (n = Rf.get(o)) && sp(e, n);
					var l = s = i.createElement("link");
					gt(l), rf(l, "link", e), l._p = new Promise(function(e, t) {
						l.onload = e, l.onerror = t;
					}), l.addEventListener("load", function() {
						c.loading |= 1;
					}), l.addEventListener("error", function() {
						c.loading |= 2;
					}), c.loading |= 4, op(s, t, i);
				}
				s = {
					type: "stylesheet",
					instance: s,
					count: 1,
					state: c
				}, a.set(o, s);
			}
		}
	}
	function Xf(e, t) {
		Vf.X(e, t);
		var n = Wf;
		if (n && e) {
			var i = ht(n).hoistableScripts, a = rp(e), o = i.get(a);
			o || (o = n.querySelector(ip(a)), o || (e = m({
				src: e,
				async: !0
			}, t), (t = Rf.get(a)) && cp(e, t), o = n.createElement("script"), gt(o), rf(o, "link", e), n.head.appendChild(o)), o = {
				type: "script",
				instance: o,
				count: 1,
				state: null
			}, i.set(a, o));
		}
	}
	function Zf(e, t) {
		Vf.M(e, t);
		var n = Wf;
		if (n && e) {
			var i = ht(n).hoistableScripts, a = rp(e), o = i.get(a);
			o || (o = n.querySelector(ip(a)), o || (e = m({
				src: e,
				async: !0,
				type: "module"
			}, t), (t = Rf.get(a)) && cp(e, t), o = n.createElement("script"), gt(o), rf(o, "link", e), n.head.appendChild(o)), o = {
				type: "script",
				instance: o,
				count: 1,
				state: null
			}, i.set(a, o));
		}
	}
	function Qf(e, t, n, i) {
		var o = (o = le.current) ? Bf(o) : null;
		if (!o) throw Error(a(446));
		switch (e) {
			case "meta":
			case "title": return null;
			case "style": return typeof n.precedence == "string" && typeof n.href == "string" ? (t = $f(n.href), n = ht(o).hoistableStyles, i = n.get(t), i || (i = {
				type: "style",
				instance: null,
				count: 0,
				state: null
			}, n.set(t, i)), i) : {
				type: "void",
				instance: null,
				count: 0,
				state: null
			};
			case "link":
				if (n.rel === "stylesheet" && typeof n.href == "string" && typeof n.precedence == "string") {
					e = $f(n.href);
					var s = ht(o).hoistableStyles, c = s.get(e);
					if (c || (o = o.ownerDocument || o, c = {
						type: "stylesheet",
						instance: null,
						count: 0,
						state: {
							loading: 0,
							preload: null
						}
					}, s.set(e, c), (s = o.querySelector(ep(e))) && !s._p && (c.instance = s, c.state.loading = 5), Rf.has(e) || (n = {
						rel: "preload",
						as: "style",
						href: n.href,
						crossOrigin: n.crossOrigin,
						integrity: n.integrity,
						media: n.media,
						hrefLang: n.hrefLang,
						referrerPolicy: n.referrerPolicy
					}, Rf.set(e, n), s || np(o, e, n, c.state))), t && i === null) throw Error(a(528, ""));
					return c;
				}
				if (t && i !== null) throw Error(a(529, ""));
				return null;
			case "script": return t = n.async, n = n.src, typeof n == "string" && t && typeof t != "function" && typeof t != "symbol" ? (t = rp(n), n = ht(o).hoistableScripts, i = n.get(t), i || (i = {
				type: "script",
				instance: null,
				count: 0,
				state: null
			}, n.set(t, i)), i) : {
				type: "void",
				instance: null,
				count: 0,
				state: null
			};
			default: throw Error(a(444, e));
		}
	}
	function $f(e) {
		return "href=\"" + Ft(e) + "\"";
	}
	function ep(e) {
		return "link[rel=\"stylesheet\"][" + e + "]";
	}
	function tp(e) {
		return m({}, e, {
			"data-precedence": e.precedence,
			precedence: null
		});
	}
	function np(e, t, n, i) {
		e.querySelector("link[rel=\"preload\"][as=\"style\"][" + t + "]") ? i.loading = 1 : (t = e.createElement("link"), i.preload = t, t.addEventListener("load", function() {
			return i.loading |= 1;
		}), t.addEventListener("error", function() {
			return i.loading |= 2;
		}), rf(t, "link", n), gt(t), e.head.appendChild(t));
	}
	function rp(e) {
		return "[src=\"" + Ft(e) + "\"]";
	}
	function ip(e) {
		return "script[async]" + e;
	}
	function ap(e, t, n) {
		if (t.count++, t.instance === null) switch (t.type) {
			case "style":
				var i = e.querySelector("style[data-href~=\"" + Ft(n.href) + "\"]");
				if (i) return t.instance = i, gt(i), i;
				var o = m({}, n, {
					"data-href": n.href,
					"data-precedence": n.precedence,
					href: null,
					precedence: null
				});
				return i = (e.ownerDocument || e).createElement("style"), gt(i), rf(i, "style", o), op(i, n.precedence, e), t.instance = i;
			case "stylesheet":
				o = $f(n.href);
				var s = e.querySelector(ep(o));
				if (s) return t.state.loading |= 4, t.instance = s, gt(s), s;
				i = tp(n), (o = Rf.get(o)) && sp(i, o), s = (e.ownerDocument || e).createElement("link"), gt(s);
				var c = s;
				return c._p = new Promise(function(e, t) {
					c.onload = e, c.onerror = t;
				}), rf(s, "link", i), t.state.loading |= 4, op(s, n.precedence, e), t.instance = s;
			case "script": return s = rp(n.src), (o = e.querySelector(ip(s))) ? (t.instance = o, gt(o), o) : (i = n, (o = Rf.get(s)) && (i = m({}, n), cp(i, o)), e = e.ownerDocument || e, o = e.createElement("script"), gt(o), rf(o, "link", i), e.head.appendChild(o), t.instance = o);
			case "void": return null;
			default: throw Error(a(443, t.type));
		}
		else t.type === "stylesheet" && !(t.state.loading & 4) && (i = t.instance, t.state.loading |= 4, op(i, n.precedence, e));
		return t.instance;
	}
	function op(e, t, n) {
		for (var i = n.querySelectorAll("link[rel=\"stylesheet\"][data-precedence],style[data-precedence]"), a = i.length ? i[i.length - 1] : null, o = a, s = 0; s < i.length; s++) {
			var c = i[s];
			if (c.dataset.precedence === t) o = c;
			else if (o !== a) break;
		}
		o ? o.parentNode.insertBefore(e, o.nextSibling) : (t = n.nodeType === 9 ? n.head : n, t.insertBefore(e, t.firstChild));
	}
	function sp(e, t) {
		e.crossOrigin ??= t.crossOrigin, e.referrerPolicy ??= t.referrerPolicy, e.title ??= t.title;
	}
	function cp(e, t) {
		e.crossOrigin ??= t.crossOrigin, e.referrerPolicy ??= t.referrerPolicy, e.integrity ??= t.integrity;
	}
	var lp = null;
	function up(e, t, n) {
		if (lp === null) {
			var i = /* @__PURE__ */ new Map(), a = lp = /* @__PURE__ */ new Map();
			a.set(n, i);
		} else a = lp, i = a.get(n), i || (i = /* @__PURE__ */ new Map(), a.set(n, i));
		if (i.has(e)) return i;
		for (i.set(e, null), n = n.getElementsByTagName(e), a = 0; a < n.length; a++) {
			var o = n[a];
			if (!(o[ut] || o[rt] || e === "link" && o.getAttribute("rel") === "stylesheet") && o.namespaceURI !== "http://www.w3.org/2000/svg") {
				var s = o.getAttribute(t) || "";
				s = e + s;
				var c = i.get(s);
				c ? c.push(o) : i.set(s, [o]);
			}
		}
		return i;
	}
	function dp(e, t, n) {
		e = e.ownerDocument || e, e.head.insertBefore(n, t === "title" ? e.querySelector("head > title") : null);
	}
	function fp(e, t, n) {
		if (n === 1 || t.itemProp != null) return !1;
		switch (e) {
			case "meta":
			case "title": return !0;
			case "style":
				if (typeof t.precedence != "string" || typeof t.href != "string" || t.href === "") break;
				return !0;
			case "link":
				if (typeof t.rel != "string" || typeof t.href != "string" || t.href === "" || t.onLoad || t.onError) break;
				switch (t.rel) {
					case "stylesheet": return e = t.disabled, typeof t.precedence == "string" && e == null;
					default: return !0;
				}
			case "script": if (t.async && typeof t.async != "function" && typeof t.async != "symbol" && !t.onLoad && !t.onError && t.src && typeof t.src == "string") return !0;
		}
		return !1;
	}
	function pp(e) {
		return !(e.type === "stylesheet" && !(e.state.loading & 3));
	}
	function mp(e, t, n, i) {
		if (n.type === "stylesheet" && (typeof i.media != "string" || !1 !== matchMedia(i.media).matches) && !(n.state.loading & 4)) {
			if (n.instance === null) {
				var a = $f(i.href), o = t.querySelector(ep(a));
				if (o) {
					t = o._p, typeof t == "object" && t && typeof t.then == "function" && (e.count++, e = _p.bind(e), t.then(e, e)), n.state.loading |= 4, n.instance = o, gt(o);
					return;
				}
				o = t.ownerDocument || t, i = tp(i), (a = Rf.get(a)) && sp(i, a), o = o.createElement("link"), gt(o);
				var s = o;
				s._p = new Promise(function(e, t) {
					s.onload = e, s.onerror = t;
				}), rf(o, "link", i), n.instance = o;
			}
			e.stylesheets === null && (e.stylesheets = /* @__PURE__ */ new Map()), e.stylesheets.set(n, t), (t = n.state.preload) && !(n.state.loading & 3) && (e.count++, n = _p.bind(e), t.addEventListener("load", n), t.addEventListener("error", n));
		}
	}
	var hp = 0;
	function gp(e, t) {
		return e.stylesheets && e.count === 0 && yp(e, e.stylesheets), 0 < e.count || 0 < e.imgCount ? function(n) {
			var i = setTimeout(function() {
				if (e.stylesheets && yp(e, e.stylesheets), e.unsuspend) {
					var t = e.unsuspend;
					e.unsuspend = null, t();
				}
			}, 6e4 + t);
			0 < e.imgBytes && hp === 0 && (hp = 62500 * cf());
			var a = setTimeout(function() {
				if (e.waitingForImages = !1, e.count === 0 && (e.stylesheets && yp(e, e.stylesheets), e.unsuspend)) {
					var t = e.unsuspend;
					e.unsuspend = null, t();
				}
			}, (e.imgBytes > hp ? 50 : 800) + t);
			return e.unsuspend = n, function() {
				e.unsuspend = null, clearTimeout(i), clearTimeout(a);
			};
		} : null;
	}
	function _p() {
		if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
			if (this.stylesheets) yp(this, this.stylesheets);
			else if (this.unsuspend) {
				var e = this.unsuspend;
				this.unsuspend = null, e();
			}
		}
	}
	var vp = null;
	function yp(e, t) {
		e.stylesheets = null, e.unsuspend !== null && (e.count++, vp = /* @__PURE__ */ new Map(), t.forEach(bp, e), vp = null, _p.call(e));
	}
	function bp(e, t) {
		if (!(t.state.loading & 4)) {
			var n = vp.get(e);
			if (n) var i = n.get(null);
			else {
				n = /* @__PURE__ */ new Map(), vp.set(e, n);
				for (var a = e.querySelectorAll("link[data-precedence],style[data-precedence]"), o = 0; o < a.length; o++) {
					var s = a[o];
					(s.nodeName === "LINK" || s.getAttribute("media") !== "not all") && (n.set(s.dataset.precedence, s), i = s);
				}
				i && n.set(null, i);
			}
			a = t.instance, s = a.getAttribute("data-precedence"), o = n.get(s) || i, o === i && n.set(null, a), n.set(s, a), this.count++, i = _p.bind(this), a.addEventListener("load", i), a.addEventListener("error", i), o ? o.parentNode.insertBefore(a, o.nextSibling) : (e = e.nodeType === 9 ? e.head : e, e.insertBefore(a, e.firstChild)), t.state.loading |= 4;
		}
	}
	var xp = {
		$$typeof: w,
		Provider: null,
		Consumer: null,
		_currentValue: te,
		_currentValue2: te,
		_threadCount: 0
	};
	function Sp(e, t, n, i, a, o, s, c, l) {
		this.tag = 1, this.containerInfo = e, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = qe(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = qe(0), this.hiddenUpdates = qe(null), this.identifierPrefix = i, this.onUncaughtError = a, this.onCaughtError = o, this.onRecoverableError = s, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = l, this.incompleteTransitions = /* @__PURE__ */ new Map();
	}
	function Cp(e, t, n, i, a, o, s, c, l, u, d, f) {
		return e = new Sp(e, t, n, s, l, u, d, f, c), t = 1, !0 === o && (t |= 24), o = gi(3, null, null, t), e.current = o, o.stateNode = e, t = ga(), t.refCount++, e.pooledCache = t, t.refCount++, o.memoizedState = {
			element: i,
			isDehydrated: n,
			cache: t
		}, Y(o), e;
	}
	function wp(e) {
		return e ? (e = mi, e) : mi;
	}
	function Tp(e, t, n, i, a, o) {
		a = wp(a), i.context === null ? i.context = a : i.pendingContext = a, i = Ja(t), i.payload = { element: n }, o = o === void 0 ? null : o, o !== null && (i.callback = o), n = Ya(e, i, t), n !== null && (Nu(n, e, t), Xa(n, e, t));
	}
	function Ep(e, t) {
		if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
			var n = e.retryLane;
			e.retryLane = n !== 0 && n < t ? n : t;
		}
	}
	function Dp(e, t) {
		Ep(e, t), (e = e.alternate) && Ep(e, t);
	}
	function Op(e) {
		if (e.tag === 13 || e.tag === 31) {
			var t = di(e, 67108864);
			t !== null && Nu(t, e, 67108864), Dp(e, 67108864);
		}
	}
	function kp(e) {
		if (e.tag === 13 || e.tag === 31) {
			var t = ju();
			t = Qe(t);
			var n = di(e, t);
			n !== null && Nu(n, e, t), Dp(e, t);
		}
	}
	var Ap = !0;
	function jp(e, t, n, i) {
		var a = L.T;
		L.T = null;
		var o = R.p;
		try {
			R.p = 2, Np(e, t, n, i);
		} finally {
			R.p = o, L.T = a;
		}
	}
	function Mp(e, t, n, i) {
		var a = L.T;
		L.T = null;
		var o = R.p;
		try {
			R.p = 8, Np(e, t, n, i);
		} finally {
			R.p = o, L.T = a;
		}
	}
	function Np(e, t, n, i) {
		if (Ap) {
			var a = Pp(i);
			if (a === null) Kd(e, t, i, Fp, n), Kp(e, i);
			else if (Jp(a, e, t, n, i)) i.stopPropagation();
			else if (Kp(e, i), t & 4 && -1 < Gp.indexOf(e)) {
				for (; a !== null;) {
					var o = pt(a);
					if (o !== null) switch (o.tag) {
						case 3:
							if (o = o.stateNode, o.current.memoizedState.isDehydrated) {
								var s = Ue(o.pendingLanes);
								if (s !== 0) {
									var c = o;
									for (c.pendingLanes |= 2, c.entangledLanes |= 2; s;) {
										var l = 1 << 31 - Ie(s);
										c.entanglements[1] |= l, s &= ~l;
									}
									Sd(o), !(Ql & 6) && (yu = Te() + 500, Cd(0, !1));
								}
							}
							break;
						case 31:
						case 13: c = di(o, 2), c !== null && Nu(c, o, 2), Ru(), Dp(o, 2);
					}
					if (o = Pp(i), o === null && Kd(e, t, i, Fp, n), o === a) break;
					a = o;
				}
				a !== null && i.stopPropagation();
			} else Kd(e, t, i, null, n);
		}
	}
	function Pp(e) {
		return e = Qt(e), Ip(e);
	}
	var Fp = null;
	function Ip(e) {
		if (Fp = null, e = ft(e), e !== null) {
			var t = s(e);
			if (t === null) e = null;
			else {
				var n = t.tag;
				if (n === 13) {
					if (e = c(t), e !== null) return e;
					e = null;
				} else if (n === 31) {
					if (e = l(t), e !== null) return e;
					e = null;
				} else if (n === 3) {
					if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
					e = null;
				} else t !== e && (e = null);
			}
		}
		return Fp = e, null;
	}
	function Lp(e) {
		switch (e) {
			case "beforetoggle":
			case "cancel":
			case "click":
			case "close":
			case "contextmenu":
			case "copy":
			case "cut":
			case "auxclick":
			case "dblclick":
			case "dragend":
			case "dragstart":
			case "drop":
			case "focusin":
			case "focusout":
			case "input":
			case "invalid":
			case "keydown":
			case "keypress":
			case "keyup":
			case "mousedown":
			case "mouseup":
			case "paste":
			case "pause":
			case "play":
			case "pointercancel":
			case "pointerdown":
			case "pointerup":
			case "ratechange":
			case "reset":
			case "resize":
			case "seeked":
			case "submit":
			case "toggle":
			case "touchcancel":
			case "touchend":
			case "touchstart":
			case "volumechange":
			case "change":
			case "selectionchange":
			case "textInput":
			case "compositionstart":
			case "compositionend":
			case "compositionupdate":
			case "beforeblur":
			case "afterblur":
			case "beforeinput":
			case "blur":
			case "fullscreenchange":
			case "focus":
			case "hashchange":
			case "popstate":
			case "select":
			case "selectstart": return 2;
			case "drag":
			case "dragenter":
			case "dragexit":
			case "dragleave":
			case "dragover":
			case "mousemove":
			case "mouseout":
			case "mouseover":
			case "pointermove":
			case "pointerout":
			case "pointerover":
			case "scroll":
			case "touchmove":
			case "wheel":
			case "mouseenter":
			case "mouseleave":
			case "pointerenter":
			case "pointerleave": return 8;
			case "message": switch (Ee()) {
				case De: return 2;
				case Oe: return 8;
				case ke:
				case Ae: return 32;
				case je: return 268435456;
				default: return 32;
			}
			default: return 32;
		}
	}
	var Rp = !1, zp = null, Bp = null, Vp = null, Hp = /* @__PURE__ */ new Map(), Up = /* @__PURE__ */ new Map(), Wp = [], Gp = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
	function Kp(e, t) {
		switch (e) {
			case "focusin":
			case "focusout":
				zp = null;
				break;
			case "dragenter":
			case "dragleave":
				Bp = null;
				break;
			case "mouseover":
			case "mouseout":
				Vp = null;
				break;
			case "pointerover":
			case "pointerout":
				Hp.delete(t.pointerId);
				break;
			case "gotpointercapture":
			case "lostpointercapture": Up.delete(t.pointerId);
		}
	}
	function qp(e, t, n, i, a, o) {
		return e === null || e.nativeEvent !== o ? (e = {
			blockedOn: t,
			domEventName: n,
			eventSystemFlags: i,
			nativeEvent: o,
			targetContainers: [a]
		}, t !== null && (t = pt(t), t !== null && Op(t)), e) : (e.eventSystemFlags |= i, t = e.targetContainers, a !== null && t.indexOf(a) === -1 && t.push(a), e);
	}
	function Jp(e, t, n, i, a) {
		switch (t) {
			case "focusin": return zp = qp(zp, e, t, n, i, a), !0;
			case "dragenter": return Bp = qp(Bp, e, t, n, i, a), !0;
			case "mouseover": return Vp = qp(Vp, e, t, n, i, a), !0;
			case "pointerover":
				var o = a.pointerId;
				return Hp.set(o, qp(Hp.get(o) || null, e, t, n, i, a)), !0;
			case "gotpointercapture": return o = a.pointerId, Up.set(o, qp(Up.get(o) || null, e, t, n, i, a)), !0;
		}
		return !1;
	}
	function Yp(e) {
		var t = ft(e.target);
		if (t !== null) {
			var n = s(t);
			if (n !== null) {
				if (t = n.tag, t === 13) {
					if (t = c(n), t !== null) {
						e.blockedOn = t, tt(e.priority, function() {
							kp(n);
						});
						return;
					}
				} else if (t === 31) {
					if (t = l(n), t !== null) {
						e.blockedOn = t, tt(e.priority, function() {
							kp(n);
						});
						return;
					}
				} else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
					e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
					return;
				}
			}
		}
		e.blockedOn = null;
	}
	function Xp(e) {
		if (e.blockedOn !== null) return !1;
		for (var t = e.targetContainers; 0 < t.length;) {
			var n = Pp(e.nativeEvent);
			if (n === null) {
				n = e.nativeEvent;
				var i = new n.constructor(n.type, n);
				Zt = i, n.target.dispatchEvent(i), Zt = null;
			} else return t = pt(n), t !== null && Op(t), e.blockedOn = n, !1;
			t.shift();
		}
		return !0;
	}
	function Zp(e, t, n) {
		Xp(e) && n.delete(t);
	}
	function Qp() {
		Rp = !1, zp !== null && Xp(zp) && (zp = null), Bp !== null && Xp(Bp) && (Bp = null), Vp !== null && Xp(Vp) && (Vp = null), Hp.forEach(Zp), Up.forEach(Zp);
	}
	function $p(e, n) {
		e.blockedOn === n && (e.blockedOn = null, Rp || (Rp = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, Qp)));
	}
	var em = null;
	function tm(e) {
		em !== e && (em = e, t.unstable_scheduleCallback(t.unstable_NormalPriority, function() {
			em === e && (em = null);
			for (var t = 0; t < e.length; t += 3) {
				var n = e[t], i = e[t + 1], a = e[t + 2];
				if (typeof i != "function") {
					if (Ip(i || n) === null) continue;
					break;
				}
				var o = pt(n);
				o !== null && (e.splice(t, 3), t -= 3, Fs(o, {
					pending: !0,
					data: a,
					method: n.method,
					action: i
				}, i, a));
			}
		}));
	}
	function nm(e) {
		function t(t) {
			return $p(t, e);
		}
		zp !== null && $p(zp, e), Bp !== null && $p(Bp, e), Vp !== null && $p(Vp, e), Hp.forEach(t), Up.forEach(t);
		for (var n = 0; n < Wp.length; n++) {
			var i = Wp[n];
			i.blockedOn === e && (i.blockedOn = null);
		}
		for (; 0 < Wp.length && (n = Wp[0], n.blockedOn === null);) Yp(n), n.blockedOn === null && Wp.shift();
		if (n = (e.ownerDocument || e).$$reactFormReplay, n != null) for (i = 0; i < n.length; i += 3) {
			var a = n[i], o = n[i + 1], s = a[it] || null;
			if (typeof o == "function") s || tm(n);
			else if (s) {
				var c = null;
				if (o && o.hasAttribute("formAction")) {
					if (a = o, s = o[it] || null) c = s.formAction;
					else if (Ip(a) !== null) continue;
				} else c = s.action;
				typeof c == "function" ? n[i + 1] = c : (n.splice(i, 3), i -= 3), tm(n);
			}
		}
	}
	function rm() {
		function e(e) {
			e.canIntercept && e.info === "react-transition" && e.intercept({
				handler: function() {
					return new Promise(function(e) {
						return a = e;
					});
				},
				focusReset: "manual",
				scroll: "manual"
			});
		}
		function t() {
			a !== null && (a(), a = null), i || setTimeout(n, 20);
		}
		function n() {
			if (!i && !navigation.transition) {
				var e = navigation.currentEntry;
				e && e.url != null && navigation.navigate(e.url, {
					state: e.getState(),
					info: "react-transition",
					history: "replace"
				});
			}
		}
		if (typeof navigation == "object") {
			var i = !1, a = null;
			return navigation.addEventListener("navigate", e), navigation.addEventListener("navigatesuccess", t), navigation.addEventListener("navigateerror", t), setTimeout(n, 100), function() {
				i = !0, navigation.removeEventListener("navigate", e), navigation.removeEventListener("navigatesuccess", t), navigation.removeEventListener("navigateerror", t), a !== null && (a(), a = null);
			};
		}
	}
	function im(e) {
		this._internalRoot = e;
	}
	am.prototype.render = im.prototype.render = function(e) {
		var t = this._internalRoot;
		if (t === null) throw Error(a(409));
		var n = t.current, i = ju();
		Tp(n, i, e, t, null, null);
	}, am.prototype.unmount = im.prototype.unmount = function() {
		var e = this._internalRoot;
		if (e !== null) {
			this._internalRoot = null;
			var t = e.containerInfo;
			Tp(e.current, 2, null, e, null, null), Ru(), t[at] = null;
		}
	};
	function am(e) {
		this._internalRoot = e;
	}
	am.prototype.unstable_scheduleHydration = function(e) {
		if (e) {
			var t = et();
			e = {
				blockedOn: null,
				target: e,
				priority: t
			};
			for (var n = 0; n < Wp.length && t !== 0 && t < Wp[n].priority; n++);
			Wp.splice(n, 0, e), n === 0 && Yp(e);
		}
	};
	var om = n.version;
	if (om !== "19.2.0") throw Error(a(527, om, "19.2.0"));
	R.findDOMNode = function(e) {
		var t = e._reactInternals;
		if (t === void 0) throw typeof e.render == "function" ? Error(a(188)) : (e = Object.keys(e).join(","), Error(a(268, e)));
		return e = d(t), e = e === null ? null : p(e), e = e === null ? null : e.stateNode, e;
	};
	var sm = {
		bundleType: 0,
		version: "19.2.0",
		rendererPackageName: "react-dom",
		currentDispatcherRef: L,
		reconcilerVersion: "19.2.0"
	};
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
		var cm = __REACT_DEVTOOLS_GLOBAL_HOOK__;
		if (!cm.isDisabled && cm.supportsFiber) try {
			U = cm.inject(sm), Pe = cm;
		} catch {}
	}
	e.createRoot = function(e, t) {
		if (!o(e)) throw Error(a(299));
		var n = !1, i = "", s = ic, c = ac, l = oc;
		return t != null && (!0 === t.unstable_strictMode && (n = !0), t.identifierPrefix !== void 0 && (i = t.identifierPrefix), t.onUncaughtError !== void 0 && (s = t.onUncaughtError), t.onCaughtError !== void 0 && (c = t.onCaughtError), t.onRecoverableError !== void 0 && (l = t.onRecoverableError)), t = Cp(e, 1, !1, null, null, n, i, null, s, c, l, rm), e[at] = t.current, Wd(e), new im(t);
	};
})), require_react_dom_client_development = /* @__PURE__ */ __commonJSMin(((e) => {
	process.env.NODE_ENV !== "production" && (function() {
		function t(e, t) {
			for (e = e.memoizedState; e !== null && 0 < t;) e = e.next, t--;
			return e;
		}
		function n(e, t, i, a) {
			if (i >= t.length) return a;
			var o = t[i], s = Gf(e) ? e.slice() : Df({}, e);
			return s[o] = n(e[o], t, i + 1, a), s;
		}
		function i(e, t, n) {
			if (t.length !== n.length) console.warn("copyWithRename() expects paths of the same length");
			else {
				for (var i = 0; i < n.length - 1; i++) if (t[i] !== n[i]) {
					console.warn("copyWithRename() expects paths to be the same except for the deepest key");
					return;
				}
				return a(e, t, n, 0);
			}
		}
		function a(e, t, n, i) {
			var o = t[i], s = Gf(e) ? e.slice() : Df({}, e);
			return i + 1 === t.length ? (s[n[i]] = s[o], Gf(s) ? s.splice(o, 1) : delete s[o]) : s[o] = a(e[o], t, n, i + 1), s;
		}
		function o(e, t, n) {
			var i = t[n], a = Gf(e) ? e.slice() : Df({}, e);
			return n + 1 === t.length ? (Gf(a) ? a.splice(i, 1) : delete a[i], a) : (a[i] = o(e[i], t, n + 1), a);
		}
		function s() {
			return !1;
		}
		function c() {
			return null;
		}
		function l() {
			console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
		}
		function u() {
			console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
		}
		function d() {}
		function p() {}
		function m(e) {
			var t = [];
			return e.forEach(function(e) {
				t.push(e);
			}), t.sort().join(", ");
		}
		function g(e, t, n, i) {
			return new ur(e, t, n, i);
		}
		function _(e, t) {
			e.context === Gg && (Xd(e.current, 2, t, e, null, null), el());
		}
		function y(e, t) {
			if (Kg !== null) {
				var n = t.staleFamilies;
				t = t.updatedFamilies, El(), lr(e.current, t, n), el();
			}
		}
		function b(e) {
			Kg = e;
		}
		function x(e) {
			return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
		}
		function S(e) {
			var t = e, n = e;
			if (e.alternate) for (; t.return;) t = t.return;
			else {
				e = t;
				do
					t = e, t.flags & 4098 && (n = t.return), e = t.return;
				while (e);
			}
			return t.tag === 3 ? n : null;
		}
		function C(e) {
			if (e.tag === 13) {
				var t = e.memoizedState;
				if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
			}
			return null;
		}
		function w(e) {
			if (e.tag === 31) {
				var t = e.memoizedState;
				if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
			}
			return null;
		}
		function T(e) {
			if (S(e) !== e) throw Error("Unable to find node on an unmounted component.");
		}
		function E(e) {
			var t = e.alternate;
			if (!t) {
				if (t = S(e), t === null) throw Error("Unable to find node on an unmounted component.");
				return t === e ? e : null;
			}
			for (var n = e, i = t;;) {
				var a = n.return;
				if (a === null) break;
				var o = a.alternate;
				if (o === null) {
					if (i = a.return, i !== null) {
						n = i;
						continue;
					}
					break;
				}
				if (a.child === o.child) {
					for (o = a.child; o;) {
						if (o === n) return T(a), e;
						if (o === i) return T(a), t;
						o = o.sibling;
					}
					throw Error("Unable to find node on an unmounted component.");
				}
				if (n.return !== i.return) n = a, i = o;
				else {
					for (var s = !1, c = a.child; c;) {
						if (c === n) {
							s = !0, n = a, i = o;
							break;
						}
						if (c === i) {
							s = !0, i = a, n = o;
							break;
						}
						c = c.sibling;
					}
					if (!s) {
						for (c = o.child; c;) {
							if (c === n) {
								s = !0, n = o, i = a;
								break;
							}
							if (c === i) {
								s = !0, i = o, n = a;
								break;
							}
							c = c.sibling;
						}
						if (!s) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
					}
				}
				if (n.alternate !== i) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
			}
			if (n.tag !== 3) throw Error("Unable to find node on an unmounted component.");
			return n.stateNode.current === n ? e : t;
		}
		function O(e) {
			var t = e.tag;
			if (t === 5 || t === 26 || t === 27 || t === 6) return e;
			for (e = e.child; e !== null;) {
				if (t = O(e), t !== null) return t;
				e = e.sibling;
			}
			return null;
		}
		function k(e) {
			return typeof e != "object" || !e ? null : (e = Uf && e[Uf] || e["@@iterator"], typeof e == "function" ? e : null);
		}
		function A(e) {
			if (e == null) return null;
			if (typeof e == "function") return e.$$typeof === Wf ? null : e.displayName || e.name || null;
			if (typeof e == "string") return e;
			switch (e) {
				case jf: return "Fragment";
				case Nf: return "Profiler";
				case Mf: return "StrictMode";
				case Lf: return "Suspense";
				case Rf: return "SuspenseList";
				case Vf: return "Activity";
			}
			if (typeof e == "object") switch (typeof e.tag == "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), e.$$typeof) {
				case Af: return "Portal";
				case Ff: return e.displayName || "Context";
				case Pf: return (e._context.displayName || "Context") + ".Consumer";
				case If:
					var t = e.render;
					return e = e.displayName, e ||= (e = t.displayName || t.name || "", e === "" ? "ForwardRef" : "ForwardRef(" + e + ")"), e;
				case zf: return t = e.displayName || null, t === null ? A(e.type) || "Memo" : t;
				case Bf:
					t = e._payload, e = e._init;
					try {
						return A(e(t));
					} catch {}
			}
			return null;
		}
		function j(e) {
			return typeof e.tag == "number" ? M(e) : typeof e.name == "string" ? e.name : null;
		}
		function M(e) {
			var t = e.type;
			switch (e.tag) {
				case 31: return "Activity";
				case 24: return "Cache";
				case 9: return (t._context.displayName || "Context") + ".Consumer";
				case 10: return t.displayName || "Context";
				case 18: return "DehydratedFragment";
				case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e === "" ? "ForwardRef" : "ForwardRef(" + e + ")");
				case 7: return "Fragment";
				case 26:
				case 27:
				case 5: return t;
				case 4: return "Portal";
				case 3: return "Root";
				case 6: return "Text";
				case 16: return A(t);
				case 8: return t === Mf ? "StrictMode" : "Mode";
				case 22: return "Offscreen";
				case 12: return "Profiler";
				case 21: return "Scope";
				case 13: return "Suspense";
				case 19: return "SuspenseList";
				case 25: return "TracingMarker";
				case 1:
				case 0:
				case 14:
				case 15:
					if (typeof t == "function") return t.displayName || t.name || null;
					if (typeof t == "string") return t;
					break;
				case 29:
					if (t = e._debugInfo, t != null) {
						for (var n = t.length - 1; 0 <= n; n--) if (typeof t[n].name == "string") return t[n].name;
					}
					if (e.return !== null) return M(e.return);
			}
			return null;
		}
		function N(e) {
			return { current: e };
		}
		function P(e, t) {
			0 > Xf ? console.error("Unexpected pop.") : (t !== Yf[Xf] && console.error("Unexpected Fiber popped."), e.current = Jf[Xf], Jf[Xf] = null, Yf[Xf] = null, Xf--);
		}
		function F(e, t, n) {
			Xf++, Jf[Xf] = e.current, Yf[Xf] = n, e.current = t;
		}
		function I(e) {
			return e === null && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."), e;
		}
		function ee(e, t) {
			F($f, t, e), F(Qf, e, e), F(Zf, null, e);
			var n = t.nodeType;
			switch (n) {
				case 9:
				case 11:
					n = n === 9 ? "#document" : "#fragment", t = (t = t.documentElement) && (t = t.namespaceURI) ? Iu(t) : dC;
					break;
				default: if (n = t.tagName, t = t.namespaceURI) t = Iu(t), t = Lu(t, n);
				else switch (n) {
					case "svg":
						t = fC;
						break;
					case "math":
						t = pC;
						break;
					default: t = dC;
				}
			}
			n = n.toLowerCase(), n = Mt(null, n), n = {
				context: t,
				ancestorInfo: n
			}, P(Zf, e), F(Zf, n, e);
		}
		function L(e) {
			P(Zf, e), P(Qf, e), P($f, e);
		}
		function R() {
			return I(Zf.current);
		}
		function te(e) {
			e.memoizedState !== null && F(ep, e, e);
			var t = I(Zf.current), n = e.type, i = Lu(t.context, n);
			n = Mt(t.ancestorInfo, n), i = {
				context: i,
				ancestorInfo: n
			}, t !== i && (F(Qf, e, e), F(Zf, i, e));
		}
		function ne(e) {
			Qf.current === e && (P(Zf, e), P(Qf, e)), ep.current === e && (P(ep, e), HC._currentValue = VC);
		}
		function ie() {}
		function ae() {
			if (tp === 0) {
				np = console.log, rp = console.info, ip = console.warn, ap = console.error, op = console.group, sp = console.groupCollapsed, cp = console.groupEnd;
				var e = {
					configurable: !0,
					enumerable: !0,
					value: ie,
					writable: !0
				};
				Object.defineProperties(console, {
					info: e,
					log: e,
					warn: e,
					error: e,
					group: e,
					groupCollapsed: e,
					groupEnd: e
				});
			}
			tp++;
		}
		function oe() {
			if (tp--, tp === 0) {
				var e = {
					configurable: !0,
					enumerable: !0,
					writable: !0
				};
				Object.defineProperties(console, {
					log: Df({}, e, { value: np }),
					info: Df({}, e, { value: rp }),
					warn: Df({}, e, { value: ip }),
					error: Df({}, e, { value: ap }),
					group: Df({}, e, { value: op }),
					groupCollapsed: Df({}, e, { value: sp }),
					groupEnd: Df({}, e, { value: cp })
				});
			}
			0 > tp && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
		}
		function z(e) {
			var t = Error.prepareStackTrace;
			if (Error.prepareStackTrace = void 0, e = e.stack, Error.prepareStackTrace = t, e.startsWith("Error: react-stack-top-frame\n") && (e = e.slice(29)), t = e.indexOf("\n"), t !== -1 && (e = e.slice(t + 1)), t = e.indexOf("react_stack_bottom_frame"), t !== -1 && (t = e.lastIndexOf("\n", t)), t !== -1) e = e.slice(0, t);
			else return "";
			return e;
		}
		function se(e) {
			if (lp === void 0) try {
				throw Error();
			} catch (e) {
				var t = e.stack.trim().match(/\n( *(at )?)/);
				lp = t && t[1] || "", up = -1 < e.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < e.stack.indexOf("@") ? "@unknown:0:0" : "";
			}
			return "\n" + lp + e + up;
		}
		function ce(e, t) {
			if (!e || dp) return "";
			var n = fp.get(e);
			if (n !== void 0) return n;
			dp = !0, n = Error.prepareStackTrace, Error.prepareStackTrace = void 0;
			var i = null;
			i = Q.H, Q.H = null, ae();
			try {
				var a = { DetermineComponentFrameRoot: function() {
					try {
						if (t) {
							var n = function() {
								throw Error();
							};
							if (Object.defineProperty(n.prototype, "props", { set: function() {
								throw Error();
							} }), typeof Reflect == "object" && Reflect.construct) {
								try {
									Reflect.construct(n, []);
								} catch (e) {
									var i = e;
								}
								Reflect.construct(e, [], n);
							} else {
								try {
									n.call();
								} catch (e) {
									i = e;
								}
								e.call(n.prototype);
							}
						} else {
							try {
								throw Error();
							} catch (e) {
								i = e;
							}
							(n = e()) && typeof n.catch == "function" && n.catch(function() {});
						}
					} catch (e) {
						if (e && i && typeof e.stack == "string") return [e.stack, i.stack];
					}
					return [null, null];
				} };
				a.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
				var o = Object.getOwnPropertyDescriptor(a.DetermineComponentFrameRoot, "name");
				o && o.configurable && Object.defineProperty(a.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
				var s = a.DetermineComponentFrameRoot(), c = s[0], l = s[1];
				if (c && l) {
					var u = c.split("\n"), d = l.split("\n");
					for (s = o = 0; o < u.length && !u[o].includes("DetermineComponentFrameRoot");) o++;
					for (; s < d.length && !d[s].includes("DetermineComponentFrameRoot");) s++;
					if (o === u.length || s === d.length) for (o = u.length - 1, s = d.length - 1; 1 <= o && 0 <= s && u[o] !== d[s];) s--;
					for (; 1 <= o && 0 <= s; o--, s--) if (u[o] !== d[s]) {
						if (o !== 1 || s !== 1) do
							if (o--, s--, 0 > s || u[o] !== d[s]) {
								var f = "\n" + u[o].replace(" at new ", " at ");
								return e.displayName && f.includes("<anonymous>") && (f = f.replace("<anonymous>", e.displayName)), typeof e == "function" && fp.set(e, f), f;
							}
						while (1 <= o && 0 <= s);
						break;
					}
				}
			} finally {
				dp = !1, Q.H = i, oe(), Error.prepareStackTrace = n;
			}
			return u = (u = e ? e.displayName || e.name : "") ? se(u) : "", typeof e == "function" && fp.set(e, u), u;
		}
		function le(e, t) {
			switch (e.tag) {
				case 26:
				case 27:
				case 5: return se(e.type);
				case 16: return se("Lazy");
				case 13: return e.child !== t && t !== null ? se("Suspense Fallback") : se("Suspense");
				case 19: return se("SuspenseList");
				case 0:
				case 15: return ce(e.type, !1);
				case 11: return ce(e.type.render, !1);
				case 1: return ce(e.type, !0);
				case 31: return se("Activity");
				default: return "";
			}
		}
		function ue(e) {
			try {
				var t = "", n = null;
				do {
					t += le(e, n);
					var i = e._debugInfo;
					if (i) for (var a = i.length - 1; 0 <= a; a--) {
						var o = i[a];
						if (typeof o.name == "string") {
							var s = t;
							a: {
								var c = o.name, l = o.env, u = o.debugLocation;
								if (u != null) {
									var d = z(u), f = d.lastIndexOf("\n"), p = f === -1 ? d : d.slice(f + 1);
									if (p.indexOf(c) !== -1) {
										var m = "\n" + p;
										break a;
									}
								}
								m = se(c + (l ? " [" + l + "]" : ""));
							}
							t = s + m;
						}
					}
					n = e, e = e.return;
				} while (e);
				return t;
			} catch (e) {
				return "\nError generating stack: " + e.message + "\n" + e.stack;
			}
		}
		function de(e) {
			return (e = e ? e.displayName || e.name : "") ? se(e) : "";
		}
		function fe() {
			if (pp === null) return null;
			var e = pp._debugOwner;
			return e == null ? null : j(e);
		}
		function pe() {
			if (pp === null) return "";
			var e = pp;
			try {
				var t = "";
				switch (e.tag === 6 && (e = e.return), e.tag) {
					case 26:
					case 27:
					case 5:
						t += se(e.type);
						break;
					case 13:
						t += se("Suspense");
						break;
					case 19:
						t += se("SuspenseList");
						break;
					case 31:
						t += se("Activity");
						break;
					case 30:
					case 0:
					case 15:
					case 1:
						e._debugOwner || t !== "" || (t += de(e.type));
						break;
					case 11: e._debugOwner || t !== "" || (t += de(e.type.render));
				}
				for (; e;) if (typeof e.tag == "number") {
					var n = e;
					e = n._debugOwner;
					var i = n._debugStack;
					if (e && i) {
						var a = z(i);
						a !== "" && (t += "\n" + a);
					}
				} else if (e.debugStack != null) {
					var o = e.debugStack;
					(e = e.owner) && o && (t += "\n" + z(o));
				} else break;
				var s = t;
			} catch (e) {
				s = "\nError generating stack: " + e.message + "\n" + e.stack;
			}
			return s;
		}
		function V(e, t, n, i, a, o, s) {
			var c = pp;
			me(e);
			try {
				return e !== null && e._debugTask ? e._debugTask.run(t.bind(null, n, i, a, o, s)) : t(n, i, a, o, s);
			} finally {
				me(c);
			}
			throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
		}
		function me(e) {
			Q.getCurrentStack = e === null ? null : pe, mp = !1, pp = e;
		}
		function he(e) {
			return typeof Symbol == "function" && Symbol.toStringTag && e[Symbol.toStringTag] || e.constructor.name || "Object";
		}
		function ge(e) {
			try {
				return _e(e), !1;
			} catch {
				return !0;
			}
		}
		function _e(e) {
			return "" + e;
		}
		function H(e, t) {
			if (ge(e)) return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", t, he(e)), _e(e);
		}
		function ve(e, t) {
			if (ge(e)) return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", t, he(e)), _e(e);
		}
		function ye(e) {
			if (ge(e)) return console.error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.", he(e)), _e(e);
		}
		function be(e) {
			if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") return !1;
			var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
			if (t.isDisabled) return !0;
			if (!t.supportsFiber) return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), !0;
			try {
				kp = t.inject(e), Ap = t;
			} catch (e) {
				console.error("React instrumentation encountered an error: %o.", e);
			}
			return !!t.checkDCE;
		}
		function xe(e) {
			if (typeof Dp == "function" && Op(e), Ap && typeof Ap.setStrictMode == "function") try {
				Ap.setStrictMode(kp, e);
			} catch (e) {
				jp || (jp = !0, console.error("React instrumentation encountered an error: %o", e));
			}
		}
		function Se(e) {
			return e >>>= 0, e === 0 ? 32 : 31 - (Pp(e) / Fp | 0) | 0;
		}
		function Ce(e) {
			var t = e & 42;
			if (t !== 0) return t;
			switch (e & -e) {
				case 1: return 1;
				case 2: return 2;
				case 4: return 4;
				case 8: return 8;
				case 16: return 16;
				case 32: return 32;
				case 64: return 64;
				case 128: return 128;
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072: return e & 261888;
				case 262144:
				case 524288:
				case 1048576:
				case 2097152: return e & 3932160;
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432: return e & 62914560;
				case 67108864: return 67108864;
				case 134217728: return 134217728;
				case 268435456: return 268435456;
				case 536870912: return 536870912;
				case 1073741824: return 0;
				default: return console.error("Should have found matching lanes. This is a bug in React."), e;
			}
		}
		function we(e, t, n) {
			var i = e.pendingLanes;
			if (i === 0) return 0;
			var a = 0, o = e.suspendedLanes, s = e.pingedLanes;
			e = e.warmLanes;
			var c = i & 134217727;
			return c === 0 ? (c = i & ~o, c === 0 ? s === 0 ? n || (n = i & ~e, n !== 0 && (a = Ce(n))) : a = Ce(s) : a = Ce(c)) : (i = c & ~o, i === 0 ? (s &= c, s === 0 ? n || (n = c & ~e, n !== 0 && (a = Ce(n))) : a = Ce(s)) : a = Ce(i)), a === 0 ? 0 : t !== 0 && t !== a && (t & o) === 0 && (o = a & -a, n = t & -t, o >= n || o === 32 && n & 4194048) ? t : a;
		}
		function Te(e, t) {
			return (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & t) === 0;
		}
		function Ee(e, t) {
			switch (e) {
				case 1:
				case 2:
				case 4:
				case 8:
				case 64: return t + 250;
				case 16:
				case 32:
				case 128:
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152: return t + 5e3;
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432: return -1;
				case 67108864:
				case 134217728:
				case 268435456:
				case 536870912:
				case 1073741824: return -1;
				default: return console.error("Should have found matching lanes. This is a bug in React."), -1;
			}
		}
		function De() {
			var e = Rp;
			return Rp <<= 1, !(Rp & 62914560) && (Rp = 4194304), e;
		}
		function Oe(e) {
			for (var t = [], n = 0; 31 > n; n++) t.push(e);
			return t;
		}
		function ke(e, t) {
			e.pendingLanes |= t, t !== 268435456 && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0);
		}
		function Ae(e, t, n, i, a, o) {
			var s = e.pendingLanes;
			e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= n, e.entangledLanes &= n, e.errorRecoveryDisabledLanes &= n, e.shellSuspendCounter = 0;
			var c = e.entanglements, l = e.expirationTimes, u = e.hiddenUpdates;
			for (n = s & ~n; 0 < n;) {
				var d = 31 - Np(n), f = 1 << d;
				c[d] = 0, l[d] = -1;
				var p = u[d];
				if (p !== null) for (u[d] = null, d = 0; d < p.length; d++) {
					var m = p[d];
					m !== null && (m.lane &= -536870913);
				}
				n &= ~f;
			}
			i !== 0 && je(e, i, 0), o !== 0 && a === 0 && e.tag !== 0 && (e.suspendedLanes |= o & ~(s & ~t));
		}
		function je(e, t, n) {
			e.pendingLanes |= t, e.suspendedLanes &= ~t;
			var i = 31 - Np(t);
			e.entangledLanes |= t, e.entanglements[i] = e.entanglements[i] | 1073741824 | n & 261930;
		}
		function Me(e, t) {
			var n = e.entangledLanes |= t;
			for (e = e.entanglements; n;) {
				var i = 31 - Np(n), a = 1 << i;
				a & t | e[i] & t && (e[i] |= t), n &= ~a;
			}
		}
		function Ne(e, t) {
			var n = t & -t;
			return n = n & 42 ? 1 : U(n), (n & (e.suspendedLanes | t)) === 0 ? n : 0;
		}
		function U(e) {
			switch (e) {
				case 2:
					e = 1;
					break;
				case 8:
					e = 4;
					break;
				case 32:
					e = 16;
					break;
				case 256:
				case 512:
				case 1024:
				case 2048:
				case 4096:
				case 8192:
				case 16384:
				case 32768:
				case 65536:
				case 131072:
				case 262144:
				case 524288:
				case 1048576:
				case 2097152:
				case 4194304:
				case 8388608:
				case 16777216:
				case 33554432:
					e = 128;
					break;
				case 268435456:
					e = 134217728;
					break;
				default: e = 0;
			}
			return e;
		}
		function Pe(e, t, n) {
			if (Mp) for (e = e.pendingUpdatersLaneMap; 0 < n;) {
				var i = 31 - Np(n), a = 1 << i;
				e[i].add(t), n &= ~a;
			}
		}
		function Fe(e, t) {
			if (Mp) for (var n = e.pendingUpdatersLaneMap, i = e.memoizedUpdaters; 0 < t;) {
				var a = 31 - Np(t);
				e = 1 << a, a = n[a], 0 < a.size && (a.forEach(function(e) {
					var t = e.alternate;
					t !== null && i.has(t) || i.add(e);
				}), a.clear()), t &= ~e;
			}
		}
		function Ie(e) {
			return e &= -e, zp !== 0 && zp < e ? Bp !== 0 && Bp < e ? e & 134217727 ? Vp : Hp : Bp : zp;
		}
		function Le() {
			var e = Kf.p;
			return e === 0 ? (e = window.event, e === void 0 ? Vp : lf(e.type)) : e;
		}
		function Re(e, t) {
			var n = Kf.p;
			try {
				return Kf.p = e, t();
			} finally {
				Kf.p = n;
			}
		}
		function ze(e) {
			delete e[Wp], delete e[Gp], delete e[qp], delete e[Jp], delete e[Yp];
		}
		function Be(e) {
			var t = e[Wp];
			if (t) return t;
			for (var n = e.parentNode; n;) {
				if (t = n[Kp] || n[Wp]) {
					if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = _d(e); e !== null;) {
						if (n = e[Wp]) return n;
						e = _d(e);
					}
					return t;
				}
				e = n, n = e.parentNode;
			}
			return null;
		}
		function Ve(e) {
			if (e = e[Wp] || e[Kp]) {
				var t = e.tag;
				if (t === 5 || t === 6 || t === 13 || t === 31 || t === 26 || t === 27 || t === 3) return e;
			}
			return null;
		}
		function He(e) {
			var t = e.tag;
			if (t === 5 || t === 26 || t === 27 || t === 6) return e.stateNode;
			throw Error("getNodeFromInstance: Invalid argument.");
		}
		function Ue(e) {
			var t = e[Xp];
			return t ||= e[Xp] = {
				hoistableStyles: /* @__PURE__ */ new Map(),
				hoistableScripts: /* @__PURE__ */ new Map()
			}, t;
		}
		function We(e) {
			e[Zp] = !0;
		}
		function W(e, t) {
			Ge(e, t), Ge(e + "Capture", t);
		}
		function Ge(e, t) {
			$p[e] && console.error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", e), $p[e] = t;
			var n = e.toLowerCase();
			for (em[n] = e, e === "onDoubleClick" && (em.ondblclick = e), e = 0; e < t.length; e++) Qp.add(t[e]);
		}
		function Ke(e, t) {
			tm[t.type] || t.onChange || t.onInput || t.readOnly || t.disabled || t.value == null || (e === "select" ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.")), t.onChange || t.readOnly || t.disabled || t.checked == null || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
		}
		function qe(e) {
			return hp.call(im, e) ? !0 : hp.call(rm, e) ? !1 : nm.test(e) ? im[e] = !0 : (rm[e] = !0, console.error("Invalid attribute name: `%s`", e), !1);
		}
		function Je(e, t, n) {
			if (qe(t)) {
				if (!e.hasAttribute(t)) {
					switch (typeof n) {
						case "symbol":
						case "object": return n;
						case "function": return n;
						case "boolean": if (!1 === n) return n;
					}
					return n === void 0 ? void 0 : null;
				}
				return e = e.getAttribute(t), e === "" && !0 === n ? !0 : (H(n, t), e === "" + n ? n : e);
			}
		}
		function G(e, t, n) {
			if (qe(t)) if (n === null) e.removeAttribute(t);
			else {
				switch (typeof n) {
					case "undefined":
					case "function":
					case "symbol":
						e.removeAttribute(t);
						return;
					case "boolean":
						var i = t.toLowerCase().slice(0, 5);
						if (i !== "data-" && i !== "aria-") {
							e.removeAttribute(t);
							return;
						}
				}
				H(n, t), e.setAttribute(t, "" + n);
			}
		}
		function Ye(e, t, n) {
			if (n === null) e.removeAttribute(t);
			else {
				switch (typeof n) {
					case "undefined":
					case "function":
					case "symbol":
					case "boolean":
						e.removeAttribute(t);
						return;
				}
				H(n, t), e.setAttribute(t, "" + n);
			}
		}
		function Xe(e, t, n, i) {
			if (i === null) e.removeAttribute(n);
			else {
				switch (typeof i) {
					case "undefined":
					case "function":
					case "symbol":
					case "boolean":
						e.removeAttribute(n);
						return;
				}
				H(i, n), e.setAttributeNS(t, n, "" + i);
			}
		}
		function Ze(e) {
			switch (typeof e) {
				case "bigint":
				case "boolean":
				case "number":
				case "string":
				case "undefined": return e;
				case "object": return ye(e), e;
				default: return "";
			}
		}
		function Qe(e) {
			var t = e.type;
			return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
		}
		function $e(e, t, n) {
			var i = Object.getOwnPropertyDescriptor(e.constructor.prototype, t);
			if (!e.hasOwnProperty(t) && i !== void 0 && typeof i.get == "function" && typeof i.set == "function") {
				var a = i.get, o = i.set;
				return Object.defineProperty(e, t, {
					configurable: !0,
					get: function() {
						return a.call(this);
					},
					set: function(e) {
						ye(e), n = "" + e, o.call(this, e);
					}
				}), Object.defineProperty(e, t, { enumerable: i.enumerable }), {
					getValue: function() {
						return n;
					},
					setValue: function(e) {
						ye(e), n = "" + e;
					},
					stopTracking: function() {
						e._valueTracker = null, delete e[t];
					}
				};
			}
		}
		function et(e) {
			if (!e._valueTracker) {
				var t = Qe(e) ? "checked" : "value";
				e._valueTracker = $e(e, t, "" + e[t]);
			}
		}
		function tt(e) {
			if (!e) return !1;
			var t = e._valueTracker;
			if (!t) return !0;
			var n = t.getValue(), i = "";
			return e && (i = Qe(e) ? e.checked ? "true" : "false" : e.value), e = i, e === n ? !1 : (t.setValue(e), !0);
		}
		function nt(e) {
			if (e ||= typeof document < "u" ? document : void 0, e === void 0) return null;
			try {
				return e.activeElement || e.body;
			} catch {
				return e.body;
			}
		}
		function rt(e) {
			return e.replace(am, function(e) {
				return "\\" + e.charCodeAt(0).toString(16) + " ";
			});
		}
		function it(e, t) {
			t.checked === void 0 || t.defaultChecked === void 0 || sm || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", fe() || "A component", t.type), sm = !0), t.value === void 0 || t.defaultValue === void 0 || om || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", fe() || "A component", t.type), om = !0);
		}
		function at(e, t, n, i, a, o, s, c) {
			e.name = "", s != null && typeof s != "function" && typeof s != "symbol" && typeof s != "boolean" ? (H(s, "type"), e.type = s) : e.removeAttribute("type"), t == null ? s !== "submit" && s !== "reset" || e.removeAttribute("value") : s === "number" ? (t === 0 && e.value === "" || e.value != t) && (e.value = "" + Ze(t)) : e.value !== "" + Ze(t) && (e.value = "" + Ze(t)), t == null ? n == null ? i != null && e.removeAttribute("value") : st(e, s, Ze(n)) : st(e, s, Ze(t)), a == null && o != null && (e.defaultChecked = !!o), a != null && (e.checked = a && typeof a != "function" && typeof a != "symbol"), c != null && typeof c != "function" && typeof c != "symbol" && typeof c != "boolean" ? (H(c, "name"), e.name = "" + Ze(c)) : e.removeAttribute("name");
		}
		function ot(e, t, n, i, a, o, s, c) {
			if (o != null && typeof o != "function" && typeof o != "symbol" && typeof o != "boolean" && (H(o, "type"), e.type = o), t != null || n != null) {
				if (!(o !== "submit" && o !== "reset" || t != null)) {
					et(e);
					return;
				}
				n = n == null ? "" : "" + Ze(n), t = t == null ? n : "" + Ze(t), c || t === e.value || (e.value = t), e.defaultValue = t;
			}
			i ??= a, i = typeof i != "function" && typeof i != "symbol" && !!i, e.checked = c ? e.checked : !!i, e.defaultChecked = !!i, s != null && typeof s != "function" && typeof s != "symbol" && typeof s != "boolean" && (H(s, "name"), e.name = s), et(e);
		}
		function st(e, t, n) {
			t === "number" && nt(e.ownerDocument) === e || e.defaultValue === "" + n || (e.defaultValue = "" + n);
		}
		function ct(e, t) {
			t.value ?? (typeof t.children == "object" && t.children !== null ? Tf.Children.forEach(t.children, function(e) {
				e == null || typeof e == "string" || typeof e == "number" || typeof e == "bigint" || lm || (lm = !0, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."));
			}) : t.dangerouslySetInnerHTML == null || um || (um = !0, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."))), t.selected == null || cm || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), cm = !0);
		}
		function lt() {
			var e = fe();
			return e ? "\n\nCheck the render method of `" + e + "`." : "";
		}
		function ut(e, t, n, i) {
			if (e = e.options, t) {
				t = {};
				for (var a = 0; a < n.length; a++) t["$" + n[a]] = !0;
				for (n = 0; n < e.length; n++) a = t.hasOwnProperty("$" + e[n].value), e[n].selected !== a && (e[n].selected = a), a && i && (e[n].defaultSelected = !0);
			} else {
				for (n = "" + Ze(n), t = null, a = 0; a < e.length; a++) {
					if (e[a].value === n) {
						e[a].selected = !0, i && (e[a].defaultSelected = !0);
						return;
					}
					t !== null || e[a].disabled || (t = e[a]);
				}
				t !== null && (t.selected = !0);
			}
		}
		function dt(e, t) {
			for (e = 0; e < fm.length; e++) {
				var n = fm[e];
				if (t[n] != null) {
					var i = Gf(t[n]);
					t.multiple && !i ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", n, lt()) : !t.multiple && i && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", n, lt());
				}
			}
			t.value === void 0 || t.defaultValue === void 0 || dm || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), dm = !0);
		}
		function ft(e, t) {
			t.value === void 0 || t.defaultValue === void 0 || pm || (console.error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components", fe() || "A component"), pm = !0), t.children != null && t.value == null && console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
		}
		function pt(e, t, n) {
			if (t != null && (t = "" + Ze(t), t !== e.value && (e.value = t), n == null)) {
				e.defaultValue !== t && (e.defaultValue = t);
				return;
			}
			e.defaultValue = n == null ? "" : "" + Ze(n);
		}
		function mt(e, t, n, i) {
			if (t == null) {
				if (i != null) {
					if (n != null) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
					if (Gf(i)) {
						if (1 < i.length) throw Error("<textarea> can only have at most one child.");
						i = i[0];
					}
					n = i;
				}
				n ??= "", t = n;
			}
			n = Ze(t), e.defaultValue = n, i = e.textContent, i === n && i !== "" && i !== null && (e.value = i), et(e);
		}
		function ht(e, t) {
			return e.serverProps === void 0 && e.serverTail.length === 0 && e.children.length === 1 && 3 < e.distanceFromLeaf && e.distanceFromLeaf > 15 - t ? ht(e.children[0], t) : e;
		}
		function gt(e) {
			return "  " + "  ".repeat(e);
		}
		function _t(e) {
			return "+ " + "  ".repeat(e);
		}
		function vt(e) {
			return "- " + "  ".repeat(e);
		}
		function yt(e) {
			switch (e.tag) {
				case 26:
				case 27:
				case 5: return e.type;
				case 16: return "Lazy";
				case 31: return "Activity";
				case 13: return "Suspense";
				case 19: return "SuspenseList";
				case 0:
				case 15: return e = e.type, e.displayName || e.name || null;
				case 11: return e = e.type.render, e.displayName || e.name || null;
				case 1: return e = e.type, e.displayName || e.name || null;
				default: return null;
			}
		}
		function bt(e, t) {
			return mm.test(e) ? (e = JSON.stringify(e), e.length > t - 2 ? 8 > t ? "{\"...\"}" : "{" + e.slice(0, t - 7) + "...\"}" : "{" + e + "}") : e.length > t ? 5 > t ? "{\"...\"}" : e.slice(0, t - 3) + "..." : e;
		}
		function xt(e, t, n) {
			var i = 120 - 2 * n;
			if (t === null) return _t(n) + bt(e, i) + "\n";
			if (typeof t == "string") {
				for (var a = 0; a < t.length && a < e.length && t.charCodeAt(a) === e.charCodeAt(a); a++);
				return a > i - 8 && 10 < a && (e = "..." + e.slice(a - 8), t = "..." + t.slice(a - 8)), _t(n) + bt(e, i) + "\n" + vt(n) + bt(t, i) + "\n";
			}
			return gt(n) + bt(e, i) + "\n";
		}
		function St(e) {
			return Object.prototype.toString.call(e).replace(/^\[object (.*)\]$/, function(e, t) {
				return t;
			});
		}
		function Ct(e, t) {
			switch (typeof e) {
				case "string": return e = JSON.stringify(e), e.length > t ? 5 > t ? "\"...\"" : e.slice(0, t - 4) + "...\"" : e;
				case "object":
					if (e === null) return "null";
					if (Gf(e)) return "[...]";
					if (e.$$typeof === kf) return (t = A(e.type)) ? "<" + t + ">" : "<...>";
					var n = St(e);
					if (n === "Object") {
						for (var i in n = "", t -= 2, e) if (e.hasOwnProperty(i)) {
							var a = JSON.stringify(i);
							if (a !== "\"" + i + "\"" && (i = a), t -= i.length - 2, a = Ct(e[i], 15 > t ? t : 15), t -= a.length, 0 > t) {
								n += n === "" ? "..." : ", ...";
								break;
							}
							n += (n === "" ? "" : ",") + i + ":" + a;
						}
						return "{" + n + "}";
					}
					return n;
				case "function": return (t = e.displayName || e.name) ? "function " + t : "function";
				default: return String(e);
			}
		}
		function wt(e, t) {
			return typeof e != "string" || mm.test(e) ? "{" + Ct(e, t - 2) + "}" : e.length > t - 2 ? 5 > t ? "\"...\"" : "\"" + e.slice(0, t - 5) + "...\"" : "\"" + e + "\"";
		}
		function Tt(e, t, n) {
			var i = 120 - n.length - e.length, a = [], o;
			for (o in t) if (t.hasOwnProperty(o) && o !== "children") {
				var s = wt(t[o], 120 - n.length - o.length - 1);
				i -= o.length + s.length + 2, a.push(o + "=" + s);
			}
			return a.length === 0 ? n + "<" + e + ">\n" : 0 < i ? n + "<" + e + " " + a.join(" ") + ">\n" : n + "<" + e + "\n" + n + "  " + a.join("\n" + n + "  ") + "\n" + n + ">\n";
		}
		function Et(e, t, n) {
			var i = "", a = Df({}, t), o;
			for (o in e) if (e.hasOwnProperty(o)) {
				delete a[o];
				var s = 120 - 2 * n - o.length - 2, c = Ct(e[o], s);
				t.hasOwnProperty(o) ? (s = Ct(t[o], s), i += _t(n) + o + ": " + c + "\n", i += vt(n) + o + ": " + s + "\n") : i += _t(n) + o + ": " + c + "\n";
			}
			for (var l in a) a.hasOwnProperty(l) && (e = Ct(a[l], 120 - 2 * n - l.length - 2), i += vt(n) + l + ": " + e + "\n");
			return i;
		}
		function Dt(e, t, n, i) {
			var a = "", o = /* @__PURE__ */ new Map();
			for (u in n) n.hasOwnProperty(u) && o.set(u.toLowerCase(), u);
			if (o.size === 1 && o.has("children")) a += Tt(e, t, gt(i));
			else {
				for (var s in t) if (t.hasOwnProperty(s) && s !== "children") {
					var c = 120 - 2 * (i + 1) - s.length - 1, l = o.get(s.toLowerCase());
					if (l !== void 0) {
						o.delete(s.toLowerCase());
						var u = t[s];
						l = n[l];
						var d = wt(u, c);
						c = wt(l, c), typeof u == "object" && u && typeof l == "object" && l && St(u) === "Object" && St(l) === "Object" && (2 < Object.keys(u).length || 2 < Object.keys(l).length || -1 < d.indexOf("...") || -1 < c.indexOf("...")) ? a += gt(i + 1) + s + "={{\n" + Et(u, l, i + 2) + gt(i + 1) + "}}\n" : (a += _t(i + 1) + s + "=" + d + "\n", a += vt(i + 1) + s + "=" + c + "\n");
					} else a += gt(i + 1) + s + "=" + wt(t[s], c) + "\n";
				}
				o.forEach(function(e) {
					if (e !== "children") {
						var t = 120 - 2 * (i + 1) - e.length - 1;
						a += vt(i + 1) + e + "=" + wt(n[e], t) + "\n";
					}
				}), a = a === "" ? gt(i) + "<" + e + ">\n" : gt(i) + "<" + e + "\n" + a + gt(i) + ">\n";
			}
			return e = n.children, t = t.children, typeof e == "string" || typeof e == "number" || typeof e == "bigint" ? (o = "", (typeof t == "string" || typeof t == "number" || typeof t == "bigint") && (o = "" + t), a += xt(o, "" + e, i + 1)) : (typeof t == "string" || typeof t == "number" || typeof t == "bigint") && (a = e == null ? a + xt("" + t, null, i + 1) : a + xt("" + t, void 0, i + 1)), a;
		}
		function Ot(e, t) {
			var n = yt(e);
			if (n === null) {
				for (n = "", e = e.child; e;) n += Ot(e, t), e = e.sibling;
				return n;
			}
			return gt(t) + "<" + n + ">\n";
		}
		function kt(e, t) {
			var n = ht(e, t);
			if (n !== e && (e.children.length !== 1 || e.children[0] !== n)) return gt(t) + "...\n" + kt(n, t + 1);
			n = "";
			var i = e.fiber._debugInfo;
			if (i) for (var a = 0; a < i.length; a++) {
				var o = i[a].name;
				typeof o == "string" && (n += gt(t) + "<" + o + ">\n", t++);
			}
			if (i = "", a = e.fiber.pendingProps, e.fiber.tag === 6) i = xt(a, e.serverProps, t), t++;
			else if (o = yt(e.fiber), o !== null) if (e.serverProps === void 0) {
				i = t;
				var s = 120 - 2 * i - o.length - 2, c = "";
				for (u in a) if (a.hasOwnProperty(u) && u !== "children") {
					var l = wt(a[u], 15);
					if (s -= u.length + l.length + 2, 0 > s) {
						c += " ...";
						break;
					}
					c += " " + u + "=" + l;
				}
				i = gt(i) + "<" + o + c + ">\n", t++;
			} else e.serverProps === null ? (i = Tt(o, a, _t(t)), t++) : typeof e.serverProps == "string" ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (i = Dt(o, a, e.serverProps, t), t++);
			var u = "";
			for (a = e.fiber.child, o = 0; a && o < e.children.length;) s = e.children[o], s.fiber === a ? (u += kt(s, t), o++) : u += Ot(a, t), a = a.sibling;
			for (a && 0 < e.children.length && (u += gt(t) + "...\n"), a = e.serverTail, e.serverProps === null && t--, e = 0; e < a.length; e++) o = a[e], u = typeof o == "string" ? u + (vt(t) + bt(o, 120 - 2 * t) + "\n") : u + Tt(o.type, o.props, vt(t));
			return n + i + u;
		}
		function At(e) {
			try {
				return "\n\n" + kt(e, 0);
			} catch {
				return "";
			}
		}
		function jt(e, t, n) {
			for (var i = t, a = null, o = 0; i;) i === e && (o = 0), a = {
				fiber: i,
				children: a === null ? [] : [a],
				serverProps: i === t ? n : i === e ? null : void 0,
				serverTail: [],
				distanceFromLeaf: o
			}, o++, i = i.return;
			return a === null ? "" : At(a).replaceAll(/^[+-]/gm, ">");
		}
		function Mt(e, t) {
			var n = Df({}, e || ym), i = { tag: t };
			return gm.indexOf(t) !== -1 && (n.aTagInScope = null, n.buttonTagInScope = null, n.nobrTagInScope = null), _m.indexOf(t) !== -1 && (n.pTagInButtonScope = null), hm.indexOf(t) !== -1 && t !== "address" && t !== "div" && t !== "p" && (n.listItemTagAutoclosing = null, n.dlItemTagAutoclosing = null), n.current = i, t === "form" && (n.formTag = i), t === "a" && (n.aTagInScope = i), t === "button" && (n.buttonTagInScope = i), t === "nobr" && (n.nobrTagInScope = i), t === "p" && (n.pTagInButtonScope = i), t === "li" && (n.listItemTagAutoclosing = i), (t === "dd" || t === "dt") && (n.dlItemTagAutoclosing = i), t === "#document" || t === "html" ? n.containerTagInScope = null : n.containerTagInScope ||= i, e !== null || t !== "#document" && t !== "html" && t !== "body" ? !0 === n.implicitRootScope && (n.implicitRootScope = !1) : n.implicitRootScope = !0, n;
		}
		function Nt(e, t, n) {
			switch (t) {
				case "select": return e === "hr" || e === "option" || e === "optgroup" || e === "script" || e === "template" || e === "#text";
				case "optgroup": return e === "option" || e === "#text";
				case "option": return e === "#text";
				case "tr": return e === "th" || e === "td" || e === "style" || e === "script" || e === "template";
				case "tbody":
				case "thead":
				case "tfoot": return e === "tr" || e === "style" || e === "script" || e === "template";
				case "colgroup": return e === "col" || e === "template";
				case "table": return e === "caption" || e === "colgroup" || e === "tbody" || e === "tfoot" || e === "thead" || e === "style" || e === "script" || e === "template";
				case "head": return e === "base" || e === "basefont" || e === "bgsound" || e === "link" || e === "meta" || e === "title" || e === "noscript" || e === "noframes" || e === "style" || e === "script" || e === "template";
				case "html":
					if (n) break;
					return e === "head" || e === "body" || e === "frameset";
				case "frameset": return e === "frame";
				case "#document": if (!n) return e === "html";
			}
			switch (e) {
				case "h1":
				case "h2":
				case "h3":
				case "h4":
				case "h5":
				case "h6": return t !== "h1" && t !== "h2" && t !== "h3" && t !== "h4" && t !== "h5" && t !== "h6";
				case "rp":
				case "rt": return vm.indexOf(t) === -1;
				case "caption":
				case "col":
				case "colgroup":
				case "frameset":
				case "frame":
				case "tbody":
				case "td":
				case "tfoot":
				case "th":
				case "thead":
				case "tr": return t == null;
				case "head": return n || t === null;
				case "html": return n && t === "#document" || t === null;
				case "body": return n && (t === "#document" || t === "html") || t === null;
			}
			return !0;
		}
		function Pt(e, t) {
			switch (e) {
				case "address":
				case "article":
				case "aside":
				case "blockquote":
				case "center":
				case "details":
				case "dialog":
				case "dir":
				case "div":
				case "dl":
				case "fieldset":
				case "figcaption":
				case "figure":
				case "footer":
				case "header":
				case "hgroup":
				case "main":
				case "menu":
				case "nav":
				case "ol":
				case "p":
				case "section":
				case "summary":
				case "ul":
				case "pre":
				case "listing":
				case "table":
				case "hr":
				case "xmp":
				case "h1":
				case "h2":
				case "h3":
				case "h4":
				case "h5":
				case "h6": return t.pTagInButtonScope;
				case "form": return t.formTag || t.pTagInButtonScope;
				case "li": return t.listItemTagAutoclosing;
				case "dd":
				case "dt": return t.dlItemTagAutoclosing;
				case "button": return t.buttonTagInScope;
				case "a": return t.aTagInScope;
				case "nobr": return t.nobrTagInScope;
			}
			return null;
		}
		function Ft(e, t) {
			for (; e;) {
				switch (e.tag) {
					case 5:
					case 26:
					case 27: if (e.type === t) return e;
				}
				e = e.return;
			}
			return null;
		}
		function It(e, t) {
			t ||= ym;
			var n = t.current;
			if (t = (n = Nt(e, n && n.tag, t.implicitRootScope) ? null : n) ? null : Pt(e, t), t = n || t, !t) return !0;
			var i = t.tag;
			if (t = String(!!n) + "|" + e + "|" + i, bm[t]) return !1;
			bm[t] = !0;
			var a = (t = pp) ? Ft(t.return, i) : null, o = t !== null && a !== null ? jt(a, t, null) : "", s = "<" + e + ">";
			return n ? (n = "", i === "table" && e === "tr" && (n += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error("In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s", s, i, n, o)) : console.error("In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s", s, i, o), t && (e = t.return, a === null || e === null || a === e && e._debugOwner === t._debugOwner || V(a, function() {
				console.error("<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.", i, s);
			})), !1;
		}
		function Lt(e, t, n) {
			if (n || Nt("#text", t, !1)) return !0;
			if (n = "#text|" + t, bm[n]) return !1;
			bm[n] = !0;
			var i = (n = pp) ? Ft(n, t) : null;
			return n = n !== null && i !== null ? jt(i, n, n.tag === 6 ? null : { children: null }) : "", /\S/.test(e) ? console.error("In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s", t, n) : console.error("In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s", t, n), !1;
		}
		function Rt(e, t) {
			if (t) {
				var n = e.firstChild;
				if (n && n === e.lastChild && n.nodeType === 3) {
					n.nodeValue = t;
					return;
				}
			}
			e.textContent = t;
		}
		function zt(e) {
			return e.replace(Em, function(e, t) {
				return t.toUpperCase();
			});
		}
		function Bt(e, t, n) {
			var i = t.indexOf("--") === 0;
			i || (-1 < t.indexOf("-") ? Om.hasOwnProperty(t) && Om[t] || (Om[t] = !0, console.error("Unsupported style property %s. Did you mean %s?", t, zt(t.replace(Tm, "ms-")))) : wm.test(t) ? Om.hasOwnProperty(t) && Om[t] || (Om[t] = !0, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", t, t.charAt(0).toUpperCase() + t.slice(1))) : !Dm.test(n) || km.hasOwnProperty(n) && km[n] || (km[n] = !0, console.error("Style property values shouldn't contain a semicolon. Try \"%s: %s\" instead.", t, n.replace(Dm, ""))), typeof n == "number" && (isNaN(n) ? Am || (Am = !0, console.error("`NaN` is an invalid value for the `%s` css style property.", t)) : isFinite(n) || jm || (jm = !0, console.error("`Infinity` is an invalid value for the `%s` css style property.", t)))), n == null || typeof n == "boolean" || n === "" ? i ? e.setProperty(t, "") : t === "float" ? e.cssFloat = "" : e[t] = "" : i ? e.setProperty(t, n) : typeof n != "number" || n === 0 || Mm.has(t) ? t === "float" ? e.cssFloat = n : (ve(n, t), e[t] = ("" + n).trim()) : e[t] = n + "px";
		}
		function Vt(e, t, n) {
			if (t != null && typeof t != "object") throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
			if (t && Object.freeze(t), e = e.style, n != null) {
				if (t) {
					var i = {};
					if (n) {
						for (var a in n) if (n.hasOwnProperty(a) && !t.hasOwnProperty(a)) for (var o = xm[a] || [a], s = 0; s < o.length; s++) i[o[s]] = a;
					}
					for (var c in t) if (t.hasOwnProperty(c) && (!n || n[c] !== t[c])) for (a = xm[c] || [c], o = 0; o < a.length; o++) i[a[o]] = c;
					for (var l in c = {}, t) for (a = xm[l] || [l], o = 0; o < a.length; o++) c[a[o]] = l;
					for (var u in l = {}, i) if (a = i[u], (o = c[u]) && a !== o && (s = a + "," + o, !l[s])) {
						l[s] = !0, s = console;
						var d = t[a];
						s.error.call(s, "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", d == null || typeof d == "boolean" || d === "" ? "Removing" : "Updating", a, o);
					}
				}
				for (var f in n) !n.hasOwnProperty(f) || t != null && t.hasOwnProperty(f) || (f.indexOf("--") === 0 ? e.setProperty(f, "") : f === "float" ? e.cssFloat = "" : e[f] = "");
				for (var p in t) u = t[p], t.hasOwnProperty(p) && n[p] !== u && Bt(e, p, u);
			} else for (i in t) t.hasOwnProperty(i) && Bt(e, i, t[i]);
		}
		function Ht(e) {
			if (e.indexOf("-") === -1) return !1;
			switch (e) {
				case "annotation-xml":
				case "color-profile":
				case "font-face":
				case "font-face-src":
				case "font-face-uri":
				case "font-face-format":
				case "font-face-name":
				case "missing-glyph": return !1;
				default: return !0;
			}
		}
		function Ut(e) {
			return Fm.get(e) || e;
		}
		function Wt(e, t) {
			if (hp.call(Rm, t) && Rm[t]) return !0;
			if (Bm.test(t)) {
				if (e = "aria-" + t.slice(4).toLowerCase(), e = Lm.hasOwnProperty(e) ? e : null, e == null) return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", t), Rm[t] = !0;
				if (t !== e) return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", t, e), Rm[t] = !0;
			}
			if (zm.test(t)) {
				if (e = t.toLowerCase(), e = Lm.hasOwnProperty(e) ? e : null, e == null) return Rm[t] = !0, !1;
				t !== e && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", t, e), Rm[t] = !0);
			}
			return !0;
		}
		function Gt(e, t) {
			var n = [], i;
			for (i in t) Wt(e, i) || n.push(i);
			t = n.map(function(e) {
				return "`" + e + "`";
			}).join(", "), n.length === 1 ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", t, e) : 1 < n.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", t, e);
		}
		function Kt(e, t, n, i) {
			if (hp.call(Hm, t) && Hm[t]) return !0;
			var a = t.toLowerCase();
			if (a === "onfocusin" || a === "onfocusout") return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Hm[t] = !0;
			if (typeof n == "function" && (e === "form" && t === "action" || e === "input" && t === "formAction" || e === "button" && t === "formAction")) return !0;
			if (i != null) {
				if (e = i.possibleRegistrationNames, i.registrationNameDependencies.hasOwnProperty(t)) return !0;
				if (i = e.hasOwnProperty(a) ? e[a] : null, i != null) return console.error("Invalid event handler property `%s`. Did you mean `%s`?", t, i), Hm[t] = !0;
				if (Um.test(t)) return console.error("Unknown event handler property `%s`. It will be ignored.", t), Hm[t] = !0;
			} else if (Um.test(t)) return Wm.test(t) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", t), Hm[t] = !0;
			if (Gm.test(t) || Km.test(t)) return !0;
			if (a === "innerhtml") return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Hm[t] = !0;
			if (a === "aria") return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Hm[t] = !0;
			if (a === "is" && n != null && typeof n != "string") return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof n), Hm[t] = !0;
			if (typeof n == "number" && isNaN(n)) return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", t), Hm[t] = !0;
			if (Im.hasOwnProperty(a)) {
				if (a = Im[a], a !== t) return console.error("Invalid DOM property `%s`. Did you mean `%s`?", t, a), Hm[t] = !0;
			} else if (t !== a) return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", t, a), Hm[t] = !0;
			switch (t) {
				case "dangerouslySetInnerHTML":
				case "children":
				case "style":
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "defaultValue":
				case "defaultChecked":
				case "innerHTML":
				case "ref": return !0;
				case "innerText":
				case "textContent": return !0;
			}
			switch (typeof n) {
				case "boolean": switch (t) {
					case "autoFocus":
					case "checked":
					case "multiple":
					case "muted":
					case "selected":
					case "contentEditable":
					case "spellCheck":
					case "draggable":
					case "value":
					case "autoReverse":
					case "externalResourcesRequired":
					case "focusable":
					case "preserveAlpha":
					case "allowFullScreen":
					case "async":
					case "autoPlay":
					case "controls":
					case "default":
					case "defer":
					case "disabled":
					case "disablePictureInPicture":
					case "disableRemotePlayback":
					case "formNoValidate":
					case "hidden":
					case "loop":
					case "noModule":
					case "noValidate":
					case "open":
					case "playsInline":
					case "readOnly":
					case "required":
					case "reversed":
					case "scoped":
					case "seamless":
					case "itemScope":
					case "capture":
					case "download":
					case "inert": return !0;
					default: return a = t.toLowerCase().slice(0, 5), a === "data-" || a === "aria-" ? !0 : (n ? console.error("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.", n, t, t, n, t) : console.error("Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", n, t, t, n, t, t, t), Hm[t] = !0);
				}
				case "function":
				case "symbol": return Hm[t] = !0, !1;
				case "string": if (n === "false" || n === "true") {
					switch (t) {
						case "checked":
						case "selected":
						case "multiple":
						case "muted":
						case "allowFullScreen":
						case "async":
						case "autoPlay":
						case "controls":
						case "default":
						case "defer":
						case "disabled":
						case "disablePictureInPicture":
						case "disableRemotePlayback":
						case "formNoValidate":
						case "hidden":
						case "loop":
						case "noModule":
						case "noValidate":
						case "open":
						case "playsInline":
						case "readOnly":
						case "required":
						case "reversed":
						case "scoped":
						case "seamless":
						case "itemScope":
						case "inert": break;
						default: return !0;
					}
					console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", n, t, n === "false" ? "The browser will interpret it as a truthy value." : "Although this works, it will not work as expected if you pass the string \"false\".", t, n), Hm[t] = !0;
				}
			}
			return !0;
		}
		function qt(e, t, n) {
			var i = [], a;
			for (a in t) Kt(e, a, t[a], n) || i.push(a);
			t = i.map(function(e) {
				return "`" + e + "`";
			}).join(", "), i.length === 1 ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", t, e) : 1 < i.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", t, e);
		}
		function Jt(e) {
			return qm.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e;
		}
		function Yt() {}
		function Xt(e) {
			return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
		}
		function Zt(e) {
			var t = Ve(e);
			if (t && (e = t.stateNode)) {
				var n = e[Gp] || null;
				a: switch (e = t.stateNode, t.type) {
					case "input":
						if (at(e, n.value, n.defaultValue, n.defaultValue, n.checked, n.defaultChecked, n.type, n.name), t = n.name, n.type === "radio" && t != null) {
							for (n = e; n.parentNode;) n = n.parentNode;
							for (H(t, "name"), n = n.querySelectorAll("input[name=\"" + rt("" + t) + "\"][type=\"radio\"]"), t = 0; t < n.length; t++) {
								var i = n[t];
								if (i !== e && i.form === e.form) {
									var a = i[Gp] || null;
									if (!a) throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
									at(i, a.value, a.defaultValue, a.defaultValue, a.checked, a.defaultChecked, a.type, a.name);
								}
							}
							for (t = 0; t < n.length; t++) i = n[t], i.form === e.form && tt(i);
						}
						break a;
					case "textarea":
						pt(e, n.value, n.defaultValue);
						break a;
					case "select": t = n.value, t != null && ut(e, !!n.multiple, t, !1);
				}
			}
		}
		function Qt(e, t, n) {
			if (Zm) return e(t, n);
			Zm = !0;
			try {
				return e(t);
			} finally {
				if (Zm = !1, (Ym !== null || Xm !== null) && (el(), Ym && (t = Ym, e = Xm, Xm = Ym = null, Zt(t), e))) for (t = 0; t < e.length; t++) Zt(e[t]);
			}
		}
		function K(e, t) {
			var n = e.stateNode;
			if (n === null) return null;
			var i = n[Gp] || null;
			if (i === null) return null;
			n = i[t];
			a: switch (t) {
				case "onClick":
				case "onClickCapture":
				case "onDoubleClick":
				case "onDoubleClickCapture":
				case "onMouseDown":
				case "onMouseDownCapture":
				case "onMouseMove":
				case "onMouseMoveCapture":
				case "onMouseUp":
				case "onMouseUpCapture":
				case "onMouseEnter":
					(i = !i.disabled) || (e = e.type, i = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !i;
					break a;
				default: e = !1;
			}
			if (e) return null;
			if (n && typeof n != "function") throw Error("Expected `" + t + "` listener to be a function, instead got a value of `" + typeof n + "` type.");
			return n;
		}
		function $t() {
			if (rh) return rh;
			var e, t = nh, n = t.length, i, a = "value" in th ? th.value : th.textContent, o = a.length;
			for (e = 0; e < n && t[e] === a[e]; e++);
			var s = n - e;
			for (i = 1; i <= s && t[n - i] === a[o - i]; i++);
			return rh = a.slice(e, 1 < i ? 1 - i : void 0);
		}
		function en(e) {
			var t = e.keyCode;
			return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
		}
		function tn() {
			return !0;
		}
		function nn() {
			return !1;
		}
		function rn(e) {
			function t(t, n, i, a, o) {
				for (var s in this._reactName = t, this._targetInst = i, this.type = n, this.nativeEvent = a, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(s) && (t = e[s], this[s] = t ? t(a) : a[s]);
				return this.isDefaultPrevented = (a.defaultPrevented == null ? !1 === a.returnValue : a.defaultPrevented) ? tn : nn, this.isPropagationStopped = nn, this;
			}
			return Df(t.prototype, {
				preventDefault: function() {
					this.defaultPrevented = !0;
					var e = this.nativeEvent;
					e && (e.preventDefault ? e.preventDefault() : typeof e.returnValue != "unknown" && (e.returnValue = !1), this.isDefaultPrevented = tn);
				},
				stopPropagation: function() {
					var e = this.nativeEvent;
					e && (e.stopPropagation ? e.stopPropagation() : typeof e.cancelBubble != "unknown" && (e.cancelBubble = !0), this.isPropagationStopped = tn);
				},
				persist: function() {},
				isPersistent: tn
			}), t;
		}
		function an(e) {
			var t = this.nativeEvent;
			return t.getModifierState ? t.getModifierState(e) : (e = Eh[e]) ? !!t[e] : !1;
		}
		function on() {
			return an;
		}
		function sn(e, t) {
			switch (e) {
				case "keyup": return zh.indexOf(t.keyCode) !== -1;
				case "keydown": return t.keyCode !== Bh;
				case "keypress":
				case "mousedown":
				case "focusout": return !0;
				default: return !1;
			}
		}
		function ln(e) {
			return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
		}
		function un(e, t) {
			switch (e) {
				case "compositionend": return ln(t);
				case "keypress": return t.which === Gh ? (qh = !0, Kh) : null;
				case "textInput": return e = t.data, e === Kh && qh ? null : e;
				default: return null;
			}
		}
		function dn(e, t) {
			if (Jh) return e === "compositionend" || !Vh && sn(e, t) ? (e = $t(), rh = nh = th = null, Jh = !1, e) : null;
			switch (e) {
				case "paste": return null;
				case "keypress":
					if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
						if (t.char && 1 < t.char.length) return t.char;
						if (t.which) return String.fromCharCode(t.which);
					}
					return null;
				case "compositionend": return Wh && t.locale !== "ko" ? null : t.data;
				default: return null;
			}
		}
		function fn(e) {
			var t = e && e.nodeName && e.nodeName.toLowerCase();
			return t === "input" ? !!Yh[e.type] : t === "textarea";
		}
		function pn(e) {
			if (!Qm) return !1;
			e = "on" + e;
			var t = e in document;
			return t ||= (t = document.createElement("div"), t.setAttribute(e, "return;"), typeof t[e] == "function"), t;
		}
		function mn(e, t, n, i) {
			Ym ? Xm ? Xm.push(i) : Xm = [i] : Ym = i, t = lu(t, "onChange"), 0 < t.length && (n = new ah("onChange", "change", null, n, i), e.push({
				event: n,
				listeners: t
			}));
		}
		function hn(e) {
			nu(e, 0);
		}
		function gn(e) {
			var t = He(e);
			if (tt(t)) return e;
		}
		function _n(e, t) {
			if (e === "change") return t;
		}
		function vn() {
			Xh && (Xh.detachEvent("onpropertychange", yn), Zh = Xh = null);
		}
		function yn(e) {
			if (e.propertyName === "value" && gn(Zh)) {
				var t = [];
				mn(t, Zh, e, Xt(e)), Qt(hn, t);
			}
		}
		function bn(e, t, n) {
			e === "focusin" ? (vn(), Xh = t, Zh = n, Xh.attachEvent("onpropertychange", yn)) : e === "focusout" && vn();
		}
		function xn(e) {
			if (e === "selectionchange" || e === "keyup" || e === "keydown") return gn(Zh);
		}
		function Sn(e, t) {
			if (e === "click") return gn(t);
		}
		function Cn(e, t) {
			if (e === "input" || e === "change") return gn(t);
		}
		function wn(e, t) {
			return e === t && (e !== 0 || 1 / e == 1 / t) || e !== e && t !== t;
		}
		function Tn(e, t) {
			if ($h(e, t)) return !0;
			if (typeof e != "object" || !e || typeof t != "object" || !t) return !1;
			var n = Object.keys(e), i = Object.keys(t);
			if (n.length !== i.length) return !1;
			for (i = 0; i < n.length; i++) {
				var a = n[i];
				if (!hp.call(t, a) || !$h(e[a], t[a])) return !1;
			}
			return !0;
		}
		function En(e) {
			for (; e && e.firstChild;) e = e.firstChild;
			return e;
		}
		function Dn(e, t) {
			var n = En(e);
			e = 0;
			for (var i; n;) {
				if (n.nodeType === 3) {
					if (i = e + n.textContent.length, e <= t && i >= t) return {
						node: n,
						offset: t - e
					};
					e = i;
				}
				a: {
					for (; n;) {
						if (n.nextSibling) {
							n = n.nextSibling;
							break a;
						}
						n = n.parentNode;
					}
					n = void 0;
				}
				n = En(n);
			}
		}
		function On(e, t) {
			return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? On(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1;
		}
		function kn(e) {
			e = e != null && e.ownerDocument != null && e.ownerDocument.defaultView != null ? e.ownerDocument.defaultView : window;
			for (var t = nt(e.document); t instanceof e.HTMLIFrameElement;) {
				try {
					var n = typeof t.contentWindow.location.href == "string";
				} catch {
					n = !1;
				}
				if (n) e = t.contentWindow;
				else break;
				t = nt(e.document);
			}
			return t;
		}
		function An(e) {
			var t = e && e.nodeName && e.nodeName.toLowerCase();
			return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
		}
		function jn(e, t, n) {
			var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
			ig || tg == null || tg !== nt(i) || (i = tg, "selectionStart" in i && An(i) ? i = {
				start: i.selectionStart,
				end: i.selectionEnd
			} : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = {
				anchorNode: i.anchorNode,
				anchorOffset: i.anchorOffset,
				focusNode: i.focusNode,
				focusOffset: i.focusOffset
			}), rg && Tn(rg, i) || (rg = i, i = lu(ng, "onSelect"), 0 < i.length && (t = new ah("onSelect", "select", null, t, n), e.push({
				event: t,
				listeners: i
			}), t.target = tg)));
		}
		function Mn(e, t) {
			var n = {};
			return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n;
		}
		function Nn(e) {
			if (og[e]) return og[e];
			if (!ag[e]) return e;
			var t = ag[e], n;
			for (n in t) if (t.hasOwnProperty(n) && n in sg) return og[e] = t[n];
			return e;
		}
		function Pn(e, t) {
			hg.set(e, t), W(t, [e]);
		}
		function Fn(e) {
			for (var t = Cg, n = 0; n < e.length; n++) {
				var i = e[n];
				if (typeof i == "object" && i) if (Gf(i) && i.length === 2 && typeof i[0] == "string") {
					if (t !== Cg && t !== Eg) return wg;
					t = Eg;
				} else return wg;
				else {
					if (typeof i == "function" || typeof i == "string" && 50 < i.length || t !== Cg && t !== Tg) return wg;
					t = Tg;
				}
			}
			return t;
		}
		function In(e, t, n, i) {
			for (var a in e) hp.call(e, a) && a[0] !== "_" && Ln(a, e[a], t, n, i);
		}
		function Ln(e, t, n, i, a) {
			switch (typeof t) {
				case "object": if (t === null) {
					t = "null";
					break;
				} else {
					if (t.$$typeof === kf) {
						var o = A(t.type) || "", s = t.key;
						t = t.props;
						var c = Object.keys(t), l = c.length;
						if (s == null && l === 0) {
							t = "<" + o + " />";
							break;
						}
						if (3 > i || l === 1 && c[0] === "children" && s == null) {
							t = "<" + o + "  />";
							break;
						}
						for (var u in n.push([a + "\xA0\xA0".repeat(i) + e, "<" + o]), s !== null && Ln("key", s, n, i + 1, a), e = !1, t) u === "children" ? t.children != null && (!Gf(t.children) || 0 < t.children.length) && (e = !0) : hp.call(t, u) && u[0] !== "_" && Ln(u, t[u], n, i + 1, a);
						n.push(["", e ? "></" + o + ">" : "/>"]);
						return;
					}
					if (o = Object.prototype.toString.call(t), o = o.slice(8, o.length - 1), o === "Array") {
						if (u = Fn(t), u === Tg || u === Cg) {
							t = JSON.stringify(t);
							break;
						} else if (u === Eg) {
							for (n.push([a + "\xA0\xA0".repeat(i) + e, ""]), e = 0; e < t.length; e++) o = t[e], Ln(o[0], o[1], n, i + 1, a);
							return;
						}
					}
					if (o === "Promise") {
						if (t.status === "fulfilled") {
							if (o = n.length, Ln(e, t.value, n, i, a), n.length > o) {
								n = n[o], n[1] = "Promise<" + (n[1] || "Object") + ">";
								return;
							}
						} else if (t.status === "rejected" && (o = n.length, Ln(e, t.reason, n, i, a), n.length > o)) {
							n = n[o], n[1] = "Rejected Promise<" + n[1] + ">";
							return;
						}
						n.push(["\xA0\xA0".repeat(i) + e, "Promise"]);
						return;
					}
					o === "Object" && (u = Object.getPrototypeOf(t)) && typeof u.constructor == "function" && (o = u.constructor.name), n.push([a + "\xA0\xA0".repeat(i) + e, o === "Object" ? 3 > i ? "" : "" : o]), 3 > i && In(t, n, i + 1, a);
					return;
				}
				case "function":
					t = t.name === "" ? "() => {}" : t.name + "() {}";
					break;
				case "string":
					t = t === Sg ? "" : JSON.stringify(t);
					break;
				case "undefined":
					t = "undefined";
					break;
				case "boolean":
					t = t ? "true" : "false";
					break;
				default: t = String(t);
			}
			n.push([a + "\xA0\xA0".repeat(i) + e, t]);
		}
		function Rn(e, t, n, i) {
			var a = !0;
			for (s in e) s in t || (n.push([Dg + "\xA0\xA0".repeat(i) + s, ""]), a = !1);
			for (var o in t) if (o in e) {
				var s = e[o], c = t[o];
				if (s !== c) {
					if (i === 0 && o === "children") a = "\xA0\xA0".repeat(i) + o, n.push([Dg + a, ""], [Og + a, ""]);
					else {
						if (!(3 <= i)) {
							if (typeof s == "object" && typeof c == "object" && s !== null && c !== null && s.$$typeof === c.$$typeof) if (c.$$typeof === kf) {
								if (s.type === c.type && s.key === c.key) {
									s = A(c.type) || "", a = "\xA0\xA0".repeat(i) + o, s = "<" + s + "  />", n.push([Dg + a, s], [Og + a, s]), a = !1;
									continue;
								}
							} else {
								var l = Object.prototype.toString.call(s), u = Object.prototype.toString.call(c);
								if (l === u && (u === "[object Object]" || u === "[object Array]")) {
									l = [kg + "\xA0\xA0".repeat(i) + o, u === "[object Array]" ? "Array" : ""], n.push(l), u = n.length, Rn(s, c, n, i + 1) ? u === n.length && (l[1] = "Referentially unequal but deeply equal objects. Consider memoization.") : a = !1;
									continue;
								}
							}
							else if (typeof s == "function" && typeof c == "function" && s.name === c.name && s.length === c.length && (l = Function.prototype.toString.call(s), u = Function.prototype.toString.call(c), l === u)) {
								s = c.name === "" ? "() => {}" : c.name + "() {}", n.push([kg + "\xA0\xA0".repeat(i) + o, s + " Referentially unequal function closure. Consider memoization."]);
								continue;
							}
						}
						Ln(o, s, n, i, Dg), Ln(o, c, n, i, Og);
					}
					a = !1;
				}
			} else n.push([Og + "\xA0\xA0".repeat(i) + o, ""]), a = !1;
			return a;
		}
		function zn(e) {
			Ng = e & 63 ? "Blocking" : e & 64 ? "Gesture" : e & 4194176 ? "Transition" : e & 62914560 ? "Suspense" : e & 2080374784 ? "Idle" : "Other";
		}
		function Bn(e, t, n, i) {
			Ag && (Ig.start = t, Ig.end = n, Fg.color = "warning", Fg.tooltipText = i, Fg.properties = null, (e = e._debugTask) ? e.run(performance.measure.bind(performance, i, Ig)) : performance.measure(i, Ig));
		}
		function Vn(e, t, n) {
			Bn(e, t, n, "Reconnect");
		}
		function Hn(e, t, n, i, a) {
			var o = M(e);
			if (o !== null && Ag) {
				var s = e.alternate, c = e.actualDuration;
				if (s === null || s.child !== e.child) for (var l = e.child; l !== null; l = l.sibling) c -= l.actualDuration;
				i = .5 > c ? i ? "tertiary-light" : "primary-light" : 10 > c ? i ? "tertiary" : "primary" : 100 > c ? i ? "tertiary-dark" : "primary-dark" : "error";
				var u = e.memoizedProps;
				c = e._debugTask, u !== null && s !== null && s.memoizedProps !== u ? (l = [Lg], u = Rn(s.memoizedProps, u, l, 0), 1 < l.length && (u && !Pg && (s.lanes & a) === 0 && 100 < e.actualDuration ? (Pg = !0, l[0] = zg, Fg.color = "warning", Fg.tooltipText = Rg) : (Fg.color = i, Fg.tooltipText = o), Fg.properties = l, Ig.start = t, Ig.end = n, c == null ? performance.measure("" + o, Ig) : c.run(performance.measure.bind(performance, "" + o, Ig)))) : c == null ? console.timeStamp(o, t, n, jg, void 0, i) : c.run(console.timeStamp.bind(console, o, t, n, jg, void 0, i));
			}
		}
		function Un(e, t, n, i) {
			if (Ag) {
				var a = M(e);
				if (a !== null) {
					for (var o = null, s = [], c = 0; c < i.length; c++) {
						var l = i[c];
						o == null && l.source !== null && (o = l.source._debugTask), l = l.value, s.push(["Error", typeof l == "object" && l && typeof l.message == "string" ? String(l.message) : String(l)]);
					}
					e.key !== null && Ln("key", e.key, s, 0, ""), e.memoizedProps !== null && In(e.memoizedProps, s, 0, ""), o ??= e._debugTask, e = {
						start: t,
						end: n,
						detail: { devtools: {
							color: "error",
							track: jg,
							tooltipText: e.tag === 13 ? "Hydration failed" : "Error boundary caught an error",
							properties: s
						} }
					}, o ? o.run(performance.measure.bind(performance, "" + a, e)) : performance.measure("" + a, e);
				}
			}
		}
		function Wn(e, t, n, i, a) {
			if (a !== null) {
				if (Ag) {
					var o = M(e);
					if (o !== null) {
						i = [];
						for (var s = 0; s < a.length; s++) {
							var c = a[s].value;
							i.push(["Error", typeof c == "object" && c && typeof c.message == "string" ? String(c.message) : String(c)]);
						}
						e.key !== null && Ln("key", e.key, i, 0, ""), e.memoizedProps !== null && In(e.memoizedProps, i, 0, ""), t = {
							start: t,
							end: n,
							detail: { devtools: {
								color: "error",
								track: jg,
								tooltipText: "A lifecycle or effect errored",
								properties: i
							} }
						}, (e = e._debugTask) ? e.run(performance.measure.bind(performance, "" + o, t)) : performance.measure("" + o, t);
					}
				}
			} else o = M(e), o !== null && Ag && (a = 1 > i ? "secondary-light" : 100 > i ? "secondary" : 500 > i ? "secondary-dark" : "error", (e = e._debugTask) ? e.run(console.timeStamp.bind(console, o, t, n, jg, void 0, a)) : console.timeStamp(o, t, n, jg, void 0, a));
		}
		function Gn(e, t, n, i) {
			if (Ag && !(t <= e)) {
				var a = (n & 738197653) === n ? "tertiary-dark" : "primary-dark";
				n = (n & 536870912) === n ? "Prepared" : (n & 201326741) === n ? "Hydrated" : "Render", i ? i.run(console.timeStamp.bind(console, n, e, t, Ng, Mg, a)) : console.timeStamp(n, e, t, Ng, Mg, a);
			}
		}
		function Kn(e, t, n, i) {
			!Ag || t <= e || (n = (n & 738197653) === n ? "tertiary-dark" : "primary-dark", i ? i.run(console.timeStamp.bind(console, "Prewarm", e, t, Ng, Mg, n)) : console.timeStamp("Prewarm", e, t, Ng, Mg, n));
		}
		function qn(e, t, n, i) {
			!Ag || t <= e || (n = (n & 738197653) === n ? "tertiary-dark" : "primary-dark", i ? i.run(console.timeStamp.bind(console, "Suspended", e, t, Ng, Mg, n)) : console.timeStamp("Suspended", e, t, Ng, Mg, n));
		}
		function Jn(e, t, n, i, a, o) {
			if (Ag && !(t <= e)) {
				n = [];
				for (var s = 0; s < i.length; s++) {
					var c = i[s].value;
					n.push(["Recoverable Error", typeof c == "object" && c && typeof c.message == "string" ? String(c.message) : String(c)]);
				}
				e = {
					start: e,
					end: t,
					detail: { devtools: {
						color: "primary-dark",
						track: Ng,
						trackGroup: Mg,
						tooltipText: a ? "Hydration Failed" : "Recovered after Error",
						properties: n
					} }
				}, o ? o.run(performance.measure.bind(performance, "Recovered", e)) : performance.measure("Recovered", e);
			}
		}
		function Yn(e, t, n, i) {
			!Ag || t <= e || (i ? i.run(console.timeStamp.bind(console, "Errored", e, t, Ng, Mg, "error")) : console.timeStamp("Errored", e, t, Ng, Mg, "error"));
		}
		function Xn(e, t, n, i) {
			!Ag || t <= e || (i ? i.run(console.timeStamp.bind(console, n, e, t, Ng, Mg, "secondary-light")) : console.timeStamp(n, e, t, Ng, Mg, "secondary-light"));
		}
		function Zn(e, t, n, i, a) {
			if (Ag && !(t <= e)) {
				for (var o = [], s = 0; s < n.length; s++) {
					var c = n[s].value;
					o.push(["Error", typeof c == "object" && c && typeof c.message == "string" ? String(c.message) : String(c)]);
				}
				e = {
					start: e,
					end: t,
					detail: { devtools: {
						color: "error",
						track: Ng,
						trackGroup: Mg,
						tooltipText: i ? "Remaining Effects Errored" : "Commit Errored",
						properties: o
					} }
				}, a ? a.run(performance.measure.bind(performance, "Errored", e)) : performance.measure("Errored", e);
			}
		}
		function Qn(e, t, n) {
			!Ag || t <= e || (n ? n.run(console.timeStamp.bind(console, "Animating", e, t, Ng, Mg, "secondary-dark")) : console.timeStamp("Animating", e, t, Ng, Mg, "secondary-dark"));
		}
		function $n() {
			for (var e = Ug, t = Wg = Ug = 0; t < e;) {
				var n = Hg[t];
				Hg[t++] = null;
				var i = Hg[t];
				Hg[t++] = null;
				var a = Hg[t];
				Hg[t++] = null;
				var o = Hg[t];
				if (Hg[t++] = null, i !== null && a !== null) {
					var s = i.pending;
					s === null ? a.next = a : (a.next = s.next, s.next = a), i.pending = a;
				}
				o !== 0 && rr(n, a, o);
			}
		}
		function er(e, t, n, i) {
			Hg[Ug++] = e, Hg[Ug++] = t, Hg[Ug++] = n, Hg[Ug++] = i, Wg |= i, e.lanes |= i, e = e.alternate, e !== null && (e.lanes |= i);
		}
		function tr(e, t, n, i) {
			return er(e, t, n, i), ir(e);
		}
		function nr(e, t) {
			return er(e, null, null, t), ir(e);
		}
		function rr(e, t, n) {
			e.lanes |= n;
			var i = e.alternate;
			i !== null && (i.lanes |= n);
			for (var a = !1, o = e.return; o !== null;) o.childLanes |= n, i = o.alternate, i !== null && (i.childLanes |= n), o.tag === 22 && (e = o.stateNode, e === null || e._visibility & Bg || (a = !0)), e = o, o = o.return;
			return e.tag === 3 ? (o = e.stateNode, a && t !== null && (a = 31 - Np(n), e = o.hiddenUpdates, i = e[a], i === null ? e[a] = [t] : i.push(t), t.lane = n | 536870912), o) : null;
		}
		function ir(e) {
			if (mS > pS) throw yS = mS = 0, bS = hS = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
			yS > vS && (yS = 0, bS = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.")), e.alternate === null && e.flags & 4098 && Rl(e);
			for (var t = e, n = t.return; n !== null;) t.alternate === null && t.flags & 4098 && Rl(e), t = n, n = t.return;
			return t.tag === 3 ? t.stateNode : null;
		}
		function ar(e) {
			if (Kg === null) return e;
			var t = Kg(e);
			return t === void 0 ? e : t.current;
		}
		function or(e) {
			if (Kg === null) return e;
			var t = Kg(e);
			return t === void 0 ? e != null && typeof e.render == "function" && (t = ar(e.render), e.render !== t) ? (t = {
				$$typeof: If,
				render: t
			}, e.displayName !== void 0 && (t.displayName = e.displayName), t) : e : t.current;
		}
		function sr(e, t) {
			if (Kg === null) return !1;
			var n = e.elementType;
			t = t.type;
			var i = !1, a = typeof t == "object" && t ? t.$$typeof : null;
			switch (e.tag) {
				case 1:
					typeof t == "function" && (i = !0);
					break;
				case 0:
					(typeof t == "function" || a === Bf) && (i = !0);
					break;
				case 11:
					(a === If || a === Bf) && (i = !0);
					break;
				case 14:
				case 15:
					(a === zf || a === Bf) && (i = !0);
					break;
				default: return !1;
			}
			return !!(i && (e = Kg(n), e !== void 0 && e === Kg(t)));
		}
		function cr(e) {
			Kg !== null && typeof WeakSet == "function" && (qg === null && (qg = /* @__PURE__ */ new WeakSet()), qg.add(e));
		}
		function lr(e, t, n) {
			do {
				var i = e, a = i.alternate, o = i.child, s = i.sibling, c = i.tag;
				i = i.type;
				var l = null;
				switch (c) {
					case 0:
					case 15:
					case 1:
						l = i;
						break;
					case 11: l = i.render;
				}
				if (Kg === null) throw Error("Expected resolveFamily to be set during hot reload.");
				var u = !1;
				if (i = !1, l !== null && (l = Kg(l), l !== void 0 && (n.has(l) ? i = !0 : t.has(l) && (c === 1 ? i = !0 : u = !0))), qg !== null && (qg.has(e) || a !== null && qg.has(a)) && (i = !0), i && (e._debugNeedsRemount = !0), (i || u) && (a = nr(e, 2), a !== null && Yc(a, e, 2)), o === null || i || lr(o, t, n), s === null) break;
				e = s;
			} while (1);
		}
		function ur(e, t, n, i) {
			this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null, this.actualDuration = -0, this.actualStartTime = -1.1, this.treeBaseDuration = this.selfBaseDuration = -0, this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, e_ || typeof Object.preventExtensions != "function" || Object.preventExtensions(this);
		}
		function dr(e) {
			return e = e.prototype, !(!e || !e.isReactComponent);
		}
		function fr(e, t) {
			var n = e.alternate;
			switch (n === null ? (n = g(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n._debugOwner = e._debugOwner, n._debugStack = e._debugStack, n._debugTask = e._debugTask, n._debugHookTypes = e._debugHookTypes, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null, n.actualDuration = -0, n.actualStartTime = -1.1), n.flags = e.flags & 65011712, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : {
				lanes: t.lanes,
				firstContext: t.firstContext,
				_debugThenableState: t._debugThenableState
			}, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n.refCleanup = e.refCleanup, n.selfBaseDuration = e.selfBaseDuration, n.treeBaseDuration = e.treeBaseDuration, n._debugInfo = e._debugInfo, n._debugNeedsRemount = e._debugNeedsRemount, n.tag) {
				case 0:
				case 15:
					n.type = ar(e.type);
					break;
				case 1:
					n.type = ar(e.type);
					break;
				case 11: n.type = or(e.type);
			}
			return n;
		}
		function pr(e, t) {
			e.flags &= 65011714;
			var n = e.alternate;
			return n === null ? (e.childLanes = 0, e.lanes = t, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null, e.selfBaseDuration = 0, e.treeBaseDuration = 0) : (e.childLanes = n.childLanes, e.lanes = n.lanes, e.child = n.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = n.memoizedProps, e.memoizedState = n.memoizedState, e.updateQueue = n.updateQueue, e.type = n.type, t = n.dependencies, e.dependencies = t === null ? null : {
				lanes: t.lanes,
				firstContext: t.firstContext,
				_debugThenableState: t._debugThenableState
			}, e.selfBaseDuration = n.selfBaseDuration, e.treeBaseDuration = n.treeBaseDuration), e;
		}
		function mr(e, t, n, i, a, o) {
			var s = 0, c = e;
			if (typeof e == "function") dr(e) && (s = 1), c = ar(c);
			else if (typeof e == "string") s = R(), s = Bd(e, n, s) ? 26 : e === "html" || e === "head" || e === "body" ? 27 : 5;
			else a: switch (e) {
				case Vf: return t = g(31, n, t, a), t.elementType = Vf, t.lanes = o, t;
				case jf: return gr(n.children, a, o, t);
				case Mf:
					s = 8, a |= Zg, a |= Qg;
					break;
				case Nf: return e = n, i = a, typeof e.id != "string" && console.error("Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.", typeof e.id), t = g(12, e, t, i | Xg), t.elementType = Nf, t.lanes = o, t.stateNode = {
					effectDuration: 0,
					passiveEffectDuration: 0
				}, t;
				case Lf: return t = g(13, n, t, a), t.elementType = Lf, t.lanes = o, t;
				case Rf: return t = g(19, n, t, a), t.elementType = Rf, t.lanes = o, t;
				default:
					if (typeof e == "object" && e) switch (e.$$typeof) {
						case Ff:
							s = 10;
							break a;
						case Pf:
							s = 9;
							break a;
						case If:
							s = 11, c = or(c);
							break a;
						case zf:
							s = 14;
							break a;
						case Bf:
							s = 16, c = null;
							break a;
					}
					c = "", (e === void 0 || typeof e == "object" && e && Object.keys(e).length === 0) && (c += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports."), e === null ? n = "null" : Gf(e) ? n = "array" : e !== void 0 && e.$$typeof === kf ? (n = "<" + (A(e.type) || "Unknown") + " />", c = " Did you accidentally export a JSX literal instead of a component?") : n = typeof e, (s = i ? j(i) : null) && (c += "\n\nCheck the render method of `" + s + "`."), s = 29, n = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (n + "." + c)), c = null;
			}
			return t = g(s, n, t, a), t.elementType = e, t.type = c, t.lanes = o, t._debugOwner = i, t;
		}
		function hr(e, t, n) {
			return t = mr(e.type, e.key, e.props, e._owner, t, n), t._debugOwner = e._owner, t._debugStack = e._debugStack, t._debugTask = e._debugTask, t;
		}
		function gr(e, t, n, i) {
			return e = g(7, e, i, t), e.lanes = n, e;
		}
		function _r(e, t, n) {
			return e = g(6, e, null, t), e.lanes = n, e;
		}
		function vr(e) {
			var t = g(18, null, null, Jg);
			return t.stateNode = e, t;
		}
		function yr(e, t, n) {
			return t = g(4, e.children === null ? [] : e.children, e.key, t), t.lanes = n, t.stateNode = {
				containerInfo: e.containerInfo,
				pendingChildren: null,
				implementation: e.implementation
			}, t;
		}
		function br(e, t) {
			if (typeof e == "object" && e) {
				var n = n_.get(e);
				return n === void 0 ? (t = {
					value: e,
					source: t,
					stack: ue(t)
				}, n_.set(e, t), t) : n;
			}
			return {
				value: e,
				source: t,
				stack: ue(t)
			};
		}
		function xr(e, t) {
			Dr(), r_[i_++] = o_, r_[i_++] = a_, a_ = e, o_ = t;
		}
		function Sr(e, t, n) {
			Dr(), s_[c_++] = u_, s_[c_++] = d_, s_[c_++] = l_, l_ = e;
			var i = u_;
			e = d_;
			var a = 32 - Np(i) - 1;
			i &= ~(1 << a), n += 1;
			var o = 32 - Np(t) + a;
			if (30 < o) {
				var s = a - a % 5;
				o = (i & (1 << s) - 1).toString(32), i >>= s, a -= s, u_ = 1 << 32 - Np(t) + a | n << a | i, d_ = o + e;
			} else u_ = 1 << o | n << a | i, d_ = e;
		}
		function Cr(e) {
			Dr(), e.return !== null && (xr(e, 1), Sr(e, 1, 0));
		}
		function wr(e) {
			for (; e === a_;) a_ = r_[--i_], r_[i_] = null, o_ = r_[--i_], r_[i_] = null;
			for (; e === l_;) l_ = s_[--c_], s_[c_] = null, d_ = s_[--c_], s_[c_] = null, u_ = s_[--c_], s_[c_] = null;
		}
		function Tr() {
			return Dr(), l_ === null ? null : {
				id: u_,
				overflow: d_
			};
		}
		function Er(e, t) {
			Dr(), s_[c_++] = u_, s_[c_++] = d_, s_[c_++] = l_, u_ = t.id, d_ = t.overflow, l_ = e;
		}
		function Dr() {
			m_ || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
		}
		function Or(e, t) {
			if (e.return === null) {
				if (g_ === null) g_ = {
					fiber: e,
					children: [],
					serverProps: void 0,
					serverTail: [],
					distanceFromLeaf: t
				};
				else {
					if (g_.fiber !== e) throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
					g_.distanceFromLeaf > t && (g_.distanceFromLeaf = t);
				}
				return g_;
			}
			var n = Or(e.return, t + 1).children;
			return 0 < n.length && n[n.length - 1].fiber === e ? (n = n[n.length - 1], n.distanceFromLeaf > t && (n.distanceFromLeaf = t), n) : (t = {
				fiber: e,
				children: [],
				serverProps: void 0,
				serverTail: [],
				distanceFromLeaf: t
			}, n.push(t), t);
		}
		function kr() {
			m_ && console.error("We should not be hydrating here. This is a bug in React. Please file a bug.");
		}
		function Ar(e, t) {
			h_ || (e = Or(e, 0), e.serverProps = null, t !== null && (t = md(t), e.serverTail.push(t)));
		}
		function jr(e) {
			var t = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : !1, n = "", i = g_;
			throw i !== null && (g_ = null, n = At(i)), Lr(br(Error("Hydration failed because the server rendered " + (t ? "text" : "HTML") + " didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + n), e)), y_;
		}
		function Mr(e) {
			var t = e.stateNode, n = e.type, i = e.memoizedProps;
			switch (t[Wp] = e, t[Gp] = i, fu(n, i), n) {
				case "dialog":
					ru("cancel", t), ru("close", t);
					break;
				case "iframe":
				case "object":
				case "embed":
					ru("load", t);
					break;
				case "video":
				case "audio":
					for (n = 0; n < PS.length; n++) ru(PS[n], t);
					break;
				case "source":
					ru("error", t);
					break;
				case "img":
				case "image":
				case "link":
					ru("error", t), ru("load", t);
					break;
				case "details":
					ru("toggle", t);
					break;
				case "input":
					Ke("input", i), ru("invalid", t), it(t, i), ot(t, i.value, i.defaultValue, i.checked, i.defaultChecked, i.type, i.name, !0);
					break;
				case "option":
					ct(t, i);
					break;
				case "select":
					Ke("select", i), ru("invalid", t), dt(t, i);
					break;
				case "textarea": Ke("textarea", i), ru("invalid", t), ft(t, i), mt(t, i.value, i.defaultValue, i.children);
			}
			n = i.children, typeof n != "string" && typeof n != "number" && typeof n != "bigint" || t.textContent === "" + n || !0 === i.suppressHydrationWarning || vu(t.textContent, n) ? (i.popover != null && (ru("beforetoggle", t), ru("toggle", t)), i.onScroll != null && ru("scroll", t), i.onScrollEnd != null && ru("scrollend", t), i.onClick != null && (t.onclick = Yt), t = !0) : t = !1, t || jr(e, !0);
		}
		function Nr(e) {
			for (f_ = e.return; f_;) switch (f_.tag) {
				case 5:
				case 31:
				case 13:
					v_ = !1;
					return;
				case 27:
				case 3:
					v_ = !0;
					return;
				default: f_ = f_.return;
			}
		}
		function Pr(e) {
			if (e !== f_) return !1;
			if (!m_) return Nr(e), m_ = !0, !1;
			var t = e.tag, n;
			if ((n = t !== 3 && t !== 27) && ((n = t === 5) && (n = e.type, n = !(n !== "form" && n !== "button") || Ru(e.type, e.memoizedProps)), n = !n), n && p_) {
				for (n = p_; n;) {
					var i = Or(e, 0), a = md(n);
					i.serverTail.push(a), n = a.type === "Suspense" ? gd(n) : pd(n.nextSibling);
				}
				jr(e);
			}
			if (Nr(e), t === 13) {
				if (e = e.memoizedState, e = e === null ? null : e.dehydrated, !e) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
				p_ = gd(e);
			} else if (t === 31) {
				if (e = e.memoizedState, e = e === null ? null : e.dehydrated, !e) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
				p_ = gd(e);
			} else t === 27 ? (t = p_, Yu(e.type) ? (e = wC, wC = null, p_ = e) : p_ = t) : p_ = f_ ? pd(e.stateNode.nextSibling) : null;
			return !0;
		}
		function Fr() {
			p_ = f_ = null, h_ = m_ = !1;
		}
		function Ir() {
			var e = __;
			return e !== null && (Ix === null ? Ix = e : Ix.push.apply(Ix, e), __ = null), e;
		}
		function Lr(e) {
			__ === null ? __ = [e] : __.push(e);
		}
		function Rr() {
			var e = g_;
			if (e !== null) {
				g_ = null;
				for (var t = At(e); 0 < e.children.length;) e = e.children[0];
				V(e.fiber, function() {
					console.error("A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s", "https://react.dev/link/hydration-mismatch", t);
				});
			}
		}
		function zr() {
			w_ = C_ = null, T_ = !1;
		}
		function Br(e, t, n) {
			F(b_, t._currentValue, e), t._currentValue = n, F(x_, t._currentRenderer, e), t._currentRenderer !== void 0 && t._currentRenderer !== null && t._currentRenderer !== S_ && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), t._currentRenderer = S_;
		}
		function Vr(e, t) {
			e._currentValue = b_.current;
			var n = x_.current;
			P(x_, t), e._currentRenderer = n, P(b_, t);
		}
		function Hr(e, t, n) {
			for (; e !== null;) {
				var i = e.alternate;
				if ((e.childLanes & t) === t ? i !== null && (i.childLanes & t) !== t && (i.childLanes |= t) : (e.childLanes |= t, i !== null && (i.childLanes |= t)), e === n) break;
				e = e.return;
			}
			e !== n && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
		}
		function Ur(e, t, n, i) {
			var a = e.child;
			for (a !== null && (a.return = e); a !== null;) {
				var o = a.dependencies;
				if (o !== null) {
					var s = a.child;
					o = o.firstContext;
					a: for (; o !== null;) {
						var c = o;
						o = a;
						for (var l = 0; l < t.length; l++) if (c.context === t[l]) {
							o.lanes |= n, c = o.alternate, c !== null && (c.lanes |= n), Hr(o.return, n, e), i || (s = null);
							break a;
						}
						o = c.next;
					}
				} else if (a.tag === 18) {
					if (s = a.return, s === null) throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
					s.lanes |= n, o = s.alternate, o !== null && (o.lanes |= n), Hr(s, n, e), s = null;
				} else s = a.child;
				if (s !== null) s.return = a;
				else for (s = a; s !== null;) {
					if (s === e) {
						s = null;
						break;
					}
					if (a = s.sibling, a !== null) {
						a.return = s.return, s = a;
						break;
					}
					s = s.return;
				}
				a = s;
			}
		}
		function Wr(e, t, n, i) {
			e = null;
			for (var a = t, o = !1; a !== null;) {
				if (!o) {
					if (a.flags & 524288) o = !0;
					else if (a.flags & 262144) break;
				}
				if (a.tag === 10) {
					var s = a.alternate;
					if (s === null) throw Error("Should have a current fiber. This is a bug in React.");
					if (s = s.memoizedProps, s !== null) {
						var c = a.type;
						$h(a.pendingProps.value, s.value) || (e === null ? e = [c] : e.push(c));
					}
				} else if (a === ep.current) {
					if (s = a.alternate, s === null) throw Error("Should have a current fiber. This is a bug in React.");
					s.memoizedState.memoizedState !== a.memoizedState.memoizedState && (e === null ? e = [HC] : e.push(HC));
				}
				a = a.return;
			}
			e !== null && Ur(t, e, n, i), t.flags |= 262144;
		}
		function Gr(e) {
			for (e = e.firstContext; e !== null;) {
				if (!$h(e.context._currentValue, e.memoizedValue)) return !0;
				e = e.next;
			}
			return !1;
		}
		function Kr(e) {
			C_ = e, w_ = null, e = e.dependencies, e !== null && (e.firstContext = null);
		}
		function qr(e) {
			return T_ && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."), Yr(C_, e);
		}
		function Jr(e, t) {
			return C_ === null && Kr(e), Yr(e, t);
		}
		function Yr(e, t) {
			var n = t._currentValue;
			if (t = {
				context: t,
				memoizedValue: n,
				next: null
			}, w_ === null) {
				if (e === null) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
				w_ = t, e.dependencies = {
					lanes: 0,
					firstContext: t,
					_debugThenableState: null
				}, e.flags |= 524288;
			} else w_ = w_.next = t;
			return n;
		}
		function Xr() {
			return {
				controller: new E_(),
				data: /* @__PURE__ */ new Map(),
				refCount: 0
			};
		}
		function Zr(e) {
			e.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React."), e.refCount++;
		}
		function Qr(e) {
			e.refCount--, 0 > e.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React."), e.refCount === 0 && D_(O_, function() {
				e.controller.abort();
			});
		}
		function $r(e, t, n) {
			e & 127 ? 0 > K_ && (K_ = A_(), q_ = j_(t), Y_ = t, n != null && (X_ = M(n)), (lx & ($b | ex)) !== Qb && (W_ = !0, J_ = M_), e = Vu(), t = Bu(), e !== $_ || t !== Q_ ? $_ = -1.1 : t !== null && (J_ = M_), Z_ = e, Q_ = t) : e & 4194048 && 0 > rv && (rv = A_(), av = j_(t), ov = t, n != null && (sv = M(n)), 0 > nv) && (e = Vu(), t = Bu(), (e !== uv || t !== lv) && (uv = -1.1), cv = e, lv = t);
		}
		function ei(e) {
			if (0 > K_) {
				K_ = A_(), q_ = e._debugTask == null ? null : e._debugTask, (lx & ($b | ex)) !== Qb && (J_ = M_);
				var t = Vu(), n = Bu();
				t !== $_ || n !== Q_ ? $_ = -1.1 : n !== null && (J_ = M_), Z_ = t, Q_ = n;
			}
			0 > rv && (rv = A_(), av = e._debugTask == null ? null : e._debugTask, 0 > nv) && (e = Vu(), t = Bu(), (e !== uv || t !== lv) && (uv = -1.1), cv = e, lv = t);
		}
		function ti() {
			var e = z_;
			return z_ = 0, e;
		}
		function ni(e) {
			var t = z_;
			return z_ = e, t;
		}
		function ri(e) {
			var t = z_;
			return z_ += e, t;
		}
		function ii() {
			H_ = V_ = -1.1;
		}
		function ai() {
			var e = V_;
			return V_ = -1.1, e;
		}
		function oi(e) {
			0 <= e && (V_ = e);
		}
		function si() {
			var e = B_;
			return B_ = -0, e;
		}
		function ci(e) {
			0 <= e && (B_ = e);
		}
		function li() {
			var e = U_;
			return U_ = null, e;
		}
		function ui() {
			var e = W_;
			return W_ = !1, e;
		}
		function di(e) {
			R_ = A_(), 0 > e.actualStartTime && (e.actualStartTime = R_);
		}
		function fi(e) {
			if (0 <= R_) {
				var t = A_() - R_;
				e.actualDuration += t, e.selfBaseDuration = t, R_ = -1;
			}
		}
		function pi(e) {
			if (0 <= R_) {
				var t = A_() - R_;
				e.actualDuration += t, R_ = -1;
			}
		}
		function mi() {
			if (0 <= R_) {
				var e = A_(), t = e - R_;
				R_ = -1, z_ += t, B_ += t, H_ = e;
			}
		}
		function hi(e) {
			U_ === null && (U_ = []), U_.push(e), L_ === null && (L_ = []), L_.push(e);
		}
		function gi() {
			R_ = A_(), 0 > V_ && (V_ = R_);
		}
		function _i(e) {
			for (var t = e.child; t;) e.actualDuration += t.actualDuration, t = t.sibling;
		}
		function vi(e, t) {
			if (bv === null) {
				var n = bv = [];
				xv = 0, Sv = Zl(), Cv = {
					status: "pending",
					value: void 0,
					then: function(e) {
						n.push(e);
					}
				};
			}
			return xv++, t.then(yi, yi), t;
		}
		function yi() {
			if (--xv === 0 && (-1 < rv || (nv = -1.1), bv !== null)) {
				Cv !== null && (Cv.status = "fulfilled");
				var e = bv;
				bv = null, Sv = 0, Cv = null;
				for (var t = 0; t < e.length; t++) (0, e[t])();
			}
		}
		function bi(e, t) {
			var n = [], i = {
				status: "pending",
				value: null,
				reason: null,
				then: function(e) {
					n.push(e);
				}
			};
			return e.then(function() {
				i.status = "fulfilled", i.value = t;
				for (var e = 0; e < n.length; e++) (0, n[e])(t);
			}, function(e) {
				for (i.status = "rejected", i.reason = e, e = 0; e < n.length; e++) (0, n[e])(void 0);
			}), i;
		}
		function xi() {
			var e = Tv.current;
			return e === null ? ux.pooledCache : e;
		}
		function Si(e, t) {
			t === null ? F(Tv, Tv.current, e) : F(Tv, t.pool, e);
		}
		function Ci() {
			var e = xi();
			return e === null ? null : {
				parent: k_._currentValue,
				pool: e
			};
		}
		function wi() {
			return {
				didWarnAboutUncachedPromise: !1,
				thenables: []
			};
		}
		function Ti(e) {
			return e = e.status, e === "fulfilled" || e === "rejected";
		}
		function Ei(e, t, n) {
			Q.actQueue !== null && (Q.didUsePromise = !0);
			var i = e.thenables;
			if (n = i[n], n === void 0 ? i.push(t) : n !== t && (e.didWarnAboutUncachedPromise || (e.didWarnAboutUncachedPromise = !0, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), t.then(Yt, Yt), t = n), t._debugInfo === void 0) {
				e = performance.now(), i = t.displayName;
				var a = {
					name: typeof i == "string" ? i : "Promise",
					start: e,
					end: e,
					value: t
				};
				t._debugInfo = [{ awaited: a }], t.status !== "fulfilled" && t.status !== "rejected" && (e = function() {
					a.end = performance.now();
				}, t.then(e, e));
			}
			switch (t.status) {
				case "fulfilled": return t.value;
				case "rejected": throw e = t.reason, ki(e), e;
				default:
					if (typeof t.status == "string") t.then(Yt, Yt);
					else {
						if (e = ux, e !== null && 100 < e.shellSuspendCounter) throw Error("An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
						e = t, e.status = "pending", e.then(function(e) {
							if (t.status === "pending") {
								var n = t;
								n.status = "fulfilled", n.value = e;
							}
						}, function(e) {
							if (t.status === "pending") {
								var n = t;
								n.status = "rejected", n.reason = e;
							}
						});
					}
					switch (t.status) {
						case "fulfilled": return t.value;
						case "rejected": throw e = t.reason, ki(e), e;
					}
					throw iy = t, ay = !0, ey;
			}
		}
		function Di(e) {
			try {
				return $v(e);
			} catch (e) {
				throw typeof e == "object" && e && typeof e.then == "function" ? (iy = e, ay = !0, ey) : e;
			}
		}
		function Oi() {
			if (iy === null) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
			var e = iy;
			return iy = null, ay = !1, e;
		}
		function ki(e) {
			if (e === ey || e === ny) throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
		}
		function Ai(e) {
			var t = cy;
			return e != null && (cy = t === null ? e : t.concat(e)), t;
		}
		function ji() {
			var e = cy;
			if (e != null) {
				for (var t = e.length - 1; 0 <= t; t--) if (e[t].name != null) {
					var n = e[t].debugTask;
					if (n != null) return n;
				}
			}
			return null;
		}
		function Mi(e, t, n) {
			for (var i = Object.keys(e.props), a = 0; a < i.length; a++) {
				var o = i[a];
				if (o !== "children" && o !== "key") {
					t === null && (t = hr(e, n.mode, 0), t._debugInfo = cy, t.return = n), V(t, function(e) {
						console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", e);
					}, o);
					break;
				}
			}
		}
		function Ni(e) {
			var t = sy;
			return sy += 1, oy === null && (oy = wi()), Ei(oy, e, t);
		}
		function Pi(e, t) {
			t = t.props.ref, e.ref = t === void 0 ? null : t;
		}
		function Fi(e, t) {
			throw t.$$typeof === Of ? Error("A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the \"react\" package is used.\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\n- A compiler tries to \"inline\" JSX instead of using the runtime.") : (e = Object.prototype.toString.call(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."));
		}
		function Ii(e, t) {
			var n = ji();
			n === null ? Fi(e, t) : n.run(Fi.bind(null, e, t));
		}
		function Li(e, t) {
			var n = M(e) || "Component";
			fy[n] || (fy[n] = !0, t = t.displayName || t.name || "Component", e.tag === 3 ? console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)", t, t, t) : console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>", t, t, n, t, n));
		}
		function Ri(e, t) {
			var n = ji();
			n === null ? Li(e, t) : n.run(Li.bind(null, e, t));
		}
		function zi(e, t) {
			var n = M(e) || "Component";
			py[n] || (py[n] = !0, t = String(t), e.tag === 3 ? console.error("Symbols are not valid as a React child.\n  root.render(%s)", t) : console.error("Symbols are not valid as a React child.\n  <%s>%s</%s>", n, t, n));
		}
		function Bi(e, t) {
			var n = ji();
			n === null ? zi(e, t) : n.run(zi.bind(null, e, t));
		}
		function Vi(e) {
			function t(t, n) {
				if (e) {
					var i = t.deletions;
					i === null ? (t.deletions = [n], t.flags |= 16) : i.push(n);
				}
			}
			function n(n, i) {
				if (!e) return null;
				for (; i !== null;) t(n, i), i = i.sibling;
				return null;
			}
			function i(e) {
				for (var t = /* @__PURE__ */ new Map(); e !== null;) e.key === null ? t.set(e.index, e) : t.set(e.key, e), e = e.sibling;
				return t;
			}
			function a(e, t) {
				return e = fr(e, t), e.index = 0, e.sibling = null, e;
			}
			function o(t, n, i) {
				return t.index = i, e ? (i = t.alternate, i === null ? (t.flags |= 67108866, n) : (i = i.index, i < n ? (t.flags |= 67108866, n) : i)) : (t.flags |= 1048576, n);
			}
			function s(t) {
				return e && t.alternate === null && (t.flags |= 67108866), t;
			}
			function c(e, t, n, i) {
				return t === null || t.tag !== 6 ? (t = _r(n, e.mode, i), t.return = e, t._debugOwner = e, t._debugTask = e._debugTask, t._debugInfo = cy, t) : (t = a(t, n), t.return = e, t._debugInfo = cy, t);
			}
			function l(e, t, n, i) {
				var o = n.type;
				return o === jf ? (t = d(e, t, n.props.children, i, n.key), Mi(n, t, e), t) : t !== null && (t.elementType === o || sr(t, n) || typeof o == "object" && o && o.$$typeof === Bf && Di(o) === t.type) ? (t = a(t, n.props), Pi(t, n), t.return = e, t._debugOwner = n._owner, t._debugInfo = cy, t) : (t = hr(n, e.mode, i), Pi(t, n), t.return = e, t._debugInfo = cy, t);
			}
			function u(e, t, n, i) {
				return t === null || t.tag !== 4 || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? (t = yr(n, e.mode, i), t.return = e, t._debugInfo = cy, t) : (t = a(t, n.children || []), t.return = e, t._debugInfo = cy, t);
			}
			function d(e, t, n, i, o) {
				return t === null || t.tag !== 7 ? (t = gr(n, e.mode, i, o), t.return = e, t._debugOwner = e, t._debugTask = e._debugTask, t._debugInfo = cy, t) : (t = a(t, n), t.return = e, t._debugInfo = cy, t);
			}
			function f(e, t, n) {
				if (typeof t == "string" && t !== "" || typeof t == "number" || typeof t == "bigint") return t = _r("" + t, e.mode, n), t.return = e, t._debugOwner = e, t._debugTask = e._debugTask, t._debugInfo = cy, t;
				if (typeof t == "object" && t) {
					switch (t.$$typeof) {
						case kf: return n = hr(t, e.mode, n), Pi(n, t), n.return = e, e = Ai(t._debugInfo), n._debugInfo = cy, cy = e, n;
						case Af: return t = yr(t, e.mode, n), t.return = e, t._debugInfo = cy, t;
						case Bf:
							var i = Ai(t._debugInfo);
							return t = Di(t), e = f(e, t, n), cy = i, e;
					}
					if (Gf(t) || k(t)) return n = gr(t, e.mode, n, null), n.return = e, n._debugOwner = e, n._debugTask = e._debugTask, e = Ai(t._debugInfo), n._debugInfo = cy, cy = e, n;
					if (typeof t.then == "function") return i = Ai(t._debugInfo), e = f(e, Ni(t), n), cy = i, e;
					if (t.$$typeof === Ff) return f(e, Jr(e, t), n);
					Ii(e, t);
				}
				return typeof t == "function" && Ri(e, t), typeof t == "symbol" && Bi(e, t), null;
			}
			function m(e, t, n, i) {
				var a = t === null ? null : t.key;
				if (typeof n == "string" && n !== "" || typeof n == "number" || typeof n == "bigint") return a === null ? c(e, t, "" + n, i) : null;
				if (typeof n == "object" && n) {
					switch (n.$$typeof) {
						case kf: return n.key === a ? (a = Ai(n._debugInfo), e = l(e, t, n, i), cy = a, e) : null;
						case Af: return n.key === a ? u(e, t, n, i) : null;
						case Bf: return a = Ai(n._debugInfo), n = Di(n), e = m(e, t, n, i), cy = a, e;
					}
					if (Gf(n) || k(n)) return a === null ? (a = Ai(n._debugInfo), e = d(e, t, n, i, null), cy = a, e) : null;
					if (typeof n.then == "function") return a = Ai(n._debugInfo), e = m(e, t, Ni(n), i), cy = a, e;
					if (n.$$typeof === Ff) return m(e, t, Jr(e, n), i);
					Ii(e, n);
				}
				return typeof n == "function" && Ri(e, n), typeof n == "symbol" && Bi(e, n), null;
			}
			function h(e, t, n, i, a) {
				if (typeof i == "string" && i !== "" || typeof i == "number" || typeof i == "bigint") return e = e.get(n) || null, c(t, e, "" + i, a);
				if (typeof i == "object" && i) {
					switch (i.$$typeof) {
						case kf: return n = e.get(i.key === null ? n : i.key) || null, e = Ai(i._debugInfo), t = l(t, n, i, a), cy = e, t;
						case Af: return e = e.get(i.key === null ? n : i.key) || null, u(t, e, i, a);
						case Bf:
							var o = Ai(i._debugInfo);
							return i = Di(i), t = h(e, t, n, i, a), cy = o, t;
					}
					if (Gf(i) || k(i)) return n = e.get(n) || null, e = Ai(i._debugInfo), t = d(t, n, i, a, null), cy = e, t;
					if (typeof i.then == "function") return o = Ai(i._debugInfo), t = h(e, t, n, Ni(i), a), cy = o, t;
					if (i.$$typeof === Ff) return h(e, t, n, Jr(t, i), a);
					Ii(t, i);
				}
				return typeof i == "function" && Ri(t, i), typeof i == "symbol" && Bi(t, i), null;
			}
			function _(e, t, n, i) {
				if (typeof n != "object" || !n) return i;
				switch (n.$$typeof) {
					case kf:
					case Af:
						p(e, t, n);
						var a = n.key;
						if (typeof a != "string") break;
						if (i === null) {
							i = /* @__PURE__ */ new Set(), i.add(a);
							break;
						}
						if (!i.has(a)) {
							i.add(a);
							break;
						}
						V(t, function() {
							console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", a);
						});
						break;
					case Bf: n = Di(n), _(e, t, n, i);
				}
				return i;
			}
			function v(a, s, c, l) {
				for (var u = null, d = null, p = null, g = s, v = s = 0, y = null; g !== null && v < c.length; v++) {
					g.index > v ? (y = g, g = null) : y = g.sibling;
					var b = m(a, g, c[v], l);
					if (b === null) {
						g === null && (g = y);
						break;
					}
					u = _(a, b, c[v], u), e && g && b.alternate === null && t(a, g), s = o(b, s, v), p === null ? d = b : p.sibling = b, p = b, g = y;
				}
				if (v === c.length) return n(a, g), m_ && xr(a, v), d;
				if (g === null) {
					for (; v < c.length; v++) g = f(a, c[v], l), g !== null && (u = _(a, g, c[v], u), s = o(g, s, v), p === null ? d = g : p.sibling = g, p = g);
					return m_ && xr(a, v), d;
				}
				for (g = i(g); v < c.length; v++) y = h(g, a, v, c[v], l), y !== null && (u = _(a, y, c[v], u), e && y.alternate !== null && g.delete(y.key === null ? v : y.key), s = o(y, s, v), p === null ? d = y : p.sibling = y, p = y);
				return e && g.forEach(function(e) {
					return t(a, e);
				}), m_ && xr(a, v), d;
			}
			function y(a, s, c, l) {
				if (c == null) throw Error("An iterable object provided no iterator.");
				for (var u = null, d = null, p = s, g = s = 0, v = null, y = null, b = c.next(); p !== null && !b.done; g++, b = c.next()) {
					p.index > g ? (v = p, p = null) : v = p.sibling;
					var x = m(a, p, b.value, l);
					if (x === null) {
						p === null && (p = v);
						break;
					}
					y = _(a, x, b.value, y), e && p && x.alternate === null && t(a, p), s = o(x, s, g), d === null ? u = x : d.sibling = x, d = x, p = v;
				}
				if (b.done) return n(a, p), m_ && xr(a, g), u;
				if (p === null) {
					for (; !b.done; g++, b = c.next()) p = f(a, b.value, l), p !== null && (y = _(a, p, b.value, y), s = o(p, s, g), d === null ? u = p : d.sibling = p, d = p);
					return m_ && xr(a, g), u;
				}
				for (p = i(p); !b.done; g++, b = c.next()) v = h(p, a, g, b.value, l), v !== null && (y = _(a, v, b.value, y), e && v.alternate !== null && p.delete(v.key === null ? g : v.key), s = o(v, s, g), d === null ? u = v : d.sibling = v, d = v);
				return e && p.forEach(function(e) {
					return t(a, e);
				}), m_ && xr(a, g), u;
			}
			function b(e, i, o, c) {
				if (typeof o == "object" && o && o.type === jf && o.key === null && (Mi(o, null, e), o = o.props.children), typeof o == "object" && o) {
					switch (o.$$typeof) {
						case kf:
							var l = Ai(o._debugInfo);
							a: {
								for (var u = o.key; i !== null;) {
									if (i.key === u) {
										if (u = o.type, u === jf) {
											if (i.tag === 7) {
												n(e, i.sibling), c = a(i, o.props.children), c.return = e, c._debugOwner = o._owner, c._debugInfo = cy, Mi(o, c, e), e = c;
												break a;
											}
										} else if (i.elementType === u || sr(i, o) || typeof u == "object" && u && u.$$typeof === Bf && Di(u) === i.type) {
											n(e, i.sibling), c = a(i, o.props), Pi(c, o), c.return = e, c._debugOwner = o._owner, c._debugInfo = cy, e = c;
											break a;
										}
										n(e, i);
										break;
									} else t(e, i);
									i = i.sibling;
								}
								o.type === jf ? (c = gr(o.props.children, e.mode, c, o.key), c.return = e, c._debugOwner = e, c._debugTask = e._debugTask, c._debugInfo = cy, Mi(o, c, e), e = c) : (c = hr(o, e.mode, c), Pi(c, o), c.return = e, c._debugInfo = cy, e = c);
							}
							return e = s(e), cy = l, e;
						case Af:
							a: {
								for (l = o, o = l.key; i !== null;) {
									if (i.key === o) if (i.tag === 4 && i.stateNode.containerInfo === l.containerInfo && i.stateNode.implementation === l.implementation) {
										n(e, i.sibling), c = a(i, l.children || []), c.return = e, e = c;
										break a;
									} else {
										n(e, i);
										break;
									}
									else t(e, i);
									i = i.sibling;
								}
								c = yr(l, e.mode, c), c.return = e, e = c;
							}
							return s(e);
						case Bf: return l = Ai(o._debugInfo), o = Di(o), e = b(e, i, o, c), cy = l, e;
					}
					if (Gf(o)) return l = Ai(o._debugInfo), e = v(e, i, o, c), cy = l, e;
					if (k(o)) {
						if (l = Ai(o._debugInfo), u = k(o), typeof u != "function") throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
						var d = u.call(o);
						return d === o ? (e.tag !== 0 || Object.prototype.toString.call(e.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(d) !== "[object Generator]") && (uy || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), uy = !0) : o.entries !== u || ly || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ly = !0), e = y(e, i, d, c), cy = l, e;
					}
					if (typeof o.then == "function") return l = Ai(o._debugInfo), e = b(e, i, Ni(o), c), cy = l, e;
					if (o.$$typeof === Ff) return b(e, i, Jr(e, o), c);
					Ii(e, o);
				}
				return typeof o == "string" && o !== "" || typeof o == "number" || typeof o == "bigint" ? (l = "" + o, i !== null && i.tag === 6 ? (n(e, i.sibling), c = a(i, l), c.return = e, e = c) : (n(e, i), c = _r(l, e.mode, c), c.return = e, c._debugOwner = e, c._debugTask = e._debugTask, c._debugInfo = cy, e = c), s(e)) : (typeof o == "function" && Ri(e, o), typeof o == "symbol" && Bi(e, o), n(e, i));
			}
			return function(e, t, n, i) {
				var a = cy;
				cy = null;
				try {
					sy = 0;
					var o = b(e, t, n, i);
					return oy = null, o;
				} catch (t) {
					if (t === ey || t === ny) throw t;
					var s = g(29, t, null, e.mode);
					s.lanes = i, s.return = e;
					var c = s._debugInfo = cy;
					if (s._debugOwner = e._debugOwner, s._debugTask = e._debugTask, c != null) {
						for (var l = c.length - 1; 0 <= l; l--) if (typeof c[l].stack == "string") {
							s._debugOwner = c[l], s._debugTask = c[l].debugTask;
							break;
						}
					}
					return s;
				} finally {
					cy = a;
				}
			};
		}
		function Hi(e, t) {
			var n = Gf(e);
			return e = !n && typeof k(e) == "function", n || e ? (n = n ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", n, t, n), !1) : !0;
		}
		function Ui(e) {
			e.updateQueue = {
				baseState: e.memoizedState,
				firstBaseUpdate: null,
				lastBaseUpdate: null,
				shared: {
					pending: null,
					lanes: 0,
					hiddenCallbacks: null
				},
				callbacks: null
			};
		}
		function Wi(e, t) {
			e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
				baseState: e.baseState,
				firstBaseUpdate: e.firstBaseUpdate,
				lastBaseUpdate: e.lastBaseUpdate,
				shared: e.shared,
				callbacks: null
			});
		}
		function Gi(e) {
			return {
				lane: e,
				tag: gy,
				payload: null,
				callback: null,
				next: null
			};
		}
		function Ki(e, t, n) {
			var i = e.updateQueue;
			if (i === null) return null;
			if (i = i.shared, Sy === i && !xy) {
				var a = M(e);
				console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s", a), xy = !0;
			}
			return (lx & $b) === Qb ? (er(e, i, t, n), ir(e)) : (a = i.pending, a === null ? t.next = t : (t.next = a.next, a.next = t), i.pending = t, t = ir(e), rr(e, null, n), t);
		}
		function qi(e, t, n) {
			if (t = t.updateQueue, t !== null && (t = t.shared, n & 4194048)) {
				var i = t.lanes;
				i &= e.pendingLanes, n |= i, t.lanes = n, Me(e, n);
			}
		}
		function Ji(e, t) {
			var n = e.updateQueue, i = e.alternate;
			if (i !== null && (i = i.updateQueue, n === i)) {
				var a = null, o = null;
				if (n = n.firstBaseUpdate, n !== null) {
					do {
						var s = {
							lane: n.lane,
							tag: n.tag,
							payload: n.payload,
							callback: null,
							next: null
						};
						o === null ? a = o = s : o = o.next = s, n = n.next;
					} while (n !== null);
					o === null ? a = o = t : o = o.next = t;
				} else a = o = t;
				n = {
					baseState: i.baseState,
					firstBaseUpdate: a,
					lastBaseUpdate: o,
					shared: i.shared,
					callbacks: i.callbacks
				}, e.updateQueue = n;
				return;
			}
			e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t;
		}
		function Yi() {
			if (Cy) {
				var e = Cv;
				if (e !== null) throw e;
			}
		}
		function Xi(e, t, n, i) {
			Cy = !1;
			var a = e.updateQueue;
			by = !1, Sy = a.shared;
			var o = a.firstBaseUpdate, s = a.lastBaseUpdate, c = a.shared.pending;
			if (c !== null) {
				a.shared.pending = null;
				var l = c, u = l.next;
				l.next = null, s === null ? o = u : s.next = u, s = l;
				var d = e.alternate;
				d !== null && (d = d.updateQueue, c = d.lastBaseUpdate, c !== s && (c === null ? d.firstBaseUpdate = u : c.next = u, d.lastBaseUpdate = l));
			}
			if (o !== null) {
				var f = a.baseState;
				s = 0, d = u = l = null, c = o;
				do {
					var p = c.lane & -536870913, m = p !== c.lane;
					if (m ? (fx & p) === p : (i & p) === p) {
						p !== 0 && p === Sv && (Cy = !0), d !== null && (d = d.next = {
							lane: 0,
							tag: c.tag,
							payload: c.payload,
							callback: null,
							next: null
						});
						a: {
							p = e;
							var h = c, g = t, _ = n;
							switch (h.tag) {
								case _y:
									if (h = h.payload, typeof h == "function") {
										T_ = !0;
										var v = h.call(_, f, g);
										if (p.mode & Zg) {
											xe(!0);
											try {
												h.call(_, f, g);
											} finally {
												xe(!1);
											}
										}
										T_ = !1, f = v;
										break a;
									}
									f = h;
									break a;
								case yy: p.flags = p.flags & -65537 | 128;
								case gy:
									if (v = h.payload, typeof v == "function") {
										if (T_ = !0, h = v.call(_, f, g), p.mode & Zg) {
											xe(!0);
											try {
												v.call(_, f, g);
											} finally {
												xe(!1);
											}
										}
										T_ = !1;
									} else h = v;
									if (h == null) break a;
									f = Df({}, f, h);
									break a;
								case vy: by = !0;
							}
						}
						p = c.callback, p !== null && (e.flags |= 64, m && (e.flags |= 8192), m = a.callbacks, m === null ? a.callbacks = [p] : m.push(p));
					} else m = {
						lane: p,
						tag: c.tag,
						payload: c.payload,
						callback: c.callback,
						next: null
					}, d === null ? (u = d = m, l = f) : d = d.next = m, s |= p;
					if (c = c.next, c === null) {
						if (c = a.shared.pending, c === null) break;
						m = c, c = m.next, m.next = null, a.lastBaseUpdate = m, a.shared.pending = null;
					}
				} while (1);
				d === null && (l = f), a.baseState = l, a.firstBaseUpdate = u, a.lastBaseUpdate = d, o === null && (a.shared.lanes = 0), Ax |= s, e.lanes = s, e.memoizedState = f;
			}
			Sy = null;
		}
		function Zi(e, t) {
			if (typeof e != "function") throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + e);
			e.call(t);
		}
		function Qi(e, t) {
			var n = e.shared.hiddenCallbacks;
			if (n !== null) for (e.shared.hiddenCallbacks = null, e = 0; e < n.length; e++) Zi(n[e], t);
		}
		function $i(e, t) {
			var n = e.callbacks;
			if (n !== null) for (e.callbacks = null, e = 0; e < n.length; e++) Zi(n[e], t);
		}
		function ea(e, t) {
			var n = Ox;
			F(Ty, n, e), F(wy, t, e), Ox = n | t.baseLanes;
		}
		function ta(e) {
			F(Ty, Ox, e), F(wy, wy.current, e);
		}
		function na(e) {
			Ox = Ty.current, P(wy, e), P(Ty, e);
		}
		function ra(e) {
			var t = e.alternate;
			F(Ay, Ay.current & Oy, e), F(Ey, e, e), Dy === null && (t === null || wy.current !== null || t.memoizedState !== null) && (Dy = e);
		}
		function ia(e) {
			F(Ay, Ay.current, e), F(Ey, e, e), Dy === null && (Dy = e);
		}
		function aa(e) {
			e.tag === 22 ? (F(Ay, Ay.current, e), F(Ey, e, e), Dy === null && (Dy = e)) : oa(e);
		}
		function oa(e) {
			F(Ay, Ay.current, e), F(Ey, Ey.current, e);
		}
		function sa(e) {
			P(Ey, e), Dy === e && (Dy = null), P(Ay, e);
		}
		function ca(e) {
			for (var t = e; t !== null;) {
				if (t.tag === 13) {
					var n = t.memoizedState;
					if (n !== null && (n = n.dehydrated, n === null || ud(n) || dd(n))) return t;
				} else if (t.tag === 19 && (t.memoizedProps.revealOrder === "forwards" || t.memoizedProps.revealOrder === "backwards" || t.memoizedProps.revealOrder === "unstable_legacy-backwards" || t.memoizedProps.revealOrder === "together")) {
					if (t.flags & 128) return t;
				} else if (t.child !== null) {
					t.child.return = t, t = t.child;
					continue;
				}
				if (t === e) break;
				for (; t.sibling === null;) {
					if (t.return === null || t.return === e) return null;
					t = t.return;
				}
				t.sibling.return = t.return, t = t.sibling;
			}
			return null;
		}
		function la() {
			var e = $;
			$y === null ? $y = [e] : $y.push(e);
		}
		function q() {
			var e = $;
			if ($y !== null && (eb++, $y[eb] !== e)) {
				var t = M(Hy);
				if (!Ly.has(t) && (Ly.add(t), $y !== null)) {
					for (var n = "", i = 0; i <= eb; i++) {
						var a = $y[i], o = i === eb ? e : a;
						for (a = i + 1 + ". " + a; 30 > a.length;) a += " ";
						a += o + "\n", n += a;
					}
					console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", t, n);
				}
			}
		}
		function ua(e) {
			e == null || Gf(e) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", $, typeof e);
		}
		function da() {
			var e = M(Hy);
			By.has(e) || (By.add(e), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", e));
		}
		function fa() {
			throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
		}
		function pa(e, t) {
			if (tb) return !1;
			if (t === null) return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", $), !1;
			e.length !== t.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", $, "[" + t.join(", ") + "]", "[" + e.join(", ") + "]");
			for (var n = 0; n < t.length && n < e.length; n++) if (!$h(e[n], t[n])) return !1;
			return !0;
		}
		function ma(e, t, n, i, a, o) {
			Vy = o, Hy = t, $y = e === null ? null : e._debugHookTypes, eb = -1, tb = e !== null && e.type !== t.type, (Object.prototype.toString.call(n) === "[object AsyncFunction]" || Object.prototype.toString.call(n) === "[object AsyncGeneratorFunction]") && (o = M(Hy), zy.has(o) || (zy.add(o), console.error("%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.", o === null ? "An unknown Component" : "<" + o + ">"))), t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Q.H = e !== null && e.memoizedState !== null ? ab : $y === null ? rb : ib, qy = o = (t.mode & Zg) !== Jg;
			var s = Lv(n, i, a);
			if (qy = !1, Ky && (s = ga(t, n, i, a)), o) {
				xe(!0);
				try {
					s = ga(t, n, i, a);
				} finally {
					xe(!1);
				}
			}
			return ha(e, t), s;
		}
		function ha(e, t) {
			t._debugHookTypes = $y, t.dependencies === null ? Xy !== null && (t.dependencies = {
				lanes: 0,
				firstContext: null,
				_debugThenableState: Xy
			}) : t.dependencies._debugThenableState = Xy, Q.H = nb;
			var n = Uy !== null && Uy.next !== null;
			if (Vy = 0, $y = $ = Wy = Uy = Hy = null, eb = -1, e !== null && (e.flags & 65011712) != (t.flags & 65011712) && console.error("Internal React error: Expected static flag was missing. Please notify the React team."), Gy = !1, Yy = 0, Xy = null, n) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
			e === null || Tb || (e = e.dependencies, e !== null && Gr(e) && (Tb = !0)), ay ? (ay = !1, e = !0) : e = !1, e && (t = M(t) || "Unknown", Ry.has(t) || zy.has(t) || (Ry.add(t), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
		}
		function ga(e, t, n, i) {
			Hy = e;
			var a = 0;
			do {
				if (Ky && (Xy = null), Yy = 0, Ky = !1, a >= Qy) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
				if (a += 1, tb = !1, Wy = Uy = null, e.updateQueue != null) {
					var o = e.updateQueue;
					o.lastEffect = null, o.events = null, o.stores = null, o.memoCache != null && (o.memoCache.index = 0);
				}
				eb = -1, Q.H = ob, o = Lv(t, n, i);
			} while (Ky);
			return o;
		}
		function _a() {
			var e = Q.H, t = e.useState()[0];
			return t = typeof t.then == "function" ? Ca(t) : t, e = e.useState()[0], (Uy === null ? null : Uy.memoizedState) !== e && (Hy.flags |= 1024), t;
		}
		function J() {
			var e = Jy !== 0;
			return Jy = 0, e;
		}
		function va(e, t, n) {
			t.updateQueue = e.updateQueue, t.flags = (t.mode & Qg) === Jg ? t.flags & -2053 : t.flags & -402655237, e.lanes &= ~n;
		}
		function ya(e) {
			if (Gy) {
				for (e = e.memoizedState; e !== null;) {
					var t = e.queue;
					t !== null && (t.pending = null), e = e.next;
				}
				Gy = !1;
			}
			Vy = 0, $y = Wy = Uy = Hy = null, eb = -1, $ = null, Ky = !1, Yy = Jy = 0, Xy = null;
		}
		function ba() {
			var e = {
				memoizedState: null,
				baseState: null,
				baseQueue: null,
				queue: null,
				next: null
			};
			return Wy === null ? Hy.memoizedState = Wy = e : Wy = Wy.next = e, Wy;
		}
		function xa() {
			if (Uy === null) {
				var e = Hy.alternate;
				e = e === null ? null : e.memoizedState;
			} else e = Uy.next;
			var t = Wy === null ? Hy.memoizedState : Wy.next;
			if (t !== null) Wy = t, Uy = e;
			else {
				if (e === null) throw Hy.alternate === null ? Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.") : Error("Rendered more hooks than during the previous render.");
				Uy = e, e = {
					memoizedState: Uy.memoizedState,
					baseState: Uy.baseState,
					baseQueue: Uy.baseQueue,
					queue: Uy.queue,
					next: null
				}, Wy === null ? Hy.memoizedState = Wy = e : Wy = Wy.next = e;
			}
			return Wy;
		}
		function Sa() {
			return {
				lastEffect: null,
				events: null,
				stores: null,
				memoCache: null
			};
		}
		function Ca(e) {
			var t = Yy;
			return Yy += 1, Xy === null && (Xy = wi()), e = Ei(Xy, e, t), t = Hy, (Wy === null ? t.memoizedState : Wy.next) === null && (t = t.alternate, Q.H = t !== null && t.memoizedState !== null ? ab : rb), e;
		}
		function wa(e) {
			if (typeof e == "object" && e) {
				if (typeof e.then == "function") return Ca(e);
				if (e.$$typeof === Ff) return qr(e);
			}
			throw Error("An unsupported type was passed to use(): " + String(e));
		}
		function Ta(e) {
			var t = null, n = Hy.updateQueue;
			if (n !== null && (t = n.memoCache), t == null) {
				var i = Hy.alternate;
				i !== null && (i = i.updateQueue, i !== null && (i = i.memoCache, i != null && (t = {
					data: i.data.map(function(e) {
						return e.slice();
					}),
					index: 0
				})));
			}
			if (t ??= {
				data: [],
				index: 0
			}, n === null && (n = Sa(), Hy.updateQueue = n), n.memoCache = t, n = t.data[t.index], n === void 0 || tb) for (n = t.data[t.index] = Array(e), i = 0; i < e; i++) n[i] = Hf;
			else n.length !== e && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", n.length, e);
			return t.index++, n;
		}
		function Ea(e, t) {
			return typeof t == "function" ? t(e) : t;
		}
		function Da(e, t, n) {
			var i = ba();
			if (n !== void 0) {
				var a = n(t);
				if (qy) {
					xe(!0);
					try {
						n(t);
					} finally {
						xe(!1);
					}
				}
			} else a = t;
			return i.memoizedState = i.baseState = a, e = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: e,
				lastRenderedState: a
			}, i.queue = e, e = e.dispatch = Po.bind(null, Hy, e), [i.memoizedState, e];
		}
		function Oa(e) {
			var t = xa();
			return ka(t, Uy, e);
		}
		function ka(e, t, n) {
			var i = e.queue;
			if (i === null) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
			i.lastRenderedReducer = n;
			var a = e.baseQueue, o = i.pending;
			if (o !== null) {
				if (a !== null) {
					var s = a.next;
					a.next = o.next, o.next = s;
				}
				t.baseQueue !== a && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), t.baseQueue = a = o, i.pending = null;
			}
			if (o = e.baseState, a === null) e.memoizedState = o;
			else {
				t = a.next;
				var c = s = null, l = null, u = t, d = !1;
				do {
					var f = u.lane & -536870913;
					if (f === u.lane ? (Vy & f) === f : (fx & f) === f) {
						var p = u.revertLane;
						if (p === 0) l !== null && (l = l.next = {
							lane: 0,
							revertLane: 0,
							gesture: null,
							action: u.action,
							hasEagerState: u.hasEagerState,
							eagerState: u.eagerState,
							next: null
						}), f === Sv && (d = !0);
						else if ((Vy & p) === p) {
							u = u.next, p === Sv && (d = !0);
							continue;
						} else f = {
							lane: 0,
							revertLane: u.revertLane,
							gesture: null,
							action: u.action,
							hasEagerState: u.hasEagerState,
							eagerState: u.eagerState,
							next: null
						}, l === null ? (c = l = f, s = o) : l = l.next = f, Hy.lanes |= p, Ax |= p;
						f = u.action, qy && n(o, f), o = u.hasEagerState ? u.eagerState : n(o, f);
					} else p = {
						lane: f,
						revertLane: u.revertLane,
						gesture: u.gesture,
						action: u.action,
						hasEagerState: u.hasEagerState,
						eagerState: u.eagerState,
						next: null
					}, l === null ? (c = l = p, s = o) : l = l.next = p, Hy.lanes |= f, Ax |= f;
					u = u.next;
				} while (u !== null && u !== t);
				if (l === null ? s = o : l.next = c, !$h(o, e.memoizedState) && (Tb = !0, d && (n = Cv, n !== null))) throw n;
				e.memoizedState = o, e.baseState = s, e.baseQueue = l, i.lastRenderedState = o;
			}
			return a === null && (i.lanes = 0), [e.memoizedState, i.dispatch];
		}
		function Aa(e) {
			var t = xa(), n = t.queue;
			if (n === null) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
			n.lastRenderedReducer = e;
			var i = n.dispatch, a = n.pending, o = t.memoizedState;
			if (a !== null) {
				n.pending = null;
				var s = a = a.next;
				do
					o = e(o, s.action), s = s.next;
				while (s !== a);
				$h(o, t.memoizedState) || (Tb = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o;
			}
			return [o, i];
		}
		function ja(e, t, n) {
			var i = Hy, a = ba();
			if (m_) {
				if (n === void 0) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
				var o = n();
				Iy || o === n() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), Iy = !0);
			} else {
				if (o = t(), Iy || (n = t(), $h(o, n) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), Iy = !0)), ux === null) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
				fx & 127 || Na(i, t, o);
			}
			return a.memoizedState = o, n = {
				value: o,
				getSnapshot: t
			}, a.queue = n, io(Fa.bind(null, i, n, e), [e]), i.flags |= 2048, eo(My | Fy, { destroy: void 0 }, Pa.bind(null, i, n, o, t), null), o;
		}
		function Ma(e, t, n) {
			var i = Hy, a = xa(), o = m_;
			if (o) {
				if (n === void 0) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
				n = n();
			} else if (n = t(), !Iy) {
				var s = t();
				$h(n, s) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), Iy = !0);
			}
			(s = !$h((Uy || a).memoizedState, n)) && (a.memoizedState = n, Tb = !0), a = a.queue;
			var c = Fa.bind(null, i, a, e);
			if (ro(2048, Fy, c, [e]), a.getSnapshot !== t || s || Wy !== null && Wy.memoizedState.tag & My) {
				if (i.flags |= 2048, eo(My | Fy, { destroy: void 0 }, Pa.bind(null, i, a, n, t), null), ux === null) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
				o || Vy & 127 || Na(i, t, n);
			}
			return n;
		}
		function Na(e, t, n) {
			e.flags |= 16384, e = {
				getSnapshot: t,
				value: n
			}, t = Hy.updateQueue, t === null ? (t = Sa(), Hy.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e));
		}
		function Pa(e, t, n, i) {
			t.value = n, t.getSnapshot = i, Ia(t) && La(e);
		}
		function Fa(e, t, n) {
			return n(function() {
				Ia(t) && ($r(2, "updateSyncExternalStore()", e), La(e));
			});
		}
		function Ia(e) {
			var t = e.getSnapshot;
			e = e.value;
			try {
				var n = t();
				return !$h(e, n);
			} catch {
				return !0;
			}
		}
		function La(e) {
			var t = nr(e, 2);
			t !== null && Yc(t, e, 2);
		}
		function Ra(e) {
			var t = ba();
			if (typeof e == "function") {
				var n = e;
				if (e = n(), qy) {
					xe(!0);
					try {
						n();
					} finally {
						xe(!1);
					}
				}
			}
			return t.memoizedState = t.baseState = e, t.queue = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: Ea,
				lastRenderedState: e
			}, t;
		}
		function za(e) {
			e = Ra(e);
			var t = e.queue, n = Fo.bind(null, Hy, t);
			return t.dispatch = n, [e.memoizedState, n];
		}
		function Ba(e) {
			var t = ba();
			t.memoizedState = t.baseState = e;
			var n = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: null,
				lastRenderedState: null
			};
			return t.queue = n, t = Lo.bind(null, Hy, !0, n), n.dispatch = t, [e, t];
		}
		function Va(e, t) {
			var n = xa();
			return Ha(n, Uy, e, t);
		}
		function Ha(e, t, n, i) {
			return e.baseState = n, ka(e, Uy, typeof i == "function" ? i : Ea);
		}
		function Ua(e, t) {
			var n = xa();
			return Uy === null ? (n.baseState = e, [e, n.queue.dispatch]) : Ha(n, Uy, e, t);
		}
		function Wa(e, t, n, i, a) {
			if (Ro(e)) throw Error("Cannot update form state while rendering.");
			if (e = t.action, e !== null) {
				var o = {
					payload: a,
					action: e,
					next: null,
					isTransition: !0,
					status: "pending",
					value: null,
					reason: null,
					listeners: [],
					then: function(e) {
						o.listeners.push(e);
					}
				};
				Q.T === null ? o.isTransition = !1 : n(!0), i(o), n = t.pending, n === null ? (o.next = t.pending = o, Ga(t, o)) : (o.next = n.next, t.pending = n.next = o);
			}
		}
		function Ga(e, t) {
			var n = t.action, i = t.payload, a = e.state;
			if (t.isTransition) {
				var o = Q.T, s = {};
				s._updatedFibers = /* @__PURE__ */ new Set(), Q.T = s;
				try {
					var c = n(a, i), l = Q.S;
					l !== null && l(s, c), Ka(e, t, c);
				} catch (n) {
					Y(e, t, n);
				} finally {
					o !== null && s.types !== null && (o.types !== null && o.types !== s.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), o.types = s.types), Q.T = o, o === null && s._updatedFibers && (e = s._updatedFibers.size, s._updatedFibers.clear(), 10 < e && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
				}
			} else try {
				s = n(a, i), Ka(e, t, s);
			} catch (n) {
				Y(e, t, n);
			}
		}
		function Ka(e, t, n) {
			typeof n == "object" && n && typeof n.then == "function" ? (Q.asyncTransitions++, n.then(So, So), n.then(function(n) {
				qa(e, t, n);
			}, function(n) {
				return Y(e, t, n);
			}), t.isTransition || console.error("An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop.")) : qa(e, t, n);
		}
		function qa(e, t, n) {
			t.status = "fulfilled", t.value = n, Z(t), e.state = n, t = e.pending, t !== null && (n = t.next, n === t ? e.pending = null : (n = n.next, t.next = n, Ga(e, n)));
		}
		function Y(e, t, n) {
			var i = e.pending;
			if (e.pending = null, i !== null) {
				i = i.next;
				do
					t.status = "rejected", t.reason = n, Z(t), t = t.next;
				while (t !== i);
			}
			e.action = null;
		}
		function Z(e) {
			e = e.listeners;
			for (var t = 0; t < e.length; t++) (0, e[t])();
		}
		function Ja(e, t) {
			return t;
		}
		function Ya(e, t) {
			if (m_) {
				var n = ux.formState;
				if (n !== null) {
					a: {
						var i = Hy;
						if (m_) {
							if (p_) {
								b: {
									for (var a = p_, o = v_; a.nodeType !== 8;) {
										if (!o) {
											a = null;
											break b;
										}
										if (a = pd(a.nextSibling), a === null) {
											a = null;
											break b;
										}
									}
									o = a.data, a = o === sC || o === cC ? a : null;
								}
								if (a) {
									p_ = pd(a.nextSibling), i = a.data === sC;
									break a;
								}
							}
							jr(i);
						}
						i = !1;
					}
					i && (t = n[0]);
				}
			}
			return n = ba(), n.memoizedState = n.baseState = t, i = {
				pending: null,
				lanes: 0,
				dispatch: null,
				lastRenderedReducer: Ja,
				lastRenderedState: t
			}, n.queue = i, n = Fo.bind(null, Hy, i), i.dispatch = n, i = Ra(!1), o = Lo.bind(null, Hy, !1, i.queue), i = ba(), a = {
				state: t,
				dispatch: null,
				action: e,
				pending: null
			}, i.queue = a, n = Wa.bind(null, Hy, a, o, n), a.dispatch = n, i.memoizedState = e, [
				t,
				n,
				!1
			];
		}
		function Xa(e) {
			var t = xa();
			return Za(t, Uy, e);
		}
		function Za(e, t, n) {
			if (t = ka(e, t, Ja)[0], e = Oa(Ea)[0], typeof t == "object" && t && typeof t.then == "function") try {
				var i = Ca(t);
			} catch (e) {
				throw e === ey ? ny : e;
			}
			else i = t;
			t = xa();
			var a = t.queue, o = a.dispatch;
			return n !== t.memoizedState && (Hy.flags |= 2048, eo(My | Fy, { destroy: void 0 }, Qa.bind(null, a, n), null)), [
				i,
				o,
				e
			];
		}
		function Qa(e, t) {
			e.action = t;
		}
		function $a(e) {
			var t = xa(), n = Uy;
			if (n !== null) return Za(t, n, e);
			xa(), t = t.memoizedState, n = xa();
			var i = n.queue.dispatch;
			return n.memoizedState = e, [
				t,
				i,
				!1
			];
		}
		function eo(e, t, n, i) {
			return e = {
				tag: e,
				create: n,
				deps: i,
				inst: t,
				next: null
			}, t = Hy.updateQueue, t === null && (t = Sa(), Hy.updateQueue = t), n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (i = n.next, n.next = e, e.next = i, t.lastEffect = e), e;
		}
		function to(e) {
			var t = ba();
			return e = { current: e }, t.memoizedState = e;
		}
		function no(e, t, n, i) {
			var a = ba();
			Hy.flags |= e, a.memoizedState = eo(My | t, { destroy: void 0 }, n, i === void 0 ? null : i);
		}
		function ro(e, t, n, i) {
			var a = xa();
			i = i === void 0 ? null : i;
			var o = a.memoizedState.inst;
			Uy !== null && i !== null && pa(i, Uy.memoizedState.deps) ? a.memoizedState = eo(t, o, n, i) : (Hy.flags |= e, a.memoizedState = eo(My | t, o, n, i));
		}
		function io(e, t) {
			(Hy.mode & Qg) === Jg ? no(8390656, Fy, e, t) : no(276826112, Fy, e, t);
		}
		function ao(e) {
			Hy.flags |= 4;
			var t = Hy.updateQueue;
			if (t === null) t = Sa(), Hy.updateQueue = t, t.events = [e];
			else {
				var n = t.events;
				n === null ? t.events = [e] : n.push(e);
			}
		}
		function oo(e) {
			var t = ba(), n = { impl: e };
			return t.memoizedState = n, function() {
				if ((lx & $b) !== Qb) throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
				return n.impl.apply(void 0, arguments);
			};
		}
		function so(e) {
			var t = xa().memoizedState;
			return ao({
				ref: t,
				nextImpl: e
			}), function() {
				if ((lx & $b) !== Qb) throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
				return t.impl.apply(void 0, arguments);
			};
		}
		function co(e, t) {
			var n = 4194308;
			return (Hy.mode & Qg) !== Jg && (n |= 134217728), no(n, Py, e, t);
		}
		function lo(e, t) {
			if (typeof t == "function") {
				e = e();
				var n = t(e);
				return function() {
					typeof n == "function" ? n() : t(null);
				};
			}
			if (t != null) return t.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(t).join(", ") + "}"), e = e(), t.current = e, function() {
				t.current = null;
			};
		}
		function uo(e, t, n) {
			typeof t != "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t === null ? "null" : typeof t), n = n == null ? null : n.concat([e]);
			var i = 4194308;
			(Hy.mode & Qg) !== Jg && (i |= 134217728), no(i, Py, lo.bind(null, t, e), n);
		}
		function fo(e, t, n) {
			typeof t != "function" && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", t === null ? "null" : typeof t), n = n == null ? null : n.concat([e]), ro(4, Py, lo.bind(null, t, e), n);
		}
		function po(e, t) {
			return ba().memoizedState = [e, t === void 0 ? null : t], e;
		}
		function mo(e, t) {
			var n = xa();
			t = t === void 0 ? null : t;
			var i = n.memoizedState;
			return t !== null && pa(t, i[1]) ? i[0] : (n.memoizedState = [e, t], e);
		}
		function ho(e, t) {
			var n = ba();
			t = t === void 0 ? null : t;
			var i = e();
			if (qy) {
				xe(!0);
				try {
					e();
				} finally {
					xe(!1);
				}
			}
			return n.memoizedState = [i, t], i;
		}
		function go(e, t) {
			var n = xa();
			t = t === void 0 ? null : t;
			var i = n.memoizedState;
			if (t !== null && pa(t, i[1])) return i[0];
			if (i = e(), qy) {
				xe(!0);
				try {
					e();
				} finally {
					xe(!1);
				}
			}
			return n.memoizedState = [i, t], i;
		}
		function _o(e, t) {
			var n = ba();
			return bo(n, e, t);
		}
		function vo(e, t) {
			var n = xa();
			return xo(n, Uy.memoizedState, e, t);
		}
		function yo(e, t) {
			var n = xa();
			return Uy === null ? bo(n, e, t) : xo(n, Uy.memoizedState, e, t);
		}
		function bo(e, t, n) {
			return n === void 0 || Vy & 1073741824 && !(fx & 261930) ? e.memoizedState = t : (e.memoizedState = n, e = Jc(), Hy.lanes |= e, Ax |= e, n);
		}
		function xo(e, t, n, i) {
			return $h(n, t) ? n : wy.current === null ? !(Vy & 42) || Vy & 1073741824 && !(fx & 261930) ? (Tb = !0, e.memoizedState = n) : (e = Jc(), Hy.lanes |= e, Ax |= e, t) : (e = bo(e, n, i), $h(e, t) || (Tb = !0), e);
		}
		function So() {
			Q.asyncTransitions--;
		}
		function Co(e, t, n, i, a) {
			var o = Kf.p;
			Kf.p = o !== 0 && o < Bp ? o : Bp;
			var s = Q.T, c = {};
			c._updatedFibers = /* @__PURE__ */ new Set(), Q.T = c, Lo(e, !1, t, n);
			try {
				var l = a(), u = Q.S;
				if (u !== null && u(c, l), typeof l == "object" && l && typeof l.then == "function") {
					Q.asyncTransitions++, l.then(So, So);
					var d = bi(l, i);
					Io(e, t, d, qc(e));
				} else Io(e, t, i, qc(e));
			} catch (n) {
				Io(e, t, {
					then: function() {},
					status: "rejected",
					reason: n
				}, qc(e));
			} finally {
				Kf.p = o, s !== null && c.types !== null && (s.types !== null && s.types !== c.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), s.types = c.types), Q.T = s, s === null && c._updatedFibers && (e = c._updatedFibers.size, c._updatedFibers.clear(), 10 < e && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
			}
		}
		function wo(e, t, n, i) {
			if (e.tag !== 5) throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");
			var a = To(e).queue;
			ei(e), Co(e, a, t, VC, n === null ? d : function() {
				return Eo(e), n(i);
			});
		}
		function To(e) {
			var t = e.memoizedState;
			if (t !== null) return t;
			t = {
				memoizedState: VC,
				baseState: VC,
				baseQueue: null,
				queue: {
					pending: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: Ea,
					lastRenderedState: VC
				},
				next: null
			};
			var n = {};
			return t.next = {
				memoizedState: n,
				baseState: n,
				baseQueue: null,
				queue: {
					pending: null,
					lanes: 0,
					dispatch: null,
					lastRenderedReducer: Ea,
					lastRenderedState: n
				},
				next: null
			}, e.memoizedState = t, e = e.alternate, e !== null && (e.memoizedState = t), t;
		}
		function Eo(e) {
			Q.T === null && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
			var t = To(e);
			t.next === null && (t = e.alternate.memoizedState), Io(e, t.next.queue, {}, qc(e));
		}
		function Do() {
			var e = Ra(!1);
			return e = Co.bind(null, Hy, e.queue, !0, !1), ba().memoizedState = e, [!1, e];
		}
		function Oo() {
			var e = Oa(Ea)[0], t = xa().memoizedState;
			return [typeof e == "boolean" ? e : Ca(e), t];
		}
		function ko() {
			var e = Aa(Ea)[0], t = xa().memoizedState;
			return [typeof e == "boolean" ? e : Ca(e), t];
		}
		function Ao() {
			return qr(HC);
		}
		function jo() {
			var e = ba(), t = ux.identifierPrefix;
			if (m_) {
				var n = d_, i = u_;
				n = (i & ~(1 << 32 - Np(i) - 1)).toString(32) + n, t = "_" + t + "R_" + n, n = Jy++, 0 < n && (t += "H" + n.toString(32)), t += "_";
			} else n = Zy++, t = "_" + t + "r_" + n.toString(32) + "_";
			return e.memoizedState = t;
		}
		function Mo() {
			return ba().memoizedState = No.bind(null, Hy);
		}
		function No(e, t) {
			for (var n = e.return; n !== null;) {
				switch (n.tag) {
					case 24:
					case 3:
						var i = qc(n), a = Gi(i), o = Ki(n, a, i);
						o !== null && ($r(i, "refresh()", e), Yc(o, n, i), qi(o, n, i)), e = Xr(), t != null && o !== null && console.error("The seed argument is not enabled outside experimental channels."), a.payload = { cache: e };
						return;
				}
				n = n.return;
			}
		}
		function Po(e, t, n) {
			var i = arguments;
			typeof i[3] == "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."), i = qc(e);
			var a = {
				lane: i,
				revertLane: 0,
				gesture: null,
				action: n,
				hasEagerState: !1,
				eagerState: null,
				next: null
			};
			Ro(e) ? zo(t, a) : (a = tr(e, t, a, i), a !== null && ($r(i, "dispatch()", e), Yc(a, e, i), Bo(a, t, i)));
		}
		function Fo(e, t, n) {
			var i = arguments;
			typeof i[3] == "function" && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."), i = qc(e), Io(e, t, n, i) && $r(i, "setState()", e);
		}
		function Io(e, t, n, i) {
			var a = {
				lane: i,
				revertLane: 0,
				gesture: null,
				action: n,
				hasEagerState: !1,
				eagerState: null,
				next: null
			};
			if (Ro(e)) zo(t, a);
			else {
				var o = e.alternate;
				if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) {
					var s = Q.H;
					Q.H = cb;
					try {
						var c = t.lastRenderedState, l = o(c, n);
						if (a.hasEagerState = !0, a.eagerState = l, $h(l, c)) return er(e, t, a, 0), ux === null && $n(), !1;
					} catch {} finally {
						Q.H = s;
					}
				}
				if (n = tr(e, t, a, i), n !== null) return Yc(n, e, i), Bo(n, t, i), !0;
			}
			return !1;
		}
		function Lo(e, t, n, i) {
			if (Q.T === null && Sv === 0 && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."), i = {
				lane: 2,
				revertLane: Zl(),
				gesture: null,
				action: i,
				hasEagerState: !1,
				eagerState: null,
				next: null
			}, Ro(e)) {
				if (t) throw Error("Cannot update optimistic state while rendering.");
				console.error("Cannot call startTransition while rendering.");
			} else t = tr(e, n, i, 2), t !== null && ($r(2, "setOptimistic()", e), Yc(t, e, 2));
		}
		function Ro(e) {
			var t = e.alternate;
			return e === Hy || t !== null && t === Hy;
		}
		function zo(e, t) {
			Ky = Gy = !0;
			var n = e.pending;
			n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t;
		}
		function Bo(e, t, n) {
			if (n & 4194048) {
				var i = t.lanes;
				i &= e.pendingLanes, n |= i, t.lanes = n, Me(e, n);
			}
		}
		function Vo(e) {
			if (e !== null && typeof e != "function") {
				var t = String(e);
				bb.has(t) || (bb.add(t), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", e));
			}
		}
		function Ho(e, t, n, i) {
			var a = e.memoizedState, o = n(i, a);
			if (e.mode & Zg) {
				xe(!0);
				try {
					o = n(i, a);
				} finally {
					xe(!1);
				}
			}
			o === void 0 && (t = A(t) || "Component", gb.has(t) || (gb.add(t), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", t))), a = o == null ? a : Df({}, a, o), e.memoizedState = a, e.lanes === 0 && (e.updateQueue.baseState = a);
		}
		function Uo(e, t, n, i, a, o, s) {
			var c = e.stateNode;
			if (typeof c.shouldComponentUpdate == "function") {
				if (n = c.shouldComponentUpdate(i, o, s), e.mode & Zg) {
					xe(!0);
					try {
						n = c.shouldComponentUpdate(i, o, s);
					} finally {
						xe(!1);
					}
				}
				return n === void 0 && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", A(t) || "Component"), n;
			}
			return t.prototype && t.prototype.isPureReactComponent ? !Tn(n, i) || !Tn(a, o) : !0;
		}
		function Wo(e, t, n, i) {
			var a = t.state;
			typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, i), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, i), t.state !== a && (e = M(e) || "Component", db.has(e) || (db.add(e), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", e)), xb.enqueueReplaceState(t, t.state, null));
		}
		function Go(e, t) {
			var n = t;
			if ("ref" in t) for (var i in n = {}, t) i !== "ref" && (n[i] = t[i]);
			if (e = e.defaultProps) for (var a in n === t && (n = Df({}, n)), e) n[a] === void 0 && (n[a] = e[a]);
			return n;
		}
		function Ko(e) {
			xg(e), console.warn("%s\n\n%s\n", Sb ? "An error occurred in the <" + Sb + "> component." : "An error occurred in one of your React components.", "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.");
		}
		function qo(e) {
			var t = Sb ? "The above error occurred in the <" + Sb + "> component." : "The above error occurred in one of your React components.", n = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((Cb || "Anonymous") + ".");
			if (typeof e == "object" && e && typeof e.environmentName == "string") {
				var i = e.environmentName;
				e = [
					"%o\n\n%s\n\n%s\n",
					e,
					t,
					n
				].slice(0), typeof e[0] == "string" ? e.splice(0, 1, UC + " " + e[0], WC, KC + i + KC, GC) : e.splice(0, 0, UC, WC, KC + i + KC, GC), e.unshift(console), i = qC.apply(console.error, e), i();
			} else console.error("%o\n\n%s\n\n%s\n", e, t, n);
		}
		function Jo(e) {
			xg(e);
		}
		function Yo(e, t) {
			try {
				Sb = t.source ? M(t.source) : null, Cb = null;
				var n = t.value;
				if (Q.actQueue !== null) Q.thrownErrors.push(n);
				else {
					var i = e.onUncaughtError;
					i(n, { componentStack: t.stack });
				}
			} catch (e) {
				setTimeout(function() {
					throw e;
				});
			}
		}
		function Xo(e, t, n) {
			try {
				Sb = n.source ? M(n.source) : null, Cb = M(t);
				var i = e.onCaughtError;
				i(n.value, {
					componentStack: n.stack,
					errorBoundary: t.tag === 1 ? t.stateNode : null
				});
			} catch (e) {
				setTimeout(function() {
					throw e;
				});
			}
		}
		function Zo(e, t, n) {
			return n = Gi(n), n.tag = yy, n.payload = { element: null }, n.callback = function() {
				V(t.source, Yo, e, t);
			}, n;
		}
		function Qo(e) {
			return e = Gi(e), e.tag = yy, e;
		}
		function $o(e, t, n, i) {
			var a = n.type.getDerivedStateFromError;
			if (typeof a == "function") {
				var o = i.value;
				e.payload = function() {
					return a(o);
				}, e.callback = function() {
					cr(n), V(i.source, Xo, t, n, i);
				};
			}
			var s = n.stateNode;
			s !== null && typeof s.componentDidCatch == "function" && (e.callback = function() {
				cr(n), V(i.source, Xo, t, n, i), typeof a != "function" && (Gx === null ? Gx = new Set([this]) : Gx.add(this)), Gv(this, i), typeof a == "function" || !(n.lanes & 2) && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", M(n) || "Unknown");
			});
		}
		function es(e, t, n, i, a) {
			if (n.flags |= 32768, Mp && zl(e, a), typeof i == "object" && i && typeof i.then == "function") {
				if (t = n.alternate, t !== null && Wr(t, n, a, !0), m_ && (h_ = !0), n = Ey.current, n !== null) {
					switch (n.tag) {
						case 31:
						case 13: return Dy === null ? ll() : n.alternate === null && kx === tx && (kx = ix), n.flags &= -257, n.flags |= 65536, n.lanes = a, i === ry ? n.flags |= 16384 : (t = n.updateQueue, t === null ? n.updateQueue = new Set([i]) : t.add(i), Al(e, i, a)), !1;
						case 22: return n.flags |= 65536, i === ry ? n.flags |= 16384 : (t = n.updateQueue, t === null ? (t = {
							transitions: null,
							markerInstances: null,
							retryQueue: new Set([i])
						}, n.updateQueue = t) : (n = t.retryQueue, n === null ? t.retryQueue = new Set([i]) : n.add(i)), Al(e, i, a)), !1;
					}
					throw Error("Unexpected Suspense handler tag (" + n.tag + "). This is a bug in React.");
				}
				return Al(e, i, a), ll(), !1;
			}
			if (m_) return h_ = !0, t = Ey.current, t === null ? (i !== y_ && Lr(br(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", { cause: i }), n)), e = e.current.alternate, e.flags |= 65536, a &= -a, e.lanes |= a, i = br(i, n), a = Zo(e.stateNode, i, a), Ji(e, a), kx !== ax && (kx = rx)) : (!(t.flags & 65536) && (t.flags |= 256), t.flags |= 65536, t.lanes = a, i !== y_ && Lr(br(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", { cause: i }), n))), !1;
			var o = br(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", { cause: i }), n);
			if (Fx === null ? Fx = [o] : Fx.push(o), kx !== ax && (kx = rx), t === null) return !0;
			i = br(i, n), n = t;
			do {
				switch (n.tag) {
					case 3: return n.flags |= 65536, e = a & -a, n.lanes |= e, e = Zo(n.stateNode, i, e), Ji(n, e), !1;
					case 1: if (t = n.type, o = n.stateNode, !(n.flags & 128) && (typeof t.getDerivedStateFromError == "function" || o !== null && typeof o.componentDidCatch == "function" && (Gx === null || !Gx.has(o)))) return n.flags |= 65536, a &= -a, n.lanes |= a, a = Qo(a), $o(a, e, n, i), Ji(n, a), !1;
				}
				n = n.return;
			} while (n !== null);
			return !1;
		}
		function ts(e, t, n, i) {
			t.child = e === null ? hy(t, null, n, i) : my(t, e.child, n, i);
		}
		function ns(e, t, n, i, a) {
			n = n.render;
			var o = t.ref;
			if ("ref" in i) {
				var s = {};
				for (var c in i) c !== "ref" && (s[c] = i[c]);
			} else s = i;
			return Kr(t), i = ma(e, t, n, s, o, a), c = J(), e !== null && !Tb ? (va(e, t, a), Os(e, t, a)) : (m_ && c && Cr(t), t.flags |= 1, ts(e, t, i, a), t.child);
		}
		function rs(e, t, n, i, a) {
			if (e === null) {
				var o = n.type;
				return typeof o == "function" && !dr(o) && o.defaultProps === void 0 && n.compare === null ? (n = ar(o), t.tag = 15, t.type = n, vs(t, o), os(e, t, n, i, a)) : (e = mr(n.type, null, i, t, t.mode, a), e.ref = t.ref, e.return = t, t.child = e);
			}
			if (o = e.child, !ks(e, a)) {
				var s = o.memoizedProps;
				if (n = n.compare, n = n === null ? Tn : n, n(s, i) && e.ref === t.ref) return Os(e, t, a);
			}
			return t.flags |= 1, e = fr(o, i), e.ref = t.ref, e.return = t, t.child = e;
		}
		function os(e, t, n, i, a) {
			if (e !== null) {
				var o = e.memoizedProps;
				if (Tn(o, i) && e.ref === t.ref && t.type === e.type) if (Tb = !1, t.pendingProps = i = o, ks(e, a)) e.flags & 131072 && (Tb = !0);
				else return t.lanes = e.lanes, Os(e, t, a);
			}
			return ms(e, t, n, i, a);
		}
		function ss(e, t, n, i) {
			var a = i.children, o = e === null ? null : e.memoizedState;
			if (e === null && t.stateNode === null && (t.stateNode = {
				_visibility: Bg,
				_pendingMarkers: null,
				_retryCache: null,
				_transitions: null
			}), i.mode === "hidden") {
				if (t.flags & 128) {
					if (o = o === null ? n : o.baseLanes | n, e !== null) {
						for (i = t.child = e.child, a = 0; i !== null;) a = a | i.lanes | i.childLanes, i = i.sibling;
						i = a & ~o;
					} else i = 0, t.child = null;
					return ls(e, t, o, n, i);
				}
				if (n & 536870912) t.memoizedState = {
					baseLanes: 0,
					cachePool: null
				}, e !== null && Si(t, o === null ? null : o.cachePool), o === null ? ta(t) : ea(t, o), aa(t);
				else return i = t.lanes = 536870912, ls(e, t, o === null ? n : o.baseLanes | n, n, i);
			} else o === null ? (e !== null && Si(t, null), ta(t), oa(t)) : (Si(t, o.cachePool), ea(t, o), oa(t), t.memoizedState = null);
			return ts(e, t, a, n), t.child;
		}
		function cs(e, t) {
			return e !== null && e.tag === 22 || t.stateNode !== null || (t.stateNode = {
				_visibility: Bg,
				_pendingMarkers: null,
				_retryCache: null,
				_transitions: null
			}), t.sibling;
		}
		function ls(e, t, n, i, a) {
			var o = xi();
			return o = o === null ? null : {
				parent: k_._currentValue,
				pool: o
			}, t.memoizedState = {
				baseLanes: n,
				cachePool: o
			}, e !== null && Si(t, null), ta(t), aa(t), e !== null && Wr(e, t, i, !0), t.childLanes = a, null;
		}
		function us(e, t) {
			var n = t.hidden;
			return n !== void 0 && console.error("<Activity> doesn't accept a hidden prop. Use mode=\"hidden\" instead.\n- <Activity %s>\n+ <Activity %s>", !0 === n ? "hidden" : !1 === n ? "hidden={false}" : "hidden={...}", n ? "mode=\"hidden\"" : "mode=\"visible\""), t = Cs({
				mode: t.mode,
				children: t.children
			}, e.mode), t.ref = e.ref, e.child = t, t.return = e, t;
		}
		function ds(e, t, n) {
			return my(t, e.child, null, n), e = us(t, t.pendingProps), e.flags |= 2, sa(t), t.memoizedState = null, e;
		}
		function fs(e, t, n) {
			var i = t.pendingProps, a = (t.flags & 128) != 0;
			if (t.flags &= -129, e === null) {
				if (m_) {
					if (i.mode === "hidden") return e = us(t, i), t.lanes = 536870912, cs(null, e);
					if (ia(t), (e = p_) ? (n = ld(e, v_), n = n !== null && n.data === ZS ? n : null, n !== null && (i = {
						dehydrated: n,
						treeContext: Tr(),
						retryLane: 536870912,
						hydrationErrors: null
					}, t.memoizedState = i, i = vr(n), i.return = t, t.child = i, f_ = t, p_ = null)) : n = null, n === null) throw Ar(t, e), jr(t);
					return t.lanes = 536870912, null;
				}
				return us(t, i);
			}
			var o = e.memoizedState;
			if (o !== null) {
				var s = o.dehydrated;
				if (ia(t), a) if (t.flags & 256) t.flags &= -257, t = ds(e, t, n);
				else if (t.memoizedState !== null) t.child = e.child, t.flags |= 128, t = null;
				else throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
				else if (kr(), n & 536870912 && cl(t), Tb || Wr(e, t, n, !1), a = (n & e.childLanes) !== 0, Tb || a) {
					if (i = ux, i !== null && (s = Ne(i, n), s !== 0 && s !== o.retryLane)) throw o.retryLane = s, nr(e, s), Yc(i, e, s), wb;
					ll(), t = ds(e, t, n);
				} else e = o.treeContext, p_ = pd(s.nextSibling), f_ = t, m_ = !0, __ = null, h_ = !1, g_ = null, v_ = !1, e !== null && Er(t, e), t = us(t, i), t.flags |= 4096;
				return t;
			}
			return o = e.child, i = {
				mode: i.mode,
				children: i.children
			}, n & 536870912 && (n & e.lanes) !== 0 && cl(t), e = fr(o, i), e.ref = t.ref, t.child = e, e.return = t, e;
		}
		function ps(e, t) {
			var n = t.ref;
			if (n === null) e !== null && e.ref !== null && (t.flags |= 4194816);
			else {
				if (typeof n != "function" && typeof n != "object") throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
				(e === null || e.ref !== n) && (t.flags |= 4194816);
			}
		}
		function ms(e, t, n, i, a) {
			if (n.prototype && typeof n.prototype.render == "function") {
				var o = A(n) || "Unknown";
				Eb[o] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", o, o), Eb[o] = !0);
			}
			return t.mode & Zg && Ev.recordLegacyContextWarning(t, null), e === null && (vs(t, t.type), n.contextTypes && (o = A(n) || "Unknown", Ob[o] || (Ob[o] = !0, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", o)))), Kr(t), n = ma(e, t, n, i, void 0, a), i = J(), e !== null && !Tb ? (va(e, t, a), Os(e, t, a)) : (m_ && i && Cr(t), t.flags |= 1, ts(e, t, n, a), t.child);
		}
		function hs(e, t, n, i, a, o) {
			return Kr(t), eb = -1, tb = e !== null && e.type !== t.type, t.updateQueue = null, n = ga(t, i, n, a), ha(e, t), i = J(), e !== null && !Tb ? (va(e, t, o), Os(e, t, o)) : (m_ && i && Cr(t), t.flags |= 1, ts(e, t, n, o), t.child);
		}
		function gs(e, t, n, i, a) {
			switch (c(t)) {
				case !1:
					var o = t.stateNode, s = new t.type(t.memoizedProps, o.context).state;
					o.updater.enqueueSetState(o, s, null);
					break;
				case !0:
					t.flags |= 128, t.flags |= 65536, o = Error("Simulated error coming from DevTools");
					var l = a & -a;
					if (t.lanes |= l, s = ux, s === null) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
					l = Qo(l), $o(l, s, t, br(o, t)), Ji(t, l);
			}
			if (Kr(t), t.stateNode === null) {
				if (s = Gg, o = n.contextType, "contextType" in n && o !== null && (o === void 0 || o.$$typeof !== Ff) && !yb.has(n) && (yb.add(n), l = o === void 0 ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof o == "object" ? o.$$typeof === Pf ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(o).join(", ") + "}." : " However, it is set to a " + typeof o + ".", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", A(n) || "Component", l)), typeof o == "object" && o && (s = qr(o)), o = new n(i, s), t.mode & Zg) {
					xe(!0);
					try {
						o = new n(i, s);
					} finally {
						xe(!1);
					}
				}
				if (s = t.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null, o.updater = xb, t.stateNode = o, o._reactInternals = t, o._reactInternalInstance = ub, typeof n.getDerivedStateFromProps == "function" && s === null && (s = A(n) || "Component", fb.has(s) || (fb.add(s), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", s, o.state === null ? "null" : "undefined", s))), typeof n.getDerivedStateFromProps == "function" || typeof o.getSnapshotBeforeUpdate == "function") {
					var u = l = s = null;
					if (typeof o.componentWillMount == "function" && !0 !== o.componentWillMount.__suppressDeprecationWarning ? s = "componentWillMount" : typeof o.UNSAFE_componentWillMount == "function" && (s = "UNSAFE_componentWillMount"), typeof o.componentWillReceiveProps == "function" && !0 !== o.componentWillReceiveProps.__suppressDeprecationWarning ? l = "componentWillReceiveProps" : typeof o.UNSAFE_componentWillReceiveProps == "function" && (l = "UNSAFE_componentWillReceiveProps"), typeof o.componentWillUpdate == "function" && !0 !== o.componentWillUpdate.__suppressDeprecationWarning ? u = "componentWillUpdate" : typeof o.UNSAFE_componentWillUpdate == "function" && (u = "UNSAFE_componentWillUpdate"), s !== null || l !== null || u !== null) {
						o = A(n) || "Component";
						var d = typeof n.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
						mb.has(o) || (mb.add(o), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", o, d, s === null ? "" : "\n  " + s, l === null ? "" : "\n  " + l, u === null ? "" : "\n  " + u));
					}
				}
				o = t.stateNode, s = A(n) || "Component", o.render || (n.prototype && typeof n.prototype.render == "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", s) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", s)), !o.getInitialState || o.getInitialState.isReactClassApproved || o.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", s), o.getDefaultProps && !o.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", s), o.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", s), n.childContextTypes && !vb.has(n) && (vb.add(n), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", s)), n.contextTypes && !_b.has(n) && (_b.add(n), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", s)), typeof o.componentShouldUpdate == "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", s), n.prototype && n.prototype.isPureReactComponent && o.shouldComponentUpdate !== void 0 && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", A(n) || "A pure component"), typeof o.componentDidUnmount == "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", s), typeof o.componentDidReceiveProps == "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", s), typeof o.componentWillRecieveProps == "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", s), typeof o.UNSAFE_componentWillRecieveProps == "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", s), l = o.props !== i, o.props !== void 0 && l && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", s), o.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", s, s), typeof o.getSnapshotBeforeUpdate != "function" || typeof o.componentDidUpdate == "function" || pb.has(n) || (pb.add(n), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", A(n))), typeof o.getDerivedStateFromProps == "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", s), typeof o.getDerivedStateFromError == "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", s), typeof n.getSnapshotBeforeUpdate == "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", s), (l = o.state) && (typeof l != "object" || Gf(l)) && console.error("%s.state: must be set to an object or null", s), typeof o.getChildContext == "function" && typeof n.childContextTypes != "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", s), o = t.stateNode, o.props = i, o.state = t.memoizedState, o.refs = {}, Ui(t), s = n.contextType, o.context = typeof s == "object" && s ? qr(s) : Gg, o.state === i && (s = A(n) || "Component", hb.has(s) || (hb.add(s), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", s))), t.mode & Zg && Ev.recordLegacyContextWarning(t, o), Ev.recordUnsafeLifecycleWarnings(t, o), o.state = t.memoizedState, s = n.getDerivedStateFromProps, typeof s == "function" && (Ho(t, n, s, i), o.state = t.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof o.getSnapshotBeforeUpdate == "function" || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (s = o.state, typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), s !== o.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", M(t) || "Component"), xb.enqueueReplaceState(o, o.state, null)), Xi(t, i, o, a), Yi(), o.state = t.memoizedState), typeof o.componentDidMount == "function" && (t.flags |= 4194308), (t.mode & Qg) !== Jg && (t.flags |= 134217728), o = !0;
			} else if (e === null) {
				o = t.stateNode;
				var f = t.memoizedProps;
				l = Go(n, f), o.props = l;
				var p = o.context;
				u = n.contextType, s = Gg, typeof u == "object" && u && (s = qr(u)), d = n.getDerivedStateFromProps, u = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function", f = t.pendingProps !== f, u || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (f || p !== s) && Wo(t, o, i, s), by = !1;
				var m = t.memoizedState;
				o.state = m, Xi(t, i, o, a), Yi(), p = t.memoizedState, f || m !== p || by ? (typeof d == "function" && (Ho(t, n, d, i), p = t.memoizedState), (l = by || Uo(t, n, l, i, m, p, s)) ? (u || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308), (t.mode & Qg) !== Jg && (t.flags |= 134217728)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), (t.mode & Qg) !== Jg && (t.flags |= 134217728), t.memoizedProps = i, t.memoizedState = p), o.props = i, o.state = p, o.context = s, o = l) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), (t.mode & Qg) !== Jg && (t.flags |= 134217728), o = !1);
			} else {
				o = t.stateNode, Wi(e, t), s = t.memoizedProps, u = Go(n, s), o.props = u, d = t.pendingProps, m = o.context, p = n.contextType, l = Gg, typeof p == "object" && p && (l = qr(p)), f = n.getDerivedStateFromProps, (p = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (s !== d || m !== l) && Wo(t, o, i, l), by = !1, m = t.memoizedState, o.state = m, Xi(t, i, o, a), Yi();
				var h = t.memoizedState;
				s !== d || m !== h || by || e !== null && e.dependencies !== null && Gr(e.dependencies) ? (typeof f == "function" && (Ho(t, n, f, i), h = t.memoizedState), (u = by || Uo(t, n, u, i, m, h, l) || e !== null && e.dependencies !== null && Gr(e.dependencies)) ? (p || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, h, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, h, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || s === e.memoizedProps && m === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || s === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024), t.memoizedProps = i, t.memoizedState = h), o.props = i, o.state = h, o.context = l, o = u) : (typeof o.componentDidUpdate != "function" || s === e.memoizedProps && m === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || s === e.memoizedProps && m === e.memoizedState || (t.flags |= 1024), o = !1);
			}
			if (l = o, ps(e, t), s = (t.flags & 128) != 0, l || s) {
				if (l = t.stateNode, me(t), s && typeof n.getDerivedStateFromError != "function") n = null, R_ = -1;
				else if (n = zv(l), t.mode & Zg) {
					xe(!0);
					try {
						zv(l);
					} finally {
						xe(!1);
					}
				}
				t.flags |= 1, e !== null && s ? (t.child = my(t, e.child, null, a), t.child = my(t, null, n, a)) : ts(e, t, n, a), t.memoizedState = l.state, e = t.child;
			} else e = Os(e, t, a);
			return a = t.stateNode, o && a.props !== i && (Ab || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", M(t) || "a component"), Ab = !0), e;
		}
		function _s(e, t, n, i) {
			return Fr(), t.flags |= 256, ts(e, t, n, i), t.child;
		}
		function vs(e, t) {
			t && t.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", t.displayName || t.name || "Component"), typeof t.getDerivedStateFromProps == "function" && (e = A(t) || "Unknown", kb[e] || (console.error("%s: Function components do not support getDerivedStateFromProps.", e), kb[e] = !0)), typeof t.contextType == "object" && t.contextType !== null && (t = A(t) || "Unknown", Db[t] || (console.error("%s: Function components do not support contextType.", t), Db[t] = !0));
		}
		function ys(e) {
			return {
				baseLanes: e,
				cachePool: Ci()
			};
		}
		function bs(e, t, n) {
			return e = e === null ? 0 : e.childLanes & ~n, t && (e |= Nx), e;
		}
		function xs(e, t, n) {
			var i, a = t.pendingProps;
			s(t) && (t.flags |= 128);
			var o = !1, c = (t.flags & 128) != 0;
			if ((i = c) || (i = e !== null && e.memoizedState === null ? !1 : (Ay.current & ky) !== 0), i && (o = !0, t.flags &= -129), i = (t.flags & 32) != 0, t.flags &= -33, e === null) {
				if (m_) {
					if (o ? ra(t) : oa(t), (e = p_) ? (n = ld(e, v_), n = n !== null && n.data !== ZS ? n : null, n !== null && (i = {
						dehydrated: n,
						treeContext: Tr(),
						retryLane: 536870912,
						hydrationErrors: null
					}, t.memoizedState = i, i = vr(n), i.return = t, t.child = i, f_ = t, p_ = null)) : n = null, n === null) throw Ar(t, e), jr(t);
					return dd(n) ? t.lanes = 32 : t.lanes = 536870912, null;
				}
				var l = a.children;
				if (a = a.fallback, o) {
					oa(t);
					var u = t.mode;
					return l = Cs({
						mode: "hidden",
						children: l
					}, u), a = gr(a, u, n, null), l.return = t, a.return = t, l.sibling = a, t.child = l, a = t.child, a.memoizedState = ys(n), a.childLanes = bs(e, i, n), t.memoizedState = Nb, cs(null, a);
				}
				return ra(t), Ss(t, l);
			}
			var d = e.memoizedState;
			if (d !== null) {
				var f = d.dehydrated;
				if (f !== null) {
					if (c) t.flags & 256 ? (ra(t), t.flags &= -257, t = ws(e, t, n)) : t.memoizedState === null ? (oa(t), l = a.fallback, u = t.mode, a = Cs({
						mode: "visible",
						children: a.children
					}, u), l = gr(l, u, n, null), l.flags |= 2, a.return = t, l.return = t, a.sibling = l, t.child = a, my(t, e.child, null, n), a = t.child, a.memoizedState = ys(n), a.childLanes = bs(e, i, n), t.memoizedState = Nb, t = cs(null, a)) : (oa(t), t.child = e.child, t.flags |= 128, t = null);
					else if (ra(t), kr(), n & 536870912 && cl(t), dd(f)) {
						if (i = f.nextSibling && f.nextSibling.dataset, i) {
							l = i.dgst;
							var p = i.msg;
							u = i.stck;
							var m = i.cstck;
						}
						o = p, i = l, a = u, f = m, l = o, u = f, l = l ? Error(l) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."), l.stack = a || "", l.digest = i, i = u === void 0 ? null : u, a = {
							value: l,
							source: null,
							stack: i
						}, typeof i == "string" && n_.set(l, a), Lr(a), t = ws(e, t, n);
					} else if (Tb || Wr(e, t, n, !1), i = (n & e.childLanes) !== 0, Tb || i) {
						if (i = ux, i !== null && (a = Ne(i, n), a !== 0 && a !== d.retryLane)) throw d.retryLane = a, nr(e, a), Yc(i, e, a), wb;
						ud(f) || ll(), t = ws(e, t, n);
					} else ud(f) ? (t.flags |= 192, t.child = e.child, t = null) : (e = d.treeContext, p_ = pd(f.nextSibling), f_ = t, m_ = !0, __ = null, h_ = !1, g_ = null, v_ = !1, e !== null && Er(t, e), t = Ss(t, a.children), t.flags |= 4096);
					return t;
				}
			}
			return o ? (oa(t), l = a.fallback, u = t.mode, m = e.child, f = m.sibling, a = fr(m, {
				mode: "hidden",
				children: a.children
			}), a.subtreeFlags = m.subtreeFlags & 65011712, f === null ? (l = gr(l, u, n, null), l.flags |= 2) : l = fr(f, l), l.return = t, a.return = t, a.sibling = l, t.child = a, cs(null, a), a = t.child, l = e.child.memoizedState, l === null ? l = ys(n) : (u = l.cachePool, u === null ? u = Ci() : (m = k_._currentValue, u = u.parent === m ? u : {
				parent: m,
				pool: m
			}), l = {
				baseLanes: l.baseLanes | n,
				cachePool: u
			}), a.memoizedState = l, a.childLanes = bs(e, i, n), t.memoizedState = Nb, cs(e.child, a)) : (d !== null && (n & 62914560) === n && (n & e.lanes) !== 0 && cl(t), ra(t), n = e.child, e = n.sibling, n = fr(n, {
				mode: "visible",
				children: a.children
			}), n.return = t, n.sibling = null, e !== null && (i = t.deletions, i === null ? (t.deletions = [e], t.flags |= 16) : i.push(e)), t.child = n, t.memoizedState = null, n);
		}
		function Ss(e, t) {
			return t = Cs({
				mode: "visible",
				children: t
			}, e.mode), t.return = e, e.child = t;
		}
		function Cs(e, t) {
			return e = g(22, e, null, t), e.lanes = 0, e;
		}
		function ws(e, t, n) {
			return my(t, e.child, null, n), e = Ss(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e;
		}
		function Ts(e, t, n) {
			e.lanes |= t;
			var i = e.alternate;
			i !== null && (i.lanes |= t), Hr(e.return, t, n);
		}
		function Es(e, t, n, i, a, o) {
			var s = e.memoizedState;
			s === null ? e.memoizedState = {
				isBackwards: t,
				rendering: null,
				renderingStartTime: 0,
				last: i,
				tail: n,
				tailMode: a,
				treeForkCount: o
			} : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = n, s.tailMode = a, s.treeForkCount = o);
		}
		function Ds(e, t, n) {
			var i = t.pendingProps, a = i.revealOrder, o = i.tail, s = i.children, c = Ay.current;
			if ((i = (c & ky) !== 0) ? (c = c & Oy | ky, t.flags |= 128) : c &= Oy, F(Ay, c, t), c = a ?? "null", a !== "forwards" && a !== "unstable_legacy-backwards" && a !== "together" && a !== "independent" && !jb[c]) if (jb[c] = !0, a == null) console.error("The default for the <SuspenseList revealOrder=\"...\"> prop is changing. To be future compatible you must explictly specify either \"independent\" (the current default), \"together\", \"forwards\" or \"legacy_unstable-backwards\".");
			else if (a === "backwards") console.error("The rendering order of <SuspenseList revealOrder=\"backwards\"> is changing. To be future compatible you must specify revealOrder=\"legacy_unstable-backwards\" instead.");
			else if (typeof a == "string") switch (a.toLowerCase()) {
				case "together":
				case "forwards":
				case "backwards":
				case "independent":
					console.error("\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.", a, a.toLowerCase());
					break;
				case "forward":
				case "backward":
					console.error("\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.", a, a.toLowerCase());
					break;
				default: console.error("\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"independent\", \"together\", \"forwards\" or \"backwards\"?", a);
			}
			else console.error("%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"independent\", \"together\", \"forwards\" or \"backwards\"?", a);
			c = o ?? "null", Mb[c] || (o == null ? (a === "forwards" || a === "backwards" || a === "unstable_legacy-backwards") && (Mb[c] = !0, console.error("The default for the <SuspenseList tail=\"...\"> prop is changing. To be future compatible you must explictly specify either \"visible\" (the current default), \"collapsed\" or \"hidden\".")) : o !== "visible" && o !== "collapsed" && o !== "hidden" ? (Mb[c] = !0, console.error("\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"visible\", \"collapsed\" or \"hidden\"?", o)) : a !== "forwards" && a !== "backwards" && a !== "unstable_legacy-backwards" && (Mb[c] = !0, console.error("<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?", o)));
			a: if ((a === "forwards" || a === "backwards" || a === "unstable_legacy-backwards") && s != null && !1 !== s) if (Gf(s)) {
				for (c = 0; c < s.length; c++) if (!Hi(s[c], c)) break a;
			} else if (c = k(s), typeof c == "function") {
				if (c = c.call(s)) for (var l = c.next(), u = 0; !l.done; l = c.next()) {
					if (!Hi(l.value, u)) break a;
					u++;
				}
			} else console.error("A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?", a);
			if (ts(e, t, s, n), m_ ? (Dr(), s = o_) : s = 0, !i && e !== null && e.flags & 128) a: for (e = t.child; e !== null;) {
				if (e.tag === 13) e.memoizedState !== null && Ts(e, n, t);
				else if (e.tag === 19) Ts(e, n, t);
				else if (e.child !== null) {
					e.child.return = e, e = e.child;
					continue;
				}
				if (e === t) break a;
				for (; e.sibling === null;) {
					if (e.return === null || e.return === t) break a;
					e = e.return;
				}
				e.sibling.return = e.return, e = e.sibling;
			}
			switch (a) {
				case "forwards":
					for (n = t.child, a = null; n !== null;) e = n.alternate, e !== null && ca(e) === null && (a = n), n = n.sibling;
					n = a, n === null ? (a = t.child, t.child = null) : (a = n.sibling, n.sibling = null), Es(t, !1, a, n, o, s);
					break;
				case "backwards":
				case "unstable_legacy-backwards":
					for (n = null, a = t.child, t.child = null; a !== null;) {
						if (e = a.alternate, e !== null && ca(e) === null) {
							t.child = a;
							break;
						}
						e = a.sibling, a.sibling = n, n = a, a = e;
					}
					Es(t, !0, n, null, o, s);
					break;
				case "together":
					Es(t, !1, null, null, void 0, s);
					break;
				default: t.memoizedState = null;
			}
			return t.child;
		}
		function Os(e, t, n) {
			if (e !== null && (t.dependencies = e.dependencies), R_ = -1, Ax |= t.lanes, (n & t.childLanes) === 0) if (e !== null) {
				if (Wr(e, t, n, !1), (n & t.childLanes) === 0) return null;
			} else return null;
			if (e !== null && t.child !== e.child) throw Error("Resuming work not yet implemented.");
			if (t.child !== null) {
				for (e = t.child, n = fr(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;) e = e.sibling, n = n.sibling = fr(e, e.pendingProps), n.return = t;
				n.sibling = null;
			}
			return t.child;
		}
		function ks(e, t) {
			return (e.lanes & t) === 0 ? (e = e.dependencies, !!(e !== null && Gr(e))) : !0;
		}
		function As(e, t, n) {
			switch (t.tag) {
				case 3:
					ee(t, t.stateNode.containerInfo), Br(t, k_, e.memoizedState.cache), Fr();
					break;
				case 27:
				case 5:
					te(t);
					break;
				case 4:
					ee(t, t.stateNode.containerInfo);
					break;
				case 10:
					Br(t, t.type, t.memoizedProps.value);
					break;
				case 12:
					(n & t.childLanes) !== 0 && (t.flags |= 4), t.flags |= 2048;
					var i = t.stateNode;
					i.effectDuration = -0, i.passiveEffectDuration = -0;
					break;
				case 31:
					if (t.memoizedState !== null) return t.flags |= 128, ia(t), null;
					break;
				case 13:
					if (i = t.memoizedState, i !== null) return i.dehydrated === null ? (n & t.child.childLanes) === 0 ? (ra(t), e = Os(e, t, n), e === null ? null : e.sibling) : xs(e, t, n) : (ra(t), t.flags |= 128, null);
					ra(t);
					break;
				case 19:
					var a = (e.flags & 128) != 0;
					if (i = (n & t.childLanes) !== 0, i ||= (Wr(e, t, n, !1), (n & t.childLanes) !== 0), a) {
						if (i) return Ds(e, t, n);
						t.flags |= 128;
					}
					if (a = t.memoizedState, a !== null && (a.rendering = null, a.tail = null, a.lastEffect = null), F(Ay, Ay.current, t), i) break;
					return null;
				case 22: return t.lanes = 0, ss(e, t, n, t.pendingProps);
				case 24: Br(t, k_, e.memoizedState.cache);
			}
			return Os(e, t, n);
		}
		function js(e, t, n) {
			if (t._debugNeedsRemount && e !== null) {
				n = mr(t.type, t.key, t.pendingProps, t._debugOwner || null, t.mode, t.lanes), n._debugStack = t._debugStack, n._debugTask = t._debugTask;
				var i = t.return;
				if (i === null) throw Error("Cannot swap the root fiber.");
				if (e.alternate = null, t.alternate = null, n.index = t.index, n.sibling = t.sibling, n.return = t.return, n.ref = t.ref, n._debugInfo = t._debugInfo, t === i.child) i.child = n;
				else {
					var a = i.child;
					if (a === null) throw Error("Expected parent to have a child.");
					for (; a.sibling !== t;) if (a = a.sibling, a === null) throw Error("Expected to find the previous sibling.");
					a.sibling = n;
				}
				return t = i.deletions, t === null ? (i.deletions = [e], i.flags |= 16) : t.push(e), n.flags |= 2, n;
			}
			if (e !== null) if (e.memoizedProps !== t.pendingProps || t.type !== e.type) Tb = !0;
			else {
				if (!ks(e, n) && !(t.flags & 128)) return Tb = !1, As(e, t, n);
				Tb = !!(e.flags & 131072);
			}
			else Tb = !1, (i = m_) && (Dr(), i = (t.flags & 1048576) != 0), i && (i = t.index, Dr(), Sr(t, o_, i));
			switch (t.lanes = 0, t.tag) {
				case 16:
					a: if (i = t.pendingProps, e = Di(t.elementType), t.type = e, typeof e == "function") dr(e) ? (i = Go(e, i), t.tag = 1, t.type = e = ar(e), t = gs(null, t, e, i, n)) : (t.tag = 0, vs(t, e), t.type = e = ar(e), t = ms(null, t, e, i, n));
					else {
						if (e != null) {
							if (a = e.$$typeof, a === If) {
								t.tag = 11, t.type = e = or(e), t = ns(null, t, e, i, n);
								break a;
							} else if (a === zf) {
								t.tag = 14, t = rs(null, t, e, i, n);
								break a;
							}
						}
						throw t = "", typeof e == "object" && e && e.$$typeof === Bf && (t = " Did you wrap a component in React.lazy() more than once?"), n = A(e) || e, Error("Element type is invalid. Received a promise that resolves to: " + n + ". Lazy element type must resolve to a class or function." + t);
					}
					return t;
				case 0: return ms(e, t, t.type, t.pendingProps, n);
				case 1: return i = t.type, a = Go(i, t.pendingProps), gs(e, t, i, a, n);
				case 3:
					a: {
						if (ee(t, t.stateNode.containerInfo), e === null) throw Error("Should have a current fiber. This is a bug in React.");
						i = t.pendingProps;
						var o = t.memoizedState;
						a = o.element, Wi(e, t), Xi(t, i, null, n);
						var s = t.memoizedState;
						if (i = s.cache, Br(t, k_, i), i !== o.cache && Ur(t, [k_], n, !0), Yi(), i = s.element, o.isDehydrated) if (o = {
							element: i,
							isDehydrated: !1,
							cache: s.cache
						}, t.updateQueue.baseState = o, t.memoizedState = o, t.flags & 256) {
							t = _s(e, t, i, n);
							break a;
						} else if (i !== a) {
							a = br(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), t), Lr(a), t = _s(e, t, i, n);
							break a;
						} else {
							switch (e = t.stateNode.containerInfo, e.nodeType) {
								case 9:
									e = e.body;
									break;
								default: e = e.nodeName === "HTML" ? e.ownerDocument.body : e;
							}
							for (p_ = pd(e.firstChild), f_ = t, m_ = !0, __ = null, h_ = !1, g_ = null, v_ = !0, n = hy(t, null, i, n), t.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
						}
						else {
							if (Fr(), i === a) {
								t = Os(e, t, n);
								break a;
							}
							ts(e, t, i, n);
						}
						t = t.child;
					}
					return t;
				case 26: return ps(e, t), e === null ? (n = Ed(t.type, null, t.pendingProps, null)) ? t.memoizedState = n : m_ || (n = t.type, e = t.pendingProps, i = I($f.current), i = Fu(i).createElement(n), i[Wp] = t, i[Gp] = e, xu(i, n, e), We(i), t.stateNode = i) : t.memoizedState = Ed(t.type, e.memoizedProps, t.pendingProps, e.memoizedState), null;
				case 27: return te(t), e === null && m_ && (i = I($f.current), a = R(), i = t.stateNode = xd(t.type, t.pendingProps, i, a, !1), h_ || (a = ju(i, t.type, t.pendingProps, a), a !== null && (Or(t, 0).serverProps = a)), f_ = t, v_ = !0, a = p_, Yu(t.type) ? (wC = a, p_ = pd(i.firstChild)) : p_ = a), ts(e, t, t.pendingProps.children, n), ps(e, t), e === null && (t.flags |= 4194304), t.child;
				case 5: return e === null && m_ && (o = R(), i = It(t.type, o.ancestorInfo), a = p_, (s = !a) || (s = sd(a, t.type, t.pendingProps, v_), s === null ? o = !1 : (t.stateNode = s, h_ || (o = ju(s, t.type, t.pendingProps, o), o !== null && (Or(t, 0).serverProps = o)), f_ = t, p_ = pd(s.firstChild), v_ = !1, o = !0), s = !o), s && (i && Ar(t, a), jr(t))), te(t), a = t.type, o = t.pendingProps, s = e === null ? null : e.memoizedProps, i = o.children, Ru(a, o) ? i = null : s !== null && Ru(a, s) && (t.flags |= 32), t.memoizedState !== null && (a = ma(e, t, _a, null, null, n), HC._currentValue = a), ps(e, t), ts(e, t, i, n), t.child;
				case 6: return e === null && m_ && (n = t.pendingProps, e = R(), i = e.ancestorInfo.current, n = i == null ? !0 : Lt(n, i.tag, e.ancestorInfo.implicitRootScope), e = p_, (i = !e) || (i = cd(e, t.pendingProps, v_), i === null ? i = !1 : (t.stateNode = i, f_ = t, p_ = null, i = !0), i = !i), i && (n && Ar(t, e), jr(t))), null;
				case 13: return xs(e, t, n);
				case 4: return ee(t, t.stateNode.containerInfo), i = t.pendingProps, e === null ? t.child = my(t, null, i, n) : ts(e, t, i, n), t.child;
				case 11: return ns(e, t, t.type, t.pendingProps, n);
				case 7: return ts(e, t, t.pendingProps, n), t.child;
				case 8: return ts(e, t, t.pendingProps.children, n), t.child;
				case 12: return t.flags |= 4, t.flags |= 2048, i = t.stateNode, i.effectDuration = -0, i.passiveEffectDuration = -0, ts(e, t, t.pendingProps.children, n), t.child;
				case 10: return i = t.type, a = t.pendingProps, o = a.value, "value" in a || Pb || (Pb = !0, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), Br(t, i, o), ts(e, t, a.children, n), t.child;
				case 9: return a = t.type._context, i = t.pendingProps.children, typeof i != "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Kr(t), a = qr(a), i = Lv(i, a, void 0), t.flags |= 1, ts(e, t, i, n), t.child;
				case 14: return rs(e, t, t.type, t.pendingProps, n);
				case 15: return os(e, t, t.type, t.pendingProps, n);
				case 19: return Ds(e, t, n);
				case 31: return fs(e, t, n);
				case 22: return ss(e, t, n, t.pendingProps);
				case 24: return Kr(t), i = qr(k_), e === null ? (a = xi(), a === null && (a = ux, o = Xr(), a.pooledCache = o, Zr(o), o !== null && (a.pooledCacheLanes |= n), a = o), t.memoizedState = {
					parent: i,
					cache: a
				}, Ui(t), Br(t, k_, a)) : ((e.lanes & n) !== 0 && (Wi(e, t), Xi(t, null, null, n), Yi()), a = e.memoizedState, o = t.memoizedState, a.parent === i ? (i = o.cache, Br(t, k_, i), i !== a.cache && Ur(t, [k_], n, !0)) : (a = {
					parent: i,
					cache: i
				}, t.memoizedState = a, t.lanes === 0 && (t.memoizedState = t.updateQueue.baseState = a), Br(t, k_, i))), ts(e, t, t.pendingProps.children, n), t.child;
				case 29: throw t.pendingProps;
			}
			throw Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
		}
		function Ms(e) {
			e.flags |= 4;
		}
		function Ns(e, t, n, i, a) {
			if ((t = (e.mode & $g) !== Jg) && (t = !1), t) {
				if (e.flags |= 16777216, (a & 335544128) === a) if (e.stateNode.complete) e.flags |= 8192;
				else if (al()) e.flags |= 8192;
				else throw iy = ry, ty;
			} else e.flags &= -16777217;
		}
		function Ps(e, t) {
			if (t.type !== "stylesheet" || (t.state.loading & kC) !== TC) e.flags &= -16777217;
			else if (e.flags |= 16777216, !Vd(t)) if (al()) e.flags |= 8192;
			else throw iy = ry, ty;
		}
		function Fs(e, t) {
			t !== null && (e.flags |= 4), e.flags & 16384 && (t = e.tag === 22 ? 536870912 : De(), e.lanes |= t, Px |= t);
		}
		function Is(e, t) {
			if (!m_) switch (e.tailMode) {
				case "hidden":
					t = e.tail;
					for (var n = null; t !== null;) t.alternate !== null && (n = t), t = t.sibling;
					n === null ? e.tail = null : n.sibling = null;
					break;
				case "collapsed":
					n = e.tail;
					for (var i = null; n !== null;) n.alternate !== null && (i = n), n = n.sibling;
					i === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : i.sibling = null;
			}
		}
		function Ls(e) {
			var t = e.alternate !== null && e.alternate.child === e.child, n = 0, i = 0;
			if (t) if ((e.mode & Xg) !== Jg) {
				for (var a = e.selfBaseDuration, o = e.child; o !== null;) n |= o.lanes | o.childLanes, i |= o.subtreeFlags & 65011712, i |= o.flags & 65011712, a += o.treeBaseDuration, o = o.sibling;
				e.treeBaseDuration = a;
			} else for (a = e.child; a !== null;) n |= a.lanes | a.childLanes, i |= a.subtreeFlags & 65011712, i |= a.flags & 65011712, a.return = e, a = a.sibling;
			else if ((e.mode & Xg) !== Jg) {
				a = e.actualDuration, o = e.selfBaseDuration;
				for (var s = e.child; s !== null;) n |= s.lanes | s.childLanes, i |= s.subtreeFlags, i |= s.flags, a += s.actualDuration, o += s.treeBaseDuration, s = s.sibling;
				e.actualDuration = a, e.treeBaseDuration = o;
			} else for (a = e.child; a !== null;) n |= a.lanes | a.childLanes, i |= a.subtreeFlags, i |= a.flags, a.return = e, a = a.sibling;
			return e.subtreeFlags |= i, e.childLanes = n, t;
		}
		function Rs(e, t, n) {
			var i = t.pendingProps;
			switch (wr(t), t.tag) {
				case 16:
				case 15:
				case 0:
				case 11:
				case 7:
				case 8:
				case 12:
				case 9:
				case 14: return Ls(t), null;
				case 1: return Ls(t), null;
				case 3: return n = t.stateNode, i = null, e !== null && (i = e.memoizedState.cache), t.memoizedState.cache !== i && (t.flags |= 2048), Vr(k_, t), L(t), n.pendingContext &&= (n.context = n.pendingContext, null), (e === null || e.child === null) && (Pr(t) ? (Rr(), Ms(t)) : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Ir())), Ls(t), null;
				case 26:
					var a = t.type, o = t.memoizedState;
					return e === null ? (Ms(t), o === null ? (Ls(t), Ns(t, a, null, i, n)) : (Ls(t), Ps(t, o))) : o ? o === e.memoizedState ? (Ls(t), t.flags &= -16777217) : (Ms(t), Ls(t), Ps(t, o)) : (e = e.memoizedProps, e !== i && Ms(t), Ls(t), Ns(t, a, e, i, n)), null;
				case 27:
					if (ne(t), n = I($f.current), a = t.type, e !== null && t.stateNode != null) e.memoizedProps !== i && Ms(t);
					else {
						if (!i) {
							if (t.stateNode === null) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
							return Ls(t), null;
						}
						e = R(), Pr(t) ? Mr(t, e) : (e = xd(a, i, n, e, !0), t.stateNode = e, Ms(t));
					}
					return Ls(t), null;
				case 5:
					if (ne(t), a = t.type, e !== null && t.stateNode != null) e.memoizedProps !== i && Ms(t);
					else {
						if (!i) {
							if (t.stateNode === null) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
							return Ls(t), null;
						}
						var s = R();
						if (Pr(t)) Mr(t, s);
						else {
							switch (o = I($f.current), It(a, s.ancestorInfo), s = s.context, o = Fu(o), s) {
								case fC:
									o = o.createElementNS(Pm, a);
									break;
								case pC:
									o = o.createElementNS(Nm, a);
									break;
								default: switch (a) {
									case "svg":
										o = o.createElementNS(Pm, a);
										break;
									case "math":
										o = o.createElementNS(Nm, a);
										break;
									case "script":
										o = o.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild);
										break;
									case "select":
										o = typeof i.is == "string" ? o.createElement("select", { is: i.is }) : o.createElement("select"), i.multiple ? o.multiple = !0 : i.size && (o.size = i.size);
										break;
									default: o = typeof i.is == "string" ? o.createElement(a, { is: i.is }) : o.createElement(a), a.indexOf("-") === -1 && (a !== a.toLowerCase() && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", a), Object.prototype.toString.call(o) !== "[object HTMLUnknownElement]" || hp.call(gC, a) || (gC[a] = !0, console.error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", a)));
								}
							}
							o[Wp] = t, o[Gp] = i;
							a: for (s = t.child; s !== null;) {
								if (s.tag === 5 || s.tag === 6) o.appendChild(s.stateNode);
								else if (s.tag !== 4 && s.tag !== 27 && s.child !== null) {
									s.child.return = s, s = s.child;
									continue;
								}
								if (s === t) break a;
								for (; s.sibling === null;) {
									if (s.return === null || s.return === t) break a;
									s = s.return;
								}
								s.sibling.return = s.return, s = s.sibling;
							}
							t.stateNode = o;
							a: switch (xu(o, a, i), a) {
								case "button":
								case "input":
								case "select":
								case "textarea":
									i = !!i.autoFocus;
									break a;
								case "img":
									i = !0;
									break a;
								default: i = !1;
							}
							i && Ms(t);
						}
					}
					return Ls(t), Ns(t, t.type, e === null ? null : e.memoizedProps, t.pendingProps, n), null;
				case 6:
					if (e && t.stateNode != null) e.memoizedProps !== i && Ms(t);
					else {
						if (typeof i != "string" && t.stateNode === null) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
						if (e = I($f.current), n = R(), Pr(t)) {
							if (e = t.stateNode, n = t.memoizedProps, a = !h_, i = null, o = f_, o !== null) switch (o.tag) {
								case 3:
									a && (a = hd(e, n, i), a !== null && (Or(t, 0).serverProps = a));
									break;
								case 27:
								case 5: i = o.memoizedProps, a && (a = hd(e, n, i), a !== null && (Or(t, 0).serverProps = a));
							}
							e[Wp] = t, e = !!(e.nodeValue === n || i !== null && !0 === i.suppressHydrationWarning || vu(e.nodeValue, n)), e || jr(t, !0);
						} else a = n.ancestorInfo.current, a != null && Lt(i, a.tag, n.ancestorInfo.implicitRootScope), e = Fu(e).createTextNode(i), e[Wp] = t, t.stateNode = e;
					}
					return Ls(t), null;
				case 31:
					if (n = t.memoizedState, e === null || e.memoizedState !== null) {
						if (i = Pr(t), n !== null) {
							if (e === null) {
								if (!i) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
								if (e = t.memoizedState, e = e === null ? null : e.dehydrated, !e) throw Error("Expected to have a hydrated activity instance. This error is likely caused by a bug in React. Please file an issue.");
								e[Wp] = t, Ls(t), (t.mode & Xg) !== Jg && n !== null && (e = t.child, e !== null && (t.treeBaseDuration -= e.treeBaseDuration));
							} else Rr(), Fr(), !(t.flags & 128) && (n = t.memoizedState = null), t.flags |= 4, Ls(t), (t.mode & Xg) !== Jg && n !== null && (e = t.child, e !== null && (t.treeBaseDuration -= e.treeBaseDuration));
							e = !1;
						} else n = Ir(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = n), e = !0;
						if (!e) return t.flags & 256 ? (sa(t), t) : (sa(t), null);
						if (t.flags & 128) throw Error("Client rendering an Activity suspended it again. This is a bug in React.");
					}
					return Ls(t), null;
				case 13:
					if (i = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
						if (a = i, o = Pr(t), a !== null && a.dehydrated !== null) {
							if (e === null) {
								if (!o) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
								if (o = t.memoizedState, o = o === null ? null : o.dehydrated, !o) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
								o[Wp] = t, Ls(t), (t.mode & Xg) !== Jg && a !== null && (a = t.child, a !== null && (t.treeBaseDuration -= a.treeBaseDuration));
							} else Rr(), Fr(), !(t.flags & 128) && (a = t.memoizedState = null), t.flags |= 4, Ls(t), (t.mode & Xg) !== Jg && a !== null && (a = t.child, a !== null && (t.treeBaseDuration -= a.treeBaseDuration));
							a = !1;
						} else a = Ir(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = a), a = !0;
						if (!a) return t.flags & 256 ? (sa(t), t) : (sa(t), null);
					}
					return sa(t), t.flags & 128 ? (t.lanes = n, (t.mode & Xg) !== Jg && _i(t), t) : (n = i !== null, e = e !== null && e.memoizedState !== null, n && (i = t.child, a = null, i.alternate !== null && i.alternate.memoizedState !== null && i.alternate.memoizedState.cachePool !== null && (a = i.alternate.memoizedState.cachePool.pool), o = null, i.memoizedState !== null && i.memoizedState.cachePool !== null && (o = i.memoizedState.cachePool.pool), o !== a && (i.flags |= 2048)), n !== e && n && (t.child.flags |= 8192), Fs(t, t.updateQueue), Ls(t), (t.mode & Xg) !== Jg && n && (e = t.child, e !== null && (t.treeBaseDuration -= e.treeBaseDuration)), null);
				case 4: return L(t), e === null && au(t.stateNode.containerInfo), Ls(t), null;
				case 10: return Vr(t.type, t), Ls(t), null;
				case 19:
					if (P(Ay, t), i = t.memoizedState, i === null) return Ls(t), null;
					if (a = (t.flags & 128) != 0, o = i.rendering, o === null) if (a) Is(i, !1);
					else {
						if (kx !== tx || e !== null && e.flags & 128) for (e = t.child; e !== null;) {
							if (o = ca(e), o !== null) {
								for (t.flags |= 128, Is(i, !1), e = o.updateQueue, t.updateQueue = e, Fs(t, e), t.subtreeFlags = 0, e = n, n = t.child; n !== null;) pr(n, e), n = n.sibling;
								return F(Ay, Ay.current & Oy | ky, t), m_ && xr(t, i.treeForkCount), t.child;
							}
							e = e.sibling;
						}
						i.tail !== null && bp() > Vx && (t.flags |= 128, a = !0, Is(i, !1), t.lanes = 4194304);
					}
					else {
						if (!a) if (e = ca(o), e !== null) {
							if (t.flags |= 128, a = !0, e = e.updateQueue, t.updateQueue = e, Fs(t, e), Is(i, !0), i.tail === null && i.tailMode === "hidden" && !o.alternate && !m_) return Ls(t), null;
						} else 2 * bp() - i.renderingStartTime > Vx && n !== 536870912 && (t.flags |= 128, a = !0, Is(i, !1), t.lanes = 4194304);
						i.isBackwards ? (o.sibling = t.child, t.child = o) : (e = i.last, e === null ? t.child = o : e.sibling = o, i.last = o);
					}
					return i.tail === null ? (Ls(t), null) : (e = i.tail, i.rendering = e, i.tail = e.sibling, i.renderingStartTime = bp(), e.sibling = null, n = Ay.current, n = a ? n & Oy | ky : n & Oy, F(Ay, n, t), m_ && xr(t, i.treeForkCount), e);
				case 22:
				case 23: return sa(t), na(t), i = t.memoizedState !== null, e === null ? i && (t.flags |= 8192) : e.memoizedState !== null !== i && (t.flags |= 8192), i ? n & 536870912 && !(t.flags & 128) && (Ls(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ls(t), n = t.updateQueue, n !== null && Fs(t, n.retryQueue), n = null, e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), i = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (i = t.memoizedState.cachePool.pool), i !== n && (t.flags |= 2048), e !== null && P(Tv, t), null;
				case 24: return n = null, e !== null && (n = e.memoizedState.cache), t.memoizedState.cache !== n && (t.flags |= 2048), Vr(k_, t), Ls(t), null;
				case 25: return null;
				case 30: return null;
			}
			throw Error("Unknown unit of work tag (" + t.tag + "). This error is likely caused by a bug in React. Please file an issue.");
		}
		function zs(e, t) {
			switch (wr(t), t.tag) {
				case 1: return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, (t.mode & Xg) !== Jg && _i(t), t) : null;
				case 3: return Vr(k_, t), L(t), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
				case 26:
				case 27:
				case 5: return ne(t), null;
				case 31:
					if (t.memoizedState !== null) {
						if (sa(t), t.alternate === null) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
						Fr();
					}
					return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, (t.mode & Xg) !== Jg && _i(t), t) : null;
				case 13:
					if (sa(t), e = t.memoizedState, e !== null && e.dehydrated !== null) {
						if (t.alternate === null) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
						Fr();
					}
					return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, (t.mode & Xg) !== Jg && _i(t), t) : null;
				case 19: return P(Ay, t), null;
				case 4: return L(t), null;
				case 10: return Vr(t.type, t), null;
				case 22:
				case 23: return sa(t), na(t), e !== null && P(Tv, t), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, (t.mode & Xg) !== Jg && _i(t), t) : null;
				case 24: return Vr(k_, t), null;
				case 25: return null;
				default: return null;
			}
		}
		function Bs(e, t) {
			switch (wr(t), t.tag) {
				case 3:
					Vr(k_, t), L(t);
					break;
				case 26:
				case 27:
				case 5:
					ne(t);
					break;
				case 4:
					L(t);
					break;
				case 31:
					t.memoizedState !== null && sa(t);
					break;
				case 13:
					sa(t);
					break;
				case 19:
					P(Ay, t);
					break;
				case 10:
					Vr(t.type, t);
					break;
				case 22:
				case 23:
					sa(t), na(t), e !== null && P(Tv, t);
					break;
				case 24: Vr(k_, t);
			}
		}
		function Vs(e) {
			return (e.mode & Xg) !== Jg;
		}
		function Hs(e, t) {
			Vs(e) ? (gi(), Ws(t, e), mi()) : Ws(t, e);
		}
		function Us(e, t, n) {
			Vs(e) ? (gi(), Gs(n, e, t), mi()) : Gs(n, e, t);
		}
		function Ws(e, t) {
			try {
				var n = t.updateQueue, i = n === null ? null : n.lastEffect;
				if (i !== null) {
					var a = i.next;
					n = a;
					do {
						if ((n.tag & e) === e && (i = void 0, (e & Ny) !== jy && (xS = !0), i = V(t, Yv, n), (e & Ny) !== jy && (xS = !1), i !== void 0 && typeof i != "function")) {
							var o = void 0;
							o = (n.tag & Py) === 0 ? (n.tag & Ny) === 0 ? "useEffect" : "useInsertionEffect" : "useLayoutEffect";
							var s = void 0;
							s = i === null ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof i.then == "function" ? "\n\nIt looks like you wrote " + o + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + o + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + i, V(t, function(e, t) {
								console.error("%s must not return anything besides a function, which is used for clean-up.%s", e, t);
							}, o, s);
						}
						n = n.next;
					} while (n !== a);
				}
			} catch (e) {
				kl(t, t.return, e);
			}
		}
		function Gs(e, t, n) {
			try {
				var i = t.updateQueue, a = i === null ? null : i.lastEffect;
				if (a !== null) {
					var o = a.next;
					i = o;
					do {
						if ((i.tag & e) === e) {
							var s = i.inst, c = s.destroy;
							c !== void 0 && (s.destroy = void 0, (e & Ny) !== jy && (xS = !0), a = t, V(a, Zv, a, n, c), (e & Ny) !== jy && (xS = !1));
						}
						i = i.next;
					} while (i !== o);
				}
			} catch (e) {
				kl(t, t.return, e);
			}
		}
		function Ks(e, t) {
			Vs(e) ? (gi(), Ws(t, e), mi()) : Ws(t, e);
		}
		function qs(e, t, n) {
			Vs(e) ? (gi(), Gs(n, e, t), mi()) : Gs(n, e, t);
		}
		function Js(e) {
			var t = e.updateQueue;
			if (t !== null) {
				var n = e.stateNode;
				e.type.defaultProps || "ref" in e.memoizedProps || Ab || (n.props !== e.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", M(e) || "instance"), n.state !== e.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", M(e) || "instance"));
				try {
					V(e, $i, t, n);
				} catch (t) {
					kl(e, e.return, t);
				}
			}
		}
		function Ys(e, t, n) {
			return e.getSnapshotBeforeUpdate(t, n);
		}
		function Xs(e, t) {
			var n = t.memoizedProps, i = t.memoizedState;
			t = e.stateNode, e.type.defaultProps || "ref" in e.memoizedProps || Ab || (t.props !== e.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", M(e) || "instance"), t.state !== e.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", M(e) || "instance"));
			try {
				var a = Go(e.type, n), o = V(e, Ys, t, a, i);
				n = Fb, o !== void 0 || n.has(e.type) || (n.add(e.type), V(e, function() {
					console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", M(e));
				})), t.__reactInternalSnapshotBeforeUpdate = o;
			} catch (t) {
				kl(e, e.return, t);
			}
		}
		function Zs(e, t, n) {
			n.props = Go(e.type, e.memoizedProps), n.state = e.memoizedState, Vs(e) ? (gi(), V(e, qv, e, t, n), mi()) : V(e, qv, e, t, n);
		}
		function Qs(e) {
			var t = e.ref;
			if (t !== null) {
				switch (e.tag) {
					case 26:
					case 27:
					case 5:
						var n = e.stateNode;
						break;
					case 30:
						n = e.stateNode;
						break;
					default: n = e.stateNode;
				}
				if (typeof t == "function") if (Vs(e)) try {
					gi(), e.refCleanup = t(n);
				} finally {
					mi();
				}
				else e.refCleanup = t(n);
				else typeof t == "string" ? console.error("String refs are no longer supported.") : t.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", M(e)), t.current = n;
			}
		}
		function $s(e, t) {
			try {
				V(e, Qs, e);
			} catch (n) {
				kl(e, t, n);
			}
		}
		function ec(e, t) {
			var n = e.ref, i = e.refCleanup;
			if (n !== null) if (typeof i == "function") try {
				if (Vs(e)) try {
					gi(), V(e, i);
				} finally {
					mi(e);
				}
				else V(e, i);
			} catch (n) {
				kl(e, t, n);
			} finally {
				e.refCleanup = null, e = e.alternate, e != null && (e.refCleanup = null);
			}
			else if (typeof n == "function") try {
				if (Vs(e)) try {
					gi(), V(e, n, null);
				} finally {
					mi(e);
				}
				else V(e, n, null);
			} catch (n) {
				kl(e, t, n);
			}
			else n.current = null;
		}
		function tc(e, t, n, i) {
			var a = e.memoizedProps, o = a.id, s = a.onCommit;
			a = a.onRender, t = t === null ? "mount" : "update", vv && (t = "nested-update"), typeof a == "function" && a(o, t, e.actualDuration, e.treeBaseDuration, e.actualStartTime, n), typeof s == "function" && s(o, t, i, n);
		}
		function nc(e, t, n, i) {
			var a = e.memoizedProps;
			e = a.id, a = a.onPostCommit, t = t === null ? "mount" : "update", vv && (t = "nested-update"), typeof a == "function" && a(e, t, i, n);
		}
		function rc(e) {
			var t = e.type, n = e.memoizedProps, i = e.stateNode;
			try {
				V(e, Uu, i, t, n, e);
			} catch (t) {
				kl(e, e.return, t);
			}
		}
		function ic(e, t, n) {
			try {
				V(e, Gu, e.stateNode, e.type, n, t, e);
			} catch (t) {
				kl(e, e.return, t);
			}
		}
		function ac(e) {
			return e.tag === 5 || e.tag === 3 || e.tag === 26 || e.tag === 27 && Yu(e.type) || e.tag === 4;
		}
		function oc(e) {
			a: for (;;) {
				for (; e.sibling === null;) {
					if (e.return === null || ac(e.return)) return null;
					e = e.return;
				}
				for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) {
					if (e.tag === 27 && Yu(e.type) || e.flags & 2 || e.child === null || e.tag === 4) continue a;
					e.child.return = e, e = e.child;
				}
				if (!(e.flags & 2)) return e.stateNode;
			}
		}
		function sc(e, t, n) {
			var i = e.tag;
			if (i === 5 || i === 6) e = e.stateNode, t ? (Ju(n), (n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n).insertBefore(e, t)) : (Ju(n), t = n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n, t.appendChild(e), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Yt));
			else if (i !== 4 && (i === 27 && Yu(e.type) && (n = e.stateNode, t = null), e = e.child, e !== null)) for (sc(e, t, n), e = e.sibling; e !== null;) sc(e, t, n), e = e.sibling;
		}
		function cc(e, t, n) {
			var i = e.tag;
			if (i === 5 || i === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
			else if (i !== 4 && (i === 27 && Yu(e.type) && (n = e.stateNode), e = e.child, e !== null)) for (cc(e, t, n), e = e.sibling; e !== null;) cc(e, t, n), e = e.sibling;
		}
		function lc(e) {
			for (var t, n = e.return; n !== null;) {
				if (ac(n)) {
					t = n;
					break;
				}
				n = n.return;
			}
			if (t == null) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
			switch (t.tag) {
				case 27:
					t = t.stateNode, n = oc(e), cc(e, n, t);
					break;
				case 5:
					n = t.stateNode, t.flags & 32 && (Ku(n), t.flags &= -33), t = oc(e), cc(e, t, n);
					break;
				case 3:
				case 4:
					t = t.stateNode.containerInfo, n = oc(e), sc(e, n, t);
					break;
				default: throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
			}
		}
		function uc(e) {
			var t = e.stateNode, n = e.memoizedProps;
			try {
				V(e, Sd, e.type, n, t, e);
			} catch (t) {
				kl(e, e.return, t);
			}
		}
		function dc(e, t) {
			return t.tag === 31 ? (t = t.memoizedState, e.memoizedState !== null && t === null) : t.tag === 13 ? (e = e.memoizedState, t = t.memoizedState, e !== null && e.dehydrated !== null && (t === null || t.dehydrated === null)) : t.tag === 3 ? e.memoizedState.isDehydrated && (t.flags & 256) == 0 : !1;
		}
		function fc(e, t) {
			if (e = e.containerInfo, mC = aw, e = kn(e), An(e)) {
				if ("selectionStart" in e) var n = {
					start: e.selectionStart,
					end: e.selectionEnd
				};
				else a: {
					n = (n = e.ownerDocument) && n.defaultView || window;
					var i = n.getSelection && n.getSelection();
					if (i && i.rangeCount !== 0) {
						n = i.anchorNode;
						var a = i.anchorOffset, o = i.focusNode;
						i = i.focusOffset;
						try {
							n.nodeType, o.nodeType;
						} catch {
							n = null;
							break a;
						}
						var s = 0, c = -1, l = -1, u = 0, d = 0, f = e, p = null;
						b: for (;;) {
							for (var m; f !== n || a !== 0 && f.nodeType !== 3 || (c = s + a), f !== o || i !== 0 && f.nodeType !== 3 || (l = s + i), f.nodeType === 3 && (s += f.nodeValue.length), (m = f.firstChild) !== null;) p = f, f = m;
							for (;;) {
								if (f === e) break b;
								if (p === n && ++u === a && (c = s), p === o && ++d === i && (l = s), (m = f.nextSibling) !== null) break;
								f = p, p = f.parentNode;
							}
							f = m;
						}
						n = c === -1 || l === -1 ? null : {
							start: c,
							end: l
						};
					} else n = null;
				}
				n ||= {
					start: 0,
					end: 0
				};
			} else n = null;
			for (hC = {
				focusedElem: e,
				selectionRange: n
			}, aw = !1, Bb = t; Bb !== null;) if (t = Bb, e = t.child, t.subtreeFlags & 1028 && e !== null) e.return = t, Bb = e;
			else for (; Bb !== null;) {
				switch (e = t = Bb, n = e.alternate, a = e.flags, e.tag) {
					case 0:
						if (a & 4 && (e = e.updateQueue, e = e === null ? null : e.events, e !== null)) for (n = 0; n < e.length; n++) a = e[n], a.ref.impl = a.nextImpl;
						break;
					case 11:
					case 15: break;
					case 1:
						a & 1024 && n !== null && Xs(e, n);
						break;
					case 3:
						if (a & 1024) {
							if (e = e.stateNode.containerInfo, n = e.nodeType, n === 9) od(e);
							else if (n === 1) switch (e.nodeName) {
								case "HEAD":
								case "HTML":
								case "BODY":
									od(e);
									break;
								default: e.textContent = "";
							}
						}
						break;
					case 5:
					case 26:
					case 27:
					case 6:
					case 4:
					case 17: break;
					default: if (a & 1024) throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
				}
				if (e = t.sibling, e !== null) {
					e.return = t.return, Bb = e;
					break;
				}
				Bb = t.return;
			}
		}
		function pc(e, t, n) {
			var i = ai(), a = si(), o = li(), s = ui(), c = n.flags;
			switch (n.tag) {
				case 0:
				case 11:
				case 15:
					Tc(e, n), c & 4 && Hs(n, Py | My);
					break;
				case 1:
					if (Tc(e, n), c & 4) if (e = n.stateNode, t === null) n.type.defaultProps || "ref" in n.memoizedProps || Ab || (e.props !== n.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", M(n) || "instance"), e.state !== n.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", M(n) || "instance")), Vs(n) ? (gi(), V(n, Vv, n, e), mi()) : V(n, Vv, n, e);
					else {
						var l = Go(n.type, t.memoizedProps);
						t = t.memoizedState, n.type.defaultProps || "ref" in n.memoizedProps || Ab || (e.props !== n.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", M(n) || "instance"), e.state !== n.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", M(n) || "instance")), Vs(n) ? (gi(), V(n, Uv, n, e, l, t, e.__reactInternalSnapshotBeforeUpdate), mi()) : V(n, Uv, n, e, l, t, e.__reactInternalSnapshotBeforeUpdate);
					}
					c & 64 && Js(n), c & 512 && $s(n, n.return);
					break;
				case 3:
					if (t = ti(), Tc(e, n), c & 64 && (c = n.updateQueue, c !== null)) {
						if (l = null, n.child !== null) switch (n.child.tag) {
							case 27:
							case 5:
								l = n.child.stateNode;
								break;
							case 1: l = n.child.stateNode;
						}
						try {
							V(n, $i, c, l);
						} catch (e) {
							kl(n, n.return, e);
						}
					}
					e.effectDuration += ni(t);
					break;
				case 27: t === null && c & 4 && uc(n);
				case 26:
				case 5:
					if (Tc(e, n), t === null) {
						if (c & 4) rc(n);
						else if (c & 64) {
							e = n.type, t = n.memoizedProps, l = n.stateNode;
							try {
								V(n, Wu, l, e, t, n);
							} catch (e) {
								kl(n, n.return, e);
							}
						}
					}
					c & 512 && $s(n, n.return);
					break;
				case 12:
					if (c & 4) {
						c = ti(), Tc(e, n), e = n.stateNode, e.effectDuration += ri(c);
						try {
							V(n, tc, n, t, F_, e.effectDuration);
						} catch (e) {
							kl(n, n.return, e);
						}
					} else Tc(e, n);
					break;
				case 31:
					Tc(e, n), c & 4 && _c(e, n);
					break;
				case 13:
					Tc(e, n), c & 4 && vc(e, n), c & 64 && (e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null && (c = Nl.bind(null, n), fd(e, c))));
					break;
				case 22:
					if (c = n.memoizedState !== null || Ib, !c) {
						t = t !== null && t.memoizedState !== null || Lb, l = Ib;
						var u = Lb;
						Ib = c, (Lb = t) && !u ? (kc(e, n, (n.subtreeFlags & 8772) != 0), (n.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && .05 < H_ - V_ && Vn(n, V_, H_)) : Tc(e, n), Ib = l, Lb = u;
					}
					break;
				case 30: break;
				default: Tc(e, n);
			}
			(n.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && ((W_ || .05 < B_) && Wn(n, V_, H_, B_, U_), n.alternate === null && n.return !== null && n.return.alternate !== null && .05 < H_ - V_ && (dc(n.return.alternate, n.return) || Bn(n, V_, H_, "Mount"))), oi(i), ci(a), U_ = o, W_ = s;
		}
		function mc(e) {
			var t = e.alternate;
			t !== null && (e.alternate = null, mc(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && ze(t)), e.stateNode = null, e._debugOwner = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
		}
		function hc(e, t, n) {
			for (n = n.child; n !== null;) gc(e, t, n), n = n.sibling;
		}
		function gc(e, t, n) {
			if (Ap && typeof Ap.onCommitFiberUnmount == "function") try {
				Ap.onCommitFiberUnmount(kp, n);
			} catch (e) {
				jp || (jp = !0, console.error("React instrumentation encountered an error: %o", e));
			}
			var i = ai(), a = si(), o = li(), s = ui();
			switch (n.tag) {
				case 26:
					Lb || ec(n, t), hc(e, t, n), n.memoizedState ? n.memoizedState.count-- : n.stateNode && (e = n.stateNode, e.parentNode.removeChild(e));
					break;
				case 27:
					Lb || ec(n, t);
					var c = Ub, l = Wb;
					Yu(n.type) && (Ub = n.stateNode, Wb = !1), hc(e, t, n), V(n, Cd, n.stateNode), Ub = c, Wb = l;
					break;
				case 5: Lb || ec(n, t);
				case 6:
					if (c = Ub, l = Wb, Ub = null, hc(e, t, n), Ub = c, Wb = l, Ub !== null) if (Wb) try {
						V(n, Zu, Ub, n.stateNode);
					} catch (e) {
						kl(n, t, e);
					}
					else try {
						V(n, Xu, Ub, n.stateNode);
					} catch (e) {
						kl(n, t, e);
					}
					break;
				case 18:
					Ub !== null && (Wb ? (e = Ub, Qu(e.nodeType === 9 ? e.body : e.nodeName === "HTML" ? e.ownerDocument.body : e, n.stateNode), yf(e)) : Qu(Ub, n.stateNode));
					break;
				case 4:
					c = Ub, l = Wb, Ub = n.stateNode.containerInfo, Wb = !0, hc(e, t, n), Ub = c, Wb = l;
					break;
				case 0:
				case 11:
				case 14:
				case 15:
					Gs(Ny, n, t), Lb || Us(n, t, Py), hc(e, t, n);
					break;
				case 1:
					Lb || (ec(n, t), c = n.stateNode, typeof c.componentWillUnmount == "function" && Zs(n, t, c)), hc(e, t, n);
					break;
				case 21:
					hc(e, t, n);
					break;
				case 22:
					Lb = (c = Lb) || n.memoizedState !== null, hc(e, t, n), Lb = c;
					break;
				default: hc(e, t, n);
			}
			(n.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && (W_ || .05 < B_) && Wn(n, V_, H_, B_, U_), oi(i), ci(a), U_ = o, W_ = s;
		}
		function _c(e, t) {
			if (t.memoizedState === null && (e = t.alternate, e !== null && (e = e.memoizedState, e !== null))) {
				e = e.dehydrated;
				try {
					V(t, yd, e);
				} catch (e) {
					kl(t, t.return, e);
				}
			}
		}
		function vc(e, t) {
			if (t.memoizedState === null && (e = t.alternate, e !== null && (e = e.memoizedState, e !== null && (e = e.dehydrated, e !== null)))) try {
				V(t, bd, e);
			} catch (e) {
				kl(t, t.return, e);
			}
		}
		function yc(e) {
			switch (e.tag) {
				case 31:
				case 13:
				case 19:
					var t = e.stateNode;
					return t === null && (t = e.stateNode = new zb()), t;
				case 22: return e = e.stateNode, t = e._retryCache, t === null && (t = e._retryCache = new zb()), t;
				default: throw Error("Unexpected Suspense handler tag (" + e.tag + "). This is a bug in React.");
			}
		}
		function bc(e, t) {
			var n = yc(e);
			t.forEach(function(t) {
				if (!n.has(t)) {
					if (n.add(t), Mp) if (Vb !== null && Hb !== null) zl(Hb, Vb);
					else throw Error("Expected finished root and lanes to be set. This is a bug in React.");
					var i = Pl.bind(null, e, t);
					t.then(i, i);
				}
			});
		}
		function xc(e, t) {
			var n = t.deletions;
			if (n !== null) for (var i = 0; i < n.length; i++) {
				var a = e, o = t, s = n[i], c = ai(), l = o;
				a: for (; l !== null;) {
					switch (l.tag) {
						case 27:
							if (Yu(l.type)) {
								Ub = l.stateNode, Wb = !1;
								break a;
							}
							break;
						case 5:
							Ub = l.stateNode, Wb = !1;
							break a;
						case 3:
						case 4:
							Ub = l.stateNode.containerInfo, Wb = !0;
							break a;
					}
					l = l.return;
				}
				if (Ub === null) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
				gc(a, o, s), Ub = null, Wb = !1, (s.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && .05 < H_ - V_ && Bn(s, V_, H_, "Unmount"), oi(c), a = s, o = a.alternate, o !== null && (o.return = null), a.return = null;
			}
			if (t.subtreeFlags & 13886) for (t = t.child; t !== null;) Sc(t, e), t = t.sibling;
		}
		function Sc(e, t) {
			var n = ai(), i = si(), a = li(), o = ui(), s = e.alternate, c = e.flags;
			switch (e.tag) {
				case 0:
				case 11:
				case 14:
				case 15:
					xc(t, e), Cc(e), c & 4 && (Gs(Ny | My, e, e.return), Ws(Ny | My, e), Us(e, e.return, Py | My));
					break;
				case 1:
					if (xc(t, e), Cc(e), c & 512 && (Lb || s === null || ec(s, s.return)), c & 64 && Ib && (c = e.updateQueue, c !== null && (s = c.callbacks, s !== null))) {
						var l = c.shared.hiddenCallbacks;
						c.shared.hiddenCallbacks = l === null ? s : l.concat(s);
					}
					break;
				case 26:
					if (l = Gb, xc(t, e), Cc(e), c & 512 && (Lb || s === null || ec(s, s.return)), c & 4) {
						var u = s === null ? null : s.memoizedState;
						if (c = e.memoizedState, s === null) if (c === null) if (e.stateNode === null) {
							a: {
								c = e.type, s = e.memoizedProps, l = l.ownerDocument || l;
								b: switch (c) {
									case "title":
										u = l.getElementsByTagName("title")[0], (!u || u[Zp] || u[Wp] || u.namespaceURI === Pm || u.hasAttribute("itemprop")) && (u = l.createElement(c), l.head.insertBefore(u, l.querySelector("head > title"))), xu(u, c, s), u[Wp] = e, We(u), c = u;
										break a;
									case "link":
										var d = Rd("link", "href", l).get(c + (s.href || ""));
										if (d) {
											for (var f = 0; f < d.length; f++) if (u = d[f], u.getAttribute("href") === (s.href == null || s.href === "" ? null : s.href) && u.getAttribute("rel") === (s.rel == null ? null : s.rel) && u.getAttribute("title") === (s.title == null ? null : s.title) && u.getAttribute("crossorigin") === (s.crossOrigin == null ? null : s.crossOrigin)) {
												d.splice(f, 1);
												break b;
											}
										}
										u = l.createElement(c), xu(u, c, s), l.head.appendChild(u);
										break;
									case "meta":
										if (d = Rd("meta", "content", l).get(c + (s.content || ""))) {
											for (f = 0; f < d.length; f++) if (u = d[f], H(s.content, "content"), u.getAttribute("content") === (s.content == null ? null : "" + s.content) && u.getAttribute("name") === (s.name == null ? null : s.name) && u.getAttribute("property") === (s.property == null ? null : s.property) && u.getAttribute("http-equiv") === (s.httpEquiv == null ? null : s.httpEquiv) && u.getAttribute("charset") === (s.charSet == null ? null : s.charSet)) {
												d.splice(f, 1);
												break b;
											}
										}
										u = l.createElement(c), xu(u, c, s), l.head.appendChild(u);
										break;
									default: throw Error("getNodesForType encountered a type it did not expect: \"" + c + "\". This is a bug in React.");
								}
								u[Wp] = e, We(u), c = u;
							}
							e.stateNode = c;
						} else zd(l, e.type, e.stateNode);
						else e.stateNode = Pd(l, c, e.memoizedProps);
						else u === c ? c === null && e.stateNode !== null && ic(e, e.memoizedProps, s.memoizedProps) : (u === null ? s.stateNode !== null && (s = s.stateNode, s.parentNode.removeChild(s)) : u.count--, c === null ? zd(l, e.type, e.stateNode) : Pd(l, c, e.memoizedProps));
					}
					break;
				case 27:
					xc(t, e), Cc(e), c & 512 && (Lb || s === null || ec(s, s.return)), s !== null && c & 4 && ic(e, e.memoizedProps, s.memoizedProps);
					break;
				case 5:
					if (xc(t, e), Cc(e), c & 512 && (Lb || s === null || ec(s, s.return)), e.flags & 32) {
						l = e.stateNode;
						try {
							V(e, Ku, l);
						} catch (t) {
							kl(e, e.return, t);
						}
					}
					c & 4 && e.stateNode != null && (l = e.memoizedProps, ic(e, l, s === null ? l : s.memoizedProps)), c & 1024 && (Rb = !0, e.type !== "form" && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
					break;
				case 6:
					if (xc(t, e), Cc(e), c & 4) {
						if (e.stateNode === null) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
						c = e.memoizedProps, s = s === null ? c : s.memoizedProps, l = e.stateNode;
						try {
							V(e, qu, l, s, c);
						} catch (t) {
							kl(e, e.return, t);
						}
					}
					break;
				case 3:
					if (l = ti(), PC = null, u = Gb, Gb = wd(t.containerInfo), xc(t, e), Gb = u, Cc(e), c & 4 && s !== null && s.memoizedState.isDehydrated) try {
						V(e, vd, t.containerInfo);
					} catch (t) {
						kl(e, e.return, t);
					}
					Rb && (Rb = !1, wc(e)), t.effectDuration += ni(l);
					break;
				case 4:
					c = Gb, Gb = wd(e.stateNode.containerInfo), xc(t, e), Cc(e), Gb = c;
					break;
				case 12:
					c = ti(), xc(t, e), Cc(e), e.stateNode.effectDuration += ri(c);
					break;
				case 31:
					xc(t, e), Cc(e), c & 4 && (c = e.updateQueue, c !== null && (e.updateQueue = null, bc(e, c)));
					break;
				case 13:
					xc(t, e), Cc(e), e.child.flags & 8192 && e.memoizedState !== null != (s !== null && s.memoizedState !== null) && (Rx = bp()), c & 4 && (c = e.updateQueue, c !== null && (e.updateQueue = null, bc(e, c)));
					break;
				case 22:
					l = e.memoizedState !== null;
					var p = s !== null && s.memoizedState !== null, m = Ib, h = Lb;
					if (Ib = m || l, Lb = h || p, xc(t, e), Lb = h, Ib = m, p && !l && !m && !h && (e.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && .05 < H_ - V_ && Vn(e, V_, H_), Cc(e), c & 8192) a: for (t = e.stateNode, t._visibility = l ? t._visibility & ~Bg : t._visibility | Bg, !l || s === null || p || Ib || Lb || (Dc(e), (e.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && .05 < H_ - V_ && Bn(e, V_, H_, "Disconnect")), s = null, t = e;;) {
						if (t.tag === 5 || t.tag === 26) {
							if (s === null) {
								p = s = t;
								try {
									u = p.stateNode, l ? V(p, td, u) : V(p, id, p.stateNode, p.memoizedProps);
								} catch (e) {
									kl(p, p.return, e);
								}
							}
						} else if (t.tag === 6) {
							if (s === null) {
								p = t;
								try {
									d = p.stateNode, l ? V(p, nd, d) : V(p, ad, d, p.memoizedProps);
								} catch (e) {
									kl(p, p.return, e);
								}
							}
						} else if (t.tag === 18) {
							if (s === null) {
								p = t;
								try {
									f = p.stateNode, l ? V(p, ed, f) : V(p, rd, p.stateNode);
								} catch (e) {
									kl(p, p.return, e);
								}
							}
						} else if ((t.tag !== 22 && t.tag !== 23 || t.memoizedState === null || t === e) && t.child !== null) {
							t.child.return = t, t = t.child;
							continue;
						}
						if (t === e) break a;
						for (; t.sibling === null;) {
							if (t.return === null || t.return === e) break a;
							s === t && (s = null), t = t.return;
						}
						s === t && (s = null), t.sibling.return = t.return, t = t.sibling;
					}
					c & 4 && (c = e.updateQueue, c !== null && (s = c.retryQueue, s !== null && (c.retryQueue = null, bc(e, s))));
					break;
				case 19:
					xc(t, e), Cc(e), c & 4 && (c = e.updateQueue, c !== null && (e.updateQueue = null, bc(e, c)));
					break;
				case 30: break;
				case 21: break;
				default: xc(t, e), Cc(e);
			}
			(e.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && ((W_ || .05 < B_) && Wn(e, V_, H_, B_, U_), e.alternate === null && e.return !== null && e.return.alternate !== null && .05 < H_ - V_ && (dc(e.return.alternate, e.return) || Bn(e, V_, H_, "Mount"))), oi(n), ci(i), U_ = a, W_ = o;
		}
		function Cc(e) {
			var t = e.flags;
			if (t & 2) {
				try {
					V(e, lc, e);
				} catch (t) {
					kl(e, e.return, t);
				}
				e.flags &= -3;
			}
			t & 4096 && (e.flags &= -4097);
		}
		function wc(e) {
			if (e.subtreeFlags & 1024) for (e = e.child; e !== null;) {
				var t = e;
				wc(t), t.tag === 5 && t.flags & 1024 && t.stateNode.reset(), e = e.sibling;
			}
		}
		function Tc(e, t) {
			if (t.subtreeFlags & 8772) for (t = t.child; t !== null;) pc(e, t.alternate, t), t = t.sibling;
		}
		function Ec(e) {
			var t = ai(), n = si(), i = li(), a = ui();
			switch (e.tag) {
				case 0:
				case 11:
				case 14:
				case 15:
					Us(e, e.return, Py), Dc(e);
					break;
				case 1:
					ec(e, e.return);
					var o = e.stateNode;
					typeof o.componentWillUnmount == "function" && Zs(e, e.return, o), Dc(e);
					break;
				case 27: V(e, Cd, e.stateNode);
				case 26:
				case 5:
					ec(e, e.return), Dc(e);
					break;
				case 22:
					e.memoizedState === null && Dc(e);
					break;
				case 30:
					Dc(e);
					break;
				default: Dc(e);
			}
			(e.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && (W_ || .05 < B_) && Wn(e, V_, H_, B_, U_), oi(t), ci(n), U_ = i, W_ = a;
		}
		function Dc(e) {
			for (e = e.child; e !== null;) Ec(e), e = e.sibling;
		}
		function Oc(e, t, n, i) {
			var a = ai(), o = si(), s = li(), c = ui(), l = n.flags;
			switch (n.tag) {
				case 0:
				case 11:
				case 15:
					kc(e, n, i), Hs(n, Py);
					break;
				case 1:
					if (kc(e, n, i), t = n.stateNode, typeof t.componentDidMount == "function" && V(n, Vv, n, t), t = n.updateQueue, t !== null) {
						e = n.stateNode;
						try {
							V(n, Qi, t, e);
						} catch (e) {
							kl(n, n.return, e);
						}
					}
					i && l & 64 && Js(n), $s(n, n.return);
					break;
				case 27: uc(n);
				case 26:
				case 5:
					kc(e, n, i), i && t === null && l & 4 && rc(n), $s(n, n.return);
					break;
				case 12:
					if (i && l & 4) {
						l = ti(), kc(e, n, i), i = n.stateNode, i.effectDuration += ri(l);
						try {
							V(n, tc, n, t, F_, i.effectDuration);
						} catch (e) {
							kl(n, n.return, e);
						}
					} else kc(e, n, i);
					break;
				case 31:
					kc(e, n, i), i && l & 4 && _c(e, n);
					break;
				case 13:
					kc(e, n, i), i && l & 4 && vc(e, n);
					break;
				case 22:
					n.memoizedState === null && kc(e, n, i), $s(n, n.return);
					break;
				case 30: break;
				default: kc(e, n, i);
			}
			(n.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && (W_ || .05 < B_) && Wn(n, V_, H_, B_, U_), oi(a), ci(o), U_ = s, W_ = c;
		}
		function kc(e, t, n) {
			for (n &&= (t.subtreeFlags & 8772) != 0, t = t.child; t !== null;) Oc(e, t.alternate, t, n), t = t.sibling;
		}
		function Ac(e, t) {
			var n = null;
			e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), e = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (e = t.memoizedState.cachePool.pool), e !== n && (e != null && Zr(e), n != null && Qr(n));
		}
		function jc(e, t) {
			e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (Zr(t), e != null && Qr(e));
		}
		function Mc(e, t, n, i, a) {
			if (t.subtreeFlags & 10256 || t.actualDuration !== 0 && (t.alternate === null || t.alternate.child !== t.child)) for (t = t.child; t !== null;) {
				var o = t.sibling;
				Nc(e, t, n, i, o === null ? a : o.actualStartTime), t = o;
			}
		}
		function Nc(e, t, n, i, a) {
			var o = ai(), s = si(), c = li(), l = ui(), u = Pg, d = t.flags;
			switch (t.tag) {
				case 0:
				case 11:
				case 15:
					(t.mode & Xg) !== Jg && 0 < t.actualStartTime && t.flags & 1 && Hn(t, t.actualStartTime, a, Kb, n), Mc(e, t, n, i, a), d & 2048 && Ks(t, Fy | My);
					break;
				case 1:
					(t.mode & Xg) !== Jg && 0 < t.actualStartTime && (t.flags & 128 ? Un(t, t.actualStartTime, a, []) : t.flags & 1 && Hn(t, t.actualStartTime, a, Kb, n)), Mc(e, t, n, i, a);
					break;
				case 3:
					var f = ti(), p = Kb;
					Kb = t.alternate !== null && t.alternate.memoizedState.isDehydrated && (t.flags & 256) == 0, Mc(e, t, n, i, a), Kb = p, d & 2048 && (n = null, t.alternate !== null && (n = t.alternate.memoizedState.cache), i = t.memoizedState.cache, i !== n && (Zr(i), n != null && Qr(n))), e.passiveEffectDuration += ni(f);
					break;
				case 12:
					if (d & 2048) {
						d = ti(), Mc(e, t, n, i, a), e = t.stateNode, e.passiveEffectDuration += ri(d);
						try {
							V(t, nc, t, t.alternate, F_, e.passiveEffectDuration);
						} catch (e) {
							kl(t, t.return, e);
						}
					} else Mc(e, t, n, i, a);
					break;
				case 31:
					d = Kb, f = t.alternate === null ? null : t.alternate.memoizedState, p = t.memoizedState, f !== null && p === null ? (p = t.deletions, p !== null && 0 < p.length && p[0].tag === 18 ? (Kb = !1, f = f.hydrationErrors, f !== null && Un(t, t.actualStartTime, a, f)) : Kb = !0) : Kb = !1, Mc(e, t, n, i, a), Kb = d;
					break;
				case 13:
					d = Kb, f = t.alternate === null ? null : t.alternate.memoizedState, p = t.memoizedState, f === null || f.dehydrated === null || p !== null && p.dehydrated !== null ? Kb = !1 : (p = t.deletions, p !== null && 0 < p.length && p[0].tag === 18 ? (Kb = !1, f = f.hydrationErrors, f !== null && Un(t, t.actualStartTime, a, f)) : Kb = !0), Mc(e, t, n, i, a), Kb = d;
					break;
				case 23: break;
				case 22:
					p = t.stateNode, f = t.alternate, t.memoizedState === null ? p._visibility & Vg ? Mc(e, t, n, i, a) : (p._visibility |= Vg, Pc(e, t, n, i, (t.subtreeFlags & 10256) != 0 || t.actualDuration !== 0 && (t.alternate === null || t.alternate.child !== t.child), a), (t.mode & Xg) === Jg || Kb || (e = t.actualStartTime, 0 <= e && .05 < a - e && Vn(t, e, a), 0 <= V_ && 0 <= H_ && .05 < H_ - V_ && Vn(t, V_, H_))) : p._visibility & Vg ? Mc(e, t, n, i, a) : Ic(e, t, n, i, a), d & 2048 && Ac(f, t);
					break;
				case 24:
					Mc(e, t, n, i, a), d & 2048 && jc(t.alternate, t);
					break;
				default: Mc(e, t, n, i, a);
			}
			(t.mode & Xg) !== Jg && ((e = !Kb && t.alternate === null && t.return !== null && t.return.alternate !== null) && (n = t.actualStartTime, 0 <= n && .05 < a - n && Bn(t, n, a, "Mount")), 0 <= V_ && 0 <= H_ && ((W_ || .05 < B_) && Wn(t, V_, H_, B_, U_), e && .05 < H_ - V_ && Bn(t, V_, H_, "Mount"))), oi(o), ci(s), U_ = c, W_ = l, Pg = u;
		}
		function Pc(e, t, n, i, a, o) {
			for (a &&= (t.subtreeFlags & 10256) != 0 || t.actualDuration !== 0 && (t.alternate === null || t.alternate.child !== t.child), t = t.child; t !== null;) {
				var s = t.sibling;
				Fc(e, t, n, i, a, s === null ? o : s.actualStartTime), t = s;
			}
		}
		function Fc(e, t, n, i, a, o) {
			var s = ai(), c = si(), l = li(), u = ui(), d = Pg;
			a && (t.mode & Xg) !== Jg && 0 < t.actualStartTime && t.flags & 1 && Hn(t, t.actualStartTime, o, Kb, n);
			var f = t.flags;
			switch (t.tag) {
				case 0:
				case 11:
				case 15:
					Pc(e, t, n, i, a, o), Ks(t, Fy);
					break;
				case 23: break;
				case 22:
					var p = t.stateNode;
					t.memoizedState === null ? (p._visibility |= Vg, Pc(e, t, n, i, a, o)) : p._visibility & Vg ? Pc(e, t, n, i, a, o) : Ic(e, t, n, i, o), a && f & 2048 && Ac(t.alternate, t);
					break;
				case 24:
					Pc(e, t, n, i, a, o), a && f & 2048 && jc(t.alternate, t);
					break;
				default: Pc(e, t, n, i, a, o);
			}
			(t.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && (W_ || .05 < B_) && Wn(t, V_, H_, B_, U_), oi(s), ci(c), U_ = l, W_ = u, Pg = d;
		}
		function Ic(e, t, n, i, a) {
			if (t.subtreeFlags & 10256 || t.actualDuration !== 0 && (t.alternate === null || t.alternate.child !== t.child)) for (var o = t.child; o !== null;) {
				t = o.sibling;
				var s = e, c = n, l = i, u = t === null ? a : t.actualStartTime, d = Pg;
				(o.mode & Xg) !== Jg && 0 < o.actualStartTime && o.flags & 1 && Hn(o, o.actualStartTime, u, Kb, c);
				var f = o.flags;
				switch (o.tag) {
					case 22:
						Ic(s, o, c, l, u), f & 2048 && Ac(o.alternate, o);
						break;
					case 24:
						Ic(s, o, c, l, u), f & 2048 && jc(o.alternate, o);
						break;
					default: Ic(s, o, c, l, u);
				}
				Pg = d, o = t;
			}
		}
		function Lc(e, t, n) {
			if (e.subtreeFlags & qb) for (e = e.child; e !== null;) Rc(e, t, n), e = e.sibling;
		}
		function Rc(e, t, n) {
			switch (e.tag) {
				case 26:
					Lc(e, t, n), e.flags & qb && e.memoizedState !== null && Hd(n, Gb, e.memoizedState, e.memoizedProps);
					break;
				case 5:
					Lc(e, t, n);
					break;
				case 3:
				case 4:
					var i = Gb;
					Gb = wd(e.stateNode.containerInfo), Lc(e, t, n), Gb = i;
					break;
				case 22:
					e.memoizedState === null && (i = e.alternate, i !== null && i.memoizedState !== null ? (i = qb, qb = 16777216, Lc(e, t, n), qb = i) : Lc(e, t, n));
					break;
				default: Lc(e, t, n);
			}
		}
		function zc(e) {
			var t = e.alternate;
			if (t !== null && (e = t.child, e !== null)) {
				t.child = null;
				do
					t = e.sibling, e.sibling = null, e = t;
				while (e !== null);
			}
		}
		function Bc(e) {
			var t = e.deletions;
			if (e.flags & 16) {
				if (t !== null) for (var n = 0; n < t.length; n++) {
					var i = t[n], a = ai();
					Bb = i, Wc(i, e), (i.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && .05 < H_ - V_ && Bn(i, V_, H_, "Unmount"), oi(a);
				}
				zc(e);
			}
			if (e.subtreeFlags & 10256) for (e = e.child; e !== null;) Vc(e), e = e.sibling;
		}
		function Vc(e) {
			var t = ai(), n = si(), i = li(), a = ui();
			switch (e.tag) {
				case 0:
				case 11:
				case 15:
					Bc(e), e.flags & 2048 && qs(e, e.return, Fy | My);
					break;
				case 3:
					var o = ti();
					Bc(e), e.stateNode.passiveEffectDuration += ni(o);
					break;
				case 12:
					o = ti(), Bc(e), e.stateNode.passiveEffectDuration += ri(o);
					break;
				case 22:
					o = e.stateNode, e.memoizedState !== null && o._visibility & Vg && (e.return === null || e.return.tag !== 13) ? (o._visibility &= ~Vg, Hc(e), (e.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && .05 < H_ - V_ && Bn(e, V_, H_, "Disconnect")) : Bc(e);
					break;
				default: Bc(e);
			}
			(e.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && (W_ || .05 < B_) && Wn(e, V_, H_, B_, U_), oi(t), ci(n), W_ = a, U_ = i;
		}
		function Hc(e) {
			var t = e.deletions;
			if (e.flags & 16) {
				if (t !== null) for (var n = 0; n < t.length; n++) {
					var i = t[n], a = ai();
					Bb = i, Wc(i, e), (i.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && .05 < H_ - V_ && Bn(i, V_, H_, "Unmount"), oi(a);
				}
				zc(e);
			}
			for (e = e.child; e !== null;) Uc(e), e = e.sibling;
		}
		function Uc(e) {
			var t = ai(), n = si(), i = li(), a = ui();
			switch (e.tag) {
				case 0:
				case 11:
				case 15:
					qs(e, e.return, Fy), Hc(e);
					break;
				case 22:
					var o = e.stateNode;
					o._visibility & Vg && (o._visibility &= ~Vg, Hc(e));
					break;
				default: Hc(e);
			}
			(e.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && (W_ || .05 < B_) && Wn(e, V_, H_, B_, U_), oi(t), ci(n), W_ = a, U_ = i;
		}
		function Wc(e, t) {
			for (; Bb !== null;) {
				var n = Bb, i = n, a = t, o = ai(), s = si(), c = li(), l = ui();
				switch (i.tag) {
					case 0:
					case 11:
					case 15:
						qs(i, a, Fy);
						break;
					case 23:
					case 22:
						i.memoizedState !== null && i.memoizedState.cachePool !== null && (a = i.memoizedState.cachePool.pool, a != null && Zr(a));
						break;
					case 24: Qr(i.memoizedState.cache);
				}
				if ((i.mode & Xg) !== Jg && 0 <= V_ && 0 <= H_ && (W_ || .05 < B_) && Wn(i, V_, H_, B_, U_), oi(o), ci(s), W_ = l, U_ = c, i = n.child, i !== null) i.return = n, Bb = i;
				else a: for (n = e; Bb !== null;) {
					if (i = Bb, o = i.sibling, s = i.return, mc(i), i === n) {
						Bb = null;
						break a;
					}
					if (o !== null) {
						o.return = s, Bb = o;
						break a;
					}
					Bb = s;
				}
			}
		}
		function Gc() {
			Xb.forEach(function(e) {
				return e();
			});
		}
		function Kc() {
			var e = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
			return e || Q.actQueue === null || console.error("The current testing environment is not configured to support act(...)"), e;
		}
		function qc(e) {
			if ((lx & $b) !== Qb && fx !== 0) return fx & -fx;
			var t = Q.T;
			return t === null ? Le() : (t._updatedFibers ||= /* @__PURE__ */ new Set(), t._updatedFibers.add(e), Zl());
		}
		function Jc() {
			if (Nx === 0) if (!(fx & 536870912) || m_) {
				var e = Lp;
				Lp <<= 1, !(Lp & 3932160) && (Lp = 262144), Nx = e;
			} else Nx = 536870912;
			return e = Ey.current, e !== null && (e.flags |= 32), Nx;
		}
		function Yc(e, t, n) {
			if (xS && console.error("useInsertionEffect must not schedule updates."), gS && (_S = !0), (e === ux && (Cx === hx || Cx === Sx) || e.cancelPendingCommit !== null) && (rl(e, 0), $c(e, fx, Nx, !1)), ke(e, n), (lx & $b) !== Qb && e === ux) {
				if (mp) switch (t.tag) {
					case 0:
					case 11:
					case 15:
						e = dx && M(dx) || "Unknown", wS.has(e) || (wS.add(e), t = M(t) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", t, e, e));
						break;
					case 1: CS ||= (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), !0);
				}
			} else Mp && Pe(e, t, n), Vl(t), e === ux && ((lx & $b) === Qb && (jx |= n), kx === ax && $c(e, fx, Nx, !1)), Hl(e);
		}
		function Xc(e, t, n) {
			if ((lx & ($b | ex)) !== Qb) throw Error("Should not already be working.");
			if (fx !== 0 && dx !== null) {
				var i = dx, a = bp();
				switch (gv) {
					case gx:
					case hx:
						var o = _v;
						Ag && ((i = i._debugTask) ? i.run(console.timeStamp.bind(console, "Suspended", o, a, jg, void 0, "primary-light")) : console.timeStamp("Suspended", o, a, jg, void 0, "primary-light"));
						break;
					case Sx:
						o = _v, Ag && ((i = i._debugTask) ? i.run(console.timeStamp.bind(console, "Action", o, a, jg, void 0, "primary-light")) : console.timeStamp("Action", o, a, jg, void 0, "primary-light"));
						break;
					default: Ag && (i = a - _v, 3 > i || console.timeStamp("Blocked", _v, a, jg, void 0, 5 > i ? "primary-light" : 10 > i ? "primary" : 100 > i ? "primary-dark" : "error"));
				}
			}
			o = (n = !n && (t & 127) == 0 && (t & e.expiredLanes) === 0 || Te(e, t)) ? fl(e, t) : ul(e, t, !0);
			var s = n;
			do {
				if (o === tx) {
					Ex && !n && $c(e, t, 0, !1), t = Cx, _v = A_(), gv = t;
					break;
				} else {
					if (i = bp(), a = e.current.alternate, s && !Qc(a)) {
						zn(t), a = P_, o = i, !Ag || o <= a || (Wx ? Wx.run(console.timeStamp.bind(console, "Teared Render", a, o, Ng, Mg, "error")) : console.timeStamp("Teared Render", a, o, Ng, Mg, "error")), nl(t, i), o = ul(e, t, !1), s = !1;
						continue;
					}
					if (o === rx) {
						if (s = t, e.errorRecoveryDisabledLanes & s) var c = 0;
						else c = e.pendingLanes & -536870913, c = c === 0 ? c & 536870912 ? 536870912 : 0 : c;
						if (c !== 0) {
							zn(t), Yn(P_, i, t, Wx), nl(t, i), t = c;
							a: {
								i = e, o = s, s = Fx;
								var l = i.current.memoizedState.isDehydrated;
								if (l && (rl(i, c).flags |= 256), c = ul(i, c, !1), c !== rx) {
									if (Dx && !l) {
										i.errorRecoveryDisabledLanes |= o, jx |= o, o = ax;
										break a;
									}
									i = Ix, Ix = s, i !== null && (Ix === null ? Ix = i : Ix.push.apply(Ix, i));
								}
								o = c;
							}
							if (s = !1, o !== rx) continue;
							i = bp();
						}
					}
					if (o === nx) {
						zn(t), Yn(P_, i, t, Wx), nl(t, i), rl(e, 0), $c(e, t, 0, !0);
						break;
					}
					a: {
						switch (n = e, o) {
							case tx:
							case nx: throw Error("Root did not complete. This is a bug in React.");
							case ax: if ((t & 4194048) !== t) break;
							case ox:
								zn(t), Kn(P_, i, t, Wx), nl(t, i), a = t, a & 127 ? ev = i : a & 4194048 && (dv = i), $c(n, t, Nx, !Tx);
								break a;
							case rx:
								Ix = null;
								break;
							case ix:
							case sx: break;
							default: throw Error("Unknown root exit status.");
						}
						if (Q.actQueue !== null) bl(n, a, t, Ix, Ux, Lx, Nx, jx, Px, o, null, null, P_, i);
						else {
							if ((t & 62914560) === t && (s = Rx + Bx - bp(), 10 < s)) {
								if ($c(n, t, Nx, !Tx), we(n, 0, !0) !== 0) break a;
								aS = t, n.timeoutHandle = yC(Zc.bind(null, n, a, Ix, Ux, Lx, t, Nx, jx, Px, Tx, o, "Throttled", P_, i), s);
								break a;
							}
							Zc(n, a, Ix, Ux, Lx, t, Nx, jx, Px, Tx, o, null, P_, i);
						}
					}
				}
				break;
			} while (1);
			Hl(e);
		}
		function Zc(e, t, n, i, a, o, s, c, l, u, d, f, p, m) {
			e.timeoutHandle = xC;
			var h = t.subtreeFlags, g = null;
			if ((h & 8192 || (h & 16785408) == 16785408) && (g = {
				stylesheets: null,
				count: 0,
				imgCount: 0,
				imgBytes: 0,
				suspenseyImages: [],
				waitingForImages: !0,
				waitingForViewTransition: !1,
				unsuspend: Yt
			}, Rc(t, o, g), h = (o & 62914560) === o ? Rx - bp() : (o & 4194048) === o ? zx - bp() : 0, h = Ud(g, h), h !== null)) {
				aS = o, e.cancelPendingCommit = h(bl.bind(null, e, t, o, n, i, a, s, c, l, d, g, g.waitingForViewTransition ? "Waiting for the previous Animation" : 0 < g.count ? 0 < g.imgCount ? "Suspended on CSS and Images" : "Suspended on CSS" : g.imgCount === 1 ? "Suspended on an Image" : 0 < g.imgCount ? "Suspended on Images" : null, p, m)), $c(e, o, s, !u);
				return;
			}
			bl(e, t, o, n, i, a, s, c, l, d, g, f, p, m);
		}
		function Qc(e) {
			for (var t = e;;) {
				var n = t.tag;
				if ((n === 0 || n === 11 || n === 15) && t.flags & 16384 && (n = t.updateQueue, n !== null && (n = n.stores, n !== null))) for (var i = 0; i < n.length; i++) {
					var a = n[i], o = a.getSnapshot;
					a = a.value;
					try {
						if (!$h(o(), a)) return !1;
					} catch {
						return !1;
					}
				}
				if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n;
				else {
					if (t === e) break;
					for (; t.sibling === null;) {
						if (t.return === null || t.return === e) return !0;
						t = t.return;
					}
					t.sibling.return = t.return, t = t.sibling;
				}
			}
			return !0;
		}
		function $c(e, t, n, i) {
			t &= ~Mx, t &= ~jx, e.suspendedLanes |= t, e.pingedLanes &= ~t, i && (e.warmLanes |= t), i = e.expirationTimes;
			for (var a = t; 0 < a;) {
				var o = 31 - Np(a), s = 1 << o;
				i[o] = -1, a &= ~s;
			}
			n !== 0 && je(e, n, t);
		}
		function el() {
			return (lx & ($b | ex)) === Qb ? (Ul(0, !1), !1) : !0;
		}
		function tl() {
			if (dx !== null) {
				if (Cx === px) var e = dx.return;
				else e = dx, zr(), ya(e), oy = null, sy = 0, e = dx;
				for (; e !== null;) Bs(e.alternate, e), e = e.return;
				dx = null;
			}
		}
		function nl(e, t) {
			e & 127 && (G_ = t), e & 4194048 && (tv = t), e & 62914560 && (fv = t), e & 2080374784 && (pv = t);
		}
		function rl(e, t) {
			Ag && (console.timeStamp("Blocking Track", .003, .003, "Blocking", Mg, "primary-light"), console.timeStamp("Transition Track", .003, .003, "Transition", Mg, "primary-light"), console.timeStamp("Suspense Track", .003, .003, "Suspense", Mg, "primary-light"), console.timeStamp("Idle Track", .003, .003, "Idle", Mg, "primary-light"));
			var n = P_;
			if (P_ = A_(), fx !== 0 && 0 < n) {
				if (zn(fx), kx === ix || kx === ax) Kn(n, P_, t, Wx);
				else {
					var i = P_, a = Wx;
					if (Ag && !(i <= n)) {
						var o = (t & 738197653) === t ? "tertiary-dark" : "primary-dark", s = (t & 536870912) === t ? "Prewarm" : (t & 201326741) === t ? "Interrupted Hydration" : "Interrupted Render";
						a ? a.run(console.timeStamp.bind(console, s, n, i, Ng, Mg, o)) : console.timeStamp(s, n, i, Ng, Mg, o);
					}
				}
				nl(fx, P_);
			}
			if (n = Wx, Wx = null, t & 127) {
				Wx = q_, a = 0 <= K_ && K_ < G_ ? G_ : K_, i = 0 <= Z_ && Z_ < G_ ? G_ : Z_, o = 0 <= i ? i : 0 <= a ? a : P_, 0 <= ev ? (zn(2), qn(ev, o, t, n)) : mv & 127 && (zn(2), Qn(G_, o, hv)), n = a;
				var c = i, l = Q_, u = 0 < $_, d = J_ === M_, f = J_ === N_;
				if (a = P_, i = q_, o = Y_, s = X_, Ag) {
					if (Ng = "Blocking", 0 < n ? n > a && (n = a) : n = a, 0 < c ? c > n && (c = n) : c = n, l !== null && n > c) {
						var p = u ? "secondary-light" : "warning";
						i ? i.run(console.timeStamp.bind(console, u ? "Consecutive" : "Event: " + l, c, n, Ng, Mg, p)) : console.timeStamp(u ? "Consecutive" : "Event: " + l, c, n, Ng, Mg, p);
					}
					a > n && (c = d ? "error" : (t & 738197653) === t ? "tertiary-light" : "primary-light", d = f ? "Promise Resolved" : d ? "Cascading Update" : 5 < a - n ? "Update Blocked" : "Update", f = [], s != null && f.push(["Component name", s]), o != null && f.push(["Method name", o]), n = {
						start: n,
						end: a,
						detail: { devtools: {
							properties: f,
							track: Ng,
							trackGroup: Mg,
							color: c
						} }
					}, i ? i.run(performance.measure.bind(performance, d, n)) : performance.measure(d, n));
				}
				K_ = -1.1, J_ = 0, X_ = Y_ = null, ev = -1.1, $_ = Z_, Z_ = -1.1, G_ = A_();
			}
			if (t & 4194048 && (Wx = av, a = 0 <= nv && nv < tv ? tv : nv, n = 0 <= rv && rv < tv ? tv : rv, i = 0 <= cv && cv < tv ? tv : cv, o = 0 <= i ? i : 0 <= n ? n : P_, 0 <= dv ? (zn(256), qn(dv, o, t, Wx)) : mv & 4194048 && (zn(256), Qn(tv, o, hv)), f = i, c = lv, l = 0 < uv, u = iv === N_, o = P_, i = av, s = ov, d = sv, Ag && (Ng = "Transition", 0 < n ? n > o && (n = o) : n = o, 0 < a ? a > n && (a = n) : a = n, 0 < f ? f > a && (f = a) : f = a, a > f && c !== null && (p = l ? "secondary-light" : "warning", i ? i.run(console.timeStamp.bind(console, l ? "Consecutive" : "Event: " + c, f, a, Ng, Mg, p)) : console.timeStamp(l ? "Consecutive" : "Event: " + c, f, a, Ng, Mg, p)), n > a && (i ? i.run(console.timeStamp.bind(console, "Action", a, n, Ng, Mg, "primary-dark")) : console.timeStamp("Action", a, n, Ng, Mg, "primary-dark")), o > n && (a = u ? "Promise Resolved" : 5 < o - n ? "Update Blocked" : "Update", f = [], d != null && f.push(["Component name", d]), s != null && f.push(["Method name", s]), n = {
				start: n,
				end: o,
				detail: { devtools: {
					properties: f,
					track: Ng,
					trackGroup: Mg,
					color: "primary-light"
				} }
			}, i ? i.run(performance.measure.bind(performance, a, n)) : performance.measure(a, n))), rv = nv = -1.1, iv = 0, dv = -1.1, uv = cv, cv = -1.1, tv = A_()), t & 62914560 && mv & 62914560 && (zn(4194304), Qn(fv, P_, hv)), t & 2080374784 && mv & 2080374784 && (zn(268435456), Qn(pv, P_, hv)), n = e.timeoutHandle, n !== xC && (e.timeoutHandle = xC, bC(n)), n = e.cancelPendingCommit, n !== null && (e.cancelPendingCommit = null, n()), aS = 0, tl(), ux = e, dx = n = fr(e.current, null), fx = t, Cx = px, wx = null, Tx = !1, Ex = Te(e, t), Dx = !1, kx = tx, Px = Nx = Mx = jx = Ax = 0, Ix = Fx = null, Lx = !1, t & 8 && (t |= t & 32), i = e.entangledLanes, i !== 0) for (e = e.entanglements, i &= t; 0 < i;) a = 31 - Np(i), o = 1 << a, t |= e[a], i &= ~o;
			return Ox = t, $n(), e = yg(), 1e3 < e - _g && (Q.recentlyCreatedOwnerStacks = 0, _g = e), Ev.discardPendingWarnings(), n;
		}
		function il(e, t) {
			Hy = null, Q.H = nb, Q.getCurrentStack = null, mp = !1, pp = null, t === ey || t === ny ? (t = Oi(), Cx = gx) : t === ty ? (t = Oi(), Cx = _x) : Cx = t === wb ? xx : typeof t == "object" && t && typeof t.then == "function" ? yx : mx, wx = t;
			var n = dx;
			n === null ? (kx = nx, Yo(e, br(t, e.current))) : n.mode & Xg && fi(n);
		}
		function al() {
			var e = Ey.current;
			return e === null ? !0 : (fx & 4194048) === fx ? Dy === null : (fx & 62914560) === fx || fx & 536870912 ? e === Dy : !1;
		}
		function ol() {
			var e = Q.H;
			return Q.H = nb, e === null ? nb : e;
		}
		function sl() {
			var e = Q.A;
			return Q.A = Jb, e;
		}
		function cl(e) {
			Wx === null && (Wx = e._debugTask == null ? null : e._debugTask);
		}
		function ll() {
			kx = ax, Tx || (fx & 4194048) !== fx && Ey.current !== null || (Ex = !0), !(Ax & 134217727) && !(jx & 134217727) || ux === null || $c(ux, fx, Nx, !1);
		}
		function ul(e, t, n) {
			var i = lx;
			lx |= $b;
			var a = ol(), o = sl();
			if (ux !== e || fx !== t) {
				if (Mp) {
					var s = e.memoizedUpdaters;
					0 < s.size && (zl(e, fx), s.clear()), Fe(e, t);
				}
				Ux = null, rl(e, t);
			}
			t = !1, s = kx;
			a: do
				try {
					if (Cx !== px && dx !== null) {
						var c = dx, l = wx;
						switch (Cx) {
							case xx:
								tl(), s = ox;
								break a;
							case gx:
							case hx:
							case Sx:
							case yx:
								Ey.current === null && (t = !0);
								var u = Cx;
								if (Cx = px, wx = null, _l(e, c, l, u), n && Ex) {
									s = tx;
									break a;
								}
								break;
							default: u = Cx, Cx = px, wx = null, _l(e, c, l, u);
						}
					}
					dl(), s = kx;
					break;
				} catch (t) {
					il(e, t);
				}
			while (1);
			return t && e.shellSuspendCounter++, zr(), lx = i, Q.H = a, Q.A = o, dx === null && (ux = null, fx = 0, $n()), s;
		}
		function dl() {
			for (; dx !== null;) ml(dx);
		}
		function fl(e, t) {
			var n = lx;
			lx |= $b;
			var i = ol(), a = sl();
			if (ux !== e || fx !== t) {
				if (Mp) {
					var o = e.memoizedUpdaters;
					0 < o.size && (zl(e, fx), o.clear()), Fe(e, t);
				}
				Ux = null, Vx = bp() + Hx, rl(e, t);
			} else Ex = Te(e, t);
			a: do
				try {
					if (Cx !== px && dx !== null) b: switch (t = dx, o = wx, Cx) {
						case mx:
							Cx = px, wx = null, _l(e, t, o, mx);
							break;
						case hx:
						case Sx:
							if (Ti(o)) {
								Cx = px, wx = null, hl(t);
								break;
							}
							t = function() {
								Cx !== hx && Cx !== Sx || ux !== e || (Cx = bx), Hl(e);
							}, o.then(t, t);
							break a;
						case gx:
							Cx = bx;
							break a;
						case _x:
							Cx = vx;
							break a;
						case bx:
							Ti(o) ? (Cx = px, wx = null, hl(t)) : (Cx = px, wx = null, _l(e, t, o, bx));
							break;
						case vx:
							var s = null;
							switch (dx.tag) {
								case 26: s = dx.memoizedState;
								case 5:
								case 27:
									var c = dx;
									if (s ? Vd(s) : c.stateNode.complete) {
										Cx = px, wx = null;
										var l = c.sibling;
										if (l !== null) dx = l;
										else {
											var u = c.return;
											u === null ? dx = null : (dx = u, vl(u));
										}
										break b;
									}
									break;
								default: console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
							}
							Cx = px, wx = null, _l(e, t, o, vx);
							break;
						case yx:
							Cx = px, wx = null, _l(e, t, o, yx);
							break;
						case xx:
							tl(), kx = ox;
							break a;
						default: throw Error("Unexpected SuspendedReason. This is a bug in React.");
					}
					Q.actQueue === null ? pl() : dl();
					break;
				} catch (t) {
					il(e, t);
				}
			while (1);
			return zr(), Q.H = i, Q.A = a, lx = n, dx === null ? (ux = null, fx = 0, $n(), kx) : tx;
		}
		function pl() {
			for (; dx !== null && !vp();) ml(dx);
		}
		function ml(e) {
			var t = e.alternate;
			(e.mode & Xg) === Jg ? t = V(e, js, t, e, Ox) : (di(e), t = V(e, js, t, e, Ox), fi(e)), e.memoizedProps = e.pendingProps, t === null ? vl(e) : dx = t;
		}
		function hl(e) {
			var t = V(e, gl, e);
			e.memoizedProps = e.pendingProps, t === null ? vl(e) : dx = t;
		}
		function gl(e) {
			var t = e.alternate, n = (e.mode & Xg) !== Jg;
			switch (n && di(e), e.tag) {
				case 15:
				case 0:
					t = hs(t, e, e.pendingProps, e.type, void 0, fx);
					break;
				case 11:
					t = hs(t, e, e.pendingProps, e.type.render, e.ref, fx);
					break;
				case 5: ya(e);
				default: Bs(t, e), e = dx = pr(e, Ox), t = js(t, e, Ox);
			}
			return n && fi(e), t;
		}
		function _l(e, t, n, i) {
			zr(), ya(t), oy = null, sy = 0;
			var a = t.return;
			try {
				if (es(e, a, t, n, fx)) {
					kx = nx, Yo(e, br(n, e.current)), dx = null;
					return;
				}
			} catch (t) {
				if (a !== null) throw dx = a, t;
				kx = nx, Yo(e, br(n, e.current)), dx = null;
				return;
			}
			t.flags & 32768 ? (m_ || i === mx ? e = !0 : Ex || fx & 536870912 ? e = !1 : (Tx = e = !0, (i === hx || i === Sx || i === gx || i === yx) && (i = Ey.current, i !== null && i.tag === 13 && (i.flags |= 16384))), yl(t, e)) : vl(t);
		}
		function vl(e) {
			var t = e;
			do {
				if (t.flags & 32768) {
					yl(t, Tx);
					return;
				}
				var n = t.alternate;
				if (e = t.return, di(t), n = V(t, Rs, n, t, Ox), (t.mode & Xg) !== Jg && pi(t), n !== null) {
					dx = n;
					return;
				}
				if (t = t.sibling, t !== null) {
					dx = t;
					return;
				}
				dx = t = e;
			} while (t !== null);
			kx === tx && (kx = sx);
		}
		function yl(e, t) {
			do {
				var n = zs(e.alternate, e);
				if (n !== null) {
					n.flags &= 32767, dx = n;
					return;
				}
				if ((e.mode & Xg) !== Jg) {
					pi(e), n = e.actualDuration;
					for (var i = e.child; i !== null;) n += i.actualDuration, i = i.sibling;
					e.actualDuration = n;
				}
				if (n = e.return, n !== null && (n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null), !t && (e = e.sibling, e !== null)) {
					dx = e;
					return;
				}
				dx = e = n;
			} while (e !== null);
			kx = ox, dx = null;
		}
		function bl(e, t, n, i, a, o, s, c, l, u, d, f, p, m) {
			e.cancelPendingCommit = null;
			do
				El();
			while (nS !== Xx);
			if (Ev.flushLegacyContextWarning(), Ev.flushPendingUnsafeLifecycleWarnings(), (lx & ($b | ex)) !== Qb) throw Error("Should not already be working.");
			if (zn(n), u === rx ? Yn(p, m, n, Wx) : i === null ? Gn(p, m, n, Wx) : Jn(p, m, n, i, t !== null && t.alternate !== null && t.alternate.memoizedState.isDehydrated && (t.flags & 256) != 0, Wx), t !== null) {
				if (n === 0 && console.error("finishedLanes should not be empty during a commit. This is a bug in React."), t === e.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
				if (o = t.lanes | t.childLanes, o |= Wg, Ae(e, n, o, s, c, l), e === ux && (dx = ux = null, fx = 0), iS = t, rS = e, aS = n, oS = o, cS = a, lS = i, sS = m, uS = f, dS = Kx, fS = null, t.actualDuration !== 0 || t.subtreeFlags & 10256 || t.flags & 10256 ? (e.callbackNode = null, e.callbackPriority = 0, Bl(wp, function() {
					return vC = window.event, dS === Kx && (dS = Jx), Dl(), null;
				})) : (e.callbackNode = null, e.callbackPriority = 0), L_ = null, F_ = A_(), f !== null && Xn(m, F_, f, Wx), i = (t.flags & 13878) != 0, t.subtreeFlags & 13878 || i) {
					i = Q.T, Q.T = null, a = Kf.p, Kf.p = zp, s = lx, lx |= ex;
					try {
						fc(e, t, n);
					} finally {
						lx = s, Kf.p = a, Q.T = i;
					}
				}
				nS = Zx, xl(), Sl(), Cl();
			}
		}
		function xl() {
			if (nS === Zx) {
				nS = Xx;
				var e = rS, t = iS, n = aS, i = (t.flags & 13878) != 0;
				if (t.subtreeFlags & 13878 || i) {
					i = Q.T, Q.T = null;
					var a = Kf.p;
					Kf.p = zp;
					var o = lx;
					lx |= ex;
					try {
						Vb = n, Hb = e, ii(), Sc(t, e), Hb = Vb = null, n = hC;
						var s = kn(e.containerInfo), c = n.focusedElem, l = n.selectionRange;
						if (s !== c && c && c.ownerDocument && On(c.ownerDocument.documentElement, c)) {
							if (l !== null && An(c)) {
								var u = l.start, d = l.end;
								if (d === void 0 && (d = u), "selectionStart" in c) c.selectionStart = u, c.selectionEnd = Math.min(d, c.value.length);
								else {
									var f = c.ownerDocument || document, p = f && f.defaultView || window;
									if (p.getSelection) {
										var m = p.getSelection(), h = c.textContent.length, g = Math.min(l.start, h), _ = l.end === void 0 ? g : Math.min(l.end, h);
										!m.extend && g > _ && (s = _, _ = g, g = s);
										var v = Dn(c, g), y = Dn(c, _);
										if (v && y && (m.rangeCount !== 1 || m.anchorNode !== v.node || m.anchorOffset !== v.offset || m.focusNode !== y.node || m.focusOffset !== y.offset)) {
											var b = f.createRange();
											b.setStart(v.node, v.offset), m.removeAllRanges(), g > _ ? (m.addRange(b), m.extend(y.node, y.offset)) : (b.setEnd(y.node, y.offset), m.addRange(b));
										}
									}
								}
							}
							for (f = [], m = c; m = m.parentNode;) m.nodeType === 1 && f.push({
								element: m,
								left: m.scrollLeft,
								top: m.scrollTop
							});
							for (typeof c.focus == "function" && c.focus(), c = 0; c < f.length; c++) {
								var x = f[c];
								x.element.scrollLeft = x.left, x.element.scrollTop = x.top;
							}
						}
						aw = !!mC, hC = mC = null;
					} finally {
						lx = o, Kf.p = a, Q.T = i;
					}
				}
				e.current = t, nS = Qx;
			}
		}
		function Sl() {
			if (nS === Qx) {
				nS = Xx;
				var e = fS;
				if (e !== null) {
					F_ = A_();
					var t = I_, n = F_;
					!Ag || n <= t || (hv ? hv.run(console.timeStamp.bind(console, e, t, n, Ng, Mg, "secondary-light")) : console.timeStamp(e, t, n, Ng, Mg, "secondary-light"));
				}
				e = rS, t = iS, n = aS;
				var i = (t.flags & 8772) != 0;
				if (t.subtreeFlags & 8772 || i) {
					i = Q.T, Q.T = null;
					var a = Kf.p;
					Kf.p = zp;
					var o = lx;
					lx |= ex;
					try {
						Vb = n, Hb = e, ii(), pc(e, t.alternate, t), Hb = Vb = null;
					} finally {
						lx = o, Kf.p = a, Q.T = i;
					}
				}
				e = sS, t = uS, I_ = A_(), e = t === null ? e : F_, t = I_, n = dS === qx, i = Wx, L_ === null ? !Ag || t <= e || (i ? i.run(console.timeStamp.bind(console, n ? "Commit Interrupted View Transition" : "Commit", e, t, Ng, Mg, n ? "error" : "secondary-dark")) : console.timeStamp(n ? "Commit Interrupted View Transition" : "Commit", e, t, Ng, Mg, n ? "error" : "secondary-dark")) : Zn(e, t, L_, !1, i), nS = $x;
			}
		}
		function Cl() {
			if (nS === eS || nS === $x) {
				if (nS === eS) {
					var e = I_;
					I_ = A_();
					var t = I_, n = dS === qx;
					!Ag || t <= e || (hv ? hv.run(console.timeStamp.bind(console, n ? "Interrupted View Transition" : "Starting Animation", e, t, Ng, Mg, n ? "error" : "secondary-light")) : console.timeStamp(n ? "Interrupted View Transition" : "Starting Animation", e, t, Ng, Mg, n ? " error" : "secondary-light")), dS !== qx && (dS = Yx);
				}
				nS = Xx, yp(), e = rS;
				var i = iS;
				t = aS, n = lS;
				var a = i.actualDuration !== 0 || (i.subtreeFlags & 10256) != 0 || (i.flags & 10256) != 0;
				a ? nS = tS : (nS = Xx, iS = rS = null, Tl(e, e.pendingLanes), yS = 0, bS = null);
				var o = e.pendingLanes;
				if (o === 0 && (Gx = null), a || Ll(e), o = Ie(t), i = i.stateNode, Ap && typeof Ap.onCommitFiberRoot == "function") try {
					var s = (i.current.flags & 128) == 128;
					switch (o) {
						case zp:
							var c = Sp;
							break;
						case Bp:
							c = Cp;
							break;
						case Vp:
							c = wp;
							break;
						case Hp:
							c = Ep;
							break;
						default: c = wp;
					}
					Ap.onCommitFiberRoot(kp, i, c, s);
				} catch (e) {
					jp || (jp = !0, console.error("React instrumentation encountered an error: %o", e));
				}
				if (Mp && e.memoizedUpdaters.clear(), Gc(), n !== null) {
					s = Q.T, c = Kf.p, Kf.p = zp, Q.T = null;
					try {
						var l = e.onRecoverableError;
						for (i = 0; i < n.length; i++) {
							var u = n[i], d = wl(u.stack);
							V(u.source, l, u.value, d);
						}
					} finally {
						Q.T = s, Kf.p = c;
					}
				}
				aS & 3 && El(), Hl(e), o = e.pendingLanes, t & 261930 && o & 42 ? (yv = !0, e === hS ? mS++ : (mS = 0, hS = e)) : mS = 0, a || nl(t, I_), Ul(0, !1);
			}
		}
		function wl(e) {
			return e = { componentStack: e }, Object.defineProperty(e, "digest", { get: function() {
				console.error("You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.");
			} }), e;
		}
		function Tl(e, t) {
			(e.pooledCacheLanes &= t) === 0 && (t = e.pooledCache, t != null && (e.pooledCache = null, Qr(t)));
		}
		function El() {
			return xl(), Sl(), Cl(), Dl();
		}
		function Dl() {
			if (nS !== tS) return !1;
			var e = rS, t = oS;
			oS = 0;
			var n = Ie(aS), i = Vp === 0 || Vp > n ? Vp : n;
			n = Q.T;
			var a = Kf.p;
			try {
				Kf.p = i, Q.T = null;
				var o = cS;
				cS = null, i = rS;
				var s = aS;
				if (nS = Xx, iS = rS = null, aS = 0, (lx & ($b | ex)) !== Qb) throw Error("Cannot flush passive effects while already rendering.");
				zn(s), gS = !0, _S = !1;
				var c = 0;
				if (L_ = null, c = bp(), dS === Yx) Qn(I_, c, hv);
				else {
					var l = I_, u = c, d = dS === Jx;
					!Ag || u <= l || (Wx ? Wx.run(console.timeStamp.bind(console, d ? "Waiting for Paint" : "Waiting", l, u, Ng, Mg, "secondary-light")) : console.timeStamp(d ? "Waiting for Paint" : "Waiting", l, u, Ng, Mg, "secondary-light"));
				}
				l = lx, lx |= ex;
				var f = i.current;
				ii(), Vc(f);
				var p = i.current;
				f = sS, ii(), Nc(i, p, s, o, f), Ll(i), lx = l;
				var m = bp();
				if (p = c, f = Wx, L_ === null ? !Ag || m <= p || (f ? f.run(console.timeStamp.bind(console, "Remaining Effects", p, m, Ng, Mg, "secondary-dark")) : console.timeStamp("Remaining Effects", p, m, Ng, Mg, "secondary-dark")) : Zn(p, m, L_, !0, f), nl(s, m), Ul(0, !1), _S ? i === bS ? yS++ : (yS = 0, bS = i) : yS = 0, _S = gS = !1, Ap && typeof Ap.onPostCommitFiberRoot == "function") try {
					Ap.onPostCommitFiberRoot(kp, i);
				} catch (e) {
					jp || (jp = !0, console.error("React instrumentation encountered an error: %o", e));
				}
				var h = i.current.stateNode;
				return h.effectDuration = 0, h.passiveEffectDuration = 0, !0;
			} finally {
				Kf.p = a, Q.T = n, Tl(e, t);
			}
		}
		function Ol(e, t, n) {
			t = br(n, t), hi(t), t = Zo(e.stateNode, t, 2), e = Ki(e, t, 2), e !== null && (ke(e, 2), Hl(e));
		}
		function kl(e, t, n) {
			if (xS = !1, e.tag === 3) Ol(e, e, n);
			else {
				for (; t !== null;) {
					if (t.tag === 3) {
						Ol(t, e, n);
						return;
					}
					if (t.tag === 1) {
						var i = t.stateNode;
						if (typeof t.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Gx === null || !Gx.has(i))) {
							e = br(n, e), hi(e), n = Qo(2), i = Ki(t, n, 2), i !== null && ($o(n, i, t, e), ke(i, 2), Hl(i));
							return;
						}
					}
					t = t.return;
				}
				console.error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", n);
			}
		}
		function Al(e, t, n) {
			var i = e.pingCache;
			if (i === null) {
				i = e.pingCache = new Zb();
				var a = /* @__PURE__ */ new Set();
				i.set(t, a);
			} else a = i.get(t), a === void 0 && (a = /* @__PURE__ */ new Set(), i.set(t, a));
			a.has(n) || (Dx = !0, a.add(n), i = jl.bind(null, e, t, n), Mp && zl(e, n), t.then(i, i));
		}
		function jl(e, t, n) {
			var i = e.pingCache;
			i !== null && i.delete(t), e.pingedLanes |= e.suspendedLanes & n, e.warmLanes &= ~n, n & 127 ? 0 > K_ && (G_ = K_ = A_(), q_ = j_("Promise Resolved"), J_ = N_) : n & 4194048 && 0 > rv && (tv = rv = A_(), av = j_("Promise Resolved"), iv = N_), Kc() && Q.actQueue === null && console.error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"), ux === e && (fx & n) === n && (kx === ax || kx === ix && (fx & 62914560) === fx && bp() - Rx < Bx ? (lx & $b) === Qb && rl(e, 0) : Mx |= n, Px === fx && (Px = 0)), Hl(e);
		}
		function Ml(e, t) {
			t === 0 && (t = De()), e = nr(e, t), e !== null && (ke(e, t), Hl(e));
		}
		function Nl(e) {
			var t = e.memoizedState, n = 0;
			t !== null && (n = t.retryLane), Ml(e, n);
		}
		function Pl(e, t) {
			var n = 0;
			switch (e.tag) {
				case 31:
				case 13:
					var i = e.stateNode, a = e.memoizedState;
					a !== null && (n = a.retryLane);
					break;
				case 19:
					i = e.stateNode;
					break;
				case 22:
					i = e.stateNode._retryCache;
					break;
				default: throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
			}
			i !== null && i.delete(t), Ml(e, n);
		}
		function Fl(e, t, n) {
			if (t.subtreeFlags & 67117056) for (t = t.child; t !== null;) {
				var i = e, a = t, o = a.type === Mf;
				o = n || o, a.tag === 22 ? a.memoizedState === null && (o && a.flags & 8192 ? V(a, Il, i, a) : a.subtreeFlags & 67108864 && V(a, Fl, i, a, o)) : a.flags & 67108864 ? o && V(a, Il, i, a) : Fl(i, a, o), t = t.sibling;
			}
		}
		function Il(e, t) {
			xe(!0);
			try {
				Ec(t), Uc(t), Oc(e, t.alternate, t, !1), Fc(e, t, 0, null, !1, 0);
			} finally {
				xe(!1);
			}
		}
		function Ll(e) {
			var t = !0;
			e.current.mode & (Zg | Qg) || (t = !1), Fl(e, e.current, t);
		}
		function Rl(e) {
			if ((lx & $b) === Qb) {
				var t = e.tag;
				if (t === 3 || t === 1 || t === 0 || t === 11 || t === 14 || t === 15) {
					if (t = M(e) || "ReactComponent", SS !== null) {
						if (SS.has(t)) return;
						SS.add(t);
					} else SS = new Set([t]);
					V(e, function() {
						console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously tries to update the component. Move this work to useEffect instead.");
					});
				}
			}
		}
		function zl(e, t) {
			Mp && e.memoizedUpdaters.forEach(function(n) {
				Pe(e, n, t);
			});
		}
		function Bl(e, t) {
			var n = Q.actQueue;
			return n === null ? gp(e, t) : (n.push(t), TS);
		}
		function Vl(e) {
			Kc() && Q.actQueue === null && V(e, function() {
				console.error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act", M(e));
			});
		}
		function Hl(e) {
			e !== DS && e.next === null && (DS === null ? ES = DS = e : DS = DS.next = e), AS = !0, Q.actQueue === null ? OS || (OS = !0, Xl()) : kS || (kS = !0, Xl());
		}
		function Ul(e, t) {
			if (!jS && AS) {
				jS = !0;
				do
					for (var n = !1, i = ES; i !== null;) {
						if (!t) if (e !== 0) {
							var a = i.pendingLanes;
							if (a === 0) var o = 0;
							else {
								var s = i.suspendedLanes, c = i.pingedLanes;
								o = (1 << 31 - Np(42 | e) + 1) - 1, o &= a & ~(s & ~c), o = o & 201326741 ? o & 201326741 | 1 : o ? o | 2 : 0;
							}
							o !== 0 && (n = !0, Jl(i, o));
						} else o = fx, o = we(i, i === ux ? o : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== xC), !(o & 3) || Te(i, o) || (n = !0, Jl(i, o));
						i = i.next;
					}
				while (n);
				jS = !1;
			}
		}
		function Wl() {
			vC = window.event, Gl();
		}
		function Gl() {
			AS = kS = OS = !1;
			var e = 0;
			MS !== 0 && zu() && (e = MS);
			for (var t = bp(), n = null, i = ES; i !== null;) {
				var a = i.next, o = Kl(i, t);
				o === 0 ? (i.next = null, n === null ? ES = a : n.next = a, a === null && (DS = n)) : (n = i, (e !== 0 || o & 3) && (AS = !0)), i = a;
			}
			nS !== Xx && nS !== tS || Ul(e, !1), MS !== 0 && (MS = 0);
		}
		function Kl(e, t) {
			for (var n = e.suspendedLanes, i = e.pingedLanes, a = e.expirationTimes, o = e.pendingLanes & -62914561; 0 < o;) {
				var s = 31 - Np(o), c = 1 << s, l = a[s];
				l === -1 ? ((c & n) === 0 || (c & i) !== 0) && (a[s] = Ee(c, t)) : l <= t && (e.expiredLanes |= c), o &= ~c;
			}
			if (t = ux, n = fx, n = we(e, e === t ? n : 0, e.cancelPendingCommit !== null || e.timeoutHandle !== xC), i = e.callbackNode, n === 0 || e === t && (Cx === hx || Cx === Sx) || e.cancelPendingCommit !== null) return i !== null && Yl(i), e.callbackNode = null, e.callbackPriority = 0;
			if (!(n & 3) || Te(e, n)) {
				if (t = n & -n, t !== e.callbackPriority || Q.actQueue !== null && i !== NS) Yl(i);
				else return t;
				switch (Ie(n)) {
					case zp:
					case Bp:
						n = Cp;
						break;
					case Vp:
						n = wp;
						break;
					case Hp:
						n = Ep;
						break;
					default: n = wp;
				}
				return i = ql.bind(null, e), Q.actQueue === null ? n = gp(n, i) : (Q.actQueue.push(i), n = NS), e.callbackPriority = t, e.callbackNode = n, t;
			}
			return i !== null && Yl(i), e.callbackPriority = 2, e.callbackNode = null, 2;
		}
		function ql(e, t) {
			if (yv = vv = !1, vC = window.event, nS !== Xx && nS !== tS) return e.callbackNode = null, e.callbackPriority = 0, null;
			var n = e.callbackNode;
			if (dS === Kx && (dS = Jx), El() && e.callbackNode !== n) return null;
			var i = fx;
			return i = we(e, e === ux ? i : 0, e.cancelPendingCommit !== null || e.timeoutHandle !== xC), i === 0 ? null : (Xc(e, i, t), Kl(e, bp()), e.callbackNode != null && e.callbackNode === n ? ql.bind(null, e) : null);
		}
		function Jl(e, t) {
			if (El()) return null;
			vv = yv, yv = !1, Xc(e, t, !0);
		}
		function Yl(e) {
			e !== NS && e !== null && _p(e);
		}
		function Xl() {
			Q.actQueue !== null && Q.actQueue.push(function() {
				return Gl(), null;
			}), CC(function() {
				(lx & ($b | ex)) === Qb ? Gl() : gp(Sp, Wl);
			});
		}
		function Zl() {
			if (MS === 0) {
				var e = Sv;
				e === 0 && (e = Ip, Ip <<= 1, !(Ip & 261888) && (Ip = 256)), MS = e;
			}
			return MS;
		}
		function Ql(e) {
			return e == null || typeof e == "symbol" || typeof e == "boolean" ? null : typeof e == "function" ? e : (H(e, "action"), Jt("" + e));
		}
		function $l(e, t) {
			var n = t.ownerDocument.createElement("input");
			return n.name = t.name, n.value = t.value, e.id && n.setAttribute("form", e.id), t.parentNode.insertBefore(n, t), e = new FormData(e), n.parentNode.removeChild(n), e;
		}
		function eu(e, t, n, i, a) {
			if (t === "submit" && n && n.stateNode === a) {
				var o = Ql((a[Gp] || null).action), s = i.submitter;
				s && (t = (t = s[Gp] || null) ? Ql(t.formAction) : s.getAttribute("formAction"), t !== null && (o = t, s = null));
				var c = new ah("action", "action", null, i, a);
				e.push({
					event: c,
					listeners: [{
						instance: null,
						listener: function() {
							if (i.defaultPrevented) {
								if (MS !== 0) {
									var e = s ? $l(a, s) : new FormData(a), t = {
										pending: !0,
										data: e,
										method: a.method,
										action: o
									};
									Object.freeze(t), wo(n, t, null, e);
								}
							} else typeof o == "function" && (c.preventDefault(), e = s ? $l(a, s) : new FormData(a), t = {
								pending: !0,
								data: e,
								method: a.method,
								action: o
							}, Object.freeze(t), wo(n, t, o, e));
						},
						currentTarget: a
					}]
				});
			}
		}
		function tu(e, t, n) {
			e.currentTarget = n;
			try {
				t(e);
			} catch (e) {
				xg(e);
			}
			e.currentTarget = null;
		}
		function nu(e, t) {
			t = (t & 4) != 0;
			for (var n = 0; n < e.length; n++) {
				var i = e[n];
				a: {
					var a = void 0, o = i.event;
					if (i = i.listeners, t) for (var s = i.length - 1; 0 <= s; s--) {
						var c = i[s], l = c.instance, u = c.currentTarget;
						if (c = c.listener, l !== a && o.isPropagationStopped()) break a;
						l === null ? tu(o, c, u) : V(l, tu, o, c, u), a = l;
					}
					else for (s = 0; s < i.length; s++) {
						if (c = i[s], l = c.instance, u = c.currentTarget, c = c.listener, l !== a && o.isPropagationStopped()) break a;
						l === null ? tu(o, c, u) : V(l, tu, o, c, u), a = l;
					}
				}
			}
		}
		function ru(e, t) {
			FS.has(e) || console.error("Did not expect a listenToNonDelegatedEvent() call for \"%s\". This is a bug in React. Please file an issue.", e);
			var n = t[qp];
			n === void 0 && (n = t[qp] = /* @__PURE__ */ new Set());
			var i = e + "__bubble";
			n.has(i) || (ou(t, e, 2, !1), n.add(i));
		}
		function iu(e, t, n) {
			FS.has(e) && !t && console.error("Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. This is a bug in React. Please file an issue.", e);
			var i = 0;
			t && (i |= 4), ou(n, e, i, t);
		}
		function au(e) {
			if (!e[IS]) {
				e[IS] = !0, Qp.forEach(function(t) {
					t !== "selectionchange" && (FS.has(t) || iu(t, !1, e), iu(t, !0, e));
				});
				var t = e.nodeType === 9 ? e : e.ownerDocument;
				t === null || t[IS] || (t[IS] = !0, iu("selectionchange", !1, t));
			}
		}
		function ou(e, t, n, i) {
			switch (lf(t)) {
				case zp:
					var a = nf;
					break;
				case Bp:
					a = rf;
					break;
				default: a = af;
			}
			n = a.bind(null, t, n, e), a = void 0, !$m || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (a = !0), i ? a === void 0 ? e.addEventListener(t, n, !0) : e.addEventListener(t, n, {
				capture: !0,
				passive: a
			}) : a === void 0 ? e.addEventListener(t, n, !1) : e.addEventListener(t, n, { passive: a });
		}
		function su(e, t, n, i, a) {
			var o = i;
			if (!(t & 1) && !(t & 2) && i !== null) a: for (;;) {
				if (i === null) return;
				var s = i.tag;
				if (s === 3 || s === 4) {
					var c = i.stateNode.containerInfo;
					if (c === a) break;
					if (s === 4) for (s = i.return; s !== null;) {
						var l = s.tag;
						if ((l === 3 || l === 4) && s.stateNode.containerInfo === a) return;
						s = s.return;
					}
					for (; c !== null;) {
						if (s = Be(c), s === null) return;
						if (l = s.tag, l === 5 || l === 6 || l === 26 || l === 27) {
							i = o = s;
							continue a;
						}
						c = c.parentNode;
					}
				}
				i = i.return;
			}
			Qt(function() {
				var i = o, a = Xt(n), s = [];
				a: {
					var c = hg.get(e);
					if (c !== void 0) {
						var l = ah, u = e;
						switch (e) {
							case "keypress": if (en(n) === 0) break a;
							case "keydown":
							case "keyup":
								l = Oh;
								break;
							case "focusin":
								u = "focus", l = gh;
								break;
							case "focusout":
								u = "blur", l = gh;
								break;
							case "beforeblur":
							case "afterblur":
								l = gh;
								break;
							case "click": if (n.button === 2) break a;
							case "auxclick":
							case "dblclick":
							case "mousedown":
							case "mousemove":
							case "mouseup":
							case "mouseout":
							case "mouseover":
							case "contextmenu":
								l = fh;
								break;
							case "drag":
							case "dragend":
							case "dragenter":
							case "dragexit":
							case "dragleave":
							case "dragover":
							case "dragstart":
							case "drop":
								l = mh;
								break;
							case "touchcancel":
							case "touchend":
							case "touchmove":
							case "touchstart":
								l = Mh;
								break;
							case cg:
							case lg:
							case ug:
								l = vh;
								break;
							case mg:
								l = Ph;
								break;
							case "scroll":
							case "scrollend":
								l = sh;
								break;
							case "wheel":
								l = Ih;
								break;
							case "copy":
							case "cut":
							case "paste":
								l = bh;
								break;
							case "gotpointercapture":
							case "lostpointercapture":
							case "pointercancel":
							case "pointerdown":
							case "pointermove":
							case "pointerout":
							case "pointerover":
							case "pointerup":
								l = Ah;
								break;
							case "toggle":
							case "beforetoggle": l = Rh;
						}
						var d = (t & 4) != 0, f = !d && (e === "scroll" || e === "scrollend"), p = d ? c === null ? null : c + "Capture" : c;
						d = [];
						for (var m = i, h; m !== null;) {
							var g = m;
							if (h = g.stateNode, g = g.tag, g !== 5 && g !== 26 && g !== 27 || h === null || p === null || (g = K(m, p), g != null && d.push(cu(m, g, h))), f) break;
							m = m.return;
						}
						0 < d.length && (c = new l(c, u, null, n, a), s.push({
							event: c,
							listeners: d
						}));
					}
				}
				if (!(t & 7)) {
					a: {
						if (c = e === "mouseover" || e === "pointerover", l = e === "mouseout" || e === "pointerout", c && n !== Jm && (u = n.relatedTarget || n.fromElement) && (Be(u) || u[Kp])) break a;
						if ((l || c) && (c = a.window === a ? a : (c = a.ownerDocument) ? c.defaultView || c.parentWindow : window, l ? (u = n.relatedTarget || n.toElement, l = i, u = u ? Be(u) : null, u !== null && (f = S(u), d = u.tag, u !== f || d !== 5 && d !== 27 && d !== 6) && (u = null)) : (l = null, u = i), l !== u)) {
							if (d = fh, g = "onMouseLeave", p = "onMouseEnter", m = "mouse", (e === "pointerout" || e === "pointerover") && (d = Ah, g = "onPointerLeave", p = "onPointerEnter", m = "pointer"), f = l == null ? c : He(l), h = u == null ? c : He(u), c = new d(g, m + "leave", l, n, a), c.target = f, c.relatedTarget = h, g = null, Be(a) === i && (d = new d(p, m + "enter", u, n, a), d.target = h, d.relatedTarget = f, g = d), f = g, l && u) b: {
								for (d = uu, p = l, m = u, h = 0, g = p; g; g = d(g)) h++;
								g = 0;
								for (var _ = m; _; _ = d(_)) g++;
								for (; 0 < h - g;) p = d(p), h--;
								for (; 0 < g - h;) m = d(m), g--;
								for (; h--;) {
									if (p === m || m !== null && p === m.alternate) {
										d = p;
										break b;
									}
									p = d(p), m = d(m);
								}
								d = null;
							}
							else d = null;
							l !== null && du(s, c, l, d, !1), u !== null && f !== null && du(s, f, u, d, !0);
						}
					}
					a: {
						if (c = i ? He(i) : window, l = c.nodeName && c.nodeName.toLowerCase(), l === "select" || l === "input" && c.type === "file") var v = _n;
						else if (fn(c)) if (Qh) v = Cn;
						else {
							v = xn;
							var y = bn;
						}
						else l = c.nodeName, !l || l.toLowerCase() !== "input" || c.type !== "checkbox" && c.type !== "radio" ? i && Ht(i.elementType) && (v = _n) : v = Sn;
						if (v &&= v(e, i)) {
							mn(s, v, n, a);
							break a;
						}
						y && y(e, c, i), e === "focusout" && i && c.type === "number" && i.memoizedProps.value != null && st(c, "number", c.value);
					}
					switch (y = i ? He(i) : window, e) {
						case "focusin":
							(fn(y) || y.contentEditable === "true") && (tg = y, ng = i, rg = null);
							break;
						case "focusout":
							rg = ng = tg = null;
							break;
						case "mousedown":
							ig = !0;
							break;
						case "contextmenu":
						case "mouseup":
						case "dragend":
							ig = !1, jn(s, n, a);
							break;
						case "selectionchange": if (eg) break;
						case "keydown":
						case "keyup": jn(s, n, a);
					}
					var b;
					if (Vh) b: {
						switch (e) {
							case "compositionstart":
								var x = "onCompositionStart";
								break b;
							case "compositionend":
								x = "onCompositionEnd";
								break b;
							case "compositionupdate":
								x = "onCompositionUpdate";
								break b;
						}
						x = void 0;
					}
					else Jh ? sn(e, n) && (x = "onCompositionEnd") : e === "keydown" && n.keyCode === Bh && (x = "onCompositionStart");
					x && (Wh && n.locale !== "ko" && (Jh || x !== "onCompositionStart" ? x === "onCompositionEnd" && Jh && (b = $t()) : (th = a, nh = "value" in th ? th.value : th.textContent, Jh = !0)), y = lu(i, x), 0 < y.length && (x = new Sh(x, e, null, n, a), s.push({
						event: x,
						listeners: y
					}), b ? x.data = b : (b = ln(n), b !== null && (x.data = b)))), (b = Uh ? un(e, n) : dn(e, n)) && (x = lu(i, "onBeforeInput"), 0 < x.length && (y = new Ch("onBeforeInput", "beforeinput", null, n, a), s.push({
						event: y,
						listeners: x
					}), y.data = b)), eu(s, e, i, n, a);
				}
				nu(s, t);
			});
		}
		function cu(e, t, n) {
			return {
				instance: e,
				listener: t,
				currentTarget: n
			};
		}
		function lu(e, t) {
			for (var n = t + "Capture", i = []; e !== null;) {
				var a = e, o = a.stateNode;
				if (a = a.tag, a !== 5 && a !== 26 && a !== 27 || o === null || (a = K(e, n), a != null && i.unshift(cu(e, a, o)), a = K(e, t), a != null && i.push(cu(e, a, o))), e.tag === 3) return i;
				e = e.return;
			}
			return [];
		}
		function uu(e) {
			if (e === null) return null;
			do
				e = e.return;
			while (e && e.tag !== 5 && e.tag !== 27);
			return e || null;
		}
		function du(e, t, n, i, a) {
			for (var o = t._reactName, s = []; n !== null && n !== i;) {
				var c = n, l = c.alternate, u = c.stateNode;
				if (c = c.tag, l !== null && l === i) break;
				c !== 5 && c !== 26 && c !== 27 || u === null || (l = u, a ? (u = K(n, o), u != null && s.unshift(cu(n, u, l))) : a || (u = K(n, o), u != null && s.push(cu(n, u, l)))), n = n.return;
			}
			s.length !== 0 && e.push({
				event: t,
				listeners: s
			});
		}
		function fu(e, t) {
			Gt(e, t), e !== "input" && e !== "textarea" && e !== "select" || t == null || t.value !== null || Vm || (Vm = !0, e === "select" && t.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", e) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", e));
			var n = {
				registrationNameDependencies: $p,
				possibleRegistrationNames: em
			};
			Ht(e) || typeof t.is == "string" || qt(e, t, n), t.contentEditable && !t.suppressContentEditableWarning && t.children != null && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
		}
		function pu(e, t, n, i) {
			t !== n && (n = _u(n), _u(t) !== n && (i[e] = t));
		}
		function mu(e, t, n) {
			t.forEach(function(t) {
				n[Cu(t)] = t === "style" ? wu(e) : e.getAttribute(t);
			});
		}
		function hu(e, t) {
			!1 === t ? console.error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", e, e, e) : console.error("Expected `%s` listener to be a function, instead got a value of `%s` type.", e, typeof t);
		}
		function gu(e, t) {
			return e = e.namespaceURI === Nm || e.namespaceURI === Pm ? e.ownerDocument.createElementNS(e.namespaceURI, e.tagName) : e.ownerDocument.createElement(e.tagName), e.innerHTML = t, e.innerHTML;
		}
		function _u(e) {
			return ge(e) && (console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", he(e)), _e(e)), (typeof e == "string" ? e : "" + e).replace(GS, "\n").replace(KS, "");
		}
		function vu(e, t) {
			return t = _u(t), _u(e) === t;
		}
		function yu(e, t, n, i, a, o) {
			switch (n) {
				case "children":
					typeof i == "string" ? (Lt(i, t, !1), t === "body" || t === "textarea" && i === "" || Rt(e, i)) : (typeof i == "number" || typeof i == "bigint") && (Lt("" + i, t, !1), t !== "body" && Rt(e, "" + i));
					break;
				case "className":
					Ye(e, "class", i);
					break;
				case "tabIndex":
					Ye(e, "tabindex", i);
					break;
				case "dir":
				case "role":
				case "viewBox":
				case "width":
				case "height":
					Ye(e, n, i);
					break;
				case "style":
					Vt(e, i, o);
					break;
				case "data": if (t !== "object") {
					Ye(e, "data", i);
					break;
				}
				case "src":
				case "href":
					if (i === "" && (t !== "a" || n !== "href")) {
						n === "src" ? console.error("An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", n, n) : console.error("An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", n, n), e.removeAttribute(n);
						break;
					}
					if (i == null || typeof i == "function" || typeof i == "symbol" || typeof i == "boolean") {
						e.removeAttribute(n);
						break;
					}
					H(i, n), i = Jt("" + i), e.setAttribute(n, i);
					break;
				case "action":
				case "formAction":
					if (i != null && (t === "form" ? n === "formAction" ? console.error("You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>.") : typeof i == "function" && (a.encType == null && a.method == null || HS || (HS = !0, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.")), a.target == null || VS || (VS = !0, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."))) : t === "input" || t === "button" ? n === "action" ? console.error("You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>.") : t !== "input" || a.type === "submit" || a.type === "image" || zS ? t !== "button" || a.type == null || a.type === "submit" || zS ? typeof i == "function" && (a.name == null || BS || (BS = !0, console.error("Cannot specify a \"name\" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.")), a.formEncType == null && a.formMethod == null || HS || (HS = !0, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.")), a.formTarget == null || VS || (VS = !0, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."))) : (zS = !0, console.error("A button can only specify a formAction along with type=\"submit\" or no type.")) : (zS = !0, console.error("An input can only specify a formAction along with type=\"submit\" or type=\"image\".")) : n === "action" ? console.error("You can only pass the action prop to <form>.") : console.error("You can only pass the formAction prop to <input> or <button>.")), typeof i == "function") {
						e.setAttribute(n, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
						break;
					} else typeof o == "function" && (n === "formAction" ? (t !== "input" && yu(e, t, "name", a.name, a, null), yu(e, t, "formEncType", a.formEncType, a, null), yu(e, t, "formMethod", a.formMethod, a, null), yu(e, t, "formTarget", a.formTarget, a, null)) : (yu(e, t, "encType", a.encType, a, null), yu(e, t, "method", a.method, a, null), yu(e, t, "target", a.target, a, null)));
					if (i == null || typeof i == "symbol" || typeof i == "boolean") {
						e.removeAttribute(n);
						break;
					}
					H(i, n), i = Jt("" + i), e.setAttribute(n, i);
					break;
				case "onClick":
					i != null && (typeof i != "function" && hu(n, i), e.onclick = Yt);
					break;
				case "onScroll":
					i != null && (typeof i != "function" && hu(n, i), ru("scroll", e));
					break;
				case "onScrollEnd":
					i != null && (typeof i != "function" && hu(n, i), ru("scrollend", e));
					break;
				case "dangerouslySetInnerHTML":
					if (i != null) {
						if (typeof i != "object" || !("__html" in i)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
						if (n = i.__html, n != null) {
							if (a.children != null) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
							e.innerHTML = n;
						}
					}
					break;
				case "multiple":
					e.multiple = i && typeof i != "function" && typeof i != "symbol";
					break;
				case "muted":
					e.muted = i && typeof i != "function" && typeof i != "symbol";
					break;
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "defaultValue":
				case "defaultChecked":
				case "innerHTML":
				case "ref": break;
				case "autoFocus": break;
				case "xlinkHref":
					if (i == null || typeof i == "function" || typeof i == "boolean" || typeof i == "symbol") {
						e.removeAttribute("xlink:href");
						break;
					}
					H(i, n), n = Jt("" + i), e.setAttributeNS(qS, "xlink:href", n);
					break;
				case "contentEditable":
				case "spellCheck":
				case "draggable":
				case "value":
				case "autoReverse":
				case "externalResourcesRequired":
				case "focusable":
				case "preserveAlpha":
					i != null && typeof i != "function" && typeof i != "symbol" ? (H(i, n), e.setAttribute(n, "" + i)) : e.removeAttribute(n);
					break;
				case "inert": i !== "" || WS[n] || (WS[n] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", n));
				case "allowFullScreen":
				case "async":
				case "autoPlay":
				case "controls":
				case "default":
				case "defer":
				case "disabled":
				case "disablePictureInPicture":
				case "disableRemotePlayback":
				case "formNoValidate":
				case "hidden":
				case "loop":
				case "noModule":
				case "noValidate":
				case "open":
				case "playsInline":
				case "readOnly":
				case "required":
				case "reversed":
				case "scoped":
				case "seamless":
				case "itemScope":
					i && typeof i != "function" && typeof i != "symbol" ? e.setAttribute(n, "") : e.removeAttribute(n);
					break;
				case "capture":
				case "download":
					!0 === i ? e.setAttribute(n, "") : !1 !== i && i != null && typeof i != "function" && typeof i != "symbol" ? (H(i, n), e.setAttribute(n, i)) : e.removeAttribute(n);
					break;
				case "cols":
				case "rows":
				case "size":
				case "span":
					i != null && typeof i != "function" && typeof i != "symbol" && !isNaN(i) && 1 <= i ? (H(i, n), e.setAttribute(n, i)) : e.removeAttribute(n);
					break;
				case "rowSpan":
				case "start":
					i == null || typeof i == "function" || typeof i == "symbol" || isNaN(i) ? e.removeAttribute(n) : (H(i, n), e.setAttribute(n, i));
					break;
				case "popover":
					ru("beforetoggle", e), ru("toggle", e), G(e, "popover", i);
					break;
				case "xlinkActuate":
					Xe(e, qS, "xlink:actuate", i);
					break;
				case "xlinkArcrole":
					Xe(e, qS, "xlink:arcrole", i);
					break;
				case "xlinkRole":
					Xe(e, qS, "xlink:role", i);
					break;
				case "xlinkShow":
					Xe(e, qS, "xlink:show", i);
					break;
				case "xlinkTitle":
					Xe(e, qS, "xlink:title", i);
					break;
				case "xlinkType":
					Xe(e, qS, "xlink:type", i);
					break;
				case "xmlBase":
					Xe(e, JS, "xml:base", i);
					break;
				case "xmlLang":
					Xe(e, JS, "xml:lang", i);
					break;
				case "xmlSpace":
					Xe(e, JS, "xml:space", i);
					break;
				case "is":
					o != null && console.error("Cannot update the \"is\" prop after it has been initialized."), G(e, "is", i);
					break;
				case "innerText":
				case "textContent": break;
				case "popoverTarget": US || typeof i != "object" || !i || (US = !0, console.error("The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.", i));
				default: !(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N" ? (n = Ut(n), G(e, n, i)) : $p.hasOwnProperty(n) && i != null && typeof i != "function" && hu(n, i);
			}
		}
		function bu(e, t, n, i, a, o) {
			switch (n) {
				case "style":
					Vt(e, i, o);
					break;
				case "dangerouslySetInnerHTML":
					if (i != null) {
						if (typeof i != "object" || !("__html" in i)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
						if (n = i.__html, n != null) {
							if (a.children != null) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
							e.innerHTML = n;
						}
					}
					break;
				case "children":
					typeof i == "string" ? Rt(e, i) : (typeof i == "number" || typeof i == "bigint") && Rt(e, "" + i);
					break;
				case "onScroll":
					i != null && (typeof i != "function" && hu(n, i), ru("scroll", e));
					break;
				case "onScrollEnd":
					i != null && (typeof i != "function" && hu(n, i), ru("scrollend", e));
					break;
				case "onClick":
					i != null && (typeof i != "function" && hu(n, i), e.onclick = Yt);
					break;
				case "suppressContentEditableWarning":
				case "suppressHydrationWarning":
				case "innerHTML":
				case "ref": break;
				case "innerText":
				case "textContent": break;
				default: if ($p.hasOwnProperty(n)) i != null && typeof i != "function" && hu(n, i);
				else a: {
					if (n[0] === "o" && n[1] === "n" && (a = n.endsWith("Capture"), t = n.slice(2, a ? n.length - 7 : void 0), o = e[Gp] || null, o = o == null ? null : o[n], typeof o == "function" && e.removeEventListener(t, o, a), typeof i == "function")) {
						typeof o != "function" && o !== null && (n in e ? e[n] = null : e.hasAttribute(n) && e.removeAttribute(n)), e.addEventListener(t, i, a);
						break a;
					}
					n in e ? e[n] = i : !0 === i ? e.setAttribute(n, "") : G(e, n, i);
				}
			}
		}
		function xu(e, t, n) {
			switch (fu(t, n), t) {
				case "div":
				case "span":
				case "svg":
				case "path":
				case "a":
				case "g":
				case "p":
				case "li": break;
				case "img":
					ru("error", e), ru("load", e);
					var i = !1, a = !1, o;
					for (o in n) if (n.hasOwnProperty(o)) {
						var s = n[o];
						if (s != null) switch (o) {
							case "src":
								i = !0;
								break;
							case "srcSet":
								a = !0;
								break;
							case "children":
							case "dangerouslySetInnerHTML": throw Error(t + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
							default: yu(e, t, o, s, n, null);
						}
					}
					a && yu(e, t, "srcSet", n.srcSet, n, null), i && yu(e, t, "src", n.src, n, null);
					return;
				case "input":
					Ke("input", n), ru("invalid", e);
					var c = o = s = a = null, l = null, u = null;
					for (i in n) if (n.hasOwnProperty(i)) {
						var d = n[i];
						if (d != null) switch (i) {
							case "name":
								a = d;
								break;
							case "type":
								s = d;
								break;
							case "checked":
								l = d;
								break;
							case "defaultChecked":
								u = d;
								break;
							case "value":
								o = d;
								break;
							case "defaultValue":
								c = d;
								break;
							case "children":
							case "dangerouslySetInnerHTML":
								if (d != null) throw Error(t + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
								break;
							default: yu(e, t, i, d, n, null);
						}
					}
					it(e, n), ot(e, o, c, l, u, s, a, !1);
					return;
				case "select":
					for (a in Ke("select", n), ru("invalid", e), i = s = o = null, n) if (n.hasOwnProperty(a) && (c = n[a], c != null)) switch (a) {
						case "value":
							o = c;
							break;
						case "defaultValue":
							s = c;
							break;
						case "multiple": i = c;
						default: yu(e, t, a, c, n, null);
					}
					dt(e, n), t = o, n = s, e.multiple = !!i, t == null ? n != null && ut(e, !!i, n, !0) : ut(e, !!i, t, !1);
					return;
				case "textarea":
					for (s in Ke("textarea", n), ru("invalid", e), o = a = i = null, n) if (n.hasOwnProperty(s) && (c = n[s], c != null)) switch (s) {
						case "value":
							i = c;
							break;
						case "defaultValue":
							a = c;
							break;
						case "children":
							o = c;
							break;
						case "dangerouslySetInnerHTML":
							if (c != null) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
							break;
						default: yu(e, t, s, c, n, null);
					}
					ft(e, n), mt(e, i, a, o);
					return;
				case "option":
					for (l in ct(e, n), n) if (n.hasOwnProperty(l) && (i = n[l], i != null)) switch (l) {
						case "selected":
							e.selected = i && typeof i != "function" && typeof i != "symbol";
							break;
						default: yu(e, t, l, i, n, null);
					}
					return;
				case "dialog":
					ru("beforetoggle", e), ru("toggle", e), ru("cancel", e), ru("close", e);
					break;
				case "iframe":
				case "object":
					ru("load", e);
					break;
				case "video":
				case "audio":
					for (i = 0; i < PS.length; i++) ru(PS[i], e);
					break;
				case "image":
					ru("error", e), ru("load", e);
					break;
				case "details":
					ru("toggle", e);
					break;
				case "embed":
				case "source":
				case "link": ru("error", e), ru("load", e);
				case "area":
				case "base":
				case "br":
				case "col":
				case "hr":
				case "keygen":
				case "meta":
				case "param":
				case "track":
				case "wbr":
				case "menuitem":
					for (u in n) if (n.hasOwnProperty(u) && (i = n[u], i != null)) switch (u) {
						case "children":
						case "dangerouslySetInnerHTML": throw Error(t + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
						default: yu(e, t, u, i, n, null);
					}
					return;
				default: if (Ht(t)) {
					for (d in n) n.hasOwnProperty(d) && (i = n[d], i !== void 0 && bu(e, t, d, i, n, void 0));
					return;
				}
			}
			for (c in n) n.hasOwnProperty(c) && (i = n[c], i != null && yu(e, t, c, i, n, null));
		}
		function Su(e, t, n, i) {
			switch (fu(t, i), t) {
				case "div":
				case "span":
				case "svg":
				case "path":
				case "a":
				case "g":
				case "p":
				case "li": break;
				case "input":
					var a = null, o = null, s = null, c = null, l = null, u = null, d = null;
					for (m in n) {
						var f = n[m];
						if (n.hasOwnProperty(m) && f != null) switch (m) {
							case "checked": break;
							case "value": break;
							case "defaultValue": l = f;
							default: i.hasOwnProperty(m) || yu(e, t, m, null, i, f);
						}
					}
					for (var p in i) {
						var m = i[p];
						if (f = n[p], i.hasOwnProperty(p) && (m != null || f != null)) switch (p) {
							case "type":
								o = m;
								break;
							case "name":
								a = m;
								break;
							case "checked":
								u = m;
								break;
							case "defaultChecked":
								d = m;
								break;
							case "value":
								s = m;
								break;
							case "defaultValue":
								c = m;
								break;
							case "children":
							case "dangerouslySetInnerHTML":
								if (m != null) throw Error(t + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
								break;
							default: m !== f && yu(e, t, p, m, i, f);
						}
					}
					t = n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null, i = i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null, t || !i || RS || (console.error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), RS = !0), !t || i || LS || (console.error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), LS = !0), at(e, s, c, l, u, d, o, a);
					return;
				case "select":
					for (o in m = s = c = p = null, n) if (l = n[o], n.hasOwnProperty(o) && l != null) switch (o) {
						case "value": break;
						case "multiple": m = l;
						default: i.hasOwnProperty(o) || yu(e, t, o, null, i, l);
					}
					for (a in i) if (o = i[a], l = n[a], i.hasOwnProperty(a) && (o != null || l != null)) switch (a) {
						case "value":
							p = o;
							break;
						case "defaultValue":
							c = o;
							break;
						case "multiple": s = o;
						default: o !== l && yu(e, t, a, o, i, l);
					}
					i = c, t = s, n = m, p == null ? !!n != !!t && (i == null ? ut(e, !!t, t ? [] : "", !1) : ut(e, !!t, i, !0)) : ut(e, !!t, p, !1);
					return;
				case "textarea":
					for (c in m = p = null, n) if (a = n[c], n.hasOwnProperty(c) && a != null && !i.hasOwnProperty(c)) switch (c) {
						case "value": break;
						case "children": break;
						default: yu(e, t, c, null, i, a);
					}
					for (s in i) if (a = i[s], o = n[s], i.hasOwnProperty(s) && (a != null || o != null)) switch (s) {
						case "value":
							p = a;
							break;
						case "defaultValue":
							m = a;
							break;
						case "children": break;
						case "dangerouslySetInnerHTML":
							if (a != null) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
							break;
						default: a !== o && yu(e, t, s, a, i, o);
					}
					pt(e, p, m);
					return;
				case "option":
					for (var h in n) if (p = n[h], n.hasOwnProperty(h) && p != null && !i.hasOwnProperty(h)) switch (h) {
						case "selected":
							e.selected = !1;
							break;
						default: yu(e, t, h, null, i, p);
					}
					for (l in i) if (p = i[l], m = n[l], i.hasOwnProperty(l) && p !== m && (p != null || m != null)) switch (l) {
						case "selected":
							e.selected = p && typeof p != "function" && typeof p != "symbol";
							break;
						default: yu(e, t, l, p, i, m);
					}
					return;
				case "img":
				case "link":
				case "area":
				case "base":
				case "br":
				case "col":
				case "embed":
				case "hr":
				case "keygen":
				case "meta":
				case "param":
				case "source":
				case "track":
				case "wbr":
				case "menuitem":
					for (var g in n) p = n[g], n.hasOwnProperty(g) && p != null && !i.hasOwnProperty(g) && yu(e, t, g, null, i, p);
					for (u in i) if (p = i[u], m = n[u], i.hasOwnProperty(u) && p !== m && (p != null || m != null)) switch (u) {
						case "children":
						case "dangerouslySetInnerHTML":
							if (p != null) throw Error(t + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
							break;
						default: yu(e, t, u, p, i, m);
					}
					return;
				default: if (Ht(t)) {
					for (var _ in n) p = n[_], n.hasOwnProperty(_) && p !== void 0 && !i.hasOwnProperty(_) && bu(e, t, _, void 0, i, p);
					for (d in i) p = i[d], m = n[d], !i.hasOwnProperty(d) || p === m || p === void 0 && m === void 0 || bu(e, t, d, p, i, m);
					return;
				}
			}
			for (var v in n) p = n[v], n.hasOwnProperty(v) && p != null && !i.hasOwnProperty(v) && yu(e, t, v, null, i, p);
			for (f in i) p = i[f], m = n[f], !i.hasOwnProperty(f) || p === m || p == null && m == null || yu(e, t, f, p, i, m);
		}
		function Cu(e) {
			switch (e) {
				case "class": return "className";
				case "for": return "htmlFor";
				default: return e;
			}
		}
		function wu(e) {
			var t = {};
			e = e.style;
			for (var n = 0; n < e.length; n++) {
				var i = e[n];
				t[i] = e.getPropertyValue(i);
			}
			return t;
		}
		function Tu(e, t, n) {
			if (t != null && typeof t != "object") console.error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
			else {
				var i, a = i = "", o;
				for (o in t) if (t.hasOwnProperty(o)) {
					var s = t[o];
					s != null && typeof s != "boolean" && s !== "" && (o.indexOf("--") === 0 ? (ve(s, o), i += a + o + ":" + ("" + s).trim()) : typeof s != "number" || s === 0 || Mm.has(o) ? (ve(s, o), i += a + o.replace(Sm, "-$1").toLowerCase().replace(Cm, "-ms-") + ":" + ("" + s).trim()) : i += a + o.replace(Sm, "-$1").toLowerCase().replace(Cm, "-ms-") + ":" + s + "px", a = ";");
				}
				i ||= null, t = e.getAttribute("style"), t !== i && (i = _u(i), _u(t) !== i && (n.style = wu(e)));
			}
		}
		function Eu(e, t, n, i, a, o) {
			if (a.delete(n), e = e.getAttribute(n), e === null) switch (typeof i) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean": return;
			}
			else if (i != null) switch (typeof i) {
				case "function":
				case "symbol":
				case "boolean": break;
				default: if (H(i, t), e === "" + i) return;
			}
			pu(t, e, i, o);
		}
		function Du(e, t, n, i, a, o) {
			if (a.delete(n), e = e.getAttribute(n), e === null) {
				switch (typeof i) {
					case "function":
					case "symbol": return;
				}
				if (!i) return;
			} else switch (typeof i) {
				case "function":
				case "symbol": break;
				default: if (i) return;
			}
			pu(t, e, i, o);
		}
		function Ou(e, t, n, i, a, o) {
			if (a.delete(n), e = e.getAttribute(n), e === null) switch (typeof i) {
				case "undefined":
				case "function":
				case "symbol": return;
			}
			else if (i != null) switch (typeof i) {
				case "function":
				case "symbol": break;
				default: if (H(i, n), e === "" + i) return;
			}
			pu(t, e, i, o);
		}
		function ku(e, t, n, i, a, o) {
			if (a.delete(n), e = e.getAttribute(n), e === null) switch (typeof i) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean": return;
				default: if (isNaN(i)) return;
			}
			else if (i != null) switch (typeof i) {
				case "function":
				case "symbol":
				case "boolean": break;
				default: if (!isNaN(i) && (H(i, t), e === "" + i)) return;
			}
			pu(t, e, i, o);
		}
		function Au(e, t, n, i, a, o) {
			if (a.delete(n), e = e.getAttribute(n), e === null) switch (typeof i) {
				case "undefined":
				case "function":
				case "symbol":
				case "boolean": return;
			}
			else if (i != null) switch (typeof i) {
				case "function":
				case "symbol":
				case "boolean": break;
				default: if (H(i, t), n = Jt("" + i), e === n) return;
			}
			pu(t, e, i, o);
		}
		function ju(e, t, n, i) {
			for (var a = {}, o = /* @__PURE__ */ new Set(), s = e.attributes, c = 0; c < s.length; c++) switch (s[c].name.toLowerCase()) {
				case "value": break;
				case "checked": break;
				case "selected": break;
				default: o.add(s[c].name);
			}
			if (Ht(t)) {
				for (var l in n) if (n.hasOwnProperty(l)) {
					var u = n[l];
					if (u != null) {
						if ($p.hasOwnProperty(l)) typeof u != "function" && hu(l, u);
						else if (!0 !== n.suppressHydrationWarning) switch (l) {
							case "children":
								typeof u != "string" && typeof u != "number" || pu("children", e.textContent, u, a);
								continue;
							case "suppressContentEditableWarning":
							case "suppressHydrationWarning":
							case "defaultValue":
							case "defaultChecked":
							case "innerHTML":
							case "ref": continue;
							case "dangerouslySetInnerHTML":
								s = e.innerHTML, u = u ? u.__html : void 0, u != null && (u = gu(e, u), pu(l, s, u, a));
								continue;
							case "style":
								o.delete(l), Tu(e, u, a);
								continue;
							case "offsetParent":
							case "offsetTop":
							case "offsetLeft":
							case "offsetWidth":
							case "offsetHeight":
							case "isContentEditable":
							case "outerText":
							case "outerHTML":
								o.delete(l.toLowerCase()), console.error("Assignment to read-only property will result in a no-op: `%s`", l);
								continue;
							case "className":
								o.delete("class"), s = Je(e, "class", u), pu("className", s, u, a);
								continue;
							default: i.context === dC && t !== "svg" && t !== "math" ? o.delete(l.toLowerCase()) : o.delete(l), s = Je(e, l, u), pu(l, s, u, a);
						}
					}
				}
			} else for (u in n) if (n.hasOwnProperty(u) && (l = n[u], l != null)) {
				if ($p.hasOwnProperty(u)) typeof l != "function" && hu(u, l);
				else if (!0 !== n.suppressHydrationWarning) switch (u) {
					case "children":
						typeof l != "string" && typeof l != "number" || pu("children", e.textContent, l, a);
						continue;
					case "suppressContentEditableWarning":
					case "suppressHydrationWarning":
					case "value":
					case "checked":
					case "selected":
					case "defaultValue":
					case "defaultChecked":
					case "innerHTML":
					case "ref": continue;
					case "dangerouslySetInnerHTML":
						s = e.innerHTML, l = l ? l.__html : void 0, l != null && (l = gu(e, l), s !== l && (a[u] = { __html: s }));
						continue;
					case "className":
						Eu(e, u, "class", l, o, a);
						continue;
					case "tabIndex":
						Eu(e, u, "tabindex", l, o, a);
						continue;
					case "style":
						o.delete(u), Tu(e, l, a);
						continue;
					case "multiple":
						o.delete(u), pu(u, e.multiple, l, a);
						continue;
					case "muted":
						o.delete(u), pu(u, e.muted, l, a);
						continue;
					case "autoFocus":
						o.delete("autofocus"), pu(u, e.autofocus, l, a);
						continue;
					case "data": if (t !== "object") {
						o.delete(u), s = e.getAttribute("data"), pu(u, s, l, a);
						continue;
					}
					case "src":
					case "href":
						if (!(l !== "" || t === "a" && u === "href" || t === "object" && u === "data")) {
							u === "src" ? console.error("An empty string (\"\") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", u, u) : console.error("An empty string (\"\") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.", u, u);
							continue;
						}
						Au(e, u, u, l, o, a);
						continue;
					case "action":
					case "formAction":
						if (s = e.getAttribute(u), typeof l == "function") {
							o.delete(u.toLowerCase()), u === "formAction" ? (o.delete("name"), o.delete("formenctype"), o.delete("formmethod"), o.delete("formtarget")) : (o.delete("enctype"), o.delete("method"), o.delete("target"));
							continue;
						} else if (s === YS) {
							o.delete(u.toLowerCase()), pu(u, "function", l, a);
							continue;
						}
						Au(e, u, u.toLowerCase(), l, o, a);
						continue;
					case "xlinkHref":
						Au(e, u, "xlink:href", l, o, a);
						continue;
					case "contentEditable":
						Ou(e, u, "contenteditable", l, o, a);
						continue;
					case "spellCheck":
						Ou(e, u, "spellcheck", l, o, a);
						continue;
					case "draggable":
					case "autoReverse":
					case "externalResourcesRequired":
					case "focusable":
					case "preserveAlpha":
						Ou(e, u, u, l, o, a);
						continue;
					case "allowFullScreen":
					case "async":
					case "autoPlay":
					case "controls":
					case "default":
					case "defer":
					case "disabled":
					case "disablePictureInPicture":
					case "disableRemotePlayback":
					case "formNoValidate":
					case "hidden":
					case "loop":
					case "noModule":
					case "noValidate":
					case "open":
					case "playsInline":
					case "readOnly":
					case "required":
					case "reversed":
					case "scoped":
					case "seamless":
					case "itemScope":
						Du(e, u, u.toLowerCase(), l, o, a);
						continue;
					case "capture":
					case "download":
						a: {
							c = e;
							var d = s = u, f = a;
							if (o.delete(d), c = c.getAttribute(d), c === null) switch (typeof l) {
								case "undefined":
								case "function":
								case "symbol": break a;
								default: if (!1 === l) break a;
							}
							else if (l != null) switch (typeof l) {
								case "function":
								case "symbol": break;
								case "boolean":
									if (!0 === l && c === "") break a;
									break;
								default: if (H(l, s), c === "" + l) break a;
							}
							pu(s, c, l, f);
						}
						continue;
					case "cols":
					case "rows":
					case "size":
					case "span":
						a: {
							if (c = e, d = s = u, f = a, o.delete(d), c = c.getAttribute(d), c === null) switch (typeof l) {
								case "undefined":
								case "function":
								case "symbol":
								case "boolean": break a;
								default: if (isNaN(l) || 1 > l) break a;
							}
							else if (l != null) switch (typeof l) {
								case "function":
								case "symbol":
								case "boolean": break;
								default: if (!(isNaN(l) || 1 > l) && (H(l, s), c === "" + l)) break a;
							}
							pu(s, c, l, f);
						}
						continue;
					case "rowSpan":
						ku(e, u, "rowspan", l, o, a);
						continue;
					case "start":
						ku(e, u, u, l, o, a);
						continue;
					case "xHeight":
						Eu(e, u, "x-height", l, o, a);
						continue;
					case "xlinkActuate":
						Eu(e, u, "xlink:actuate", l, o, a);
						continue;
					case "xlinkArcrole":
						Eu(e, u, "xlink:arcrole", l, o, a);
						continue;
					case "xlinkRole":
						Eu(e, u, "xlink:role", l, o, a);
						continue;
					case "xlinkShow":
						Eu(e, u, "xlink:show", l, o, a);
						continue;
					case "xlinkTitle":
						Eu(e, u, "xlink:title", l, o, a);
						continue;
					case "xlinkType":
						Eu(e, u, "xlink:type", l, o, a);
						continue;
					case "xmlBase":
						Eu(e, u, "xml:base", l, o, a);
						continue;
					case "xmlLang":
						Eu(e, u, "xml:lang", l, o, a);
						continue;
					case "xmlSpace":
						Eu(e, u, "xml:space", l, o, a);
						continue;
					case "inert":
						l !== "" || WS[u] || (WS[u] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", u)), Du(e, u, u, l, o, a);
						continue;
					default: if (!(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") {
						c = Ut(u), s = !1, i.context === dC && t !== "svg" && t !== "math" ? o.delete(c.toLowerCase()) : (d = u.toLowerCase(), d = Im.hasOwnProperty(d) && Im[d] || null, d !== null && d !== u && (s = !0, o.delete(d)), o.delete(c));
						a: if (d = e, f = c, c = l, qe(f)) if (d.hasAttribute(f)) d = d.getAttribute(f), H(c, f), c = d === "" + c ? c : d;
						else {
							switch (typeof c) {
								case "function":
								case "symbol": break a;
								case "boolean": if (d = f.toLowerCase().slice(0, 5), d !== "data-" && d !== "aria-") break a;
							}
							c = c === void 0 ? void 0 : null;
						}
						else c = void 0;
						s || pu(u, c, l, a);
					}
				}
			}
			return 0 < o.size && !0 !== n.suppressHydrationWarning && mu(e, o, a), Object.keys(a).length === 0 ? null : a;
		}
		function Mu(e, t) {
			switch (e.length) {
				case 0: return "";
				case 1: return e[0];
				case 2: return e[0] + " " + t + " " + e[1];
				default: return e.slice(0, -1).join(", ") + ", " + t + " " + e[e.length - 1];
			}
		}
		function Nu(e) {
			switch (e) {
				case "css":
				case "script":
				case "font":
				case "img":
				case "image":
				case "input":
				case "link": return !0;
				default: return !1;
			}
		}
		function Pu() {
			if (typeof performance.getEntriesByType == "function") {
				for (var e = 0, t = 0, n = performance.getEntriesByType("resource"), i = 0; i < n.length; i++) {
					var a = n[i], o = a.transferSize, s = a.initiatorType, c = a.duration;
					if (o && c && Nu(s)) {
						for (s = 0, c = a.responseEnd, i += 1; i < n.length; i++) {
							var l = n[i], u = l.startTime;
							if (u > c) break;
							var d = l.transferSize, f = l.initiatorType;
							d && Nu(f) && (l = l.responseEnd, s += d * (l < c ? 1 : (c - u) / (l - u)));
						}
						if (--i, t += 8 * (o + s) / (a.duration / 1e3), e++, 10 < e) break;
					}
				}
				if (0 < e) return t / e / 1e6;
			}
			return navigator.connection && (e = navigator.connection.downlink, typeof e == "number") ? e : 5;
		}
		function Fu(e) {
			return e.nodeType === 9 ? e : e.ownerDocument;
		}
		function Iu(e) {
			switch (e) {
				case Pm: return fC;
				case Nm: return pC;
				default: return dC;
			}
		}
		function Lu(e, t) {
			if (e === dC) switch (t) {
				case "svg": return fC;
				case "math": return pC;
				default: return dC;
			}
			return e === fC && t === "foreignObject" ? dC : e;
		}
		function Ru(e, t) {
			return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.children == "bigint" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
		}
		function zu() {
			var e = window.event;
			return e && e.type === "popstate" ? e === _C ? !1 : (_C = e, !0) : (_C = null, !1);
		}
		function Bu() {
			var e = window.event;
			return e && e !== vC ? e.type : null;
		}
		function Vu() {
			var e = window.event;
			return e && e !== vC ? e.timeStamp : -1.1;
		}
		function Hu(e) {
			setTimeout(function() {
				throw e;
			});
		}
		function Uu(e, t, n) {
			switch (t) {
				case "button":
				case "input":
				case "select":
				case "textarea":
					n.autoFocus && e.focus();
					break;
				case "img": n.src ? e.src = n.src : n.srcSet && (e.srcset = n.srcSet);
			}
		}
		function Wu() {}
		function Gu(e, t, n, i) {
			Su(e, t, n, i), e[Gp] = i;
		}
		function Ku(e) {
			Rt(e, "");
		}
		function qu(e, t, n) {
			e.nodeValue = n;
		}
		function Ju(e) {
			if (!e.__reactWarnedAboutChildrenConflict) {
				var t = e[Gp] || null;
				if (t !== null) {
					var n = Ve(e);
					n !== null && (typeof t.children == "string" || typeof t.children == "number" ? (e.__reactWarnedAboutChildrenConflict = !0, V(n, function() {
						console.error("Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets \"children\" text content using React. It should be a leaf with no children. Otherwise it's ambiguous which children should be used.");
					})) : t.dangerouslySetInnerHTML != null && (e.__reactWarnedAboutChildrenConflict = !0, V(n, function() {
						console.error("Cannot use a ref on a React element as a container to `createRoot` or `createPortal` if that element also sets \"dangerouslySetInnerHTML\" using React. It should be a leaf with no children. Otherwise it's ambiguous which children should be used.");
					})));
				}
			}
		}
		function Yu(e) {
			return e === "head";
		}
		function Xu(e, t) {
			e.removeChild(t);
		}
		function Zu(e, t) {
			(e.nodeType === 9 ? e.body : e.nodeName === "HTML" ? e.ownerDocument.body : e).removeChild(t);
		}
		function Qu(e, t) {
			var n = t, i = 0;
			do {
				var a = n.nextSibling;
				if (e.removeChild(n), a && a.nodeType === 8) if (n = a.data, n === eC || n === QS) {
					if (i === 0) {
						e.removeChild(a), yf(t);
						return;
					}
					i--;
				} else if (n === $S || n === tC || n === nC || n === rC || n === ZS) i++;
				else if (n === iC) Cd(e.ownerDocument.documentElement);
				else if (n === oC) {
					n = e.ownerDocument.head, Cd(n);
					for (var o = n.firstChild; o;) {
						var s = o.nextSibling, c = o.nodeName;
						o[Zp] || c === "SCRIPT" || c === "STYLE" || c === "LINK" && o.rel.toLowerCase() === "stylesheet" || n.removeChild(o), o = s;
					}
				} else n === aC && Cd(e.ownerDocument.body);
				n = a;
			} while (n);
			yf(t);
		}
		function $u(e, t) {
			var n = e;
			e = 0;
			do {
				var i = n.nextSibling;
				if (n.nodeType === 1 ? t ? (n._stashedDisplay = n.style.display, n.style.display = "none") : (n.style.display = n._stashedDisplay || "", n.getAttribute("style") === "" && n.removeAttribute("style")) : n.nodeType === 3 && (t ? (n._stashedText = n.nodeValue, n.nodeValue = "") : n.nodeValue = n._stashedText || ""), i && i.nodeType === 8) if (n = i.data, n === eC) {
					if (e === 0) break;
					e--;
				} else n !== $S && n !== tC && n !== nC && n !== rC || e++;
				n = i;
			} while (n);
		}
		function ed(e) {
			$u(e, !0);
		}
		function td(e) {
			e = e.style, typeof e.setProperty == "function" ? e.setProperty("display", "none", "important") : e.display = "none";
		}
		function nd(e) {
			e.nodeValue = "";
		}
		function rd(e) {
			$u(e, !1);
		}
		function id(e, t) {
			t = t[uC], t = t != null && t.hasOwnProperty("display") ? t.display : null, e.style.display = t == null || typeof t == "boolean" ? "" : ("" + t).trim();
		}
		function ad(e, t) {
			e.nodeValue = t;
		}
		function od(e) {
			var t = e.firstChild;
			for (t && t.nodeType === 10 && (t = t.nextSibling); t;) {
				var n = t;
				switch (t = t.nextSibling, n.nodeName) {
					case "HTML":
					case "HEAD":
					case "BODY":
						od(n), ze(n);
						continue;
					case "SCRIPT":
					case "STYLE": continue;
					case "LINK": if (n.rel.toLowerCase() === "stylesheet") continue;
				}
				e.removeChild(n);
			}
		}
		function sd(e, t, n, i) {
			for (; e.nodeType === 1;) {
				var a = n;
				if (e.nodeName.toLowerCase() !== t.toLowerCase()) {
					if (!i && (e.nodeName !== "INPUT" || e.type !== "hidden")) break;
				} else if (i) {
					if (!e[Zp]) switch (t) {
						case "meta":
							if (!e.hasAttribute("itemprop")) break;
							return e;
						case "link":
							if (o = e.getAttribute("rel"), o === "stylesheet" && e.hasAttribute("data-precedence") || o !== a.rel || e.getAttribute("href") !== (a.href == null || a.href === "" ? null : a.href) || e.getAttribute("crossorigin") !== (a.crossOrigin == null ? null : a.crossOrigin) || e.getAttribute("title") !== (a.title == null ? null : a.title)) break;
							return e;
						case "style":
							if (e.hasAttribute("data-precedence")) break;
							return e;
						case "script":
							if (o = e.getAttribute("src"), (o !== (a.src == null ? null : a.src) || e.getAttribute("type") !== (a.type == null ? null : a.type) || e.getAttribute("crossorigin") !== (a.crossOrigin == null ? null : a.crossOrigin)) && o && e.hasAttribute("async") && !e.hasAttribute("itemprop")) break;
							return e;
						default: return e;
					}
				} else if (t === "input" && e.type === "hidden") {
					H(a.name, "name");
					var o = a.name == null ? null : "" + a.name;
					if (a.type === "hidden" && e.getAttribute("name") === o) return e;
				} else return e;
				if (e = pd(e.nextSibling), e === null) break;
			}
			return null;
		}
		function cd(e, t, n) {
			if (t === "") return null;
			for (; e.nodeType !== 3;) if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !n || (e = pd(e.nextSibling), e === null)) return null;
			return e;
		}
		function ld(e, t) {
			for (; e.nodeType !== 8;) if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !t || (e = pd(e.nextSibling), e === null)) return null;
			return e;
		}
		function ud(e) {
			return e.data === tC || e.data === nC;
		}
		function dd(e) {
			return e.data === rC || e.data === tC && e.ownerDocument.readyState !== lC;
		}
		function fd(e, t) {
			var n = e.ownerDocument;
			if (e.data === nC) e._reactRetry = t;
			else if (e.data !== tC || n.readyState !== lC) t();
			else {
				var i = function() {
					t(), n.removeEventListener("DOMContentLoaded", i);
				};
				n.addEventListener("DOMContentLoaded", i), e._reactRetry = i;
			}
		}
		function pd(e) {
			for (; e != null; e = e.nextSibling) {
				var t = e.nodeType;
				if (t === 1 || t === 3) break;
				if (t === 8) {
					if (t = e.data, t === $S || t === rC || t === tC || t === nC || t === ZS || t === sC || t === cC) break;
					if (t === eC || t === QS) return null;
				}
			}
			return e;
		}
		function md(e) {
			if (e.nodeType === 1) {
				for (var t = e.nodeName.toLowerCase(), n = {}, i = e.attributes, a = 0; a < i.length; a++) {
					var o = i[a];
					n[Cu(o.name)] = o.name.toLowerCase() === "style" ? wu(e) : o.value;
				}
				return {
					type: t,
					props: n
				};
			}
			return e.nodeType === 8 ? e.data === ZS ? {
				type: "Activity",
				props: {}
			} : {
				type: "Suspense",
				props: {}
			} : e.nodeValue;
		}
		function hd(e, t, n) {
			return n === null || !0 !== n[XS] ? (e.nodeValue === t ? e = null : (t = _u(t), e = _u(e.nodeValue) === t ? null : e.nodeValue), e) : null;
		}
		function gd(e) {
			e = e.nextSibling;
			for (var t = 0; e;) {
				if (e.nodeType === 8) {
					var n = e.data;
					if (n === eC || n === QS) {
						if (t === 0) return pd(e.nextSibling);
						t--;
					} else n !== $S && n !== rC && n !== tC && n !== nC && n !== ZS || t++;
				}
				e = e.nextSibling;
			}
			return null;
		}
		function _d(e) {
			e = e.previousSibling;
			for (var t = 0; e;) {
				if (e.nodeType === 8) {
					var n = e.data;
					if (n === $S || n === rC || n === tC || n === nC || n === ZS) {
						if (t === 0) return e;
						t--;
					} else n !== eC && n !== QS || t++;
				}
				e = e.previousSibling;
			}
			return null;
		}
		function vd(e) {
			yf(e);
		}
		function yd(e) {
			yf(e);
		}
		function bd(e) {
			yf(e);
		}
		function xd(e, t, n, i, a) {
			switch (a && It(e, i.ancestorInfo), t = Fu(n), e) {
				case "html":
					if (e = t.documentElement, !e) throw Error("React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.");
					return e;
				case "head":
					if (e = t.head, !e) throw Error("React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.");
					return e;
				case "body":
					if (e = t.body, !e) throw Error("React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.");
					return e;
				default: throw Error("resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.");
			}
		}
		function Sd(e, t, n, i) {
			if (!n[Kp] && Ve(n)) {
				var a = n.tagName.toLowerCase();
				console.error("You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.", a, a, a);
			}
			switch (e) {
				case "html":
				case "head":
				case "body": break;
				default: console.error("acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.");
			}
			for (a = n.attributes; a.length;) n.removeAttributeNode(a[0]);
			xu(n, e, t), n[Wp] = i, n[Gp] = t;
		}
		function Cd(e) {
			for (var t = e.attributes; t.length;) e.removeAttributeNode(t[0]);
			ze(e);
		}
		function wd(e) {
			return typeof e.getRootNode == "function" ? e.getRootNode() : e.nodeType === 9 ? e : e.ownerDocument;
		}
		function Td(e, t, n) {
			var i = NC;
			if (i && typeof t == "string" && t) {
				var a = rt(t);
				a = "link[rel=\"" + e + "\"][href=\"" + a + "\"]", typeof n == "string" && (a += "[crossorigin=\"" + n + "\"]"), jC.has(a) || (jC.add(a), e = {
					rel: e,
					crossOrigin: n,
					href: t
				}, i.querySelector(a) === null && (t = i.createElement("link"), xu(t, "link", e), We(t), i.head.appendChild(t)));
			}
		}
		function Ed(e, t, n, i) {
			var a = (a = $f.current) ? wd(a) : null;
			if (!a) throw Error("\"resourceRoot\" was expected to exist. This is a bug in React.");
			switch (e) {
				case "meta":
				case "title": return null;
				case "style": return typeof n.precedence == "string" && typeof n.href == "string" ? (n = Od(n.href), t = Ue(a).hoistableStyles, i = t.get(n), i || (i = {
					type: "style",
					instance: null,
					count: 0,
					state: null
				}, t.set(n, i)), i) : {
					type: "void",
					instance: null,
					count: 0,
					state: null
				};
				case "link":
					if (n.rel === "stylesheet" && typeof n.href == "string" && typeof n.precedence == "string") {
						e = Od(n.href);
						var o = Ue(a).hoistableStyles, s = o.get(e);
						if (!s && (a = a.ownerDocument || a, s = {
							type: "stylesheet",
							instance: null,
							count: 0,
							state: {
								loading: TC,
								preload: null
							}
						}, o.set(e, s), (o = a.querySelector(kd(e))) && !o._p && (s.instance = o, s.state.loading = EC | kC), !AC.has(e))) {
							var c = {
								rel: "preload",
								as: "style",
								href: n.href,
								crossOrigin: n.crossOrigin,
								integrity: n.integrity,
								media: n.media,
								hrefLang: n.hrefLang,
								referrerPolicy: n.referrerPolicy
							};
							AC.set(e, c), o || jd(a, e, c, s.state);
						}
						if (t && i === null) throw n = "\n\n  - " + Dd(t) + "\n  + " + Dd(n), Error("Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + n);
						return s;
					}
					if (t && i !== null) throw n = "\n\n  - " + Dd(t) + "\n  + " + Dd(n), Error("Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + n);
					return null;
				case "script": return t = n.async, n = n.src, typeof n == "string" && t && typeof t != "function" && typeof t != "symbol" ? (n = Md(n), t = Ue(a).hoistableScripts, i = t.get(n), i || (i = {
					type: "script",
					instance: null,
					count: 0,
					state: null
				}, t.set(n, i)), i) : {
					type: "void",
					instance: null,
					count: 0,
					state: null
				};
				default: throw Error("getResource encountered a type it did not expect: \"" + e + "\". this is a bug in React.");
			}
		}
		function Dd(e) {
			var t = 0, n = "<link";
			return typeof e.rel == "string" ? (t++, n += " rel=\"" + e.rel + "\"") : hp.call(e, "rel") && (t++, n += " rel=\"" + (e.rel === null ? "null" : "invalid type " + typeof e.rel) + "\""), typeof e.href == "string" ? (t++, n += " href=\"" + e.href + "\"") : hp.call(e, "href") && (t++, n += " href=\"" + (e.href === null ? "null" : "invalid type " + typeof e.href) + "\""), typeof e.precedence == "string" ? (t++, n += " precedence=\"" + e.precedence + "\"") : hp.call(e, "precedence") && (t++, n += " precedence={" + (e.precedence === null ? "null" : "invalid type " + typeof e.precedence) + "}"), Object.getOwnPropertyNames(e).length > t && (n += " ..."), n + " />";
		}
		function Od(e) {
			return "href=\"" + rt(e) + "\"";
		}
		function kd(e) {
			return "link[rel=\"stylesheet\"][" + e + "]";
		}
		function Ad(e) {
			return Df({}, e, {
				"data-precedence": e.precedence,
				precedence: null
			});
		}
		function jd(e, t, n, i) {
			e.querySelector("link[rel=\"preload\"][as=\"style\"][" + t + "]") ? i.loading = EC : (t = e.createElement("link"), i.preload = t, t.addEventListener("load", function() {
				return i.loading |= EC;
			}), t.addEventListener("error", function() {
				return i.loading |= DC;
			}), xu(t, "link", n), We(t), e.head.appendChild(t));
		}
		function Md(e) {
			return "[src=\"" + rt(e) + "\"]";
		}
		function Nd(e) {
			return "script[async]" + e;
		}
		function Pd(e, t, n) {
			if (t.count++, t.instance === null) switch (t.type) {
				case "style":
					var i = e.querySelector("style[data-href~=\"" + rt(n.href) + "\"]");
					if (i) return t.instance = i, We(i), i;
					var a = Df({}, n, {
						"data-href": n.href,
						"data-precedence": n.precedence,
						href: null,
						precedence: null
					});
					return i = (e.ownerDocument || e).createElement("style"), We(i), xu(i, "style", a), Fd(i, n.precedence, e), t.instance = i;
				case "stylesheet":
					a = Od(n.href);
					var o = e.querySelector(kd(a));
					if (o) return t.state.loading |= kC, t.instance = o, We(o), o;
					i = Ad(n), (a = AC.get(a)) && Id(i, a), o = (e.ownerDocument || e).createElement("link"), We(o);
					var s = o;
					return s._p = new Promise(function(e, t) {
						s.onload = e, s.onerror = t;
					}), xu(o, "link", i), t.state.loading |= kC, Fd(o, n.precedence, e), t.instance = o;
				case "script": return o = Md(n.src), (a = e.querySelector(Nd(o))) ? (t.instance = a, We(a), a) : (i = n, (a = AC.get(o)) && (i = Df({}, n), Ld(i, a)), e = e.ownerDocument || e, a = e.createElement("script"), We(a), xu(a, "link", i), e.head.appendChild(a), t.instance = a);
				case "void": return null;
				default: throw Error("acquireResource encountered a resource type it did not expect: \"" + t.type + "\". this is a bug in React.");
			}
			else t.type === "stylesheet" && (t.state.loading & kC) === TC && (i = t.instance, t.state.loading |= kC, Fd(i, n.precedence, e));
			return t.instance;
		}
		function Fd(e, t, n) {
			for (var i = n.querySelectorAll("link[rel=\"stylesheet\"][data-precedence],style[data-precedence]"), a = i.length ? i[i.length - 1] : null, o = a, s = 0; s < i.length; s++) {
				var c = i[s];
				if (c.dataset.precedence === t) o = c;
				else if (o !== a) break;
			}
			o ? o.parentNode.insertBefore(e, o.nextSibling) : (t = n.nodeType === 9 ? n.head : n, t.insertBefore(e, t.firstChild));
		}
		function Id(e, t) {
			e.crossOrigin ??= t.crossOrigin, e.referrerPolicy ??= t.referrerPolicy, e.title ??= t.title;
		}
		function Ld(e, t) {
			e.crossOrigin ??= t.crossOrigin, e.referrerPolicy ??= t.referrerPolicy, e.integrity ??= t.integrity;
		}
		function Rd(e, t, n) {
			if (PC === null) {
				var i = /* @__PURE__ */ new Map(), a = PC = /* @__PURE__ */ new Map();
				a.set(n, i);
			} else a = PC, i = a.get(n), i || (i = /* @__PURE__ */ new Map(), a.set(n, i));
			if (i.has(e)) return i;
			for (i.set(e, null), n = n.getElementsByTagName(e), a = 0; a < n.length; a++) {
				var o = n[a];
				if (!(o[Zp] || o[Wp] || e === "link" && o.getAttribute("rel") === "stylesheet") && o.namespaceURI !== Pm) {
					var s = o.getAttribute(t) || "";
					s = e + s;
					var c = i.get(s);
					c ? c.push(o) : i.set(s, [o]);
				}
			}
			return i;
		}
		function zd(e, t, n) {
			e = e.ownerDocument || e, e.head.insertBefore(n, t === "title" ? e.querySelector("head > title") : null);
		}
		function Bd(e, t, n) {
			var i = !n.ancestorInfo.containerTagInScope;
			if (n.context === fC || t.itemProp != null) return !i || t.itemProp == null || e !== "meta" && e !== "title" && e !== "style" && e !== "link" && e !== "script" || console.error("Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.", e, e), !1;
			switch (e) {
				case "meta":
				case "title": return !0;
				case "style":
					if (typeof t.precedence != "string" || typeof t.href != "string" || t.href === "") {
						i && console.error("Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel=\"stylesheet\" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence=\"default\"` and `href=\"some unique resource identifier\"`.");
						break;
					}
					return !0;
				case "link":
					if (typeof t.rel != "string" || typeof t.href != "string" || t.href === "" || t.onLoad || t.onError) {
						if (t.rel === "stylesheet" && typeof t.precedence == "string") {
							e = t.href;
							var a = t.onError, o = t.disabled;
							n = [], t.onLoad && n.push("`onLoad`"), a && n.push("`onError`"), o != null && n.push("`disabled`"), a = Mu(n, "and"), a += n.length === 1 ? " prop" : " props", o = n.length === 1 ? "an " + a : "the " + a, n.length && console.error("React encountered a <link rel=\"stylesheet\" href=\"%s\" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.", e, o, a);
						}
						i && (typeof t.rel != "string" || typeof t.href != "string" || t.href === "" ? console.error("Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag") : (t.onError || t.onLoad) && console.error("Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."));
						break;
					}
					switch (t.rel) {
						case "stylesheet": return e = t.precedence, t = t.disabled, typeof e != "string" && i && console.error("Cannot render a <link rel=\"stylesheet\" /> outside the main document without knowing its precedence. Consider adding precedence=\"default\" or moving it into the root <head> tag."), typeof e == "string" && t == null;
						default: return !0;
					}
				case "script":
					if (e = t.async && typeof t.async != "function" && typeof t.async != "symbol", !e || t.onLoad || t.onError || !t.src || typeof t.src != "string") {
						i && (e ? t.onLoad || t.onError ? console.error("Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.") : console.error("Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>.") : console.error("Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async=\"\" or moving it into the root <head> tag."));
						break;
					}
					return !0;
				case "noscript":
				case "template": i && console.error("Cannot render <%s> outside the main document. Try moving it into the root <head> tag.", e);
			}
			return !1;
		}
		function Vd(e) {
			return !(e.type === "stylesheet" && (e.state.loading & OC) === TC);
		}
		function Hd(e, t, n, i) {
			if (n.type === "stylesheet" && (typeof i.media != "string" || !1 !== matchMedia(i.media).matches) && (n.state.loading & kC) === TC) {
				if (n.instance === null) {
					var a = Od(i.href), o = t.querySelector(kd(a));
					if (o) {
						t = o._p, typeof t == "object" && t && typeof t.then == "function" && (e.count++, e = Wd.bind(e), t.then(e, e)), n.state.loading |= kC, n.instance = o, We(o);
						return;
					}
					o = t.ownerDocument || t, i = Ad(i), (a = AC.get(a)) && Id(i, a), o = o.createElement("link"), We(o);
					var s = o;
					s._p = new Promise(function(e, t) {
						s.onload = e, s.onerror = t;
					}), xu(o, "link", i), n.instance = o;
				}
				e.stylesheets === null && (e.stylesheets = /* @__PURE__ */ new Map()), e.stylesheets.set(n, t), (t = n.state.preload) && (n.state.loading & OC) === TC && (e.count++, n = Wd.bind(e), t.addEventListener("load", n), t.addEventListener("error", n));
			}
		}
		function Ud(e, t) {
			return e.stylesheets && e.count === 0 && Gd(e, e.stylesheets), 0 < e.count || 0 < e.imgCount ? function(n) {
				var i = setTimeout(function() {
					if (e.stylesheets && Gd(e, e.stylesheets), e.unsuspend) {
						var t = e.unsuspend;
						e.unsuspend = null, t();
					}
				}, FC + t);
				0 < e.imgBytes && RC === 0 && (RC = 125 * Pu() * LC);
				var a = setTimeout(function() {
					if (e.waitingForImages = !1, e.count === 0 && (e.stylesheets && Gd(e, e.stylesheets), e.unsuspend)) {
						var t = e.unsuspend;
						e.unsuspend = null, t();
					}
				}, (e.imgBytes > RC ? 50 : IC) + t);
				return e.unsuspend = n, function() {
					e.unsuspend = null, clearTimeout(i), clearTimeout(a);
				};
			} : null;
		}
		function Wd() {
			if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
				if (this.stylesheets) Gd(this, this.stylesheets);
				else if (this.unsuspend) {
					var e = this.unsuspend;
					this.unsuspend = null, e();
				}
			}
		}
		function Gd(e, t) {
			e.stylesheets = null, e.unsuspend !== null && (e.count++, BC = /* @__PURE__ */ new Map(), t.forEach(Kd, e), BC = null, Wd.call(e));
		}
		function Kd(e, t) {
			if (!(t.state.loading & kC)) {
				var n = BC.get(e);
				if (n) var i = n.get(zC);
				else {
					n = /* @__PURE__ */ new Map(), BC.set(e, n);
					for (var a = e.querySelectorAll("link[data-precedence],style[data-precedence]"), o = 0; o < a.length; o++) {
						var s = a[o];
						(s.nodeName === "LINK" || s.getAttribute("media") !== "not all") && (n.set(s.dataset.precedence, s), i = s);
					}
					i && n.set(zC, i);
				}
				a = t.instance, s = a.getAttribute("data-precedence"), o = n.get(s) || i, o === i && n.set(zC, a), n.set(s, a), this.count++, i = Wd.bind(this), a.addEventListener("load", i), a.addEventListener("error", i), o ? o.parentNode.insertBefore(a, o.nextSibling) : (e = e.nodeType === 9 ? e.head : e, e.insertBefore(a, e.firstChild)), t.state.loading |= kC;
			}
		}
		function qd(e, t, n, i, a, o, s, c, l) {
			for (this.tag = 1, this.containerInfo = e, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = xC, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Oe(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Oe(0), this.hiddenUpdates = Oe(null), this.identifierPrefix = i, this.onUncaughtError = a, this.onCaughtError = o, this.onRecoverableError = s, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = l, this.incompleteTransitions = /* @__PURE__ */ new Map(), this.passiveEffectDuration = this.effectDuration = -0, this.memoizedUpdaters = /* @__PURE__ */ new Set(), e = this.pendingUpdatersLaneMap = [], t = 0; 31 > t; t++) e.push(/* @__PURE__ */ new Set());
			this._debugRootType = n ? "hydrateRoot()" : "createRoot()";
		}
		function Jd(e, t, n, i, a, o, s, c, l, u, d, f) {
			return e = new qd(e, t, n, s, l, u, d, f, c), t = Yg, !0 === o && (t |= Zg | Qg), t |= Xg, o = g(3, null, null, t), e.current = o, o.stateNode = e, t = Xr(), Zr(t), e.pooledCache = t, Zr(t), o.memoizedState = {
				element: i,
				isDehydrated: n,
				cache: t
			}, Ui(o), e;
		}
		function Yd(e) {
			return e ? (e = Gg, e) : Gg;
		}
		function Xd(e, t, n, i, a, o) {
			if (Ap && typeof Ap.onScheduleFiberRoot == "function") try {
				Ap.onScheduleFiberRoot(kp, i, n);
			} catch (e) {
				jp || (jp = !0, console.error("React instrumentation encountered an error: %o", e));
			}
			a = Yd(a), i.context === null ? i.context = a : i.pendingContext = a, mp && pp !== null && !JC && (JC = !0, console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", M(pp) || "Unknown")), i = Gi(t), i.payload = { element: n }, o = o === void 0 ? null : o, o !== null && (typeof o != "function" && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", o), i.callback = o), n = Ki(e, i, t), n !== null && ($r(t, "root.render()", null), Yc(n, e, t), qi(n, e, t));
		}
		function Zd(e, t) {
			if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
				var n = e.retryLane;
				e.retryLane = n !== 0 && n < t ? n : t;
			}
		}
		function Qd(e, t) {
			Zd(e, t), (e = e.alternate) && Zd(e, t);
		}
		function $d(e) {
			if (e.tag === 13 || e.tag === 31) {
				var t = nr(e, 67108864);
				t !== null && Yc(t, e, 67108864), Qd(e, 67108864);
			}
		}
		function ef(e) {
			if (e.tag === 13 || e.tag === 31) {
				var t = qc(e);
				t = U(t);
				var n = nr(e, t);
				n !== null && Yc(n, e, t), Qd(e, t);
			}
		}
		function tf() {
			return pp;
		}
		function nf(e, t, n, i) {
			var a = Q.T;
			Q.T = null;
			var o = Kf.p;
			try {
				Kf.p = zp, af(e, t, n, i);
			} finally {
				Kf.p = o, Q.T = a;
			}
		}
		function rf(e, t, n, i) {
			var a = Q.T;
			Q.T = null;
			var o = Kf.p;
			try {
				Kf.p = Bp, af(e, t, n, i);
			} finally {
				Kf.p = o, Q.T = a;
			}
		}
		function af(e, t, n, i) {
			if (aw) {
				var a = sf(i);
				if (a === null) su(e, t, i, ow, n), uf(e, i);
				else if (ff(a, e, t, n, i)) i.stopPropagation();
				else if (uf(e, i), t & 4 && -1 < mw.indexOf(e)) {
					for (; a !== null;) {
						var o = Ve(a);
						if (o !== null) switch (o.tag) {
							case 3:
								if (o = o.stateNode, o.current.memoizedState.isDehydrated) {
									var s = Ce(o.pendingLanes);
									if (s !== 0) {
										var c = o;
										for (c.pendingLanes |= 2, c.entangledLanes |= 2; s;) {
											var l = 1 << 31 - Np(s);
											c.entanglements[1] |= l, s &= ~l;
										}
										Hl(o), (lx & ($b | ex)) === Qb && (Vx = bp() + Hx, Ul(0, !1));
									}
								}
								break;
							case 31:
							case 13: c = nr(o, 2), c !== null && Yc(c, o, 2), el(), Qd(o, 2);
						}
						if (o = sf(i), o === null && su(e, t, i, ow, n), o === a) break;
						a = o;
					}
					a !== null && i.stopPropagation();
				} else su(e, t, i, null, n);
			}
		}
		function sf(e) {
			return e = Xt(e), cf(e);
		}
		function cf(e) {
			if (ow = null, e = Be(e), e !== null) {
				var t = S(e);
				if (t === null) e = null;
				else {
					var n = t.tag;
					if (n === 13) {
						if (e = C(t), e !== null) return e;
						e = null;
					} else if (n === 31) {
						if (e = w(t), e !== null) return e;
						e = null;
					} else if (n === 3) {
						if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null;
						e = null;
					} else t !== e && (e = null);
				}
			}
			return ow = e, null;
		}
		function lf(e) {
			switch (e) {
				case "beforetoggle":
				case "cancel":
				case "click":
				case "close":
				case "contextmenu":
				case "copy":
				case "cut":
				case "auxclick":
				case "dblclick":
				case "dragend":
				case "dragstart":
				case "drop":
				case "focusin":
				case "focusout":
				case "input":
				case "invalid":
				case "keydown":
				case "keypress":
				case "keyup":
				case "mousedown":
				case "mouseup":
				case "paste":
				case "pause":
				case "play":
				case "pointercancel":
				case "pointerdown":
				case "pointerup":
				case "ratechange":
				case "reset":
				case "resize":
				case "seeked":
				case "submit":
				case "toggle":
				case "touchcancel":
				case "touchend":
				case "touchstart":
				case "volumechange":
				case "change":
				case "selectionchange":
				case "textInput":
				case "compositionstart":
				case "compositionend":
				case "compositionupdate":
				case "beforeblur":
				case "afterblur":
				case "beforeinput":
				case "blur":
				case "fullscreenchange":
				case "focus":
				case "hashchange":
				case "popstate":
				case "select":
				case "selectstart": return zp;
				case "drag":
				case "dragenter":
				case "dragexit":
				case "dragleave":
				case "dragover":
				case "mousemove":
				case "mouseout":
				case "mouseover":
				case "pointermove":
				case "pointerout":
				case "pointerover":
				case "scroll":
				case "touchmove":
				case "wheel":
				case "mouseenter":
				case "mouseleave":
				case "pointerenter":
				case "pointerleave": return Bp;
				case "message": switch (xp()) {
					case Sp: return zp;
					case Cp: return Bp;
					case wp:
					case Tp: return Vp;
					case Ep: return Hp;
					default: return Vp;
				}
				default: return Vp;
			}
		}
		function uf(e, t) {
			switch (e) {
				case "focusin":
				case "focusout":
					cw = null;
					break;
				case "dragenter":
				case "dragleave":
					lw = null;
					break;
				case "mouseover":
				case "mouseout":
					uw = null;
					break;
				case "pointerover":
				case "pointerout":
					dw.delete(t.pointerId);
					break;
				case "gotpointercapture":
				case "lostpointercapture": fw.delete(t.pointerId);
			}
		}
		function df(e, t, n, i, a, o) {
			return e === null || e.nativeEvent !== o ? (e = {
				blockedOn: t,
				domEventName: n,
				eventSystemFlags: i,
				nativeEvent: o,
				targetContainers: [a]
			}, t !== null && (t = Ve(t), t !== null && $d(t)), e) : (e.eventSystemFlags |= i, t = e.targetContainers, a !== null && t.indexOf(a) === -1 && t.push(a), e);
		}
		function ff(e, t, n, i, a) {
			switch (t) {
				case "focusin": return cw = df(cw, e, t, n, i, a), !0;
				case "dragenter": return lw = df(lw, e, t, n, i, a), !0;
				case "mouseover": return uw = df(uw, e, t, n, i, a), !0;
				case "pointerover":
					var o = a.pointerId;
					return dw.set(o, df(dw.get(o) || null, e, t, n, i, a)), !0;
				case "gotpointercapture": return o = a.pointerId, fw.set(o, df(fw.get(o) || null, e, t, n, i, a)), !0;
			}
			return !1;
		}
		function pf(e) {
			var t = Be(e.target);
			if (t !== null) {
				var n = S(t);
				if (n !== null) {
					if (t = n.tag, t === 13) {
						if (t = C(n), t !== null) {
							e.blockedOn = t, Re(e.priority, function() {
								ef(n);
							});
							return;
						}
					} else if (t === 31) {
						if (t = w(n), t !== null) {
							e.blockedOn = t, Re(e.priority, function() {
								ef(n);
							});
							return;
						}
					} else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
						e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
						return;
					}
				}
			}
			e.blockedOn = null;
		}
		function mf(e) {
			if (e.blockedOn !== null) return !1;
			for (var t = e.targetContainers; 0 < t.length;) {
				var n = sf(e.nativeEvent);
				if (n === null) {
					n = e.nativeEvent;
					var i = new n.constructor(n.type, n), a = i;
					Jm !== null && console.error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Jm = a, n.target.dispatchEvent(i), Jm === null && console.error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Jm = null;
				} else return t = Ve(n), t !== null && $d(t), e.blockedOn = n, !1;
				t.shift();
			}
			return !0;
		}
		function hf(e, t, n) {
			mf(e) && n.delete(t);
		}
		function gf() {
			sw = !1, cw !== null && mf(cw) && (cw = null), lw !== null && mf(lw) && (lw = null), uw !== null && mf(uw) && (uw = null), dw.forEach(hf), fw.forEach(hf);
		}
		function _f(e, t) {
			e.blockedOn === t && (e.blockedOn = null, sw || (sw = !0, wf.unstable_scheduleCallback(wf.unstable_NormalPriority, gf)));
		}
		function vf(e) {
			hw !== e && (hw = e, wf.unstable_scheduleCallback(wf.unstable_NormalPriority, function() {
				hw === e && (hw = null);
				for (var t = 0; t < e.length; t += 3) {
					var n = e[t], i = e[t + 1], a = e[t + 2];
					if (typeof i != "function") {
						if (cf(i || n) === null) continue;
						break;
					}
					var o = Ve(n);
					o !== null && (e.splice(t, 3), t -= 3, n = {
						pending: !0,
						data: a,
						method: n.method,
						action: i
					}, Object.freeze(n), wo(o, n, i, a));
				}
			}));
		}
		function yf(e) {
			function t(t) {
				return _f(t, e);
			}
			cw !== null && _f(cw, e), lw !== null && _f(lw, e), uw !== null && _f(uw, e), dw.forEach(t), fw.forEach(t);
			for (var n = 0; n < pw.length; n++) {
				var i = pw[n];
				i.blockedOn === e && (i.blockedOn = null);
			}
			for (; 0 < pw.length && (n = pw[0], n.blockedOn === null);) pf(n), n.blockedOn === null && pw.shift();
			if (n = (e.ownerDocument || e).$$reactFormReplay, n != null) for (i = 0; i < n.length; i += 3) {
				var a = n[i], o = n[i + 1], s = a[Gp] || null;
				if (typeof o == "function") s || vf(n);
				else if (s) {
					var c = null;
					if (o && o.hasAttribute("formAction")) {
						if (a = o, s = o[Gp] || null) c = s.formAction;
						else if (cf(a) !== null) continue;
					} else c = s.action;
					typeof c == "function" ? n[i + 1] = c : (n.splice(i, 3), i -= 3), vf(n);
				}
			}
		}
		function bf() {
			function e(e) {
				e.canIntercept && e.info === "react-transition" && e.intercept({
					handler: function() {
						return new Promise(function(e) {
							return a = e;
						});
					},
					focusReset: "manual",
					scroll: "manual"
				});
			}
			function t() {
				a !== null && (a(), a = null), i || setTimeout(n, 20);
			}
			function n() {
				if (!i && !navigation.transition) {
					var e = navigation.currentEntry;
					e && e.url != null && navigation.navigate(e.url, {
						state: e.getState(),
						info: "react-transition",
						history: "replace"
					});
				}
			}
			if (typeof navigation == "object") {
				var i = !1, a = null;
				return navigation.addEventListener("navigate", e), navigation.addEventListener("navigatesuccess", t), navigation.addEventListener("navigateerror", t), setTimeout(n, 100), function() {
					i = !0, navigation.removeEventListener("navigate", e), navigation.removeEventListener("navigatesuccess", t), navigation.removeEventListener("navigateerror", t), a !== null && (a(), a = null);
				};
			}
		}
		function xf(e) {
			this._internalRoot = e;
		}
		function Sf(e) {
			this._internalRoot = e;
		}
		function Cf(e) {
			e[Kp] && (e._reactRootContainer ? console.error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : console.error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
		}
		typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var wf = require_scheduler(), Tf = require_react(), Ef = require_react_dom(), Df = Object.assign, Of = Symbol.for("react.element"), kf = Symbol.for("react.transitional.element"), Af = Symbol.for("react.portal"), jf = Symbol.for("react.fragment"), Mf = Symbol.for("react.strict_mode"), Nf = Symbol.for("react.profiler"), Pf = Symbol.for("react.consumer"), Ff = Symbol.for("react.context"), If = Symbol.for("react.forward_ref"), Lf = Symbol.for("react.suspense"), Rf = Symbol.for("react.suspense_list"), zf = Symbol.for("react.memo"), Bf = Symbol.for("react.lazy"), Vf = Symbol.for("react.activity"), Hf = Symbol.for("react.memo_cache_sentinel"), Uf = Symbol.iterator, Wf = Symbol.for("react.client.reference"), Gf = Array.isArray, Q = Tf.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Kf = Ef.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, qf = Object.freeze({
			pending: !1,
			data: null,
			method: null,
			action: null
		}), Jf = [], Yf = [], Xf = -1, Zf = N(null), Qf = N(null), $f = N(null), ep = N(null), tp = 0, np, rp, ip, ap, op, sp, cp;
		ie.__reactDisabledLog = !0;
		var lp, up, dp = !1, fp = new (typeof WeakMap == "function" ? WeakMap : Map)(), pp = null, mp = !1, hp = Object.prototype.hasOwnProperty, gp = wf.unstable_scheduleCallback, _p = wf.unstable_cancelCallback, vp = wf.unstable_shouldYield, yp = wf.unstable_requestPaint, bp = wf.unstable_now, xp = wf.unstable_getCurrentPriorityLevel, Sp = wf.unstable_ImmediatePriority, Cp = wf.unstable_UserBlockingPriority, wp = wf.unstable_NormalPriority, Tp = wf.unstable_LowPriority, Ep = wf.unstable_IdlePriority, Dp = wf.log, Op = wf.unstable_setDisableYieldValue, kp = null, Ap = null, jp = !1, Mp = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u", Np = Math.clz32 ? Math.clz32 : Se, Pp = Math.log, Fp = Math.LN2, Ip = 256, Lp = 262144, Rp = 4194304, zp = 2, Bp = 8, Vp = 32, Hp = 268435456, Up = Math.random().toString(36).slice(2), Wp = "__reactFiber$" + Up, Gp = "__reactProps$" + Up, Kp = "__reactContainer$" + Up, qp = "__reactEvents$" + Up, Jp = "__reactListeners$" + Up, Yp = "__reactHandles$" + Up, Xp = "__reactResources$" + Up, Zp = "__reactMarker$" + Up, Qp = /* @__PURE__ */ new Set(), $p = {}, em = {}, tm = {
			button: !0,
			checkbox: !0,
			image: !0,
			hidden: !0,
			radio: !0,
			reset: !0,
			submit: !0
		}, nm = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rm = {}, im = {}, am = /[\n"\\]/g, om = !1, sm = !1, cm = !1, lm = !1, um = !1, dm = !1, fm = ["value", "defaultValue"], pm = !1, mm = /["'&<>\n\t]|^\s|\s$/, hm = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(" "), gm = "applet caption html table td th marquee object template foreignObject desc title".split(" "), _m = gm.concat(["button"]), vm = "dd dt li option optgroup p rp rt".split(" "), ym = {
			current: null,
			formTag: null,
			aTagInScope: null,
			buttonTagInScope: null,
			nobrTagInScope: null,
			pTagInButtonScope: null,
			listItemTagAutoclosing: null,
			dlItemTagAutoclosing: null,
			containerTagInScope: null,
			implicitRootScope: !1
		}, bm = {}, xm = {
			animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(" "),
			background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(" "),
			backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
			border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(" "),
			borderBlockEnd: [
				"borderBlockEndColor",
				"borderBlockEndStyle",
				"borderBlockEndWidth"
			],
			borderBlockStart: [
				"borderBlockStartColor",
				"borderBlockStartStyle",
				"borderBlockStartWidth"
			],
			borderBottom: [
				"borderBottomColor",
				"borderBottomStyle",
				"borderBottomWidth"
			],
			borderColor: [
				"borderBottomColor",
				"borderLeftColor",
				"borderRightColor",
				"borderTopColor"
			],
			borderImage: [
				"borderImageOutset",
				"borderImageRepeat",
				"borderImageSlice",
				"borderImageSource",
				"borderImageWidth"
			],
			borderInlineEnd: [
				"borderInlineEndColor",
				"borderInlineEndStyle",
				"borderInlineEndWidth"
			],
			borderInlineStart: [
				"borderInlineStartColor",
				"borderInlineStartStyle",
				"borderInlineStartWidth"
			],
			borderLeft: [
				"borderLeftColor",
				"borderLeftStyle",
				"borderLeftWidth"
			],
			borderRadius: [
				"borderBottomLeftRadius",
				"borderBottomRightRadius",
				"borderTopLeftRadius",
				"borderTopRightRadius"
			],
			borderRight: [
				"borderRightColor",
				"borderRightStyle",
				"borderRightWidth"
			],
			borderStyle: [
				"borderBottomStyle",
				"borderLeftStyle",
				"borderRightStyle",
				"borderTopStyle"
			],
			borderTop: [
				"borderTopColor",
				"borderTopStyle",
				"borderTopWidth"
			],
			borderWidth: [
				"borderBottomWidth",
				"borderLeftWidth",
				"borderRightWidth",
				"borderTopWidth"
			],
			columnRule: [
				"columnRuleColor",
				"columnRuleStyle",
				"columnRuleWidth"
			],
			columns: ["columnCount", "columnWidth"],
			flex: [
				"flexBasis",
				"flexGrow",
				"flexShrink"
			],
			flexFlow: ["flexDirection", "flexWrap"],
			font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(" "),
			fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(" "),
			gap: ["columnGap", "rowGap"],
			grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(" "),
			gridArea: [
				"gridColumnEnd",
				"gridColumnStart",
				"gridRowEnd",
				"gridRowStart"
			],
			gridColumn: ["gridColumnEnd", "gridColumnStart"],
			gridColumnGap: ["columnGap"],
			gridGap: ["columnGap", "rowGap"],
			gridRow: ["gridRowEnd", "gridRowStart"],
			gridRowGap: ["rowGap"],
			gridTemplate: [
				"gridTemplateAreas",
				"gridTemplateColumns",
				"gridTemplateRows"
			],
			listStyle: [
				"listStyleImage",
				"listStylePosition",
				"listStyleType"
			],
			margin: [
				"marginBottom",
				"marginLeft",
				"marginRight",
				"marginTop"
			],
			marker: [
				"markerEnd",
				"markerMid",
				"markerStart"
			],
			mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(" "),
			maskPosition: ["maskPositionX", "maskPositionY"],
			outline: [
				"outlineColor",
				"outlineStyle",
				"outlineWidth"
			],
			overflow: ["overflowX", "overflowY"],
			padding: [
				"paddingBottom",
				"paddingLeft",
				"paddingRight",
				"paddingTop"
			],
			placeContent: ["alignContent", "justifyContent"],
			placeItems: ["alignItems", "justifyItems"],
			placeSelf: ["alignSelf", "justifySelf"],
			textDecoration: [
				"textDecorationColor",
				"textDecorationLine",
				"textDecorationStyle"
			],
			textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
			transition: [
				"transitionDelay",
				"transitionDuration",
				"transitionProperty",
				"transitionTimingFunction"
			],
			wordWrap: ["overflowWrap"]
		}, Sm = /([A-Z])/g, Cm = /^ms-/, wm = /^(?:webkit|moz|o)[A-Z]/, Tm = /^-ms-/, Em = /-(.)/g, Dm = /;\s*$/, Om = {}, km = {}, Am = !1, jm = !1, Mm = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), Nm = "http://www.w3.org/1998/Math/MathML", Pm = "http://www.w3.org/2000/svg", Fm = new Map([
			["acceptCharset", "accept-charset"],
			["htmlFor", "for"],
			["httpEquiv", "http-equiv"],
			["crossOrigin", "crossorigin"],
			["accentHeight", "accent-height"],
			["alignmentBaseline", "alignment-baseline"],
			["arabicForm", "arabic-form"],
			["baselineShift", "baseline-shift"],
			["capHeight", "cap-height"],
			["clipPath", "clip-path"],
			["clipRule", "clip-rule"],
			["colorInterpolation", "color-interpolation"],
			["colorInterpolationFilters", "color-interpolation-filters"],
			["colorProfile", "color-profile"],
			["colorRendering", "color-rendering"],
			["dominantBaseline", "dominant-baseline"],
			["enableBackground", "enable-background"],
			["fillOpacity", "fill-opacity"],
			["fillRule", "fill-rule"],
			["floodColor", "flood-color"],
			["floodOpacity", "flood-opacity"],
			["fontFamily", "font-family"],
			["fontSize", "font-size"],
			["fontSizeAdjust", "font-size-adjust"],
			["fontStretch", "font-stretch"],
			["fontStyle", "font-style"],
			["fontVariant", "font-variant"],
			["fontWeight", "font-weight"],
			["glyphName", "glyph-name"],
			["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
			["glyphOrientationVertical", "glyph-orientation-vertical"],
			["horizAdvX", "horiz-adv-x"],
			["horizOriginX", "horiz-origin-x"],
			["imageRendering", "image-rendering"],
			["letterSpacing", "letter-spacing"],
			["lightingColor", "lighting-color"],
			["markerEnd", "marker-end"],
			["markerMid", "marker-mid"],
			["markerStart", "marker-start"],
			["overlinePosition", "overline-position"],
			["overlineThickness", "overline-thickness"],
			["paintOrder", "paint-order"],
			["panose-1", "panose-1"],
			["pointerEvents", "pointer-events"],
			["renderingIntent", "rendering-intent"],
			["shapeRendering", "shape-rendering"],
			["stopColor", "stop-color"],
			["stopOpacity", "stop-opacity"],
			["strikethroughPosition", "strikethrough-position"],
			["strikethroughThickness", "strikethrough-thickness"],
			["strokeDasharray", "stroke-dasharray"],
			["strokeDashoffset", "stroke-dashoffset"],
			["strokeLinecap", "stroke-linecap"],
			["strokeLinejoin", "stroke-linejoin"],
			["strokeMiterlimit", "stroke-miterlimit"],
			["strokeOpacity", "stroke-opacity"],
			["strokeWidth", "stroke-width"],
			["textAnchor", "text-anchor"],
			["textDecoration", "text-decoration"],
			["textRendering", "text-rendering"],
			["transformOrigin", "transform-origin"],
			["underlinePosition", "underline-position"],
			["underlineThickness", "underline-thickness"],
			["unicodeBidi", "unicode-bidi"],
			["unicodeRange", "unicode-range"],
			["unitsPerEm", "units-per-em"],
			["vAlphabetic", "v-alphabetic"],
			["vHanging", "v-hanging"],
			["vIdeographic", "v-ideographic"],
			["vMathematical", "v-mathematical"],
			["vectorEffect", "vector-effect"],
			["vertAdvY", "vert-adv-y"],
			["vertOriginX", "vert-origin-x"],
			["vertOriginY", "vert-origin-y"],
			["wordSpacing", "word-spacing"],
			["writingMode", "writing-mode"],
			["xmlnsXlink", "xmlns:xlink"],
			["xHeight", "x-height"]
		]), Im = {
			accept: "accept",
			acceptcharset: "acceptCharset",
			"accept-charset": "acceptCharset",
			accesskey: "accessKey",
			action: "action",
			allowfullscreen: "allowFullScreen",
			alt: "alt",
			as: "as",
			async: "async",
			autocapitalize: "autoCapitalize",
			autocomplete: "autoComplete",
			autocorrect: "autoCorrect",
			autofocus: "autoFocus",
			autoplay: "autoPlay",
			autosave: "autoSave",
			capture: "capture",
			cellpadding: "cellPadding",
			cellspacing: "cellSpacing",
			challenge: "challenge",
			charset: "charSet",
			checked: "checked",
			children: "children",
			cite: "cite",
			class: "className",
			classid: "classID",
			classname: "className",
			cols: "cols",
			colspan: "colSpan",
			content: "content",
			contenteditable: "contentEditable",
			contextmenu: "contextMenu",
			controls: "controls",
			controlslist: "controlsList",
			coords: "coords",
			crossorigin: "crossOrigin",
			dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
			data: "data",
			datetime: "dateTime",
			default: "default",
			defaultchecked: "defaultChecked",
			defaultvalue: "defaultValue",
			defer: "defer",
			dir: "dir",
			disabled: "disabled",
			disablepictureinpicture: "disablePictureInPicture",
			disableremoteplayback: "disableRemotePlayback",
			download: "download",
			draggable: "draggable",
			enctype: "encType",
			enterkeyhint: "enterKeyHint",
			fetchpriority: "fetchPriority",
			for: "htmlFor",
			form: "form",
			formmethod: "formMethod",
			formaction: "formAction",
			formenctype: "formEncType",
			formnovalidate: "formNoValidate",
			formtarget: "formTarget",
			frameborder: "frameBorder",
			headers: "headers",
			height: "height",
			hidden: "hidden",
			high: "high",
			href: "href",
			hreflang: "hrefLang",
			htmlfor: "htmlFor",
			httpequiv: "httpEquiv",
			"http-equiv": "httpEquiv",
			icon: "icon",
			id: "id",
			imagesizes: "imageSizes",
			imagesrcset: "imageSrcSet",
			inert: "inert",
			innerhtml: "innerHTML",
			inputmode: "inputMode",
			integrity: "integrity",
			is: "is",
			itemid: "itemID",
			itemprop: "itemProp",
			itemref: "itemRef",
			itemscope: "itemScope",
			itemtype: "itemType",
			keyparams: "keyParams",
			keytype: "keyType",
			kind: "kind",
			label: "label",
			lang: "lang",
			list: "list",
			loop: "loop",
			low: "low",
			manifest: "manifest",
			marginwidth: "marginWidth",
			marginheight: "marginHeight",
			max: "max",
			maxlength: "maxLength",
			media: "media",
			mediagroup: "mediaGroup",
			method: "method",
			min: "min",
			minlength: "minLength",
			multiple: "multiple",
			muted: "muted",
			name: "name",
			nomodule: "noModule",
			nonce: "nonce",
			novalidate: "noValidate",
			open: "open",
			optimum: "optimum",
			pattern: "pattern",
			placeholder: "placeholder",
			playsinline: "playsInline",
			poster: "poster",
			preload: "preload",
			profile: "profile",
			radiogroup: "radioGroup",
			readonly: "readOnly",
			referrerpolicy: "referrerPolicy",
			rel: "rel",
			required: "required",
			reversed: "reversed",
			role: "role",
			rows: "rows",
			rowspan: "rowSpan",
			sandbox: "sandbox",
			scope: "scope",
			scoped: "scoped",
			scrolling: "scrolling",
			seamless: "seamless",
			selected: "selected",
			shape: "shape",
			size: "size",
			sizes: "sizes",
			span: "span",
			spellcheck: "spellCheck",
			src: "src",
			srcdoc: "srcDoc",
			srclang: "srcLang",
			srcset: "srcSet",
			start: "start",
			step: "step",
			style: "style",
			summary: "summary",
			tabindex: "tabIndex",
			target: "target",
			title: "title",
			type: "type",
			usemap: "useMap",
			value: "value",
			width: "width",
			wmode: "wmode",
			wrap: "wrap",
			about: "about",
			accentheight: "accentHeight",
			"accent-height": "accentHeight",
			accumulate: "accumulate",
			additive: "additive",
			alignmentbaseline: "alignmentBaseline",
			"alignment-baseline": "alignmentBaseline",
			allowreorder: "allowReorder",
			alphabetic: "alphabetic",
			amplitude: "amplitude",
			arabicform: "arabicForm",
			"arabic-form": "arabicForm",
			ascent: "ascent",
			attributename: "attributeName",
			attributetype: "attributeType",
			autoreverse: "autoReverse",
			azimuth: "azimuth",
			basefrequency: "baseFrequency",
			baselineshift: "baselineShift",
			"baseline-shift": "baselineShift",
			baseprofile: "baseProfile",
			bbox: "bbox",
			begin: "begin",
			bias: "bias",
			by: "by",
			calcmode: "calcMode",
			capheight: "capHeight",
			"cap-height": "capHeight",
			clip: "clip",
			clippath: "clipPath",
			"clip-path": "clipPath",
			clippathunits: "clipPathUnits",
			cliprule: "clipRule",
			"clip-rule": "clipRule",
			color: "color",
			colorinterpolation: "colorInterpolation",
			"color-interpolation": "colorInterpolation",
			colorinterpolationfilters: "colorInterpolationFilters",
			"color-interpolation-filters": "colorInterpolationFilters",
			colorprofile: "colorProfile",
			"color-profile": "colorProfile",
			colorrendering: "colorRendering",
			"color-rendering": "colorRendering",
			contentscripttype: "contentScriptType",
			contentstyletype: "contentStyleType",
			cursor: "cursor",
			cx: "cx",
			cy: "cy",
			d: "d",
			datatype: "datatype",
			decelerate: "decelerate",
			descent: "descent",
			diffuseconstant: "diffuseConstant",
			direction: "direction",
			display: "display",
			divisor: "divisor",
			dominantbaseline: "dominantBaseline",
			"dominant-baseline": "dominantBaseline",
			dur: "dur",
			dx: "dx",
			dy: "dy",
			edgemode: "edgeMode",
			elevation: "elevation",
			enablebackground: "enableBackground",
			"enable-background": "enableBackground",
			end: "end",
			exponent: "exponent",
			externalresourcesrequired: "externalResourcesRequired",
			fill: "fill",
			fillopacity: "fillOpacity",
			"fill-opacity": "fillOpacity",
			fillrule: "fillRule",
			"fill-rule": "fillRule",
			filter: "filter",
			filterres: "filterRes",
			filterunits: "filterUnits",
			floodopacity: "floodOpacity",
			"flood-opacity": "floodOpacity",
			floodcolor: "floodColor",
			"flood-color": "floodColor",
			focusable: "focusable",
			fontfamily: "fontFamily",
			"font-family": "fontFamily",
			fontsize: "fontSize",
			"font-size": "fontSize",
			fontsizeadjust: "fontSizeAdjust",
			"font-size-adjust": "fontSizeAdjust",
			fontstretch: "fontStretch",
			"font-stretch": "fontStretch",
			fontstyle: "fontStyle",
			"font-style": "fontStyle",
			fontvariant: "fontVariant",
			"font-variant": "fontVariant",
			fontweight: "fontWeight",
			"font-weight": "fontWeight",
			format: "format",
			from: "from",
			fx: "fx",
			fy: "fy",
			g1: "g1",
			g2: "g2",
			glyphname: "glyphName",
			"glyph-name": "glyphName",
			glyphorientationhorizontal: "glyphOrientationHorizontal",
			"glyph-orientation-horizontal": "glyphOrientationHorizontal",
			glyphorientationvertical: "glyphOrientationVertical",
			"glyph-orientation-vertical": "glyphOrientationVertical",
			glyphref: "glyphRef",
			gradienttransform: "gradientTransform",
			gradientunits: "gradientUnits",
			hanging: "hanging",
			horizadvx: "horizAdvX",
			"horiz-adv-x": "horizAdvX",
			horizoriginx: "horizOriginX",
			"horiz-origin-x": "horizOriginX",
			ideographic: "ideographic",
			imagerendering: "imageRendering",
			"image-rendering": "imageRendering",
			in2: "in2",
			in: "in",
			inlist: "inlist",
			intercept: "intercept",
			k1: "k1",
			k2: "k2",
			k3: "k3",
			k4: "k4",
			k: "k",
			kernelmatrix: "kernelMatrix",
			kernelunitlength: "kernelUnitLength",
			kerning: "kerning",
			keypoints: "keyPoints",
			keysplines: "keySplines",
			keytimes: "keyTimes",
			lengthadjust: "lengthAdjust",
			letterspacing: "letterSpacing",
			"letter-spacing": "letterSpacing",
			lightingcolor: "lightingColor",
			"lighting-color": "lightingColor",
			limitingconeangle: "limitingConeAngle",
			local: "local",
			markerend: "markerEnd",
			"marker-end": "markerEnd",
			markerheight: "markerHeight",
			markermid: "markerMid",
			"marker-mid": "markerMid",
			markerstart: "markerStart",
			"marker-start": "markerStart",
			markerunits: "markerUnits",
			markerwidth: "markerWidth",
			mask: "mask",
			maskcontentunits: "maskContentUnits",
			maskunits: "maskUnits",
			mathematical: "mathematical",
			mode: "mode",
			numoctaves: "numOctaves",
			offset: "offset",
			opacity: "opacity",
			operator: "operator",
			order: "order",
			orient: "orient",
			orientation: "orientation",
			origin: "origin",
			overflow: "overflow",
			overlineposition: "overlinePosition",
			"overline-position": "overlinePosition",
			overlinethickness: "overlineThickness",
			"overline-thickness": "overlineThickness",
			paintorder: "paintOrder",
			"paint-order": "paintOrder",
			panose1: "panose1",
			"panose-1": "panose1",
			pathlength: "pathLength",
			patterncontentunits: "patternContentUnits",
			patterntransform: "patternTransform",
			patternunits: "patternUnits",
			pointerevents: "pointerEvents",
			"pointer-events": "pointerEvents",
			points: "points",
			pointsatx: "pointsAtX",
			pointsaty: "pointsAtY",
			pointsatz: "pointsAtZ",
			popover: "popover",
			popovertarget: "popoverTarget",
			popovertargetaction: "popoverTargetAction",
			prefix: "prefix",
			preservealpha: "preserveAlpha",
			preserveaspectratio: "preserveAspectRatio",
			primitiveunits: "primitiveUnits",
			property: "property",
			r: "r",
			radius: "radius",
			refx: "refX",
			refy: "refY",
			renderingintent: "renderingIntent",
			"rendering-intent": "renderingIntent",
			repeatcount: "repeatCount",
			repeatdur: "repeatDur",
			requiredextensions: "requiredExtensions",
			requiredfeatures: "requiredFeatures",
			resource: "resource",
			restart: "restart",
			result: "result",
			results: "results",
			rotate: "rotate",
			rx: "rx",
			ry: "ry",
			scale: "scale",
			security: "security",
			seed: "seed",
			shaperendering: "shapeRendering",
			"shape-rendering": "shapeRendering",
			slope: "slope",
			spacing: "spacing",
			specularconstant: "specularConstant",
			specularexponent: "specularExponent",
			speed: "speed",
			spreadmethod: "spreadMethod",
			startoffset: "startOffset",
			stddeviation: "stdDeviation",
			stemh: "stemh",
			stemv: "stemv",
			stitchtiles: "stitchTiles",
			stopcolor: "stopColor",
			"stop-color": "stopColor",
			stopopacity: "stopOpacity",
			"stop-opacity": "stopOpacity",
			strikethroughposition: "strikethroughPosition",
			"strikethrough-position": "strikethroughPosition",
			strikethroughthickness: "strikethroughThickness",
			"strikethrough-thickness": "strikethroughThickness",
			string: "string",
			stroke: "stroke",
			strokedasharray: "strokeDasharray",
			"stroke-dasharray": "strokeDasharray",
			strokedashoffset: "strokeDashoffset",
			"stroke-dashoffset": "strokeDashoffset",
			strokelinecap: "strokeLinecap",
			"stroke-linecap": "strokeLinecap",
			strokelinejoin: "strokeLinejoin",
			"stroke-linejoin": "strokeLinejoin",
			strokemiterlimit: "strokeMiterlimit",
			"stroke-miterlimit": "strokeMiterlimit",
			strokewidth: "strokeWidth",
			"stroke-width": "strokeWidth",
			strokeopacity: "strokeOpacity",
			"stroke-opacity": "strokeOpacity",
			suppresscontenteditablewarning: "suppressContentEditableWarning",
			suppresshydrationwarning: "suppressHydrationWarning",
			surfacescale: "surfaceScale",
			systemlanguage: "systemLanguage",
			tablevalues: "tableValues",
			targetx: "targetX",
			targety: "targetY",
			textanchor: "textAnchor",
			"text-anchor": "textAnchor",
			textdecoration: "textDecoration",
			"text-decoration": "textDecoration",
			textlength: "textLength",
			textrendering: "textRendering",
			"text-rendering": "textRendering",
			to: "to",
			transform: "transform",
			transformorigin: "transformOrigin",
			"transform-origin": "transformOrigin",
			typeof: "typeof",
			u1: "u1",
			u2: "u2",
			underlineposition: "underlinePosition",
			"underline-position": "underlinePosition",
			underlinethickness: "underlineThickness",
			"underline-thickness": "underlineThickness",
			unicode: "unicode",
			unicodebidi: "unicodeBidi",
			"unicode-bidi": "unicodeBidi",
			unicoderange: "unicodeRange",
			"unicode-range": "unicodeRange",
			unitsperem: "unitsPerEm",
			"units-per-em": "unitsPerEm",
			unselectable: "unselectable",
			valphabetic: "vAlphabetic",
			"v-alphabetic": "vAlphabetic",
			values: "values",
			vectoreffect: "vectorEffect",
			"vector-effect": "vectorEffect",
			version: "version",
			vertadvy: "vertAdvY",
			"vert-adv-y": "vertAdvY",
			vertoriginx: "vertOriginX",
			"vert-origin-x": "vertOriginX",
			vertoriginy: "vertOriginY",
			"vert-origin-y": "vertOriginY",
			vhanging: "vHanging",
			"v-hanging": "vHanging",
			videographic: "vIdeographic",
			"v-ideographic": "vIdeographic",
			viewbox: "viewBox",
			viewtarget: "viewTarget",
			visibility: "visibility",
			vmathematical: "vMathematical",
			"v-mathematical": "vMathematical",
			vocab: "vocab",
			widths: "widths",
			wordspacing: "wordSpacing",
			"word-spacing": "wordSpacing",
			writingmode: "writingMode",
			"writing-mode": "writingMode",
			x1: "x1",
			x2: "x2",
			x: "x",
			xchannelselector: "xChannelSelector",
			xheight: "xHeight",
			"x-height": "xHeight",
			xlinkactuate: "xlinkActuate",
			"xlink:actuate": "xlinkActuate",
			xlinkarcrole: "xlinkArcrole",
			"xlink:arcrole": "xlinkArcrole",
			xlinkhref: "xlinkHref",
			"xlink:href": "xlinkHref",
			xlinkrole: "xlinkRole",
			"xlink:role": "xlinkRole",
			xlinkshow: "xlinkShow",
			"xlink:show": "xlinkShow",
			xlinktitle: "xlinkTitle",
			"xlink:title": "xlinkTitle",
			xlinktype: "xlinkType",
			"xlink:type": "xlinkType",
			xmlbase: "xmlBase",
			"xml:base": "xmlBase",
			xmllang: "xmlLang",
			"xml:lang": "xmlLang",
			xmlns: "xmlns",
			"xml:space": "xmlSpace",
			xmlnsxlink: "xmlnsXlink",
			"xmlns:xlink": "xmlnsXlink",
			xmlspace: "xmlSpace",
			y1: "y1",
			y2: "y2",
			y: "y",
			ychannelselector: "yChannelSelector",
			z: "z",
			zoomandpan: "zoomAndPan"
		}, Lm = {
			"aria-current": 0,
			"aria-description": 0,
			"aria-details": 0,
			"aria-disabled": 0,
			"aria-hidden": 0,
			"aria-invalid": 0,
			"aria-keyshortcuts": 0,
			"aria-label": 0,
			"aria-roledescription": 0,
			"aria-autocomplete": 0,
			"aria-checked": 0,
			"aria-expanded": 0,
			"aria-haspopup": 0,
			"aria-level": 0,
			"aria-modal": 0,
			"aria-multiline": 0,
			"aria-multiselectable": 0,
			"aria-orientation": 0,
			"aria-placeholder": 0,
			"aria-pressed": 0,
			"aria-readonly": 0,
			"aria-required": 0,
			"aria-selected": 0,
			"aria-sort": 0,
			"aria-valuemax": 0,
			"aria-valuemin": 0,
			"aria-valuenow": 0,
			"aria-valuetext": 0,
			"aria-atomic": 0,
			"aria-busy": 0,
			"aria-live": 0,
			"aria-relevant": 0,
			"aria-dropeffect": 0,
			"aria-grabbed": 0,
			"aria-activedescendant": 0,
			"aria-colcount": 0,
			"aria-colindex": 0,
			"aria-colspan": 0,
			"aria-controls": 0,
			"aria-describedby": 0,
			"aria-errormessage": 0,
			"aria-flowto": 0,
			"aria-labelledby": 0,
			"aria-owns": 0,
			"aria-posinset": 0,
			"aria-rowcount": 0,
			"aria-rowindex": 0,
			"aria-rowspan": 0,
			"aria-setsize": 0,
			"aria-braillelabel": 0,
			"aria-brailleroledescription": 0,
			"aria-colindextext": 0,
			"aria-rowindextext": 0
		}, Rm = {}, zm = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Bm = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Vm = !1, Hm = {}, Um = /^on./, Wm = /^on[^A-Z]/, Gm = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Km = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), qm = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, Jm = null, Ym = null, Xm = null, Zm = !1, Qm = !(typeof window > "u" || window.document === void 0 || window.document.createElement === void 0), $m = !1;
		if (Qm) try {
			var eh = {};
			Object.defineProperty(eh, "passive", { get: function() {
				$m = !0;
			} }), window.addEventListener("test", eh, eh), window.removeEventListener("test", eh, eh);
		} catch {
			$m = !1;
		}
		var th = null, nh = null, rh = null, ih = {
			eventPhase: 0,
			bubbles: 0,
			cancelable: 0,
			timeStamp: function(e) {
				return e.timeStamp || Date.now();
			},
			defaultPrevented: 0,
			isTrusted: 0
		}, ah = rn(ih), oh = Df({}, ih, {
			view: 0,
			detail: 0
		}), sh = rn(oh), ch, lh, uh, dh = Df({}, oh, {
			screenX: 0,
			screenY: 0,
			clientX: 0,
			clientY: 0,
			pageX: 0,
			pageY: 0,
			ctrlKey: 0,
			shiftKey: 0,
			altKey: 0,
			metaKey: 0,
			getModifierState: on,
			button: 0,
			buttons: 0,
			relatedTarget: function(e) {
				return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
			},
			movementX: function(e) {
				return "movementX" in e ? e.movementX : (e !== uh && (uh && e.type === "mousemove" ? (ch = e.screenX - uh.screenX, lh = e.screenY - uh.screenY) : lh = ch = 0, uh = e), ch);
			},
			movementY: function(e) {
				return "movementY" in e ? e.movementY : lh;
			}
		}), fh = rn(dh), ph = Df({}, dh, { dataTransfer: 0 }), mh = rn(ph), hh = Df({}, oh, { relatedTarget: 0 }), gh = rn(hh), _h = Df({}, ih, {
			animationName: 0,
			elapsedTime: 0,
			pseudoElement: 0
		}), vh = rn(_h), yh = Df({}, ih, { clipboardData: function(e) {
			return "clipboardData" in e ? e.clipboardData : window.clipboardData;
		} }), bh = rn(yh), xh = Df({}, ih, { data: 0 }), Sh = rn(xh), Ch = Sh, wh = {
			Esc: "Escape",
			Spacebar: " ",
			Left: "ArrowLeft",
			Up: "ArrowUp",
			Right: "ArrowRight",
			Down: "ArrowDown",
			Del: "Delete",
			Win: "OS",
			Menu: "ContextMenu",
			Apps: "ContextMenu",
			Scroll: "ScrollLock",
			MozPrintableKey: "Unidentified"
		}, Th = {
			8: "Backspace",
			9: "Tab",
			12: "Clear",
			13: "Enter",
			16: "Shift",
			17: "Control",
			18: "Alt",
			19: "Pause",
			20: "CapsLock",
			27: "Escape",
			32: " ",
			33: "PageUp",
			34: "PageDown",
			35: "End",
			36: "Home",
			37: "ArrowLeft",
			38: "ArrowUp",
			39: "ArrowRight",
			40: "ArrowDown",
			45: "Insert",
			46: "Delete",
			112: "F1",
			113: "F2",
			114: "F3",
			115: "F4",
			116: "F5",
			117: "F6",
			118: "F7",
			119: "F8",
			120: "F9",
			121: "F10",
			122: "F11",
			123: "F12",
			144: "NumLock",
			145: "ScrollLock",
			224: "Meta"
		}, Eh = {
			Alt: "altKey",
			Control: "ctrlKey",
			Meta: "metaKey",
			Shift: "shiftKey"
		}, Dh = Df({}, oh, {
			key: function(e) {
				if (e.key) {
					var t = wh[e.key] || e.key;
					if (t !== "Unidentified") return t;
				}
				return e.type === "keypress" ? (e = en(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Th[e.keyCode] || "Unidentified" : "";
			},
			code: 0,
			location: 0,
			ctrlKey: 0,
			shiftKey: 0,
			altKey: 0,
			metaKey: 0,
			repeat: 0,
			locale: 0,
			getModifierState: on,
			charCode: function(e) {
				return e.type === "keypress" ? en(e) : 0;
			},
			keyCode: function(e) {
				return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
			},
			which: function(e) {
				return e.type === "keypress" ? en(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
			}
		}), Oh = rn(Dh), kh = Df({}, dh, {
			pointerId: 0,
			width: 0,
			height: 0,
			pressure: 0,
			tangentialPressure: 0,
			tiltX: 0,
			tiltY: 0,
			twist: 0,
			pointerType: 0,
			isPrimary: 0
		}), Ah = rn(kh), jh = Df({}, oh, {
			touches: 0,
			targetTouches: 0,
			changedTouches: 0,
			altKey: 0,
			metaKey: 0,
			ctrlKey: 0,
			shiftKey: 0,
			getModifierState: on
		}), Mh = rn(jh), Nh = Df({}, ih, {
			propertyName: 0,
			elapsedTime: 0,
			pseudoElement: 0
		}), Ph = rn(Nh), Fh = Df({}, dh, {
			deltaX: function(e) {
				return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
			},
			deltaY: function(e) {
				return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
			},
			deltaZ: 0,
			deltaMode: 0
		}), Ih = rn(Fh), Lh = Df({}, ih, {
			newState: 0,
			oldState: 0
		}), Rh = rn(Lh), zh = [
			9,
			13,
			27,
			32
		], Bh = 229, Vh = Qm && "CompositionEvent" in window, Hh = null;
		Qm && "documentMode" in document && (Hh = document.documentMode);
		var Uh = Qm && "TextEvent" in window && !Hh, Wh = Qm && (!Vh || Hh && 8 < Hh && 11 >= Hh), Gh = 32, Kh = String.fromCharCode(Gh), qh = !1, Jh = !1, Yh = {
			color: !0,
			date: !0,
			datetime: !0,
			"datetime-local": !0,
			email: !0,
			month: !0,
			number: !0,
			password: !0,
			range: !0,
			search: !0,
			tel: !0,
			text: !0,
			time: !0,
			url: !0,
			week: !0
		}, Xh = null, Zh = null, Qh = !1;
		Qm && (Qh = pn("input") && (!document.documentMode || 9 < document.documentMode));
		var $h = typeof Object.is == "function" ? Object.is : wn, eg = Qm && "documentMode" in document && 11 >= document.documentMode, tg = null, ng = null, rg = null, ig = !1, ag = {
			animationend: Mn("Animation", "AnimationEnd"),
			animationiteration: Mn("Animation", "AnimationIteration"),
			animationstart: Mn("Animation", "AnimationStart"),
			transitionrun: Mn("Transition", "TransitionRun"),
			transitionstart: Mn("Transition", "TransitionStart"),
			transitioncancel: Mn("Transition", "TransitionCancel"),
			transitionend: Mn("Transition", "TransitionEnd")
		}, og = {}, sg = {};
		Qm && (sg = document.createElement("div").style, "AnimationEvent" in window || (delete ag.animationend.animation, delete ag.animationiteration.animation, delete ag.animationstart.animation), "TransitionEvent" in window || delete ag.transitionend.transition);
		var cg = Nn("animationend"), lg = Nn("animationiteration"), ug = Nn("animationstart"), dg = Nn("transitionrun"), fg = Nn("transitionstart"), pg = Nn("transitioncancel"), mg = Nn("transitionend"), hg = /* @__PURE__ */ new Map(), gg = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
		gg.push("scrollEnd");
		var _g = 0;
		if (typeof performance == "object" && typeof performance.now == "function") var vg = performance, yg = function() {
			return vg.now();
		};
		else {
			var bg = Date;
			yg = function() {
				return bg.now();
			};
		}
		var xg = typeof reportError == "function" ? reportError : function(e) {
			if (typeof window == "object" && typeof window.ErrorEvent == "function") {
				var t = new window.ErrorEvent("error", {
					bubbles: !0,
					cancelable: !0,
					message: typeof e == "object" && e && typeof e.message == "string" ? String(e.message) : String(e),
					error: e
				});
				if (!window.dispatchEvent(t)) return;
			} else if (typeof process == "object" && typeof process.emit == "function") {
				process.emit("uncaughtException", e);
				return;
			}
			console.error(e);
		}, Sg = "This object has been omitted by React in the console log to avoid sending too much data from the server. Try logging smaller or more specific objects.", Cg = 0, wg = 1, Tg = 2, Eg = 3, Dg = "\xA0", Og = "+\xA0", kg = "\xA0", Ag = typeof console < "u" && typeof console.timeStamp == "function" && typeof performance < "u" && typeof performance.measure == "function", jg = "Components ", Mg = "Scheduler ", Ng = "Blocking", Pg = !1, Fg = {
			color: "primary",
			properties: null,
			tooltipText: "",
			track: jg
		}, Ig = {
			start: -0,
			end: -0,
			detail: { devtools: Fg }
		}, Lg = ["Changed Props", ""], Rg = "This component received deeply equal props. It might benefit from useMemo or the React Compiler in its owner.", zg = ["Changed Props", Rg], Bg = 1, Vg = 2, Hg = [], Ug = 0, Wg = 0, Gg = {};
		Object.freeze(Gg);
		var Kg = null, qg = null, Jg = 0, Yg = 1, Xg = 2, Zg = 8, Qg = 16, $g = 32, e_ = !1;
		try {
			var t_ = Object.preventExtensions({});
			new Map([[t_, null]]), new Set([t_]);
		} catch {
			e_ = !0;
		}
		var n_ = /* @__PURE__ */ new WeakMap(), r_ = [], i_ = 0, a_ = null, o_ = 0, s_ = [], c_ = 0, l_ = null, u_ = 1, d_ = "", f_ = null, p_ = null, m_ = !1, h_ = !1, g_ = null, __ = null, v_ = !1, y_ = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), b_ = N(null), x_ = N(null), S_ = {}, C_ = null, w_ = null, T_ = !1, E_ = typeof AbortController < "u" ? AbortController : function() {
			var e = [], t = this.signal = {
				aborted: !1,
				addEventListener: function(t, n) {
					e.push(n);
				}
			};
			this.abort = function() {
				t.aborted = !0, e.forEach(function(e) {
					return e();
				});
			};
		}, D_ = wf.unstable_scheduleCallback, O_ = wf.unstable_NormalPriority, k_ = {
			$$typeof: Ff,
			Consumer: null,
			Provider: null,
			_currentValue: null,
			_currentValue2: null,
			_threadCount: 0,
			_currentRenderer: null,
			_currentRenderer2: null
		}, A_ = wf.unstable_now, j_ = console.createTask ? console.createTask : function() {
			return null;
		}, M_ = 1, N_ = 2, P_ = -0, F_ = -0, I_ = -0, L_ = null, R_ = -1.1, z_ = -0, B_ = -0, V_ = -1.1, H_ = -1.1, U_ = null, W_ = !1, G_ = -0, K_ = -1.1, q_ = null, J_ = 0, Y_ = null, X_ = null, Z_ = -1.1, Q_ = null, $_ = -1.1, ev = -1.1, tv = -0, nv = -1.1, rv = -1.1, iv = 0, av = null, ov = null, sv = null, cv = -1.1, lv = null, uv = -1.1, dv = -1.1, fv = -0, pv = -0, mv = 0, hv = null, gv = 0, _v = -1.1, vv = !1, yv = !1, bv = null, xv = 0, Sv = 0, Cv = null, wv = Q.S;
		Q.S = function(e, t) {
			if (zx = bp(), typeof t == "object" && t && typeof t.then == "function") {
				if (0 > nv && 0 > rv) {
					nv = A_();
					var n = Vu(), i = Bu();
					(n !== uv || i !== lv) && (uv = -1.1), cv = n, lv = i;
				}
				vi(e, t);
			}
			wv !== null && wv(e, t);
		};
		var Tv = N(null), Ev = {
			recordUnsafeLifecycleWarnings: function() {},
			flushPendingUnsafeLifecycleWarnings: function() {},
			recordLegacyContextWarning: function() {},
			flushLegacyContextWarning: function() {},
			discardPendingWarnings: function() {}
		}, Dv = [], Ov = [], kv = [], Av = [], jv = [], Mv = [], Nv = /* @__PURE__ */ new Set();
		Ev.recordUnsafeLifecycleWarnings = function(e, t) {
			Nv.has(e.type) || (typeof t.componentWillMount == "function" && !0 !== t.componentWillMount.__suppressDeprecationWarning && Dv.push(e), e.mode & Zg && typeof t.UNSAFE_componentWillMount == "function" && Ov.push(e), typeof t.componentWillReceiveProps == "function" && !0 !== t.componentWillReceiveProps.__suppressDeprecationWarning && kv.push(e), e.mode & Zg && typeof t.UNSAFE_componentWillReceiveProps == "function" && Av.push(e), typeof t.componentWillUpdate == "function" && !0 !== t.componentWillUpdate.__suppressDeprecationWarning && jv.push(e), e.mode & Zg && typeof t.UNSAFE_componentWillUpdate == "function" && Mv.push(e));
		}, Ev.flushPendingUnsafeLifecycleWarnings = function() {
			var e = /* @__PURE__ */ new Set();
			0 < Dv.length && (Dv.forEach(function(t) {
				e.add(M(t) || "Component"), Nv.add(t.type);
			}), Dv = []);
			var t = /* @__PURE__ */ new Set();
			0 < Ov.length && (Ov.forEach(function(e) {
				t.add(M(e) || "Component"), Nv.add(e.type);
			}), Ov = []);
			var n = /* @__PURE__ */ new Set();
			0 < kv.length && (kv.forEach(function(e) {
				n.add(M(e) || "Component"), Nv.add(e.type);
			}), kv = []);
			var i = /* @__PURE__ */ new Set();
			0 < Av.length && (Av.forEach(function(e) {
				i.add(M(e) || "Component"), Nv.add(e.type);
			}), Av = []);
			var a = /* @__PURE__ */ new Set();
			0 < jv.length && (jv.forEach(function(e) {
				a.add(M(e) || "Component"), Nv.add(e.type);
			}), jv = []);
			var o = /* @__PURE__ */ new Set();
			if (0 < Mv.length && (Mv.forEach(function(e) {
				o.add(M(e) || "Component"), Nv.add(e.type);
			}), Mv = []), 0 < t.size) {
				var s = m(t);
				console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", s);
			}
			0 < i.size && (s = m(i), console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s", s)), 0 < o.size && (s = m(o), console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", s)), 0 < e.size && (s = m(e), console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", s)), 0 < n.size && (s = m(n), console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", s)), 0 < a.size && (s = m(a), console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", s));
		};
		var Pv = /* @__PURE__ */ new Map(), Fv = /* @__PURE__ */ new Set();
		Ev.recordLegacyContextWarning = function(e, t) {
			for (var n = null, i = e; i !== null;) i.mode & Zg && (n = i), i = i.return;
			n === null ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !Fv.has(e.type) && (i = Pv.get(n), e.type.contextTypes != null || e.type.childContextTypes != null || t !== null && typeof t.getChildContext == "function") && (i === void 0 && (i = [], Pv.set(n, i)), i.push(e));
		}, Ev.flushLegacyContextWarning = function() {
			Pv.forEach(function(e) {
				if (e.length !== 0) {
					var t = e[0], n = /* @__PURE__ */ new Set();
					e.forEach(function(e) {
						n.add(M(e) || "Component"), Fv.add(e.type);
					});
					var i = m(n);
					V(t, function() {
						console.error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context", i);
					});
				}
			});
		}, Ev.discardPendingWarnings = function() {
			Dv = [], Ov = [], kv = [], Av = [], jv = [], Mv = [], Pv = /* @__PURE__ */ new Map();
		};
		var Iv = { react_stack_bottom_frame: function(e, t, n) {
			var i = mp;
			mp = !0;
			try {
				return e(t, n);
			} finally {
				mp = i;
			}
		} }, Lv = Iv.react_stack_bottom_frame.bind(Iv), Rv = { react_stack_bottom_frame: function(e) {
			var t = mp;
			mp = !0;
			try {
				return e.render();
			} finally {
				mp = t;
			}
		} }, zv = Rv.react_stack_bottom_frame.bind(Rv), Bv = { react_stack_bottom_frame: function(e, t) {
			try {
				t.componentDidMount();
			} catch (t) {
				kl(e, e.return, t);
			}
		} }, Vv = Bv.react_stack_bottom_frame.bind(Bv), Hv = { react_stack_bottom_frame: function(e, t, n, i, a) {
			try {
				t.componentDidUpdate(n, i, a);
			} catch (t) {
				kl(e, e.return, t);
			}
		} }, Uv = Hv.react_stack_bottom_frame.bind(Hv), Wv = { react_stack_bottom_frame: function(e, t) {
			var n = t.stack;
			e.componentDidCatch(t.value, { componentStack: n === null ? "" : n });
		} }, Gv = Wv.react_stack_bottom_frame.bind(Wv), Kv = { react_stack_bottom_frame: function(e, t, n) {
			try {
				n.componentWillUnmount();
			} catch (n) {
				kl(e, t, n);
			}
		} }, qv = Kv.react_stack_bottom_frame.bind(Kv), Jv = { react_stack_bottom_frame: function(e) {
			var t = e.create;
			return e = e.inst, t = t(), e.destroy = t;
		} }, Yv = Jv.react_stack_bottom_frame.bind(Jv), Xv = { react_stack_bottom_frame: function(e, t, n) {
			try {
				n();
			} catch (n) {
				kl(e, t, n);
			}
		} }, Zv = Xv.react_stack_bottom_frame.bind(Xv), Qv = { react_stack_bottom_frame: function(e) {
			var t = e._init;
			return t(e._payload);
		} }, $v = Qv.react_stack_bottom_frame.bind(Qv), ey = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), ty = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."), ny = Error("Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."), ry = { then: function() {
			console.error("Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.");
		} }, iy = null, ay = !1, oy = null, sy = 0, cy = null, ly, uy = ly = !1, dy = {}, fy = {}, py = {};
		p = function(e, t, n) {
			if (typeof n == "object" && n && n._store && (!n._store.validated && n.key == null || n._store.validated === 2)) {
				if (typeof n._store != "object") throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
				n._store.validated = 1;
				var i = M(e), a = i || "null";
				if (!dy[a]) {
					dy[a] = !0, n = n._owner, e = e._debugOwner;
					var o = "";
					e && typeof e.tag == "number" && (a = M(e)) && (o = "\n\nCheck the render method of `" + a + "`."), o || i && (o = "\n\nCheck the top-level render call using <" + i + ">.");
					var s = "";
					n != null && e !== n && (i = null, typeof n.tag == "number" ? i = M(n) : typeof n.name == "string" && (i = n.name), i && (s = " It was passed a child from " + i + ".")), V(t, function() {
						console.error("Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.", o, s);
					});
				}
			}
		};
		var my = Vi(!0), hy = Vi(!1), gy = 0, _y = 1, vy = 2, yy = 3, by = !1, xy = !1, Sy = null, Cy = !1, wy = N(null), Ty = N(0), Ey = N(null), Dy = null, Oy = 1, ky = 2, Ay = N(0), jy = 0, My = 1, Ny = 2, Py = 4, Fy = 8, Iy, Ly = /* @__PURE__ */ new Set(), Ry = /* @__PURE__ */ new Set(), zy = /* @__PURE__ */ new Set(), By = /* @__PURE__ */ new Set(), Vy = 0, Hy = null, Uy = null, Wy = null, Gy = !1, Ky = !1, qy = !1, Jy = 0, Yy = 0, Xy = null, Zy = 0, Qy = 25, $ = null, $y = null, eb = -1, tb = !1, nb = {
			readContext: qr,
			use: wa,
			useCallback: fa,
			useContext: fa,
			useEffect: fa,
			useImperativeHandle: fa,
			useLayoutEffect: fa,
			useInsertionEffect: fa,
			useMemo: fa,
			useReducer: fa,
			useRef: fa,
			useState: fa,
			useDebugValue: fa,
			useDeferredValue: fa,
			useTransition: fa,
			useSyncExternalStore: fa,
			useId: fa,
			useHostTransitionStatus: fa,
			useFormState: fa,
			useActionState: fa,
			useOptimistic: fa,
			useMemoCache: fa,
			useCacheRefresh: fa
		};
		nb.useEffectEvent = fa;
		var rb = null, ib = null, ab = null, ob = null, sb = null, cb = null, lb = null;
		rb = {
			readContext: function(e) {
				return qr(e);
			},
			use: wa,
			useCallback: function(e, t) {
				return $ = "useCallback", la(), ua(t), po(e, t);
			},
			useContext: function(e) {
				return $ = "useContext", la(), qr(e);
			},
			useEffect: function(e, t) {
				return $ = "useEffect", la(), ua(t), io(e, t);
			},
			useImperativeHandle: function(e, t, n) {
				return $ = "useImperativeHandle", la(), ua(n), uo(e, t, n);
			},
			useInsertionEffect: function(e, t) {
				$ = "useInsertionEffect", la(), ua(t), no(4, Ny, e, t);
			},
			useLayoutEffect: function(e, t) {
				return $ = "useLayoutEffect", la(), ua(t), co(e, t);
			},
			useMemo: function(e, t) {
				$ = "useMemo", la(), ua(t);
				var n = Q.H;
				Q.H = sb;
				try {
					return ho(e, t);
				} finally {
					Q.H = n;
				}
			},
			useReducer: function(e, t, n) {
				$ = "useReducer", la();
				var i = Q.H;
				Q.H = sb;
				try {
					return Da(e, t, n);
				} finally {
					Q.H = i;
				}
			},
			useRef: function(e) {
				return $ = "useRef", la(), to(e);
			},
			useState: function(e) {
				$ = "useState", la();
				var t = Q.H;
				Q.H = sb;
				try {
					return za(e);
				} finally {
					Q.H = t;
				}
			},
			useDebugValue: function() {
				$ = "useDebugValue", la();
			},
			useDeferredValue: function(e, t) {
				return $ = "useDeferredValue", la(), _o(e, t);
			},
			useTransition: function() {
				return $ = "useTransition", la(), Do();
			},
			useSyncExternalStore: function(e, t, n) {
				return $ = "useSyncExternalStore", la(), ja(e, t, n);
			},
			useId: function() {
				return $ = "useId", la(), jo();
			},
			useFormState: function(e, t) {
				return $ = "useFormState", la(), da(), Ya(e, t);
			},
			useActionState: function(e, t) {
				return $ = "useActionState", la(), Ya(e, t);
			},
			useOptimistic: function(e) {
				return $ = "useOptimistic", la(), Ba(e);
			},
			useHostTransitionStatus: Ao,
			useMemoCache: Ta,
			useCacheRefresh: function() {
				return $ = "useCacheRefresh", la(), Mo();
			},
			useEffectEvent: function(e) {
				return $ = "useEffectEvent", la(), oo(e);
			}
		}, ib = {
			readContext: function(e) {
				return qr(e);
			},
			use: wa,
			useCallback: function(e, t) {
				return $ = "useCallback", q(), po(e, t);
			},
			useContext: function(e) {
				return $ = "useContext", q(), qr(e);
			},
			useEffect: function(e, t) {
				return $ = "useEffect", q(), io(e, t);
			},
			useImperativeHandle: function(e, t, n) {
				return $ = "useImperativeHandle", q(), uo(e, t, n);
			},
			useInsertionEffect: function(e, t) {
				$ = "useInsertionEffect", q(), no(4, Ny, e, t);
			},
			useLayoutEffect: function(e, t) {
				return $ = "useLayoutEffect", q(), co(e, t);
			},
			useMemo: function(e, t) {
				$ = "useMemo", q();
				var n = Q.H;
				Q.H = sb;
				try {
					return ho(e, t);
				} finally {
					Q.H = n;
				}
			},
			useReducer: function(e, t, n) {
				$ = "useReducer", q();
				var i = Q.H;
				Q.H = sb;
				try {
					return Da(e, t, n);
				} finally {
					Q.H = i;
				}
			},
			useRef: function(e) {
				return $ = "useRef", q(), to(e);
			},
			useState: function(e) {
				$ = "useState", q();
				var t = Q.H;
				Q.H = sb;
				try {
					return za(e);
				} finally {
					Q.H = t;
				}
			},
			useDebugValue: function() {
				$ = "useDebugValue", q();
			},
			useDeferredValue: function(e, t) {
				return $ = "useDeferredValue", q(), _o(e, t);
			},
			useTransition: function() {
				return $ = "useTransition", q(), Do();
			},
			useSyncExternalStore: function(e, t, n) {
				return $ = "useSyncExternalStore", q(), ja(e, t, n);
			},
			useId: function() {
				return $ = "useId", q(), jo();
			},
			useActionState: function(e, t) {
				return $ = "useActionState", q(), Ya(e, t);
			},
			useFormState: function(e, t) {
				return $ = "useFormState", q(), da(), Ya(e, t);
			},
			useOptimistic: function(e) {
				return $ = "useOptimistic", q(), Ba(e);
			},
			useHostTransitionStatus: Ao,
			useMemoCache: Ta,
			useCacheRefresh: function() {
				return $ = "useCacheRefresh", q(), Mo();
			},
			useEffectEvent: function(e) {
				return $ = "useEffectEvent", q(), oo(e);
			}
		}, ab = {
			readContext: function(e) {
				return qr(e);
			},
			use: wa,
			useCallback: function(e, t) {
				return $ = "useCallback", q(), mo(e, t);
			},
			useContext: function(e) {
				return $ = "useContext", q(), qr(e);
			},
			useEffect: function(e, t) {
				$ = "useEffect", q(), ro(2048, Fy, e, t);
			},
			useImperativeHandle: function(e, t, n) {
				return $ = "useImperativeHandle", q(), fo(e, t, n);
			},
			useInsertionEffect: function(e, t) {
				return $ = "useInsertionEffect", q(), ro(4, Ny, e, t);
			},
			useLayoutEffect: function(e, t) {
				return $ = "useLayoutEffect", q(), ro(4, Py, e, t);
			},
			useMemo: function(e, t) {
				$ = "useMemo", q();
				var n = Q.H;
				Q.H = cb;
				try {
					return go(e, t);
				} finally {
					Q.H = n;
				}
			},
			useReducer: function(e, t, n) {
				$ = "useReducer", q();
				var i = Q.H;
				Q.H = cb;
				try {
					return Oa(e, t, n);
				} finally {
					Q.H = i;
				}
			},
			useRef: function() {
				return $ = "useRef", q(), xa().memoizedState;
			},
			useState: function() {
				$ = "useState", q();
				var e = Q.H;
				Q.H = cb;
				try {
					return Oa(Ea);
				} finally {
					Q.H = e;
				}
			},
			useDebugValue: function() {
				$ = "useDebugValue", q();
			},
			useDeferredValue: function(e, t) {
				return $ = "useDeferredValue", q(), vo(e, t);
			},
			useTransition: function() {
				return $ = "useTransition", q(), Oo();
			},
			useSyncExternalStore: function(e, t, n) {
				return $ = "useSyncExternalStore", q(), Ma(e, t, n);
			},
			useId: function() {
				return $ = "useId", q(), xa().memoizedState;
			},
			useFormState: function(e) {
				return $ = "useFormState", q(), da(), Xa(e);
			},
			useActionState: function(e) {
				return $ = "useActionState", q(), Xa(e);
			},
			useOptimistic: function(e, t) {
				return $ = "useOptimistic", q(), Va(e, t);
			},
			useHostTransitionStatus: Ao,
			useMemoCache: Ta,
			useCacheRefresh: function() {
				return $ = "useCacheRefresh", q(), xa().memoizedState;
			},
			useEffectEvent: function(e) {
				return $ = "useEffectEvent", q(), so(e);
			}
		}, ob = {
			readContext: function(e) {
				return qr(e);
			},
			use: wa,
			useCallback: function(e, t) {
				return $ = "useCallback", q(), mo(e, t);
			},
			useContext: function(e) {
				return $ = "useContext", q(), qr(e);
			},
			useEffect: function(e, t) {
				$ = "useEffect", q(), ro(2048, Fy, e, t);
			},
			useImperativeHandle: function(e, t, n) {
				return $ = "useImperativeHandle", q(), fo(e, t, n);
			},
			useInsertionEffect: function(e, t) {
				return $ = "useInsertionEffect", q(), ro(4, Ny, e, t);
			},
			useLayoutEffect: function(e, t) {
				return $ = "useLayoutEffect", q(), ro(4, Py, e, t);
			},
			useMemo: function(e, t) {
				$ = "useMemo", q();
				var n = Q.H;
				Q.H = lb;
				try {
					return go(e, t);
				} finally {
					Q.H = n;
				}
			},
			useReducer: function(e, t, n) {
				$ = "useReducer", q();
				var i = Q.H;
				Q.H = lb;
				try {
					return Aa(e, t, n);
				} finally {
					Q.H = i;
				}
			},
			useRef: function() {
				return $ = "useRef", q(), xa().memoizedState;
			},
			useState: function() {
				$ = "useState", q();
				var e = Q.H;
				Q.H = lb;
				try {
					return Aa(Ea);
				} finally {
					Q.H = e;
				}
			},
			useDebugValue: function() {
				$ = "useDebugValue", q();
			},
			useDeferredValue: function(e, t) {
				return $ = "useDeferredValue", q(), yo(e, t);
			},
			useTransition: function() {
				return $ = "useTransition", q(), ko();
			},
			useSyncExternalStore: function(e, t, n) {
				return $ = "useSyncExternalStore", q(), Ma(e, t, n);
			},
			useId: function() {
				return $ = "useId", q(), xa().memoizedState;
			},
			useFormState: function(e) {
				return $ = "useFormState", q(), da(), $a(e);
			},
			useActionState: function(e) {
				return $ = "useActionState", q(), $a(e);
			},
			useOptimistic: function(e, t) {
				return $ = "useOptimistic", q(), Ua(e, t);
			},
			useHostTransitionStatus: Ao,
			useMemoCache: Ta,
			useCacheRefresh: function() {
				return $ = "useCacheRefresh", q(), xa().memoizedState;
			},
			useEffectEvent: function(e) {
				return $ = "useEffectEvent", q(), so(e);
			}
		}, sb = {
			readContext: function(e) {
				return u(), qr(e);
			},
			use: function(e) {
				return l(), wa(e);
			},
			useCallback: function(e, t) {
				return $ = "useCallback", l(), la(), po(e, t);
			},
			useContext: function(e) {
				return $ = "useContext", l(), la(), qr(e);
			},
			useEffect: function(e, t) {
				return $ = "useEffect", l(), la(), io(e, t);
			},
			useImperativeHandle: function(e, t, n) {
				return $ = "useImperativeHandle", l(), la(), uo(e, t, n);
			},
			useInsertionEffect: function(e, t) {
				$ = "useInsertionEffect", l(), la(), no(4, Ny, e, t);
			},
			useLayoutEffect: function(e, t) {
				return $ = "useLayoutEffect", l(), la(), co(e, t);
			},
			useMemo: function(e, t) {
				$ = "useMemo", l(), la();
				var n = Q.H;
				Q.H = sb;
				try {
					return ho(e, t);
				} finally {
					Q.H = n;
				}
			},
			useReducer: function(e, t, n) {
				$ = "useReducer", l(), la();
				var i = Q.H;
				Q.H = sb;
				try {
					return Da(e, t, n);
				} finally {
					Q.H = i;
				}
			},
			useRef: function(e) {
				return $ = "useRef", l(), la(), to(e);
			},
			useState: function(e) {
				$ = "useState", l(), la();
				var t = Q.H;
				Q.H = sb;
				try {
					return za(e);
				} finally {
					Q.H = t;
				}
			},
			useDebugValue: function() {
				$ = "useDebugValue", l(), la();
			},
			useDeferredValue: function(e, t) {
				return $ = "useDeferredValue", l(), la(), _o(e, t);
			},
			useTransition: function() {
				return $ = "useTransition", l(), la(), Do();
			},
			useSyncExternalStore: function(e, t, n) {
				return $ = "useSyncExternalStore", l(), la(), ja(e, t, n);
			},
			useId: function() {
				return $ = "useId", l(), la(), jo();
			},
			useFormState: function(e, t) {
				return $ = "useFormState", l(), la(), Ya(e, t);
			},
			useActionState: function(e, t) {
				return $ = "useActionState", l(), la(), Ya(e, t);
			},
			useOptimistic: function(e) {
				return $ = "useOptimistic", l(), la(), Ba(e);
			},
			useMemoCache: function(e) {
				return l(), Ta(e);
			},
			useHostTransitionStatus: Ao,
			useCacheRefresh: function() {
				return $ = "useCacheRefresh", la(), Mo();
			},
			useEffectEvent: function(e) {
				return $ = "useEffectEvent", l(), la(), oo(e);
			}
		}, cb = {
			readContext: function(e) {
				return u(), qr(e);
			},
			use: function(e) {
				return l(), wa(e);
			},
			useCallback: function(e, t) {
				return $ = "useCallback", l(), q(), mo(e, t);
			},
			useContext: function(e) {
				return $ = "useContext", l(), q(), qr(e);
			},
			useEffect: function(e, t) {
				$ = "useEffect", l(), q(), ro(2048, Fy, e, t);
			},
			useImperativeHandle: function(e, t, n) {
				return $ = "useImperativeHandle", l(), q(), fo(e, t, n);
			},
			useInsertionEffect: function(e, t) {
				return $ = "useInsertionEffect", l(), q(), ro(4, Ny, e, t);
			},
			useLayoutEffect: function(e, t) {
				return $ = "useLayoutEffect", l(), q(), ro(4, Py, e, t);
			},
			useMemo: function(e, t) {
				$ = "useMemo", l(), q();
				var n = Q.H;
				Q.H = cb;
				try {
					return go(e, t);
				} finally {
					Q.H = n;
				}
			},
			useReducer: function(e, t, n) {
				$ = "useReducer", l(), q();
				var i = Q.H;
				Q.H = cb;
				try {
					return Oa(e, t, n);
				} finally {
					Q.H = i;
				}
			},
			useRef: function() {
				return $ = "useRef", l(), q(), xa().memoizedState;
			},
			useState: function() {
				$ = "useState", l(), q();
				var e = Q.H;
				Q.H = cb;
				try {
					return Oa(Ea);
				} finally {
					Q.H = e;
				}
			},
			useDebugValue: function() {
				$ = "useDebugValue", l(), q();
			},
			useDeferredValue: function(e, t) {
				return $ = "useDeferredValue", l(), q(), vo(e, t);
			},
			useTransition: function() {
				return $ = "useTransition", l(), q(), Oo();
			},
			useSyncExternalStore: function(e, t, n) {
				return $ = "useSyncExternalStore", l(), q(), Ma(e, t, n);
			},
			useId: function() {
				return $ = "useId", l(), q(), xa().memoizedState;
			},
			useFormState: function(e) {
				return $ = "useFormState", l(), q(), Xa(e);
			},
			useActionState: function(e) {
				return $ = "useActionState", l(), q(), Xa(e);
			},
			useOptimistic: function(e, t) {
				return $ = "useOptimistic", l(), q(), Va(e, t);
			},
			useMemoCache: function(e) {
				return l(), Ta(e);
			},
			useHostTransitionStatus: Ao,
			useCacheRefresh: function() {
				return $ = "useCacheRefresh", q(), xa().memoizedState;
			},
			useEffectEvent: function(e) {
				return $ = "useEffectEvent", l(), q(), so(e);
			}
		}, lb = {
			readContext: function(e) {
				return u(), qr(e);
			},
			use: function(e) {
				return l(), wa(e);
			},
			useCallback: function(e, t) {
				return $ = "useCallback", l(), q(), mo(e, t);
			},
			useContext: function(e) {
				return $ = "useContext", l(), q(), qr(e);
			},
			useEffect: function(e, t) {
				$ = "useEffect", l(), q(), ro(2048, Fy, e, t);
			},
			useImperativeHandle: function(e, t, n) {
				return $ = "useImperativeHandle", l(), q(), fo(e, t, n);
			},
			useInsertionEffect: function(e, t) {
				return $ = "useInsertionEffect", l(), q(), ro(4, Ny, e, t);
			},
			useLayoutEffect: function(e, t) {
				return $ = "useLayoutEffect", l(), q(), ro(4, Py, e, t);
			},
			useMemo: function(e, t) {
				$ = "useMemo", l(), q();
				var n = Q.H;
				Q.H = cb;
				try {
					return go(e, t);
				} finally {
					Q.H = n;
				}
			},
			useReducer: function(e, t, n) {
				$ = "useReducer", l(), q();
				var i = Q.H;
				Q.H = cb;
				try {
					return Aa(e, t, n);
				} finally {
					Q.H = i;
				}
			},
			useRef: function() {
				return $ = "useRef", l(), q(), xa().memoizedState;
			},
			useState: function() {
				$ = "useState", l(), q();
				var e = Q.H;
				Q.H = cb;
				try {
					return Aa(Ea);
				} finally {
					Q.H = e;
				}
			},
			useDebugValue: function() {
				$ = "useDebugValue", l(), q();
			},
			useDeferredValue: function(e, t) {
				return $ = "useDeferredValue", l(), q(), yo(e, t);
			},
			useTransition: function() {
				return $ = "useTransition", l(), q(), ko();
			},
			useSyncExternalStore: function(e, t, n) {
				return $ = "useSyncExternalStore", l(), q(), Ma(e, t, n);
			},
			useId: function() {
				return $ = "useId", l(), q(), xa().memoizedState;
			},
			useFormState: function(e) {
				return $ = "useFormState", l(), q(), $a(e);
			},
			useActionState: function(e) {
				return $ = "useActionState", l(), q(), $a(e);
			},
			useOptimistic: function(e, t) {
				return $ = "useOptimistic", l(), q(), Ua(e, t);
			},
			useMemoCache: function(e) {
				return l(), Ta(e);
			},
			useHostTransitionStatus: Ao,
			useCacheRefresh: function() {
				return $ = "useCacheRefresh", q(), xa().memoizedState;
			},
			useEffectEvent: function(e) {
				return $ = "useEffectEvent", l(), q(), so(e);
			}
		};
		var ub = {}, db = /* @__PURE__ */ new Set(), fb = /* @__PURE__ */ new Set(), pb = /* @__PURE__ */ new Set(), mb = /* @__PURE__ */ new Set(), hb = /* @__PURE__ */ new Set(), gb = /* @__PURE__ */ new Set(), _b = /* @__PURE__ */ new Set(), vb = /* @__PURE__ */ new Set(), yb = /* @__PURE__ */ new Set(), bb = /* @__PURE__ */ new Set();
		Object.freeze(ub);
		var xb = {
			enqueueSetState: function(e, t, n) {
				e = e._reactInternals;
				var i = qc(e), a = Gi(i);
				a.payload = t, n != null && (Vo(n), a.callback = n), t = Ki(e, a, i), t !== null && ($r(i, "this.setState()", e), Yc(t, e, i), qi(t, e, i));
			},
			enqueueReplaceState: function(e, t, n) {
				e = e._reactInternals;
				var i = qc(e), a = Gi(i);
				a.tag = _y, a.payload = t, n != null && (Vo(n), a.callback = n), t = Ki(e, a, i), t !== null && ($r(i, "this.replaceState()", e), Yc(t, e, i), qi(t, e, i));
			},
			enqueueForceUpdate: function(e, t) {
				e = e._reactInternals;
				var n = qc(e), i = Gi(n);
				i.tag = vy, t != null && (Vo(t), i.callback = t), t = Ki(e, i, n), t !== null && ($r(n, "this.forceUpdate()", e), Yc(t, e, n), qi(t, e, n));
			}
		}, Sb = null, Cb = null, wb = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."), Tb = !1, Eb = {}, Db = {}, Ob = {}, kb = {}, Ab = !1, jb = {}, Mb = {}, Nb = {
			dehydrated: null,
			treeContext: null,
			retryLane: 0,
			hydrationErrors: null
		}, Pb = !1, Fb = null;
		Fb = /* @__PURE__ */ new Set();
		var Ib = !1, Lb = !1, Rb = !1, zb = typeof WeakSet == "function" ? WeakSet : Set, Bb = null, Vb = null, Hb = null, Ub = null, Wb = !1, Gb = null, Kb = !1, qb = 8192, Jb = {
			getCacheForType: function(e) {
				var t = qr(k_), n = t.data.get(e);
				return n === void 0 && (n = e(), t.data.set(e, n)), n;
			},
			cacheSignal: function() {
				return qr(k_).controller.signal;
			},
			getOwner: function() {
				return pp;
			}
		};
		if (typeof Symbol == "function" && Symbol.for) {
			var Yb = Symbol.for;
			Yb("selector.component"), Yb("selector.has_pseudo_class"), Yb("selector.role"), Yb("selector.test_id"), Yb("selector.text");
		}
		var Xb = [], Zb = typeof WeakMap == "function" ? WeakMap : Map, Qb = 0, $b = 2, ex = 4, tx = 0, nx = 1, rx = 2, ix = 3, ax = 4, ox = 6, sx = 5, lx = Qb, ux = null, dx = null, fx = 0, px = 0, mx = 1, hx = 2, gx = 3, _x = 4, vx = 5, yx = 6, bx = 7, xx = 8, Sx = 9, Cx = px, wx = null, Tx = !1, Ex = !1, Dx = !1, Ox = 0, kx = tx, Ax = 0, jx = 0, Mx = 0, Nx = 0, Px = 0, Fx = null, Ix = null, Lx = !1, Rx = 0, zx = 0, Bx = 300, Vx = Infinity, Hx = 500, Ux = null, Wx = null, Gx = null, Kx = 0, qx = 1, Jx = 2, Yx = 3, Xx = 0, Zx = 1, Qx = 2, $x = 3, eS = 4, tS = 5, nS = 0, rS = null, iS = null, aS = 0, oS = 0, sS = -0, cS = null, lS = null, uS = null, dS = Kx, fS = null, pS = 50, mS = 0, hS = null, gS = !1, _S = !1, vS = 50, yS = 0, bS = null, xS = !1, SS = null, CS = !1, wS = /* @__PURE__ */ new Set(), TS = {}, ES = null, DS = null, OS = !1, kS = !1, AS = !1, jS = !1, MS = 0, NS = {};
		(function() {
			for (var e = 0; e < gg.length; e++) {
				var t = gg[e], n = t.toLowerCase();
				t = t[0].toUpperCase() + t.slice(1), Pn(n, "on" + t);
			}
			Pn(cg, "onAnimationEnd"), Pn(lg, "onAnimationIteration"), Pn(ug, "onAnimationStart"), Pn("dblclick", "onDoubleClick"), Pn("focusin", "onFocus"), Pn("focusout", "onBlur"), Pn(dg, "onTransitionRun"), Pn(fg, "onTransitionStart"), Pn(pg, "onTransitionCancel"), Pn(mg, "onTransitionEnd");
		})(), Ge("onMouseEnter", ["mouseout", "mouseover"]), Ge("onMouseLeave", ["mouseout", "mouseover"]), Ge("onPointerEnter", ["pointerout", "pointerover"]), Ge("onPointerLeave", ["pointerout", "pointerover"]), W("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), W("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), W("onBeforeInput", [
			"compositionend",
			"keypress",
			"textInput",
			"paste"
		]), W("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), W("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), W("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
		var PS = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), FS = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(PS)), IS = "_reactListening" + Math.random().toString(36).slice(2), LS = !1, RS = !1, zS = !1, BS = !1, VS = !1, HS = !1, US = !1, WS = {}, GS = /\r\n?/g, KS = /\u0000|\uFFFD/g, qS = "http://www.w3.org/1999/xlink", JS = "http://www.w3.org/XML/1998/namespace", YS = "javascript:throw new Error('React form unexpectedly submitted.')", XS = "suppressHydrationWarning", ZS = "&", QS = "/&", $S = "$", eC = "/$", tC = "$?", nC = "$~", rC = "$!", iC = "html", aC = "body", oC = "head", sC = "F!", cC = "F", lC = "loading", uC = "style", dC = 0, fC = 1, pC = 2, mC = null, hC = null, gC = {
			dialog: !0,
			webview: !0
		}, _C = null, vC = void 0, yC = typeof setTimeout == "function" ? setTimeout : void 0, bC = typeof clearTimeout == "function" ? clearTimeout : void 0, xC = -1, SC = typeof Promise == "function" ? Promise : void 0, CC = typeof queueMicrotask == "function" ? queueMicrotask : SC === void 0 ? yC : function(e) {
			return SC.resolve(null).then(e).catch(Hu);
		}, wC = null, TC = 0, EC = 1, DC = 2, OC = 3, kC = 4, AC = /* @__PURE__ */ new Map(), jC = /* @__PURE__ */ new Set(), MC = Kf.d;
		Kf.d = {
			f: function() {
				var e = MC.f(), t = el();
				return e || t;
			},
			r: function(e) {
				var t = Ve(e);
				t !== null && t.tag === 5 && t.type === "form" ? Eo(t) : MC.r(e);
			},
			D: function(e) {
				MC.D(e), Td("dns-prefetch", e, null);
			},
			C: function(e, t) {
				MC.C(e, t), Td("preconnect", e, t);
			},
			L: function(e, t, n) {
				MC.L(e, t, n);
				var i = NC;
				if (i && e && t) {
					var a = "link[rel=\"preload\"][as=\"" + rt(t) + "\"]";
					t === "image" && n && n.imageSrcSet ? (a += "[imagesrcset=\"" + rt(n.imageSrcSet) + "\"]", typeof n.imageSizes == "string" && (a += "[imagesizes=\"" + rt(n.imageSizes) + "\"]")) : a += "[href=\"" + rt(e) + "\"]";
					var o = a;
					switch (t) {
						case "style":
							o = Od(e);
							break;
						case "script": o = Md(e);
					}
					AC.has(o) || (e = Df({
						rel: "preload",
						href: t === "image" && n && n.imageSrcSet ? void 0 : e,
						as: t
					}, n), AC.set(o, e), i.querySelector(a) !== null || t === "style" && i.querySelector(kd(o)) || t === "script" && i.querySelector(Nd(o)) || (t = i.createElement("link"), xu(t, "link", e), We(t), i.head.appendChild(t)));
				}
			},
			m: function(e, t) {
				MC.m(e, t);
				var n = NC;
				if (n && e) {
					var i = t && typeof t.as == "string" ? t.as : "script", a = "link[rel=\"modulepreload\"][as=\"" + rt(i) + "\"][href=\"" + rt(e) + "\"]", o = a;
					switch (i) {
						case "audioworklet":
						case "paintworklet":
						case "serviceworker":
						case "sharedworker":
						case "worker":
						case "script": o = Md(e);
					}
					if (!AC.has(o) && (e = Df({
						rel: "modulepreload",
						href: e
					}, t), AC.set(o, e), n.querySelector(a) === null)) {
						switch (i) {
							case "audioworklet":
							case "paintworklet":
							case "serviceworker":
							case "sharedworker":
							case "worker":
							case "script": if (n.querySelector(Nd(o))) return;
						}
						i = n.createElement("link"), xu(i, "link", e), We(i), n.head.appendChild(i);
					}
				}
			},
			X: function(e, t) {
				MC.X(e, t);
				var n = NC;
				if (n && e) {
					var i = Ue(n).hoistableScripts, a = Md(e), o = i.get(a);
					o || (o = n.querySelector(Nd(a)), o || (e = Df({
						src: e,
						async: !0
					}, t), (t = AC.get(a)) && Ld(e, t), o = n.createElement("script"), We(o), xu(o, "link", e), n.head.appendChild(o)), o = {
						type: "script",
						instance: o,
						count: 1,
						state: null
					}, i.set(a, o));
				}
			},
			S: function(e, t, n) {
				MC.S(e, t, n);
				var i = NC;
				if (i && e) {
					var a = Ue(i).hoistableStyles, o = Od(e);
					t ||= "default";
					var s = a.get(o);
					if (!s) {
						var c = {
							loading: TC,
							preload: null
						};
						if (s = i.querySelector(kd(o))) c.loading = EC | kC;
						else {
							e = Df({
								rel: "stylesheet",
								href: e,
								"data-precedence": t
							}, n), (n = AC.get(o)) && Id(e, n);
							var l = s = i.createElement("link");
							We(l), xu(l, "link", e), l._p = new Promise(function(e, t) {
								l.onload = e, l.onerror = t;
							}), l.addEventListener("load", function() {
								c.loading |= EC;
							}), l.addEventListener("error", function() {
								c.loading |= DC;
							}), c.loading |= kC, Fd(s, t, i);
						}
						s = {
							type: "stylesheet",
							instance: s,
							count: 1,
							state: c
						}, a.set(o, s);
					}
				}
			},
			M: function(e, t) {
				MC.M(e, t);
				var n = NC;
				if (n && e) {
					var i = Ue(n).hoistableScripts, a = Md(e), o = i.get(a);
					o || (o = n.querySelector(Nd(a)), o || (e = Df({
						src: e,
						async: !0,
						type: "module"
					}, t), (t = AC.get(a)) && Ld(e, t), o = n.createElement("script"), We(o), xu(o, "link", e), n.head.appendChild(o)), o = {
						type: "script",
						instance: o,
						count: 1,
						state: null
					}, i.set(a, o));
				}
			}
		};
		var NC = typeof document > "u" ? null : document, PC = null, FC = 6e4, IC = 800, LC = 500, RC = 0, zC = null, BC = null, VC = qf, HC = {
			$$typeof: Ff,
			Provider: null,
			Consumer: null,
			_currentValue: VC,
			_currentValue2: VC,
			_threadCount: 0
		}, UC = "%c%s%c", WC = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", GC = "", KC = " ", qC = Function.prototype.bind, JC = !1, YC = null, XC = null, ZC = null, QC = null, $C = null, ew = null, tw = null, nw = null, rw = null, iw = null;
		YC = function(e, i, a, o) {
			i = t(e, i), i !== null && (a = n(i.memoizedState, a, 0, o), i.memoizedState = a, i.baseState = a, e.memoizedProps = Df({}, e.memoizedProps), a = nr(e, 2), a !== null && Yc(a, e, 2));
		}, XC = function(e, n, i) {
			n = t(e, n), n !== null && (i = o(n.memoizedState, i, 0), n.memoizedState = i, n.baseState = i, e.memoizedProps = Df({}, e.memoizedProps), i = nr(e, 2), i !== null && Yc(i, e, 2));
		}, ZC = function(e, n, a, o) {
			n = t(e, n), n !== null && (a = i(n.memoizedState, a, o), n.memoizedState = a, n.baseState = a, e.memoizedProps = Df({}, e.memoizedProps), a = nr(e, 2), a !== null && Yc(a, e, 2));
		}, QC = function(e, t, i) {
			e.pendingProps = n(e.memoizedProps, t, 0, i), e.alternate && (e.alternate.pendingProps = e.pendingProps), t = nr(e, 2), t !== null && Yc(t, e, 2);
		}, $C = function(e, t) {
			e.pendingProps = o(e.memoizedProps, t, 0), e.alternate && (e.alternate.pendingProps = e.pendingProps), t = nr(e, 2), t !== null && Yc(t, e, 2);
		}, ew = function(e, t, n) {
			e.pendingProps = i(e.memoizedProps, t, n), e.alternate && (e.alternate.pendingProps = e.pendingProps), t = nr(e, 2), t !== null && Yc(t, e, 2);
		}, tw = function(e) {
			var t = nr(e, 2);
			t !== null && Yc(t, e, 2);
		}, nw = function(e) {
			var t = De(), n = nr(e, t);
			n !== null && Yc(n, e, t);
		}, rw = function(e) {
			c = e;
		}, iw = function(e) {
			s = e;
		};
		var aw = !0, ow = null, sw = !1, cw = null, lw = null, uw = null, dw = /* @__PURE__ */ new Map(), fw = /* @__PURE__ */ new Map(), pw = [], mw = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "), hw = null;
		if (Sf.prototype.render = xf.prototype.render = function(e) {
			var t = this._internalRoot;
			if (t === null) throw Error("Cannot update an unmounted root.");
			var n = arguments;
			typeof n[1] == "function" ? console.error("does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : x(n[1]) ? console.error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : n[1] !== void 0 && console.error("You passed a second argument to root.render(...) but it only accepts one argument."), n = e;
			var i = t.current, a = qc(i);
			Xd(i, a, n, t, null, null);
		}, Sf.prototype.unmount = xf.prototype.unmount = function() {
			var e = arguments;
			if (typeof e[0] == "function" && console.error("does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."), e = this._internalRoot, e !== null) {
				this._internalRoot = null;
				var t = e.containerInfo;
				(lx & ($b | ex)) !== Qb && console.error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Xd(e.current, 2, null, e, null, null), el(), t[Kp] = null;
			}
		}, Sf.prototype.unstable_scheduleHydration = function(e) {
			if (e) {
				var t = Le();
				e = {
					blockedOn: null,
					target: e,
					priority: t
				};
				for (var n = 0; n < pw.length && t !== 0 && t < pw[n].priority; n++);
				pw.splice(n, 0, e), n === 0 && pf(e);
			}
		}, (function() {
			var e = Tf.version;
			if (e !== "19.2.0") throw Error("Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\n  - react:      " + (e + "\n  - react-dom:  19.2.0\nLearn more: https://react.dev/warnings/version-mismatch"));
		})(), typeof Map == "function" && Map.prototype != null && typeof Map.prototype.forEach == "function" && typeof Set == "function" && Set.prototype != null && typeof Set.prototype.clear == "function" && typeof Set.prototype.forEach == "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"), Kf.findDOMNode = function(e) {
			var t = e._reactInternals;
			if (t === void 0) throw typeof e.render == "function" ? Error("Unable to find node on an unmounted component.") : (e = Object.keys(e).join(","), Error("Argument appears to not be a ReactComponent. Keys: " + e));
			return e = E(t), e = e === null ? null : O(e), e = e === null ? null : e.stateNode, e;
		}, !(function() {
			var e = {
				bundleType: 1,
				version: "19.2.0",
				rendererPackageName: "react-dom",
				currentDispatcherRef: Q,
				reconcilerVersion: "19.2.0"
			};
			return e.overrideHookState = YC, e.overrideHookStateDeletePath = XC, e.overrideHookStateRenamePath = ZC, e.overrideProps = QC, e.overridePropsDeletePath = $C, e.overridePropsRenamePath = ew, e.scheduleUpdate = tw, e.scheduleRetry = nw, e.setErrorHandler = rw, e.setSuspenseHandler = iw, e.scheduleRefresh = y, e.scheduleRoot = _, e.setRefreshHandler = b, e.getCurrentFiber = tf, be(e);
		})() && Qm && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && navigator.userAgent.indexOf("Edge") === -1 || -1 < navigator.userAgent.indexOf("Firefox"))) {
			var gw = window.location.protocol;
			/^(https?|file):$/.test(gw) && console.info("%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + (gw === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""), "font-weight:bold");
		}
		e.createRoot = function(e, t) {
			if (!x(e)) throw Error("Target container is not a DOM element.");
			Cf(e);
			var n = !1, i = "", a = Ko, o = qo, s = Jo;
			return t != null && (t.hydrate ? console.warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof t == "object" && t && t.$$typeof === kf && console.error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"), !0 === t.unstable_strictMode && (n = !0), t.identifierPrefix !== void 0 && (i = t.identifierPrefix), t.onUncaughtError !== void 0 && (a = t.onUncaughtError), t.onCaughtError !== void 0 && (o = t.onCaughtError), t.onRecoverableError !== void 0 && (s = t.onRecoverableError)), t = Jd(e, 1, !1, null, null, n, i, null, a, o, s, bf), e[Kp] = t.current, au(e), new xf(t);
		}, e.hydrateRoot = function(e, t, n) {
			if (!x(e)) throw Error("Target container is not a DOM element.");
			Cf(e), t === void 0 && console.error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
			var i = !1, a = "", o = Ko, s = qo, c = Jo, l = null;
			return n != null && (!0 === n.unstable_strictMode && (i = !0), n.identifierPrefix !== void 0 && (a = n.identifierPrefix), n.onUncaughtError !== void 0 && (o = n.onUncaughtError), n.onCaughtError !== void 0 && (s = n.onCaughtError), n.onRecoverableError !== void 0 && (c = n.onRecoverableError), n.formState !== void 0 && (l = n.formState)), t = Jd(e, 1, !0, t, n ?? null, i, a, l, o, s, c, bf), t.context = Yd(null), n = t.current, i = qc(n), i = U(i), a = Gi(i), a.callback = null, Ki(n, a, i), $r(i, "hydrateRoot()", null), n = i, t.current.lanes = n, ke(t, n), Hl(t), e[Kp] = t.current, au(e), new Sf(t);
		}, e.version = "19.2.0", typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
})), import_client = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((e, t) => {
	function n() {
		if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
			if (process.env.NODE_ENV !== "production") throw Error("^_^");
			try {
				__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
			} catch (e) {
				console.error(e);
			}
		}
	}
	process.env.NODE_ENV === "production" ? (n(), t.exports = require_react_dom_client_production()) : t.exports = require_react_dom_client_development();
})))()), import_react = /* @__PURE__ */ __toESM(require_react(), 1), import_react_dom$3 = /* @__PURE__ */ __toESM(require_react_dom(), 1);
function clamp(e, [t, n]) {
	return Math.min(n, Math.max(t, e));
}
typeof window < "u" && window.document && window.document.createElement;
function composeEventHandlers(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
	return function(i) {
		if (e?.(i), n === !1 || !i.defaultPrevented) return t?.(i);
	};
}
var require_react_jsx_runtime_production = /* @__PURE__ */ __commonJSMin(((e) => {
	var t = Symbol.for("react.transitional.element"), n = Symbol.for("react.fragment");
	function i(e, n, i) {
		var a = null;
		if (i !== void 0 && (a = "" + i), n.key !== void 0 && (a = "" + n.key), "key" in n) for (var o in i = {}, n) o !== "key" && (i[o] = n[o]);
		else i = n;
		return n = i.ref, {
			$$typeof: t,
			type: e,
			key: a,
			ref: n === void 0 ? null : n,
			props: i
		};
	}
	e.Fragment = n, e.jsx = i, e.jsxs = i;
})), require_react_jsx_runtime_development = /* @__PURE__ */ __commonJSMin(((e) => {
	process.env.NODE_ENV !== "production" && (function() {
		function t(e) {
			if (e == null) return null;
			if (typeof e == "function") return e.$$typeof === j ? null : e.displayName || e.name || null;
			if (typeof e == "string") return e;
			switch (e) {
				case y: return "Fragment";
				case x: return "Profiler";
				case b: return "StrictMode";
				case T: return "Suspense";
				case E: return "SuspenseList";
				case A: return "Activity";
			}
			if (typeof e == "object") switch (typeof e.tag == "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), e.$$typeof) {
				case v: return "Portal";
				case C: return e.displayName || "Context";
				case S: return (e._context.displayName || "Context") + ".Consumer";
				case w:
					var n = e.render;
					return e = e.displayName, e ||= (e = n.displayName || n.name || "", e === "" ? "ForwardRef" : "ForwardRef(" + e + ")"), e;
				case O: return n = e.displayName || null, n === null ? t(e.type) || "Memo" : n;
				case k:
					n = e._payload, e = e._init;
					try {
						return t(e(n));
					} catch {}
			}
			return null;
		}
		function n(e) {
			return "" + e;
		}
		function i(e) {
			try {
				n(e);
				var t = !1;
			} catch {
				t = !0;
			}
			if (t) {
				t = console;
				var i = t.error, a = typeof Symbol == "function" && Symbol.toStringTag && e[Symbol.toStringTag] || e.constructor.name || "Object";
				return i.call(t, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", a), n(e);
			}
		}
		function a(e) {
			if (e === y) return "<>";
			if (typeof e == "object" && e && e.$$typeof === k) return "<...>";
			try {
				var n = t(e);
				return n ? "<" + n + ">" : "<...>";
			} catch {
				return "<...>";
			}
		}
		function o() {
			var e = M.A;
			return e === null ? null : e.getOwner();
		}
		function s() {
			return Error("react-stack-top-frame");
		}
		function c(e) {
			if (N.call(e, "key")) {
				var t = Object.getOwnPropertyDescriptor(e, "key").get;
				if (t && t.isReactWarning) return !1;
			}
			return e.key !== void 0;
		}
		function l(e, t) {
			function n() {
				I || (I = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", t));
			}
			n.isReactWarning = !0, Object.defineProperty(e, "key", {
				get: n,
				configurable: !0
			});
		}
		function u() {
			var e = t(this.type);
			return ee[e] || (ee[e] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")), e = this.props.ref, e === void 0 ? null : e;
		}
		function d(e, t, n, i, a, o) {
			var s = n.ref;
			return e = {
				$$typeof: _,
				type: e,
				key: t,
				props: n,
				_owner: i
			}, (s === void 0 ? null : s) === null ? Object.defineProperty(e, "ref", {
				enumerable: !1,
				value: null
			}) : Object.defineProperty(e, "ref", {
				enumerable: !1,
				get: u
			}), e._store = {}, Object.defineProperty(e._store, "validated", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: 0
			}), Object.defineProperty(e, "_debugInfo", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: null
			}), Object.defineProperty(e, "_debugStack", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: a
			}), Object.defineProperty(e, "_debugTask", {
				configurable: !1,
				enumerable: !1,
				writable: !0,
				value: o
			}), Object.freeze && (Object.freeze(e.props), Object.freeze(e)), e;
		}
		function p(e, n, a, s, u, f) {
			var p = n.children;
			if (p !== void 0) if (s) if (P(p)) {
				for (s = 0; s < p.length; s++) m(p[s]);
				Object.freeze && Object.freeze(p);
			} else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
			else m(p);
			if (N.call(n, "key")) {
				p = t(e);
				var h = Object.keys(n).filter(function(e) {
					return e !== "key";
				});
				s = 0 < h.length ? "{key: someKey, " + h.join(": ..., ") + ": ...}" : "{key: someKey}", te[p + s] || (h = 0 < h.length ? "{" + h.join(": ..., ") + ": ...}" : "{}", console.error("A props object containing a \"key\" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />", s, p, h, p), te[p + s] = !0);
			}
			if (p = null, a !== void 0 && (i(a), p = "" + a), c(n) && (i(n.key), p = "" + n.key), "key" in n) for (var g in a = {}, n) g !== "key" && (a[g] = n[g]);
			else a = n;
			return p && l(a, typeof e == "function" ? e.displayName || e.name || "Unknown" : e), d(e, p, a, o(), u, f);
		}
		function m(e) {
			h(e) ? e._store && (e._store.validated = 1) : typeof e == "object" && e && e.$$typeof === k && (e._payload.status === "fulfilled" ? h(e._payload.value) && e._payload.value._store && (e._payload.value._store.validated = 1) : e._store && (e._store.validated = 1));
		}
		function h(e) {
			return typeof e == "object" && !!e && e.$$typeof === _;
		}
		var g = require_react(), _ = Symbol.for("react.transitional.element"), v = Symbol.for("react.portal"), y = Symbol.for("react.fragment"), b = Symbol.for("react.strict_mode"), x = Symbol.for("react.profiler"), S = Symbol.for("react.consumer"), C = Symbol.for("react.context"), w = Symbol.for("react.forward_ref"), T = Symbol.for("react.suspense"), E = Symbol.for("react.suspense_list"), O = Symbol.for("react.memo"), k = Symbol.for("react.lazy"), A = Symbol.for("react.activity"), j = Symbol.for("react.client.reference"), M = g.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, N = Object.prototype.hasOwnProperty, P = Array.isArray, F = console.createTask ? console.createTask : function() {
			return null;
		};
		g = { react_stack_bottom_frame: function(e) {
			return e();
		} };
		var I, ee = {}, L = g.react_stack_bottom_frame.bind(g, s)(), R = F(a(s)), te = {};
		e.Fragment = y, e.jsx = function(e, t, n) {
			var i = 1e4 > M.recentlyCreatedOwnerStacks++;
			return p(e, t, n, !1, i ? Error("react-stack-top-frame") : L, i ? F(a(e)) : R);
		}, e.jsxs = function(e, t, n) {
			var i = 1e4 > M.recentlyCreatedOwnerStacks++;
			return p(e, t, n, !0, i ? Error("react-stack-top-frame") : L, i ? F(a(e)) : R);
		};
	})();
})), import_jsx_runtime = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((e, t) => {
	process.env.NODE_ENV === "production" ? t.exports = require_react_jsx_runtime_production() : t.exports = require_react_jsx_runtime_development();
})))(), 1);
function createContext2(e, t) {
	let n = import_react.createContext(t), i = (e) => {
		let { children: t,...i } = e, a = import_react.useMemo(() => i, Object.values(i));
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(n.Provider, {
			value: a,
			children: t
		});
	};
	i.displayName = e + "Provider";
	function a(i) {
		let a = import_react.useContext(n);
		if (a) return a;
		if (t !== void 0) return t;
		throw Error(`\`${i}\` must be used within \`${e}\``);
	}
	return [i, a];
}
function createContextScope(e, t = []) {
	let n = [];
	function i(t, i) {
		let a = import_react.createContext(i), o = n.length;
		n = [...n, i];
		let s = (t) => {
			let { scope: n, children: i,...s } = t, c = n?.[e]?.[o] || a, l = import_react.useMemo(() => s, Object.values(s));
			return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(c.Provider, {
				value: l,
				children: i
			});
		};
		s.displayName = t + "Provider";
		function c(n, s) {
			let c = s?.[e]?.[o] || a, l = import_react.useContext(c);
			if (l) return l;
			if (i !== void 0) return i;
			throw Error(`\`${n}\` must be used within \`${t}\``);
		}
		return [s, c];
	}
	let a = () => {
		let t = n.map((e) => import_react.createContext(e));
		return function(n) {
			let i = n?.[e] || t;
			return import_react.useMemo(() => ({ [`__scope${e}`]: {
				...n,
				[e]: i
			} }), [n, i]);
		};
	};
	return a.scopeName = e, [i, composeContextScopes(a, ...t)];
}
function composeContextScopes(...e) {
	let t = e[0];
	if (e.length === 1) return t;
	let n = () => {
		let n = e.map((e) => ({
			useScope: e(),
			scopeName: e.scopeName
		}));
		return function(e) {
			let i = n.reduce((t, { useScope: n, scopeName: i }) => {
				let a = n(e)[`__scope${i}`];
				return {
					...t,
					...a
				};
			}, {});
			return import_react.useMemo(() => ({ [`__scope${t.scopeName}`]: i }), [i]);
		};
	};
	return n.scopeName = t.scopeName, n;
}
function setRef(e, t) {
	if (typeof e == "function") return e(t);
	e != null && (e.current = t);
}
function composeRefs(...e) {
	return (t) => {
		let n = !1, i = e.map((e) => {
			let i = setRef(e, t);
			return !n && typeof i == "function" && (n = !0), i;
		});
		if (n) return () => {
			for (let t = 0; t < i.length; t++) {
				let n = i[t];
				typeof n == "function" ? n() : setRef(e[t], null);
			}
		};
	};
}
function useComposedRefs(...e) {
	return import_react.useCallback(composeRefs(...e), e);
}
/* @__NO_SIDE_EFFECTS__ */
function createSlot(e) {
	let t = /* @__PURE__ */ createSlotClone(e), n = import_react.forwardRef((e, n) => {
		let { children: i,...a } = e, o = import_react.Children.toArray(i), s = o.find(isSlottable);
		if (s) {
			let e = s.props.children, i = o.map((t) => t === s ? import_react.Children.count(e) > 1 ? import_react.Children.only(null) : import_react.isValidElement(e) ? e.props.children : null : t);
			return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(t, {
				...a,
				ref: n,
				children: import_react.isValidElement(e) ? import_react.cloneElement(e, void 0, i) : null
			});
		}
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(t, {
			...a,
			ref: n,
			children: i
		});
	});
	return n.displayName = `${e}.Slot`, n;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
/* @__NO_SIDE_EFFECTS__ */
function createSlotClone(e) {
	let t = import_react.forwardRef((e, t) => {
		let { children: n,...i } = e;
		if (import_react.isValidElement(n)) {
			let e = getElementRef$1(n), a = mergeProps(i, n.props);
			return n.type !== import_react.Fragment && (a.ref = t ? composeRefs(t, e) : e), import_react.cloneElement(n, a);
		}
		return import_react.Children.count(n) > 1 ? import_react.Children.only(null) : null;
	});
	return t.displayName = `${e}.SlotClone`, t;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function isSlottable(e) {
	return import_react.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(e, t) {
	let n = { ...t };
	for (let i in t) {
		let a = e[i], o = t[i];
		/^on[A-Z]/.test(i) ? a && o ? n[i] = (...e) => {
			let t = o(...e);
			return a(...e), t;
		} : a && (n[i] = a) : i === "style" ? n[i] = {
			...a,
			...o
		} : i === "className" && (n[i] = [a, o].filter(Boolean).join(" "));
	}
	return {
		...e,
		...n
	};
}
function getElementRef$1(e) {
	let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
	return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
function createCollection(e) {
	let t = e + "CollectionProvider", [n, i] = createContextScope(t), [a, o] = n(t, {
		collectionRef: { current: null },
		itemMap: /* @__PURE__ */ new Map()
	}), s = (e) => {
		let { scope: t, children: n } = e, i = import_react.useRef(null), o = import_react.useRef(/* @__PURE__ */ new Map()).current;
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(a, {
			scope: t,
			itemMap: o,
			collectionRef: i,
			children: n
		});
	};
	s.displayName = t;
	let c = e + "CollectionSlot", l = /* @__PURE__ */ createSlot(c), u = import_react.forwardRef((e, t) => {
		let { scope: n, children: i } = e, a = o(c, n), s = useComposedRefs(t, a.collectionRef);
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(l, {
			ref: s,
			children: i
		});
	});
	u.displayName = c;
	let d = e + "CollectionItemSlot", f = "data-radix-collection-item", p = /* @__PURE__ */ createSlot(d), m = import_react.forwardRef((e, t) => {
		let { scope: n, children: i,...a } = e, s = import_react.useRef(null), c = useComposedRefs(t, s), l = o(d, n);
		return import_react.useEffect(() => (l.itemMap.set(s, {
			ref: s,
			...a
		}), () => void l.itemMap.delete(s))), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(p, {
			[f]: "",
			ref: c,
			children: i
		});
	});
	m.displayName = d;
	function h(t) {
		let n = o(e + "CollectionConsumer", t);
		return import_react.useCallback(() => {
			let e = n.collectionRef.current;
			if (!e) return [];
			let t = Array.from(e.querySelectorAll(`[${f}]`));
			return Array.from(n.itemMap.values()).sort((e, n) => t.indexOf(e.ref.current) - t.indexOf(n.ref.current));
		}, [n.collectionRef, n.itemMap]);
	}
	return [
		{
			Provider: s,
			Slot: u,
			ItemSlot: m
		},
		h,
		i
	];
}
var DirectionContext = import_react.createContext(void 0);
function useDirection(e) {
	let t = import_react.useContext(DirectionContext);
	return e || t || "ltr";
}
var Primitive = [
	"a",
	"button",
	"div",
	"form",
	"h2",
	"h3",
	"img",
	"input",
	"label",
	"li",
	"nav",
	"ol",
	"p",
	"select",
	"span",
	"svg",
	"ul"
].reduce((e, t) => {
	let n = /* @__PURE__ */ createSlot(`Primitive.${t}`), i = import_react.forwardRef((e, i) => {
		let { asChild: a,...o } = e, s = a ? n : t;
		return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(s, {
			...o,
			ref: i
		});
	});
	return i.displayName = `Primitive.${t}`, {
		...e,
		[t]: i
	};
}, {});
function dispatchDiscreteCustomEvent(e, t) {
	e && import_react_dom$3.flushSync(() => e.dispatchEvent(t));
}
function useCallbackRef(e) {
	let t = import_react.useRef(e);
	return import_react.useEffect(() => {
		t.current = e;
	}), import_react.useMemo(() => (...e) => t.current?.(...e), []);
}
function useEscapeKeydown(e, t = globalThis?.document) {
	let n = useCallbackRef(e);
	import_react.useEffect(() => {
		let e = (e) => {
			e.key === "Escape" && n(e);
		};
		return t.addEventListener("keydown", e, { capture: !0 }), () => t.removeEventListener("keydown", e, { capture: !0 });
	}, [n, t]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer", CONTEXT_UPDATE = "dismissableLayer.update", POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside", FOCUS_OUTSIDE = "dismissableLayer.focusOutside", originalBodyPointerEvents, DismissableLayerContext = import_react.createContext({
	layers: /* @__PURE__ */ new Set(),
	layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
	branches: /* @__PURE__ */ new Set()
}), DismissableLayer = import_react.forwardRef((e, t) => {
	let { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: i, onPointerDownOutside: a, onFocusOutside: o, onInteractOutside: s, onDismiss: c,...l } = e, u = import_react.useContext(DismissableLayerContext), [d, f] = import_react.useState(null), p = d?.ownerDocument ?? globalThis?.document, [, m] = import_react.useState({}), h = useComposedRefs(t, (e) => f(e)), g = Array.from(u.layers), [_] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), v = g.indexOf(_), y = d ? g.indexOf(d) : -1, b = u.layersWithOutsidePointerEventsDisabled.size > 0, x = y >= v, C = usePointerDownOutside((e) => {
		let t = e.target, n = [...u.branches].some((e) => e.contains(t));
		!x || n || (a?.(e), s?.(e), e.defaultPrevented || c?.());
	}, p), w = useFocusOutside((e) => {
		let t = e.target;
		[...u.branches].some((e) => e.contains(t)) || (o?.(e), s?.(e), e.defaultPrevented || c?.());
	}, p);
	return useEscapeKeydown((e) => {
		y === u.layers.size - 1 && (i?.(e), !e.defaultPrevented && c && (e.preventDefault(), c()));
	}, p), import_react.useEffect(() => {
		if (d) return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (originalBodyPointerEvents = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), dispatchUpdate(), () => {
			n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = originalBodyPointerEvents);
		};
	}, [
		d,
		p,
		n,
		u
	]), import_react.useEffect(() => () => {
		d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), dispatchUpdate());
	}, [d, u]), import_react.useEffect(() => {
		let e = () => m({});
		return document.addEventListener(CONTEXT_UPDATE, e), () => document.removeEventListener(CONTEXT_UPDATE, e);
	}, []), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		...l,
		ref: h,
		style: {
			pointerEvents: b ? x ? "auto" : "none" : void 0,
			...e.style
		},
		onFocusCapture: composeEventHandlers(e.onFocusCapture, w.onFocusCapture),
		onBlurCapture: composeEventHandlers(e.onBlurCapture, w.onBlurCapture),
		onPointerDownCapture: composeEventHandlers(e.onPointerDownCapture, C.onPointerDownCapture)
	});
});
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch", DismissableLayerBranch = import_react.forwardRef((e, t) => {
	let n = import_react.useContext(DismissableLayerContext), i = import_react.useRef(null), a = useComposedRefs(t, i);
	return import_react.useEffect(() => {
		let e = i.current;
		if (e) return n.branches.add(e), () => {
			n.branches.delete(e);
		};
	}, [n.branches]), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		...e,
		ref: a
	});
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(e, t = globalThis?.document) {
	let n = useCallbackRef(e), i = import_react.useRef(!1), a = import_react.useRef(() => {});
	return import_react.useEffect(() => {
		let e = (e) => {
			if (e.target && !i.current) {
				let i = function() {
					handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, n, o, { discrete: !0 });
				}, o = { originalEvent: e };
				e.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = i, t.addEventListener("click", a.current, { once: !0 })) : i();
			} else t.removeEventListener("click", a.current);
			i.current = !1;
		}, o = window.setTimeout(() => {
			t.addEventListener("pointerdown", e);
		}, 0);
		return () => {
			window.clearTimeout(o), t.removeEventListener("pointerdown", e), t.removeEventListener("click", a.current);
		};
	}, [t, n]), { onPointerDownCapture: () => i.current = !0 };
}
function useFocusOutside(e, t = globalThis?.document) {
	let n = useCallbackRef(e), i = import_react.useRef(!1);
	return import_react.useEffect(() => {
		let e = (e) => {
			e.target && !i.current && handleAndDispatchCustomEvent(FOCUS_OUTSIDE, n, { originalEvent: e }, { discrete: !1 });
		};
		return t.addEventListener("focusin", e), () => t.removeEventListener("focusin", e);
	}, [t, n]), {
		onFocusCapture: () => i.current = !0,
		onBlurCapture: () => i.current = !1
	};
}
function dispatchUpdate() {
	let e = new CustomEvent(CONTEXT_UPDATE);
	document.dispatchEvent(e);
}
function handleAndDispatchCustomEvent(e, t, n, { discrete: i }) {
	let a = n.originalEvent.target, o = new CustomEvent(e, {
		bubbles: !1,
		cancelable: !0,
		detail: n
	});
	t && a.addEventListener(e, t, { once: !0 }), i ? dispatchDiscreteCustomEvent(a, o) : a.dispatchEvent(o);
}
var count$2 = 0;
function useFocusGuards() {
	import_react.useEffect(() => {
		let e = document.querySelectorAll("[data-radix-focus-guard]");
		return document.body.insertAdjacentElement("afterbegin", e[0] ?? createFocusGuard()), document.body.insertAdjacentElement("beforeend", e[1] ?? createFocusGuard()), count$2++, () => {
			count$2 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), count$2--;
		};
	}, []);
}
function createFocusGuard() {
	let e = document.createElement("span");
	return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount", AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount", EVENT_OPTIONS = {
	bubbles: !1,
	cancelable: !0
}, FOCUS_SCOPE_NAME = "FocusScope", FocusScope = import_react.forwardRef((e, t) => {
	let { loop: n = !1, trapped: i = !1, onMountAutoFocus: a, onUnmountAutoFocus: o,...s } = e, [c, l] = import_react.useState(null), u = useCallbackRef(a), d = useCallbackRef(o), f = import_react.useRef(null), p = useComposedRefs(t, (e) => l(e)), m = import_react.useRef({
		paused: !1,
		pause() {
			this.paused = !0;
		},
		resume() {
			this.paused = !1;
		}
	}).current;
	import_react.useEffect(() => {
		if (i) {
			let e = function(e) {
				if (m.paused || !c) return;
				let t = e.target;
				c.contains(t) ? f.current = t : focus(f.current, { select: !0 });
			}, t = function(e) {
				if (m.paused || !c) return;
				let t = e.relatedTarget;
				t !== null && (c.contains(t) || focus(f.current, { select: !0 }));
			}, n = function(e) {
				if (document.activeElement === document.body) for (let t of e) t.removedNodes.length > 0 && focus(c);
			};
			document.addEventListener("focusin", e), document.addEventListener("focusout", t);
			let i = new MutationObserver(n);
			return c && i.observe(c, {
				childList: !0,
				subtree: !0
			}), () => {
				document.removeEventListener("focusin", e), document.removeEventListener("focusout", t), i.disconnect();
			};
		}
	}, [
		i,
		c,
		m.paused
	]), import_react.useEffect(() => {
		if (c) {
			focusScopesStack.add(m);
			let e = document.activeElement;
			if (!c.contains(e)) {
				let t = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
				c.addEventListener(AUTOFOCUS_ON_MOUNT, u), c.dispatchEvent(t), t.defaultPrevented || (focusFirst(removeLinks(getTabbableCandidates(c)), { select: !0 }), document.activeElement === e && focus(c));
			}
			return () => {
				c.removeEventListener(AUTOFOCUS_ON_MOUNT, u), setTimeout(() => {
					let t = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
					c.addEventListener(AUTOFOCUS_ON_UNMOUNT, d), c.dispatchEvent(t), t.defaultPrevented || focus(e ?? document.body, { select: !0 }), c.removeEventListener(AUTOFOCUS_ON_UNMOUNT, d), focusScopesStack.remove(m);
				}, 0);
			};
		}
	}, [
		c,
		u,
		d,
		m
	]);
	let h = import_react.useCallback((e) => {
		if (!n && !i || m.paused) return;
		let t = e.key === "Tab" && !e.altKey && !e.ctrlKey && !e.metaKey, a = document.activeElement;
		if (t && a) {
			let t = e.currentTarget, [i, o] = getTabbableEdges(t);
			i && o ? !e.shiftKey && a === o ? (e.preventDefault(), n && focus(i, { select: !0 })) : e.shiftKey && a === i && (e.preventDefault(), n && focus(o, { select: !0 })) : a === t && e.preventDefault();
		}
	}, [
		n,
		i,
		m.paused
	]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		tabIndex: -1,
		...s,
		ref: p,
		onKeyDown: h
	});
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(e, { select: t = !1 } = {}) {
	let n = document.activeElement;
	for (let i of e) if (focus(i, { select: t }), document.activeElement !== n) return;
}
function getTabbableEdges(e) {
	let t = getTabbableCandidates(e), n = findVisible(t, e), i = findVisible(t.reverse(), e);
	return [n, i];
}
function getTabbableCandidates(e) {
	let t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: (e) => {
		let t = e.tagName === "INPUT" && e.type === "hidden";
		return e.disabled || e.hidden || t ? NodeFilter.FILTER_SKIP : e.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
	} });
	for (; n.nextNode();) t.push(n.currentNode);
	return t;
}
function findVisible(e, t) {
	for (let n of e) if (!isHidden(n, { upTo: t })) return n;
}
function isHidden(e, { upTo: t }) {
	if (getComputedStyle(e).visibility === "hidden") return !0;
	for (; e;) {
		if (t !== void 0 && e === t) return !1;
		if (getComputedStyle(e).display === "none") return !0;
		e = e.parentElement;
	}
	return !1;
}
function isSelectableInput(e) {
	return e instanceof HTMLInputElement && "select" in e;
}
function focus(e, { select: t = !1 } = {}) {
	if (e && e.focus) {
		let n = document.activeElement;
		e.focus({ preventScroll: !0 }), e !== n && isSelectableInput(e) && t && e.select();
	}
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
	let e = [];
	return {
		add(t) {
			let n = e[0];
			t !== n && n?.pause(), e = arrayRemove(e, t), e.unshift(t);
		},
		remove(t) {
			e = arrayRemove(e, t), e[0]?.resume();
		}
	};
}
function arrayRemove(e, t) {
	let n = [...e], i = n.indexOf(t);
	return i !== -1 && n.splice(i, 1), n;
}
function removeLinks(e) {
	return e.filter((e) => e.tagName !== "A");
}
var useLayoutEffect2 = globalThis?.document ? import_react.useLayoutEffect : () => {}, useReactId = import_react.useId || (() => void 0), count$1 = 0;
function useId(e) {
	let [t, n] = import_react.useState(useReactId());
	return useLayoutEffect2(() => {
		e || n((e) => e ?? String(count$1++));
	}, [e]), e || (t ? `radix-${t}` : "");
}
var sides = [
	"top",
	"right",
	"bottom",
	"left"
], min$1 = Math.min, max$1 = Math.max, round = Math.round, floor = Math.floor, createCoords = (e) => ({
	x: e,
	y: e
}), oppositeSideMap = {
	left: "right",
	right: "left",
	bottom: "top",
	top: "bottom"
}, oppositeAlignmentMap = {
	start: "end",
	end: "start"
};
function clamp$1(e, t, n) {
	return max$1(e, min$1(t, n));
}
function evaluate(e, t) {
	return typeof e == "function" ? e(t) : e;
}
function getSide(e) {
	return e.split("-")[0];
}
function getAlignment(e) {
	return e.split("-")[1];
}
function getOppositeAxis(e) {
	return e === "x" ? "y" : "x";
}
function getAxisLength(e) {
	return e === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(e) {
	return yAxisSides.has(getSide(e)) ? "y" : "x";
}
function getAlignmentAxis(e) {
	return getOppositeAxis(getSideAxis(e));
}
function getAlignmentSides(e, t, n) {
	n === void 0 && (n = !1);
	let i = getAlignment(e), a = getAlignmentAxis(e), o = getAxisLength(a), s = a === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
	return t.reference[o] > t.floating[o] && (s = getOppositePlacement(s)), [s, getOppositePlacement(s)];
}
function getExpandedPlacements(e) {
	let t = getOppositePlacement(e);
	return [
		getOppositeAlignmentPlacement(e),
		t,
		getOppositeAlignmentPlacement(t)
	];
}
function getOppositeAlignmentPlacement(e) {
	return e.replace(/start|end/g, (e) => oppositeAlignmentMap[e]);
}
var lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"];
function getSideList(e, t, n) {
	switch (e) {
		case "top":
		case "bottom": return n ? t ? rlPlacement : lrPlacement : t ? lrPlacement : rlPlacement;
		case "left":
		case "right": return t ? tbPlacement : btPlacement;
		default: return [];
	}
}
function getOppositeAxisPlacements(e, t, n, i) {
	let a = getAlignment(e), o = getSideList(getSide(e), n === "start", i);
	return a && (o = o.map((e) => e + "-" + a), t && (o = o.concat(o.map(getOppositeAlignmentPlacement)))), o;
}
function getOppositePlacement(e) {
	return e.replace(/left|right|bottom|top/g, (e) => oppositeSideMap[e]);
}
function expandPaddingObject(e) {
	return {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...e
	};
}
function getPaddingObject(e) {
	return typeof e == "number" ? {
		top: e,
		right: e,
		bottom: e,
		left: e
	} : expandPaddingObject(e);
}
function rectToClientRect(e) {
	let { x: t, y: n, width: i, height: a } = e;
	return {
		width: i,
		height: a,
		top: n,
		left: t,
		right: t + i,
		bottom: n + a,
		x: t,
		y: n
	};
}
function computeCoordsFromPlacement(e, t, n) {
	let { reference: i, floating: a } = e, o = getSideAxis(t), s = getAlignmentAxis(t), c = getAxisLength(s), l = getSide(t), u = o === "y", d = i.x + i.width / 2 - a.width / 2, f = i.y + i.height / 2 - a.height / 2, p = i[c] / 2 - a[c] / 2, m;
	switch (l) {
		case "top":
			m = {
				x: d,
				y: i.y - a.height
			};
			break;
		case "bottom":
			m = {
				x: d,
				y: i.y + i.height
			};
			break;
		case "right":
			m = {
				x: i.x + i.width,
				y: f
			};
			break;
		case "left":
			m = {
				x: i.x - a.width,
				y: f
			};
			break;
		default: m = {
			x: i.x,
			y: i.y
		};
	}
	switch (getAlignment(t)) {
		case "start":
			m[s] -= p * (n && u ? -1 : 1);
			break;
		case "end":
			m[s] += p * (n && u ? -1 : 1);
			break;
	}
	return m;
}
var computePosition$1 = async (e, t, n) => {
	let { placement: i = "bottom", strategy: a = "absolute", middleware: o = [], platform: s } = n, c = o.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(t)), u = await s.getElementRects({
		reference: e,
		floating: t,
		strategy: a
	}), { x: d, y: f } = computeCoordsFromPlacement(u, i, l), p = i, m = {}, h = 0;
	for (let n = 0; n < c.length; n++) {
		let { name: o, fn: g } = c[n], { x: _, y: v, data: y, reset: b } = await g({
			x: d,
			y: f,
			initialPlacement: i,
			placement: p,
			strategy: a,
			middlewareData: m,
			rects: u,
			platform: s,
			elements: {
				reference: e,
				floating: t
			}
		});
		d = _ ?? d, f = v ?? f, m = {
			...m,
			[o]: {
				...m[o],
				...y
			}
		}, b && h <= 50 && (h++, typeof b == "object" && (b.placement && (p = b.placement), b.rects && (u = b.rects === !0 ? await s.getElementRects({
			reference: e,
			floating: t,
			strategy: a
		}) : b.rects), {x: d, y: f} = computeCoordsFromPlacement(u, p, l)), n = -1);
	}
	return {
		x: d,
		y: f,
		placement: p,
		strategy: a,
		middlewareData: m
	};
};
async function detectOverflow$1(e, t) {
	t === void 0 && (t = {});
	let { x: n, y: i, platform: a, rects: o, elements: s, strategy: c } = e, { boundary: l = "clippingAncestors", rootBoundary: u = "viewport", elementContext: d = "floating", altBoundary: f = !1, padding: p = 0 } = evaluate(t, e), m = getPaddingObject(p), h = s[f ? d === "floating" ? "reference" : "floating" : d], g = rectToClientRect(await a.getClippingRect({
		element: await (a.isElement == null ? void 0 : a.isElement(h)) ?? !0 ? h : h.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
		boundary: l,
		rootBoundary: u,
		strategy: c
	})), _ = d === "floating" ? {
		x: n,
		y: i,
		width: o.floating.width,
		height: o.floating.height
	} : o.reference, v = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), y = await (a.isElement == null ? void 0 : a.isElement(v)) && await (a.getScale == null ? void 0 : a.getScale(v)) || {
		x: 1,
		y: 1
	}, b = rectToClientRect(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
		elements: s,
		rect: _,
		offsetParent: v,
		strategy: c
	}) : _);
	return {
		top: (g.top - b.top + m.top) / y.y,
		bottom: (b.bottom - g.bottom + m.bottom) / y.y,
		left: (g.left - b.left + m.left) / y.x,
		right: (b.right - g.right + m.right) / y.x
	};
}
var arrow$2 = (e) => ({
	name: "arrow",
	options: e,
	async fn(t) {
		let { x: n, y: i, placement: a, rects: o, platform: s, elements: c, middlewareData: l } = t, { element: u, padding: d = 0 } = evaluate(e, t) || {};
		if (u == null) return {};
		let f = getPaddingObject(d), p = {
			x: n,
			y: i
		}, m = getAlignmentAxis(a), h = getAxisLength(m), g = await s.getDimensions(u), _ = m === "y", v = _ ? "top" : "left", y = _ ? "bottom" : "right", b = _ ? "clientHeight" : "clientWidth", x = o.reference[h] + o.reference[m] - p[m] - o.floating[h], S = p[m] - o.reference[m], C = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u)), w = C ? C[b] : 0;
		(!w || !await (s.isElement == null ? void 0 : s.isElement(C))) && (w = c.floating[b] || o.floating[h]);
		let T = x / 2 - S / 2, E = w / 2 - g[h] / 2 - 1, O = min$1(f[v], E), k = min$1(f[y], E), A = O, j = w - g[h] - k, M = w / 2 - g[h] / 2 + T, N = clamp$1(A, M, j), P = !l.arrow && getAlignment(a) != null && M !== N && o.reference[h] / 2 - (M < A ? O : k) - g[h] / 2 < 0, F = P ? M < A ? M - A : M - j : 0;
		return {
			[m]: p[m] + F,
			data: {
				[m]: N,
				centerOffset: M - N - F,
				...P && { alignmentOffset: F }
			},
			reset: P
		};
	}
}), flip$2 = function(e) {
	return e === void 0 && (e = {}), {
		name: "flip",
		options: e,
		async fn(t) {
			var n;
			let { placement: i, middlewareData: a, rects: o, initialPlacement: s, platform: c, elements: l } = t, { mainAxis: u = !0, crossAxis: d = !0, fallbackPlacements: f, fallbackStrategy: p = "bestFit", fallbackAxisSideDirection: m = "none", flipAlignment: h = !0,...g } = evaluate(e, t);
			if ((n = a.arrow) != null && n.alignmentOffset) return {};
			let _ = getSide(i), v = getSideAxis(s), y = getSide(s) === s, b = await (c.isRTL == null ? void 0 : c.isRTL(l.floating)), x = f || (y || !h ? [getOppositePlacement(s)] : getExpandedPlacements(s)), S = m !== "none";
			!f && S && x.push(...getOppositeAxisPlacements(s, h, m, b));
			let C = [s, ...x], w = await detectOverflow$1(t, g), T = [], E = a.flip?.overflows || [];
			if (u && T.push(w[_]), d) {
				let e = getAlignmentSides(i, o, b);
				T.push(w[e[0]], w[e[1]]);
			}
			if (E = [...E, {
				placement: i,
				overflows: T
			}], !T.every((e) => e <= 0)) {
				let e = (a.flip?.index || 0) + 1, t = C[e];
				if (t && (!(d === "alignment" && v !== getSideAxis(t)) || E.every((e) => getSideAxis(e.placement) === v ? e.overflows[0] > 0 : !0))) return {
					data: {
						index: e,
						overflows: E
					},
					reset: { placement: t }
				};
				let n = E.filter((e) => e.overflows[0] <= 0).sort((e, t) => e.overflows[1] - t.overflows[1])[0]?.placement;
				if (!n) switch (p) {
					case "bestFit": {
						let e = E.filter((e) => {
							if (S) {
								let t = getSideAxis(e.placement);
								return t === v || t === "y";
							}
							return !0;
						}).map((e) => [e.placement, e.overflows.filter((e) => e > 0).reduce((e, t) => e + t, 0)]).sort((e, t) => e[1] - t[1])[0]?.[0];
						e && (n = e);
						break;
					}
					case "initialPlacement":
						n = s;
						break;
				}
				if (i !== n) return { reset: { placement: n } };
			}
			return {};
		}
	};
};
function getSideOffsets(e, t) {
	return {
		top: e.top - t.height,
		right: e.right - t.width,
		bottom: e.bottom - t.height,
		left: e.left - t.width
	};
}
function isAnySideFullyClipped(e) {
	return sides.some((t) => e[t] >= 0);
}
var hide$2 = function(e) {
	return e === void 0 && (e = {}), {
		name: "hide",
		options: e,
		async fn(t) {
			let { rects: n } = t, { strategy: i = "referenceHidden",...a } = evaluate(e, t);
			switch (i) {
				case "referenceHidden": {
					let e = await detectOverflow$1(t, {
						...a,
						elementContext: "reference"
					}), i = getSideOffsets(e, n.reference);
					return { data: {
						referenceHiddenOffsets: i,
						referenceHidden: isAnySideFullyClipped(i)
					} };
				}
				case "escaped": {
					let e = await detectOverflow$1(t, {
						...a,
						altBoundary: !0
					}), i = getSideOffsets(e, n.floating);
					return { data: {
						escapedOffsets: i,
						escaped: isAnySideFullyClipped(i)
					} };
				}
				default: return {};
			}
		}
	};
}, originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(e, t) {
	let { placement: n, platform: i, elements: a } = e, o = await (i.isRTL == null ? void 0 : i.isRTL(a.floating)), s = getSide(n), c = getAlignment(n), l = getSideAxis(n) === "y", u = originSides.has(s) ? -1 : 1, d = o && l ? -1 : 1, f = evaluate(t, e), { mainAxis: p, crossAxis: m, alignmentAxis: h } = typeof f == "number" ? {
		mainAxis: f,
		crossAxis: 0,
		alignmentAxis: null
	} : {
		mainAxis: f.mainAxis || 0,
		crossAxis: f.crossAxis || 0,
		alignmentAxis: f.alignmentAxis
	};
	return c && typeof h == "number" && (m = c === "end" ? h * -1 : h), l ? {
		x: m * d,
		y: p * u
	} : {
		x: p * u,
		y: m * d
	};
}
var offset$2 = function(e) {
	return e === void 0 && (e = 0), {
		name: "offset",
		options: e,
		async fn(t) {
			var n;
			let { x: i, y: a, placement: o, middlewareData: s } = t, c = await convertValueToCoords(t, e);
			return o === s.offset?.placement && (n = s.arrow) != null && n.alignmentOffset ? {} : {
				x: i + c.x,
				y: a + c.y,
				data: {
					...c,
					placement: o
				}
			};
		}
	};
}, shift$2 = function(e) {
	return e === void 0 && (e = {}), {
		name: "shift",
		options: e,
		async fn(t) {
			let { x: n, y: i, placement: a } = t, { mainAxis: o = !0, crossAxis: s = !1, limiter: c = { fn: (e) => {
				let { x: t, y: n } = e;
				return {
					x: t,
					y: n
				};
			} },...l } = evaluate(e, t), u = {
				x: n,
				y: i
			}, d = await detectOverflow$1(t, l), f = getSideAxis(getSide(a)), p = getOppositeAxis(f), m = u[p], h = u[f];
			if (o) {
				let e = p === "y" ? "top" : "left", t = p === "y" ? "bottom" : "right", n = m + d[e], i = m - d[t];
				m = clamp$1(n, m, i);
			}
			if (s) {
				let e = f === "y" ? "top" : "left", t = f === "y" ? "bottom" : "right", n = h + d[e], i = h - d[t];
				h = clamp$1(n, h, i);
			}
			let g = c.fn({
				...t,
				[p]: m,
				[f]: h
			});
			return {
				...g,
				data: {
					x: g.x - n,
					y: g.y - i,
					enabled: {
						[p]: o,
						[f]: s
					}
				}
			};
		}
	};
}, limitShift$2 = function(e) {
	return e === void 0 && (e = {}), {
		options: e,
		fn(t) {
			let { x: n, y: i, placement: a, rects: o, middlewareData: s } = t, { offset: c = 0, mainAxis: l = !0, crossAxis: u = !0 } = evaluate(e, t), d = {
				x: n,
				y: i
			}, f = getSideAxis(a), p = getOppositeAxis(f), m = d[p], h = d[f], g = evaluate(c, t), _ = typeof g == "number" ? {
				mainAxis: g,
				crossAxis: 0
			} : {
				mainAxis: 0,
				crossAxis: 0,
				...g
			};
			if (l) {
				let e = p === "y" ? "height" : "width", t = o.reference[p] - o.floating[e] + _.mainAxis, n = o.reference[p] + o.reference[e] - _.mainAxis;
				m < t ? m = t : m > n && (m = n);
			}
			if (u) {
				let e = p === "y" ? "width" : "height", t = originSides.has(getSide(a)), n = o.reference[f] - o.floating[e] + (t && s.offset?.[f] || 0) + (t ? 0 : _.crossAxis), i = o.reference[f] + o.reference[e] + (t ? 0 : s.offset?.[f] || 0) - (t ? _.crossAxis : 0);
				h < n ? h = n : h > i && (h = i);
			}
			return {
				[p]: m,
				[f]: h
			};
		}
	};
}, size$2 = function(e) {
	return e === void 0 && (e = {}), {
		name: "size",
		options: e,
		async fn(t) {
			var n, i;
			let { placement: a, rects: o, platform: s, elements: c } = t, { apply: l = () => {},...u } = evaluate(e, t), d = await detectOverflow$1(t, u), f = getSide(a), p = getAlignment(a), m = getSideAxis(a) === "y", { width: h, height: g } = o.floating, _, v;
			f === "top" || f === "bottom" ? (_ = f, v = p === (await (s.isRTL == null ? void 0 : s.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (v = f, _ = p === "end" ? "top" : "bottom");
			let y = g - d.top - d.bottom, b = h - d.left - d.right, x = min$1(g - d[_], y), S = min$1(h - d[v], b), C = !t.middlewareData.shift, w = x, T = S;
			if ((n = t.middlewareData.shift) != null && n.enabled.x && (T = b), (i = t.middlewareData.shift) != null && i.enabled.y && (w = y), C && !p) {
				let e = max$1(d.left, 0), t = max$1(d.right, 0), n = max$1(d.top, 0), i = max$1(d.bottom, 0);
				m ? T = h - 2 * (e !== 0 || t !== 0 ? e + t : max$1(d.left, d.right)) : w = g - 2 * (n !== 0 || i !== 0 ? n + i : max$1(d.top, d.bottom));
			}
			await l({
				...t,
				availableWidth: T,
				availableHeight: w
			});
			let E = await s.getDimensions(c.floating);
			return h !== E.width || g !== E.height ? { reset: { rects: !0 } } : {};
		}
	};
};
function hasWindow() {
	return typeof window < "u";
}
function getNodeName(e) {
	return isNode(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function getWindow(e) {
	var t;
	return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function getDocumentElement(e) {
	return ((isNode(e) ? e.ownerDocument : e.document) || window.document)?.documentElement;
}
function isNode(e) {
	return hasWindow() ? e instanceof Node || e instanceof getWindow(e).Node : !1;
}
function isElement(e) {
	return hasWindow() ? e instanceof Element || e instanceof getWindow(e).Element : !1;
}
function isHTMLElement(e) {
	return hasWindow() ? e instanceof HTMLElement || e instanceof getWindow(e).HTMLElement : !1;
}
function isShadowRoot(e) {
	return !hasWindow() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof getWindow(e).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(e) {
	let { overflow: t, overflowX: n, overflowY: i, display: a } = getComputedStyle$1(e);
	return /auto|scroll|overlay|hidden|clip/.test(t + i + n) && !invalidOverflowDisplayValues.has(a);
}
var tableElements = /* @__PURE__ */ new Set([
	"table",
	"td",
	"th"
]);
function isTableElement(e) {
	return tableElements.has(getNodeName(e));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(e) {
	return topLayerSelectors.some((t) => {
		try {
			return e.matches(t);
		} catch {
			return !1;
		}
	});
}
var transformProperties = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective"
], willChangeValues = [
	"transform",
	"translate",
	"scale",
	"rotate",
	"perspective",
	"filter"
], containValues = [
	"paint",
	"layout",
	"strict",
	"content"
];
function isContainingBlock(e) {
	let t = isWebKit(), n = isElement(e) ? getComputedStyle$1(e) : e;
	return transformProperties.some((e) => n[e] ? n[e] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || willChangeValues.some((e) => (n.willChange || "").includes(e)) || containValues.some((e) => (n.contain || "").includes(e));
}
function getContainingBlock(e) {
	let t = getParentNode(e);
	for (; isHTMLElement(t) && !isLastTraversableNode(t);) {
		if (isContainingBlock(t)) return t;
		if (isTopLayer(t)) return null;
		t = getParentNode(t);
	}
	return null;
}
function isWebKit() {
	return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set([
	"html",
	"body",
	"#document"
]);
function isLastTraversableNode(e) {
	return lastTraversableNodeNames.has(getNodeName(e));
}
function getComputedStyle$1(e) {
	return getWindow(e).getComputedStyle(e);
}
function getNodeScroll(e) {
	return isElement(e) ? {
		scrollLeft: e.scrollLeft,
		scrollTop: e.scrollTop
	} : {
		scrollLeft: e.scrollX,
		scrollTop: e.scrollY
	};
}
function getParentNode(e) {
	if (getNodeName(e) === "html") return e;
	let t = e.assignedSlot || e.parentNode || isShadowRoot(e) && e.host || getDocumentElement(e);
	return isShadowRoot(t) ? t.host : t;
}
function getNearestOverflowAncestor(e) {
	let t = getParentNode(e);
	return isLastTraversableNode(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : isHTMLElement(t) && isOverflowElement(t) ? t : getNearestOverflowAncestor(t);
}
function getOverflowAncestors(e, t, n) {
	t === void 0 && (t = []), n === void 0 && (n = !0);
	let i = getNearestOverflowAncestor(e), a = i === e.ownerDocument?.body, o = getWindow(i);
	if (a) {
		let e = getFrameElement(o);
		return t.concat(o, o.visualViewport || [], isOverflowElement(i) ? i : [], e && n ? getOverflowAncestors(e) : []);
	}
	return t.concat(i, getOverflowAncestors(i, [], n));
}
function getFrameElement(e) {
	return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function getCssDimensions(e) {
	let t = getComputedStyle$1(e), n = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0, a = isHTMLElement(e), o = a ? e.offsetWidth : n, s = a ? e.offsetHeight : i, c = round(n) !== o || round(i) !== s;
	return c && (n = o, i = s), {
		width: n,
		height: i,
		$: c
	};
}
function unwrapElement(e) {
	return isElement(e) ? e : e.contextElement;
}
function getScale(e) {
	let t = unwrapElement(e);
	if (!isHTMLElement(t)) return createCoords(1);
	let n = t.getBoundingClientRect(), { width: i, height: a, $: o } = getCssDimensions(t), s = (o ? round(n.width) : n.width) / i, c = (o ? round(n.height) : n.height) / a;
	return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
		x: s,
		y: c
	};
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(e) {
	let t = getWindow(e);
	return !isWebKit() || !t.visualViewport ? noOffsets : {
		x: t.visualViewport.offsetLeft,
		y: t.visualViewport.offsetTop
	};
}
function shouldAddVisualOffsets(e, t, n) {
	return t === void 0 && (t = !1), !n || t && n !== getWindow(e) ? !1 : t;
}
function getBoundingClientRect(e, t, n, i) {
	t === void 0 && (t = !1), n === void 0 && (n = !1);
	let a = e.getBoundingClientRect(), o = unwrapElement(e), s = createCoords(1);
	t && (i ? isElement(i) && (s = getScale(i)) : s = getScale(e));
	let c = shouldAddVisualOffsets(o, n, i) ? getVisualOffsets(o) : createCoords(0), l = (a.left + c.x) / s.x, u = (a.top + c.y) / s.y, d = a.width / s.x, f = a.height / s.y;
	if (o) {
		let e = getWindow(o), t = i && isElement(i) ? getWindow(i) : i, n = e, a = getFrameElement(n);
		for (; a && i && t !== n;) {
			let e = getScale(a), t = a.getBoundingClientRect(), i = getComputedStyle$1(a), o = t.left + (a.clientLeft + parseFloat(i.paddingLeft)) * e.x, s = t.top + (a.clientTop + parseFloat(i.paddingTop)) * e.y;
			l *= e.x, u *= e.y, d *= e.x, f *= e.y, l += o, u += s, n = getWindow(a), a = getFrameElement(n);
		}
	}
	return rectToClientRect({
		width: d,
		height: f,
		x: l,
		y: u
	});
}
function getWindowScrollBarX(e, t) {
	let n = getNodeScroll(e).scrollLeft;
	return t ? t.left + n : getBoundingClientRect(getDocumentElement(e)).left + n;
}
function getHTMLOffset(e, t) {
	let n = e.getBoundingClientRect(), i = n.left + t.scrollLeft - getWindowScrollBarX(e, n), a = n.top + t.scrollTop;
	return {
		x: i,
		y: a
	};
}
function convertOffsetParentRelativeRectToViewportRelativeRect(e) {
	let { elements: t, rect: n, offsetParent: i, strategy: a } = e, o = a === "fixed", s = getDocumentElement(i), c = t ? isTopLayer(t.floating) : !1;
	if (i === s || c && o) return n;
	let l = {
		scrollLeft: 0,
		scrollTop: 0
	}, u = createCoords(1), d = createCoords(0), f = isHTMLElement(i);
	if ((f || !f && !o) && ((getNodeName(i) !== "body" || isOverflowElement(s)) && (l = getNodeScroll(i)), isHTMLElement(i))) {
		let e = getBoundingClientRect(i);
		u = getScale(i), d.x = e.x + i.clientLeft, d.y = e.y + i.clientTop;
	}
	let p = s && !f && !o ? getHTMLOffset(s, l) : createCoords(0);
	return {
		width: n.width * u.x,
		height: n.height * u.y,
		x: n.x * u.x - l.scrollLeft * u.x + d.x + p.x,
		y: n.y * u.y - l.scrollTop * u.y + d.y + p.y
	};
}
function getClientRects(e) {
	return Array.from(e.getClientRects());
}
function getDocumentRect(e) {
	let t = getDocumentElement(e), n = getNodeScroll(e), i = e.ownerDocument.body, a = max$1(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), o = max$1(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight), s = -n.scrollLeft + getWindowScrollBarX(e), c = -n.scrollTop;
	return getComputedStyle$1(i).direction === "rtl" && (s += max$1(t.clientWidth, i.clientWidth) - a), {
		width: a,
		height: o,
		x: s,
		y: c
	};
}
var SCROLLBAR_MAX = 25;
function getViewportRect(e, t) {
	let n = getWindow(e), i = getDocumentElement(e), a = n.visualViewport, o = i.clientWidth, s = i.clientHeight, c = 0, l = 0;
	if (a) {
		o = a.width, s = a.height;
		let e = isWebKit();
		(!e || e && t === "fixed") && (c = a.offsetLeft, l = a.offsetTop);
	}
	let u = getWindowScrollBarX(i);
	if (u <= 0) {
		let e = i.ownerDocument, t = e.body, n = getComputedStyle(t), a = e.compatMode === "CSS1Compat" && parseFloat(n.marginLeft) + parseFloat(n.marginRight) || 0, s = Math.abs(i.clientWidth - t.clientWidth - a);
		s <= SCROLLBAR_MAX && (o -= s);
	} else u <= SCROLLBAR_MAX && (o += u);
	return {
		width: o,
		height: s,
		x: c,
		y: l
	};
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(e, t) {
	let n = getBoundingClientRect(e, !0, t === "fixed"), i = n.top + e.clientTop, a = n.left + e.clientLeft, o = isHTMLElement(e) ? getScale(e) : createCoords(1), s = e.clientWidth * o.x, c = e.clientHeight * o.y, l = a * o.x, u = i * o.y;
	return {
		width: s,
		height: c,
		x: l,
		y: u
	};
}
function getClientRectFromClippingAncestor(e, t, n) {
	let i;
	if (t === "viewport") i = getViewportRect(e, n);
	else if (t === "document") i = getDocumentRect(getDocumentElement(e));
	else if (isElement(t)) i = getInnerBoundingClientRect(t, n);
	else {
		let n = getVisualOffsets(e);
		i = {
			x: t.x - n.x,
			y: t.y - n.y,
			width: t.width,
			height: t.height
		};
	}
	return rectToClientRect(i);
}
function hasFixedPositionAncestor(e, t) {
	let n = getParentNode(e);
	return n === t || !isElement(n) || isLastTraversableNode(n) ? !1 : getComputedStyle$1(n).position === "fixed" || hasFixedPositionAncestor(n, t);
}
function getClippingElementAncestors(e, t) {
	let n = t.get(e);
	if (n) return n;
	let i = getOverflowAncestors(e, [], !1).filter((e) => isElement(e) && getNodeName(e) !== "body"), a = null, o = getComputedStyle$1(e).position === "fixed", s = o ? getParentNode(e) : e;
	for (; isElement(s) && !isLastTraversableNode(s);) {
		let t = getComputedStyle$1(s), n = isContainingBlock(s);
		!n && t.position === "fixed" && (a = null), (o ? !n && !a : !n && t.position === "static" && a && absoluteOrFixed.has(a.position) || isOverflowElement(s) && !n && hasFixedPositionAncestor(e, s)) ? i = i.filter((e) => e !== s) : a = t, s = getParentNode(s);
	}
	return t.set(e, i), i;
}
function getClippingRect(e) {
	let { element: t, boundary: n, rootBoundary: i, strategy: a } = e, o = [...n === "clippingAncestors" ? isTopLayer(t) ? [] : getClippingElementAncestors(t, this._c) : [].concat(n), i], s = o[0], c = o.reduce((e, n) => {
		let i = getClientRectFromClippingAncestor(t, n, a);
		return e.top = max$1(i.top, e.top), e.right = min$1(i.right, e.right), e.bottom = min$1(i.bottom, e.bottom), e.left = max$1(i.left, e.left), e;
	}, getClientRectFromClippingAncestor(t, s, a));
	return {
		width: c.right - c.left,
		height: c.bottom - c.top,
		x: c.left,
		y: c.top
	};
}
function getDimensions(e) {
	let { width: t, height: n } = getCssDimensions(e);
	return {
		width: t,
		height: n
	};
}
function getRectRelativeToOffsetParent(e, t, n) {
	let i = isHTMLElement(t), a = getDocumentElement(t), o = n === "fixed", s = getBoundingClientRect(e, !0, o, t), c = {
		scrollLeft: 0,
		scrollTop: 0
	}, l = createCoords(0);
	function u() {
		l.x = getWindowScrollBarX(a);
	}
	if (i || !i && !o) if ((getNodeName(t) !== "body" || isOverflowElement(a)) && (c = getNodeScroll(t)), i) {
		let e = getBoundingClientRect(t, !0, o, t);
		l.x = e.x + t.clientLeft, l.y = e.y + t.clientTop;
	} else a && u();
	o && !i && a && u();
	let d = a && !i && !o ? getHTMLOffset(a, c) : createCoords(0), f = s.left + c.scrollLeft - l.x - d.x, p = s.top + c.scrollTop - l.y - d.y;
	return {
		x: f,
		y: p,
		width: s.width,
		height: s.height
	};
}
function isStaticPositioned(e) {
	return getComputedStyle$1(e).position === "static";
}
function getTrueOffsetParent(e, t) {
	if (!isHTMLElement(e) || getComputedStyle$1(e).position === "fixed") return null;
	if (t) return t(e);
	let n = e.offsetParent;
	return getDocumentElement(e) === n && (n = n.ownerDocument.body), n;
}
function getOffsetParent(e, t) {
	let n = getWindow(e);
	if (isTopLayer(e)) return n;
	if (!isHTMLElement(e)) {
		let t = getParentNode(e);
		for (; t && !isLastTraversableNode(t);) {
			if (isElement(t) && !isStaticPositioned(t)) return t;
			t = getParentNode(t);
		}
		return n;
	}
	let i = getTrueOffsetParent(e, t);
	for (; i && isTableElement(i) && isStaticPositioned(i);) i = getTrueOffsetParent(i, t);
	return i && isLastTraversableNode(i) && isStaticPositioned(i) && !isContainingBlock(i) ? n : i || getContainingBlock(e) || n;
}
var getElementRects = async function(e) {
	let t = this.getOffsetParent || getOffsetParent, n = this.getDimensions, i = await n(e.floating);
	return {
		reference: getRectRelativeToOffsetParent(e.reference, await t(e.floating), e.strategy),
		floating: {
			x: 0,
			y: 0,
			width: i.width,
			height: i.height
		}
	};
};
function isRTL(e) {
	return getComputedStyle$1(e).direction === "rtl";
}
var platform = {
	convertOffsetParentRelativeRectToViewportRelativeRect,
	getDocumentElement,
	getClippingRect,
	getOffsetParent,
	getElementRects,
	getClientRects,
	getDimensions,
	getScale,
	isElement,
	isRTL
};
function rectsAreEqual(e, t) {
	return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function observeMove(e, t) {
	let n = null, i, a = getDocumentElement(e);
	function o() {
		var e;
		clearTimeout(i), (e = n) == null || e.disconnect(), n = null;
	}
	function s(c, l) {
		c === void 0 && (c = !1), l === void 0 && (l = 1), o();
		let u = e.getBoundingClientRect(), { left: d, top: f, width: p, height: m } = u;
		if (c || t(), !p || !m) return;
		let h = floor(f), g = floor(a.clientWidth - (d + p)), _ = floor(a.clientHeight - (f + m)), v = floor(d), y = {
			rootMargin: -h + "px " + -g + "px " + -_ + "px " + -v + "px",
			threshold: max$1(0, min$1(1, l)) || 1
		}, b = !0;
		function x(t) {
			let n = t[0].intersectionRatio;
			if (n !== l) {
				if (!b) return s();
				n ? s(!1, n) : i = setTimeout(() => {
					s(!1, 1e-7);
				}, 1e3);
			}
			n === 1 && !rectsAreEqual(u, e.getBoundingClientRect()) && s(), b = !1;
		}
		try {
			n = new IntersectionObserver(x, {
				...y,
				root: a.ownerDocument
			});
		} catch {
			n = new IntersectionObserver(x, y);
		}
		n.observe(e);
	}
	return s(!0), o;
}
function autoUpdate(e, t, n, i) {
	i === void 0 && (i = {});
	let { ancestorScroll: a = !0, ancestorResize: o = !0, elementResize: s = typeof ResizeObserver == "function", layoutShift: c = typeof IntersectionObserver == "function", animationFrame: l = !1 } = i, u = unwrapElement(e), d = a || o ? [...u ? getOverflowAncestors(u) : [], ...getOverflowAncestors(t)] : [];
	d.forEach((e) => {
		a && e.addEventListener("scroll", n, { passive: !0 }), o && e.addEventListener("resize", n);
	});
	let f = u && c ? observeMove(u, n) : null, p = -1, m = null;
	s && (m = new ResizeObserver((e) => {
		let [i] = e;
		i && i.target === u && m && (m.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
			var e;
			(e = m) == null || e.observe(t);
		})), n();
	}), u && !l && m.observe(u), m.observe(t));
	let h, g = l ? getBoundingClientRect(e) : null;
	l && _();
	function _() {
		let t = getBoundingClientRect(e);
		g && !rectsAreEqual(g, t) && n(), g = t, h = requestAnimationFrame(_);
	}
	return n(), () => {
		var e;
		d.forEach((e) => {
			a && e.removeEventListener("scroll", n), o && e.removeEventListener("resize", n);
		}), f?.(), (e = m) == null || e.disconnect(), m = null, l && cancelAnimationFrame(h);
	};
}
var offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, hide$1 = hide$2, arrow$1 = arrow$2, limitShift$1 = limitShift$2, computePosition = (e, t, n) => {
	let i = /* @__PURE__ */ new Map(), a = {
		platform,
		...n
	}, o = {
		...a.platform,
		_c: i
	};
	return computePosition$1(e, t, {
		...a,
		platform: o
	});
}, import_react_dom$2 = /* @__PURE__ */ __toESM(require_react_dom(), 1), index = typeof document < "u" ? import_react.useLayoutEffect : function() {};
function deepEqual(e, t) {
	if (e === t) return !0;
	if (typeof e != typeof t) return !1;
	if (typeof e == "function" && e.toString() === t.toString()) return !0;
	let n, i, a;
	if (e && t && typeof e == "object") {
		if (Array.isArray(e)) {
			if (n = e.length, n !== t.length) return !1;
			for (i = n; i-- !== 0;) if (!deepEqual(e[i], t[i])) return !1;
			return !0;
		}
		if (a = Object.keys(e), n = a.length, n !== Object.keys(t).length) return !1;
		for (i = n; i-- !== 0;) if (!{}.hasOwnProperty.call(t, a[i])) return !1;
		for (i = n; i-- !== 0;) {
			let n = a[i];
			if (!(n === "_owner" && e.$$typeof) && !deepEqual(e[n], t[n])) return !1;
		}
		return !0;
	}
	return e !== e && t !== t;
}
function getDPR(e) {
	return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(e, t) {
	let n = getDPR(e);
	return Math.round(t * n) / n;
}
function useLatestRef(e) {
	let t = import_react.useRef(e);
	return index(() => {
		t.current = e;
	}), t;
}
function useFloating(e) {
	e === void 0 && (e = {});
	let { placement: t = "bottom", strategy: n = "absolute", middleware: i = [], platform: a, elements: { reference: o, floating: s } = {}, transform: c = !0, whileElementsMounted: l, open: u } = e, [d, f] = import_react.useState({
		x: 0,
		y: 0,
		strategy: n,
		placement: t,
		middlewareData: {},
		isPositioned: !1
	}), [p, m] = import_react.useState(i);
	deepEqual(p, i) || m(i);
	let [h, g] = import_react.useState(null), [_, v] = import_react.useState(null), y = import_react.useCallback((e) => {
		e !== w.current && (w.current = e, g(e));
	}, []), b = import_react.useCallback((e) => {
		e !== T.current && (T.current = e, v(e));
	}, []), x = o || h, C = s || _, w = import_react.useRef(null), T = import_react.useRef(null), E = import_react.useRef(d), O = l != null, k = useLatestRef(l), A = useLatestRef(a), j = useLatestRef(u), M = import_react.useCallback(() => {
		if (!w.current || !T.current) return;
		let e = {
			placement: t,
			strategy: n,
			middleware: p
		};
		A.current && (e.platform = A.current), computePosition(w.current, T.current, e).then((e) => {
			let t = {
				...e,
				isPositioned: j.current !== !1
			};
			N.current && !deepEqual(E.current, t) && (E.current = t, import_react_dom$2.flushSync(() => {
				f(t);
			}));
		});
	}, [
		p,
		t,
		n,
		A,
		j
	]);
	index(() => {
		u === !1 && E.current.isPositioned && (E.current.isPositioned = !1, f((e) => ({
			...e,
			isPositioned: !1
		})));
	}, [u]);
	let N = import_react.useRef(!1);
	index(() => (N.current = !0, () => {
		N.current = !1;
	}), []), index(() => {
		if (x && (w.current = x), C && (T.current = C), x && C) {
			if (k.current) return k.current(x, C, M);
			M();
		}
	}, [
		x,
		C,
		M,
		k,
		O
	]);
	let P = import_react.useMemo(() => ({
		reference: w,
		floating: T,
		setReference: y,
		setFloating: b
	}), [y, b]), F = import_react.useMemo(() => ({
		reference: x,
		floating: C
	}), [x, C]), I = import_react.useMemo(() => {
		let e = {
			position: n,
			left: 0,
			top: 0
		};
		if (!F.floating) return e;
		let t = roundByDPR(F.floating, d.x), i = roundByDPR(F.floating, d.y);
		return c ? {
			...e,
			transform: "translate(" + t + "px, " + i + "px)",
			...getDPR(F.floating) >= 1.5 && { willChange: "transform" }
		} : {
			position: n,
			left: t,
			top: i
		};
	}, [
		n,
		c,
		F.floating,
		d.x,
		d.y
	]);
	return import_react.useMemo(() => ({
		...d,
		update: M,
		refs: P,
		elements: F,
		floatingStyles: I
	}), [
		d,
		M,
		P,
		F,
		I
	]);
}
var arrow$1$1 = (e) => {
	function t(e) {
		return {}.hasOwnProperty.call(e, "current");
	}
	return {
		name: "arrow",
		options: e,
		fn(n) {
			let { element: i, padding: a } = typeof e == "function" ? e(n) : e;
			return i && t(i) ? i.current == null ? {} : arrow$1({
				element: i.current,
				padding: a
			}).fn(n) : i ? arrow$1({
				element: i,
				padding: a
			}).fn(n) : {};
		}
	};
}, offset = (e, t) => ({
	...offset$1(e),
	options: [e, t]
}), shift = (e, t) => ({
	...shift$1(e),
	options: [e, t]
}), limitShift = (e, t) => ({
	...limitShift$1(e),
	options: [e, t]
}), flip = (e, t) => ({
	...flip$1(e),
	options: [e, t]
}), size = (e, t) => ({
	...size$1(e),
	options: [e, t]
}), hide = (e, t) => ({
	...hide$1(e),
	options: [e, t]
}), arrow = (e, t) => ({
	...arrow$1$1(e),
	options: [e, t]
}), NAME$2 = "Arrow", Arrow$1 = import_react.forwardRef((e, t) => {
	let { children: n, width: i = 10, height: a = 5,...o } = e;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.svg, {
		...o,
		ref: t,
		width: i,
		height: a,
		viewBox: "0 0 30 10",
		preserveAspectRatio: "none",
		children: e.asChild ? n : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("polygon", { points: "0,0 30,0 15,10" })
	});
});
Arrow$1.displayName = NAME$2;
var Root$2 = Arrow$1;
function useSize(e) {
	let [t, n] = import_react.useState(void 0);
	return useLayoutEffect2(() => {
		if (e) {
			n({
				width: e.offsetWidth,
				height: e.offsetHeight
			});
			let t = new ResizeObserver((t) => {
				if (!Array.isArray(t) || !t.length) return;
				let i = t[0], a, o;
				if ("borderBoxSize" in i) {
					let e = i.borderBoxSize, t = Array.isArray(e) ? e[0] : e;
					a = t.inlineSize, o = t.blockSize;
				} else a = e.offsetWidth, o = e.offsetHeight;
				n({
					width: a,
					height: o
				});
			});
			return t.observe(e, { box: "border-box" }), () => t.unobserve(e);
		} else n(void 0);
	}, [e]), t;
}
var POPPER_NAME = "Popper", [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME), [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME), Popper = (e) => {
	let { __scopePopper: t, children: n } = e, [i, a] = import_react.useState(null);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopperProvider, {
		scope: t,
		anchor: i,
		onAnchorChange: a,
		children: n
	});
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor", PopperAnchor = import_react.forwardRef((e, t) => {
	let { __scopePopper: n, virtualRef: i,...a } = e, o = usePopperContext(ANCHOR_NAME, n), s = import_react.useRef(null), c = useComposedRefs(t, s), l = import_react.useRef(null);
	return import_react.useEffect(() => {
		let e = l.current;
		l.current = i?.current || s.current, e !== l.current && o.onAnchorChange(l.current);
	}), i ? null : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		...a,
		ref: c
	});
});
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME$2 = "PopperContent", [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$2), PopperContent = import_react.forwardRef((e, t) => {
	let { __scopePopper: n, side: i = "bottom", sideOffset: a = 0, align: o = "center", alignOffset: s = 0, arrowPadding: c = 0, avoidCollisions: l = !0, collisionBoundary: u = [], collisionPadding: d = 0, sticky: f = "partial", hideWhenDetached: p = !1, updatePositionStrategy: m = "optimized", onPlaced: h,...g } = e, _ = usePopperContext(CONTENT_NAME$2, n), [v, y] = import_react.useState(null), b = useComposedRefs(t, (e) => y(e)), [x, C] = import_react.useState(null), w = useSize(x), T = w?.width ?? 0, E = w?.height ?? 0, O = i + (o === "center" ? "" : "-" + o), A = typeof d == "number" ? d : {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		...d
	}, j = Array.isArray(u) ? u : [u], M = j.length > 0, N = {
		padding: A,
		boundary: j.filter(isNotNull),
		altBoundary: M
	}, { refs: P, floatingStyles: I, placement: ee, isPositioned: L, middlewareData: R } = useFloating({
		strategy: "fixed",
		placement: O,
		whileElementsMounted: (...e) => autoUpdate(...e, { animationFrame: m === "always" }),
		elements: { reference: _.anchor },
		middleware: [
			offset({
				mainAxis: a + E,
				alignmentAxis: s
			}),
			l && shift({
				mainAxis: !0,
				crossAxis: !1,
				limiter: f === "partial" ? limitShift() : void 0,
				...N
			}),
			l && flip({ ...N }),
			size({
				...N,
				apply: ({ elements: e, rects: t, availableWidth: n, availableHeight: i }) => {
					let { width: a, height: o } = t.reference, s = e.floating.style;
					s.setProperty("--radix-popper-available-width", `${n}px`), s.setProperty("--radix-popper-available-height", `${i}px`), s.setProperty("--radix-popper-anchor-width", `${a}px`), s.setProperty("--radix-popper-anchor-height", `${o}px`);
				}
			}),
			x && arrow({
				element: x,
				padding: c
			}),
			transformOrigin({
				arrowWidth: T,
				arrowHeight: E
			}),
			p && hide({
				strategy: "referenceHidden",
				...N
			})
		]
	}), [te, ne] = getSideAndAlignFromPlacement(ee), ie = useCallbackRef(h);
	useLayoutEffect2(() => {
		L && ie?.();
	}, [L, ie]);
	let ae = R.arrow?.x, oe = R.arrow?.y, z = R.arrow?.centerOffset !== 0, [ce, ue] = import_react.useState();
	return useLayoutEffect2(() => {
		v && ue(window.getComputedStyle(v).zIndex);
	}, [v]), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		ref: P.setFloating,
		"data-radix-popper-content-wrapper": "",
		style: {
			...I,
			transform: L ? I.transform : "translate(0, -200%)",
			minWidth: "max-content",
			zIndex: ce,
			"--radix-popper-transform-origin": [R.transformOrigin?.x, R.transformOrigin?.y].join(" "),
			...R.hide?.referenceHidden && {
				visibility: "hidden",
				pointerEvents: "none"
			}
		},
		dir: e.dir,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PopperContentProvider, {
			scope: n,
			placedSide: te,
			onArrowChange: C,
			arrowX: ae,
			arrowY: oe,
			shouldHideArrow: z,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
				"data-side": te,
				"data-align": ne,
				...g,
				ref: b,
				style: {
					...g.style,
					animation: L ? void 0 : "none"
				}
			})
		})
	});
});
PopperContent.displayName = CONTENT_NAME$2;
var ARROW_NAME$1 = "PopperArrow", OPPOSITE_SIDE = {
	top: "bottom",
	right: "left",
	bottom: "top",
	left: "right"
}, PopperArrow = import_react.forwardRef(function(e, t) {
	let { __scopePopper: n,...i } = e, a = useContentContext(ARROW_NAME$1, n), o = OPPOSITE_SIDE[a.placedSide];
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
		ref: a.onArrowChange,
		style: {
			position: "absolute",
			left: a.arrowX,
			top: a.arrowY,
			[o]: 0,
			transformOrigin: {
				top: "",
				right: "0 0",
				bottom: "center 0",
				left: "100% 0"
			}[a.placedSide],
			transform: {
				top: "translateY(100%)",
				right: "translateY(50%) rotate(90deg) translateX(-50%)",
				bottom: "rotate(180deg)",
				left: "translateY(50%) rotate(-90deg) translateX(50%)"
			}[a.placedSide],
			visibility: a.shouldHideArrow ? "hidden" : void 0
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Root$2, {
			...i,
			ref: t,
			style: {
				...i.style,
				display: "block"
			}
		})
	});
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(e) {
	return e !== null;
}
var transformOrigin = (e) => ({
	name: "transformOrigin",
	options: e,
	fn(t) {
		let { placement: n, rects: i, middlewareData: a } = t, o = a.arrow?.centerOffset !== 0, s = o ? 0 : e.arrowWidth, c = o ? 0 : e.arrowHeight, [l, u] = getSideAndAlignFromPlacement(n), d = {
			start: "0%",
			center: "50%",
			end: "100%"
		}[u], f = (a.arrow?.x ?? 0) + s / 2, p = (a.arrow?.y ?? 0) + c / 2, m = "", h = "";
		return l === "bottom" ? (m = o ? d : `${f}px`, h = `${-c}px`) : l === "top" ? (m = o ? d : `${f}px`, h = `${i.floating.height + c}px`) : l === "right" ? (m = `${-c}px`, h = o ? d : `${p}px`) : l === "left" && (m = `${i.floating.width + c}px`, h = o ? d : `${p}px`), { data: {
			x: m,
			y: h
		} };
	}
});
function getSideAndAlignFromPlacement(e) {
	let [t, n = "center"] = e.split("-");
	return [t, n];
}
var Root2$1 = Popper, Anchor = PopperAnchor, Content$1 = PopperContent, Arrow = PopperArrow, import_react_dom$1 = /* @__PURE__ */ __toESM(require_react_dom(), 1), PORTAL_NAME$2 = "Portal", Portal = import_react.forwardRef((e, t) => {
	let { container: n,...i } = e, [a, o] = import_react.useState(!1);
	useLayoutEffect2(() => o(!0), []);
	let s = n || a && globalThis?.document?.body;
	return s ? import_react_dom$1.createPortal(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		...i,
		ref: t
	}), s) : null;
});
Portal.displayName = PORTAL_NAME$2;
var useInsertionEffect = import_react.useInsertionEffect || useLayoutEffect2;
function useControllableState({ prop: e, defaultProp: t, onChange: n = () => {}, caller: i }) {
	let [a, o, s] = useUncontrolledState({
		defaultProp: t,
		onChange: n
	}), c = e !== void 0, l = c ? e : a;
	{
		let t = import_react.useRef(e !== void 0);
		import_react.useEffect(() => {
			let e = t.current;
			if (e !== c) {
				let t = e ? "controlled" : "uncontrolled", n = c ? "controlled" : "uncontrolled";
				console.warn(`${i} is changing from ${t} to ${n}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`);
			}
			t.current = c;
		}, [c, i]);
	}
	let u = import_react.useCallback((t) => {
		if (c) {
			let n = isFunction$1(t) ? t(e) : t;
			n !== e && s.current?.(n);
		} else o(t);
	}, [
		c,
		e,
		o,
		s
	]);
	return [l, u];
}
function useUncontrolledState({ defaultProp: e, onChange: t }) {
	let [n, i] = import_react.useState(e), a = import_react.useRef(n), o = import_react.useRef(t);
	return useInsertionEffect(() => {
		o.current = t;
	}, [t]), import_react.useEffect(() => {
		a.current !== n && (o.current?.(n), a.current = n);
	}, [n, a]), [
		n,
		i,
		o
	];
}
function isFunction$1(e) {
	return typeof e == "function";
}
function usePrevious(e) {
	let t = import_react.useRef({
		value: e,
		previous: e
	});
	return import_react.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
	position: "absolute",
	border: 0,
	width: 1,
	height: 1,
	padding: 0,
	margin: -1,
	overflow: "hidden",
	clip: "rect(0, 0, 0, 0)",
	whiteSpace: "nowrap",
	wordWrap: "normal"
}), NAME$1 = "VisuallyHidden", VisuallyHidden = import_react.forwardRef((e, t) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.span, {
	...e,
	ref: t,
	style: {
		...VISUALLY_HIDDEN_STYLES,
		...e.style
	}
}));
VisuallyHidden.displayName = NAME$1;
var getDefaultParent = function(e) {
	return typeof document > "u" ? null : (Array.isArray(e) ? e[0] : e).ownerDocument.body;
}, counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {}, lockCount = 0, unwrapHost = function(e) {
	return e && (e.host || unwrapHost(e.parentNode));
}, correctTargets = function(e, t) {
	return t.map(function(t) {
		if (e.contains(t)) return t;
		var n = unwrapHost(t);
		return n && e.contains(n) ? n : (console.error("aria-hidden", t, "in not contained inside", e, ". Doing nothing"), null);
	}).filter(function(e) {
		return !!e;
	});
}, applyAttributeToOthers = function(e, t, n, i) {
	var a = correctTargets(t, Array.isArray(e) ? e : [e]);
	markerMap[n] || (markerMap[n] = /* @__PURE__ */ new WeakMap());
	var o = markerMap[n], s = [], c = /* @__PURE__ */ new Set(), l = new Set(a), u = function(e) {
		!e || c.has(e) || (c.add(e), u(e.parentNode));
	};
	a.forEach(u);
	var d = function(e) {
		!e || l.has(e) || Array.prototype.forEach.call(e.children, function(e) {
			if (c.has(e)) d(e);
			else try {
				var t = e.getAttribute(i), a = t !== null && t !== "false", l = (counterMap.get(e) || 0) + 1, u = (o.get(e) || 0) + 1;
				counterMap.set(e, l), o.set(e, u), s.push(e), l === 1 && a && uncontrolledNodes.set(e, !0), u === 1 && e.setAttribute(n, "true"), a || e.setAttribute(i, "true");
			} catch (t) {
				console.error("aria-hidden: cannot operate on ", e, t);
			}
		});
	};
	return d(t), c.clear(), lockCount++, function() {
		s.forEach(function(e) {
			var t = counterMap.get(e) - 1, a = o.get(e) - 1;
			counterMap.set(e, t), o.set(e, a), t || (uncontrolledNodes.has(e) || e.removeAttribute(i), uncontrolledNodes.delete(e)), a || e.removeAttribute(n);
		}), lockCount--, lockCount || (counterMap = /* @__PURE__ */ new WeakMap(), counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {});
	};
}, hideOthers = function(e, t, n) {
	n === void 0 && (n = "data-aria-hidden");
	var i = Array.from(Array.isArray(e) ? e : [e]), a = t || getDefaultParent(e);
	return a ? (i.push.apply(i, Array.from(a.querySelectorAll("[aria-live], script"))), applyAttributeToOthers(i, a, n, "aria-hidden")) : function() {
		return null;
	};
}, __assign = function() {
	return __assign = Object.assign || function(e) {
		for (var t, n = 1, i = arguments.length; n < i; n++) for (var a in t = arguments[n], t) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
		return e;
	}, __assign.apply(this, arguments);
};
function __rest(e, t) {
	var n = {};
	for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (n[i] = e[i]);
	if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, i = Object.getOwnPropertySymbols(e); a < i.length; a++) t.indexOf(i[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[a]) && (n[i[a]] = e[i[a]]);
	return n;
}
function __spreadArray(e, t, n) {
	if (n || arguments.length === 2) for (var i = 0, a = t.length, o; i < a; i++) (o || !(i in t)) && (o ||= Array.prototype.slice.call(t, 0, i), o[i] = t[i]);
	return e.concat(o || Array.prototype.slice.call(t));
}
var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(e, t) {
	return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function useCallbackRef$1(e, t) {
	var n = (0, import_react.useState)(function() {
		return {
			value: e,
			callback: t,
			facade: {
				get current() {
					return n.value;
				},
				set current(e) {
					var t = n.value;
					t !== e && (n.value = e, n.callback(e, t));
				}
			}
		};
	})[0];
	return n.callback = t, n.facade;
}
var useIsomorphicLayoutEffect = typeof window < "u" ? import_react.useLayoutEffect : import_react.useEffect, currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(e, t) {
	var n = useCallbackRef$1(t || null, function(t) {
		return e.forEach(function(e) {
			return assignRef(e, t);
		});
	});
	return useIsomorphicLayoutEffect(function() {
		var t = currentValues.get(n);
		if (t) {
			var i = new Set(t), a = new Set(e), o = n.current;
			i.forEach(function(e) {
				a.has(e) || assignRef(e, null);
			}), a.forEach(function(e) {
				i.has(e) || assignRef(e, o);
			});
		}
		currentValues.set(n, e);
	}, [e]), n;
}
function ItoI(e) {
	return e;
}
function innerCreateMedium(e, t) {
	t === void 0 && (t = ItoI);
	var n = [], i = !1;
	return {
		read: function() {
			if (i) throw Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
			return n.length ? n[n.length - 1] : e;
		},
		useMedium: function(e) {
			var a = t(e, i);
			return n.push(a), function() {
				n = n.filter(function(e) {
					return e !== a;
				});
			};
		},
		assignSyncMedium: function(e) {
			for (i = !0; n.length;) {
				var t = n;
				n = [], t.forEach(e);
			}
			n = {
				push: function(t) {
					return e(t);
				},
				filter: function() {
					return n;
				}
			};
		},
		assignMedium: function(e) {
			i = !0;
			var t = [];
			if (n.length) {
				var a = n;
				n = [], a.forEach(e), t = n;
			}
			var o = function() {
				var n = t;
				t = [], n.forEach(e);
			}, s = function() {
				return Promise.resolve().then(o);
			};
			s(), n = {
				push: function(e) {
					t.push(e), s();
				},
				filter: function(e) {
					return t = t.filter(e), n;
				}
			};
		}
	};
}
function createSidecarMedium(e) {
	e === void 0 && (e = {});
	var t = innerCreateMedium(null);
	return t.options = __assign({
		async: !0,
		ssr: !1
	}, e), t;
}
var SideCar = function(e) {
	var t = e.sideCar, n = __rest(e, ["sideCar"]);
	if (!t) throw Error("Sidecar: please provide `sideCar` property to import the right car");
	var i = t.read();
	if (!i) throw Error("Sidecar medium not found");
	return import_react.createElement(i, __assign({}, n));
};
SideCar.isSideCarExport = !0;
function exportSidecar(e, t) {
	return e.useMedium(t), SideCar;
}
var effectCar = createSidecarMedium(), nothing = function() {}, RemoveScroll = import_react.forwardRef(function(e, t) {
	var n = import_react.useRef(null), i = import_react.useState({
		onScrollCapture: nothing,
		onWheelCapture: nothing,
		onTouchMoveCapture: nothing
	}), a = i[0], o = i[1], s = e.forwardProps, c = e.children, l = e.className, u = e.removeScrollBar, d = e.enabled, f = e.shards, p = e.sideCar, m = e.noRelative, h = e.noIsolation, g = e.inert, _ = e.allowPinchZoom, v = e.as, y = v === void 0 ? "div" : v, b = e.gapMode, x = __rest(e, [
		"forwardProps",
		"children",
		"className",
		"removeScrollBar",
		"enabled",
		"shards",
		"sideCar",
		"noRelative",
		"noIsolation",
		"inert",
		"allowPinchZoom",
		"as",
		"gapMode"
	]), C = p, w = useMergeRefs([n, t]), T = __assign(__assign({}, x), a);
	return import_react.createElement(import_react.Fragment, null, d && import_react.createElement(C, {
		sideCar: effectCar,
		removeScrollBar: u,
		shards: f,
		noRelative: m,
		noIsolation: h,
		inert: g,
		setCallbacks: o,
		allowPinchZoom: !!_,
		lockRef: n,
		gapMode: b
	}), s ? import_react.cloneElement(import_react.Children.only(c), __assign(__assign({}, T), { ref: w })) : import_react.createElement(y, __assign({}, T, {
		className: l,
		ref: w
	}), c));
});
RemoveScroll.defaultProps = {
	enabled: !0,
	removeScrollBar: !0,
	inert: !1
}, RemoveScroll.classNames = {
	fullWidth: fullWidthClassName,
	zeroRight: zeroRightClassName
};
var currentNonce, getNonce = function() {
	if (currentNonce) return currentNonce;
	if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
};
function makeStyleTag() {
	if (!document) return null;
	var e = document.createElement("style");
	e.type = "text/css";
	var t = getNonce();
	return t && e.setAttribute("nonce", t), e;
}
function injectStyles(e, t) {
	e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function insertStyleTag(e) {
	(document.head || document.getElementsByTagName("head")[0]).appendChild(e);
}
var stylesheetSingleton = function() {
	var e = 0, t = null;
	return {
		add: function(n) {
			e == 0 && (t = makeStyleTag()) && (injectStyles(t, n), insertStyleTag(t)), e++;
		},
		remove: function() {
			e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
		}
	};
}, styleHookSingleton = function() {
	var e = stylesheetSingleton();
	return function(t, n) {
		import_react.useEffect(function() {
			return e.add(t), function() {
				e.remove();
			};
		}, [t && n]);
	};
}, styleSingleton = function() {
	var e = styleHookSingleton();
	return function(t) {
		var n = t.styles, i = t.dynamic;
		return e(n, i), null;
	};
}, zeroGap = {
	left: 0,
	top: 0,
	right: 0,
	gap: 0
}, parse = function(e) {
	return parseInt(e || "", 10) || 0;
}, getOffset = function(e) {
	var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], i = t[e === "padding" ? "paddingTop" : "marginTop"], a = t[e === "padding" ? "paddingRight" : "marginRight"];
	return [
		parse(n),
		parse(i),
		parse(a)
	];
}, getGapWidth = function(e) {
	if (e === void 0 && (e = "margin"), typeof window > "u") return zeroGap;
	var t = getOffset(e), n = document.documentElement.clientWidth, i = window.innerWidth;
	return {
		left: t[0],
		top: t[1],
		right: t[2],
		gap: Math.max(0, i - n + t[2] - t[0])
	};
}, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = function(e, t, n, i) {
	var a = e.left, o = e.top, s = e.right, c = e.gap;
	return n === void 0 && (n = "margin"), `
  .${noScrollbarsClassName} {
   overflow: hidden ${i};
   padding-right: ${c}px ${i};
  }
  body[${lockAttribute}] {
    overflow: hidden ${i};
    overscroll-behavior: contain;
    ${[
		t && `position: relative ${i};`,
		n === "margin" && `
    padding-left: ${a}px;
    padding-top: ${o}px;
    padding-right: ${s}px;
    margin-left:0;
    margin-top:0;
    margin-right: ${c}px ${i};
    `,
		n === "padding" && `padding-right: ${c}px ${i};`
	].filter(Boolean).join("")}
  }
  
  .${zeroRightClassName} {
    right: ${c}px ${i};
  }
  
  .${fullWidthClassName} {
    margin-right: ${c}px ${i};
  }
  
  .${zeroRightClassName} .${zeroRightClassName} {
    right: 0 ${i};
  }
  
  .${fullWidthClassName} .${fullWidthClassName} {
    margin-right: 0 ${i};
  }
  
  body[${lockAttribute}] {
    ${removedBarSizeVariable}: ${c}px;
  }
`;
}, getCurrentUseCounter = function() {
	var e = parseInt(document.body.getAttribute("data-scroll-locked") || "0", 10);
	return isFinite(e) ? e : 0;
}, useLockAttribute = function() {
	import_react.useEffect(function() {
		return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function() {
			var e = getCurrentUseCounter() - 1;
			e <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, e.toString());
		};
	}, []);
}, RemoveScrollBar = function(e) {
	var t = e.noRelative, n = e.noImportant, i = e.gapMode, a = i === void 0 ? "margin" : i;
	useLockAttribute();
	var o = import_react.useMemo(function() {
		return getGapWidth(a);
	}, [a]);
	return import_react.createElement(Style, { styles: getStyles(o, !t, a, n ? "" : "!important") });
}, passiveSupported$1 = !1;
if (typeof window < "u") try {
	var options = Object.defineProperty({}, "passive", { get: function() {
		return passiveSupported$1 = !0, !0;
	} });
	window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
} catch {
	passiveSupported$1 = !1;
}
var nonPassive = passiveSupported$1 ? { passive: !1 } : !1, alwaysContainsScroll = function(e) {
	return e.tagName === "TEXTAREA";
}, elementCanBeScrolled = function(e, t) {
	if (!(e instanceof Element)) return !1;
	var n = window.getComputedStyle(e);
	return n[t] !== "hidden" && !(n.overflowY === n.overflowX && !alwaysContainsScroll(e) && n[t] === "visible");
}, elementCouldBeVScrolled = function(e) {
	return elementCanBeScrolled(e, "overflowY");
}, elementCouldBeHScrolled = function(e) {
	return elementCanBeScrolled(e, "overflowX");
}, locationCouldBeScrolled = function(e, t) {
	var n = t.ownerDocument, i = t;
	do {
		if (typeof ShadowRoot < "u" && i instanceof ShadowRoot && (i = i.host), elementCouldBeScrolled(e, i)) {
			var a = getScrollVariables(e, i), o = a[1], s = a[2];
			if (o > s) return !0;
		}
		i = i.parentNode;
	} while (i && i !== n.body);
	return !1;
}, getVScrollVariables = function(e) {
	var t = e.scrollTop, n = e.scrollHeight, i = e.clientHeight;
	return [
		t,
		n,
		i
	];
}, getHScrollVariables = function(e) {
	var t = e.scrollLeft, n = e.scrollWidth, i = e.clientWidth;
	return [
		t,
		n,
		i
	];
}, elementCouldBeScrolled = function(e, t) {
	return e === "v" ? elementCouldBeVScrolled(t) : elementCouldBeHScrolled(t);
}, getScrollVariables = function(e, t) {
	return e === "v" ? getVScrollVariables(t) : getHScrollVariables(t);
}, getDirectionFactor = function(e, t) {
	return e === "h" && t === "rtl" ? -1 : 1;
}, handleScroll = function(e, t, n, i, a) {
	var o = getDirectionFactor(e, window.getComputedStyle(t).direction), s = o * i, c = n.target, l = t.contains(c), u = !1, d = s > 0, f = 0, p = 0;
	do {
		if (!c) break;
		var m = getScrollVariables(e, c), h = m[0], g = m[1], _ = m[2], v = g - _ - o * h;
		(h || v) && elementCouldBeScrolled(e, c) && (f += v, p += h);
		var y = c.parentNode;
		c = y && y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? y.host : y;
	} while (!l && c !== document.body || l && (t.contains(c) || t === c));
	return (d && (a && Math.abs(f) < 1 || !a && s > f) || !d && (a && Math.abs(p) < 1 || !a && -s > p)) && (u = !0), u;
}, getTouchXY = function(e) {
	return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, getDeltaXY = function(e) {
	return [e.deltaX, e.deltaY];
}, extractRef = function(e) {
	return e && "current" in e ? e.current : e;
}, deltaCompare = function(e, t) {
	return e[0] === t[0] && e[1] === t[1];
}, generateStyle = function(e) {
	return `
  .block-interactivity-${e} {pointer-events: none;}
  .allow-interactivity-${e} {pointer-events: all;}
`;
}, idCounter = 0, lockStack = [];
function RemoveScrollSideCar(e) {
	var t = import_react.useRef([]), n = import_react.useRef([0, 0]), i = import_react.useRef(), a = import_react.useState(idCounter++)[0], o = import_react.useState(styleSingleton)[0], s = import_react.useRef(e);
	import_react.useEffect(function() {
		s.current = e;
	}, [e]), import_react.useEffect(function() {
		if (e.inert) {
			document.body.classList.add(`block-interactivity-${a}`);
			var t = __spreadArray([e.lockRef.current], (e.shards || []).map(extractRef), !0).filter(Boolean);
			return t.forEach(function(e) {
				return e.classList.add(`allow-interactivity-${a}`);
			}), function() {
				document.body.classList.remove(`block-interactivity-${a}`), t.forEach(function(e) {
					return e.classList.remove(`allow-interactivity-${a}`);
				});
			};
		}
	}, [
		e.inert,
		e.lockRef.current,
		e.shards
	]);
	var c = import_react.useCallback(function(e, t) {
		if ("touches" in e && e.touches.length === 2 || e.type === "wheel" && e.ctrlKey) return !s.current.allowPinchZoom;
		var a = getTouchXY(e), o = n.current, c = "deltaX" in e ? e.deltaX : o[0] - a[0], l = "deltaY" in e ? e.deltaY : o[1] - a[1], u, d = e.target, f = Math.abs(c) > Math.abs(l) ? "h" : "v";
		if ("touches" in e && f === "h" && d.type === "range") return !1;
		var p = locationCouldBeScrolled(f, d);
		if (!p) return !0;
		if (p ? u = f : (u = f === "v" ? "h" : "v", p = locationCouldBeScrolled(f, d)), !p) return !1;
		if (!i.current && "changedTouches" in e && (c || l) && (i.current = u), !u) return !0;
		var m = i.current || u;
		return handleScroll(m, t, e, m === "h" ? c : l, !0);
	}, []), l = import_react.useCallback(function(e) {
		var n = e;
		if (!(!lockStack.length || lockStack[lockStack.length - 1] !== o)) {
			var i = "deltaY" in n ? getDeltaXY(n) : getTouchXY(n), a = t.current.filter(function(e) {
				return e.name === n.type && (e.target === n.target || n.target === e.shadowParent) && deltaCompare(e.delta, i);
			})[0];
			if (a && a.should) {
				n.cancelable && n.preventDefault();
				return;
			}
			if (!a) {
				var l = (s.current.shards || []).map(extractRef).filter(Boolean).filter(function(e) {
					return e.contains(n.target);
				});
				(l.length > 0 ? c(n, l[0]) : !s.current.noIsolation) && n.cancelable && n.preventDefault();
			}
		}
	}, []), u = import_react.useCallback(function(e, n, i, a) {
		var o = {
			name: e,
			delta: n,
			target: i,
			should: a,
			shadowParent: getOutermostShadowParent(i)
		};
		t.current.push(o), setTimeout(function() {
			t.current = t.current.filter(function(e) {
				return e !== o;
			});
		}, 1);
	}, []), d = import_react.useCallback(function(e) {
		n.current = getTouchXY(e), i.current = void 0;
	}, []), f = import_react.useCallback(function(t) {
		u(t.type, getDeltaXY(t), t.target, c(t, e.lockRef.current));
	}, []), p = import_react.useCallback(function(t) {
		u(t.type, getTouchXY(t), t.target, c(t, e.lockRef.current));
	}, []);
	import_react.useEffect(function() {
		return lockStack.push(o), e.setCallbacks({
			onScrollCapture: f,
			onWheelCapture: f,
			onTouchMoveCapture: p
		}), document.addEventListener("wheel", l, nonPassive), document.addEventListener("touchmove", l, nonPassive), document.addEventListener("touchstart", d, nonPassive), function() {
			lockStack = lockStack.filter(function(e) {
				return e !== o;
			}), document.removeEventListener("wheel", l, nonPassive), document.removeEventListener("touchmove", l, nonPassive), document.removeEventListener("touchstart", d, nonPassive);
		};
	}, []);
	var m = e.removeScrollBar, h = e.inert;
	return import_react.createElement(import_react.Fragment, null, h ? import_react.createElement(o, { styles: generateStyle(a) }) : null, m ? import_react.createElement(RemoveScrollBar, {
		noRelative: e.noRelative,
		gapMode: e.gapMode
	}) : null);
}
function getOutermostShadowParent(e) {
	for (var t = null; e !== null;) e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
	return t;
}
var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar), ReactRemoveScroll = import_react.forwardRef(function(e, t) {
	return import_react.createElement(RemoveScroll, __assign({}, e, {
		ref: t,
		sideCar: sidecar_default
	}));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var Combination_default = ReactRemoveScroll, import_react_dom = /* @__PURE__ */ __toESM(require_react_dom(), 1), OPEN_KEYS = [
	" ",
	"Enter",
	"ArrowUp",
	"ArrowDown"
], SELECTION_KEYS = [" ", "Enter"], SELECT_NAME = "Select", [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME), [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [createCollectionScope, createPopperScope]), usePopperScope = createPopperScope(), [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME), [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME), Select$1 = (e) => {
	let { __scopeSelect: t, children: n, open: i, defaultOpen: a, onOpenChange: o, value: s, defaultValue: c, onValueChange: l, dir: u, name: d, autoComplete: f, disabled: p, required: m, form: h } = e, g = usePopperScope(t), [_, v] = import_react.useState(null), [y, b] = import_react.useState(null), [x, C] = import_react.useState(!1), w = useDirection(u), [T, E] = useControllableState({
		prop: i,
		defaultProp: a ?? !1,
		onChange: o,
		caller: SELECT_NAME
	}), [O, A] = useControllableState({
		prop: s,
		defaultProp: c,
		onChange: l,
		caller: SELECT_NAME
	}), j = import_react.useRef(null), M = _ ? h || !!_.closest("form") : !0, [N, P] = import_react.useState(/* @__PURE__ */ new Set()), F = Array.from(N).map((e) => e.props.value).join(";");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Root2$1, {
		...g,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(SelectProvider, {
			required: m,
			scope: t,
			trigger: _,
			onTriggerChange: v,
			valueNode: y,
			onValueNodeChange: b,
			valueNodeHasChildren: x,
			onValueNodeHasChildrenChange: C,
			contentId: useId(),
			value: O,
			onValueChange: A,
			open: T,
			onOpenChange: E,
			dir: w,
			triggerPointerDownPosRef: j,
			disabled: p,
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collection.Provider, {
				scope: t,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectNativeOptionsProvider, {
					scope: e.__scopeSelect,
					onNativeOptionAdd: import_react.useCallback((e) => {
						P((t) => new Set(t).add(e));
					}, []),
					onNativeOptionRemove: import_react.useCallback((e) => {
						P((t) => {
							let n = new Set(t);
							return n.delete(e), n;
						});
					}, []),
					children: n
				})
			}), M ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(SelectBubbleInput, {
				"aria-hidden": !0,
				required: m,
				tabIndex: -1,
				name: d,
				autoComplete: f,
				value: O,
				onChange: (e) => A(e.target.value),
				disabled: p,
				form: h,
				children: [O === void 0 ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", { value: "" }) : null, Array.from(N)]
			}, F) : null]
		})
	});
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$1 = "SelectTrigger", SelectTrigger$1 = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, disabled: i = !1,...a } = e, o = usePopperScope(n), s = useSelectContext(TRIGGER_NAME$1, n), c = s.disabled || i, l = useComposedRefs(t, s.onTriggerChange), u = useCollection(n), d = import_react.useRef("touch"), [f, p, m] = useTypeaheadSearch((e) => {
		let t = u().filter((e) => !e.disabled), n = t.find((e) => e.value === s.value), i = findNextItem(t, e, n);
		i !== void 0 && s.onValueChange(i.value);
	}), h = (e) => {
		c || (s.onOpenChange(!0), m()), e && (s.triggerPointerDownPosRef.current = {
			x: Math.round(e.pageX),
			y: Math.round(e.pageY)
		});
	};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Anchor, {
		asChild: !0,
		...o,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.button, {
			type: "button",
			role: "combobox",
			"aria-controls": s.contentId,
			"aria-expanded": s.open,
			"aria-required": s.required,
			"aria-autocomplete": "none",
			dir: s.dir,
			"data-state": s.open ? "open" : "closed",
			disabled: c,
			"data-disabled": c ? "" : void 0,
			"data-placeholder": shouldShowPlaceholder(s.value) ? "" : void 0,
			...a,
			ref: l,
			onClick: composeEventHandlers(a.onClick, (e) => {
				e.currentTarget.focus(), d.current !== "mouse" && h(e);
			}),
			onPointerDown: composeEventHandlers(a.onPointerDown, (e) => {
				d.current = e.pointerType;
				let t = e.target;
				t.hasPointerCapture(e.pointerId) && t.releasePointerCapture(e.pointerId), e.button === 0 && e.ctrlKey === !1 && e.pointerType === "mouse" && (h(e), e.preventDefault());
			}),
			onKeyDown: composeEventHandlers(a.onKeyDown, (e) => {
				let t = f.current !== "";
				!(e.ctrlKey || e.altKey || e.metaKey) && e.key.length === 1 && p(e.key), !(t && e.key === " ") && OPEN_KEYS.includes(e.key) && (h(), e.preventDefault());
			})
		})
	});
});
SelectTrigger$1.displayName = TRIGGER_NAME$1;
var VALUE_NAME = "SelectValue", SelectValue$1 = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, className: i, style: a, children: o, placeholder: s = "",...c } = e, l = useSelectContext(VALUE_NAME, n), { onValueNodeHasChildrenChange: u } = l, d = o !== void 0, f = useComposedRefs(t, l.onValueNodeChange);
	return useLayoutEffect2(() => {
		u(d);
	}, [u, d]), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.span, {
		...c,
		ref: f,
		style: { pointerEvents: "none" },
		children: shouldShowPlaceholder(l.value) ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: s }) : o
	});
});
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon", SelectIcon = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, children: i,...a } = e;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.span, {
		"aria-hidden": !0,
		...a,
		ref: t,
		children: i || ""
	});
});
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$1 = "SelectPortal", SelectPortal = (e) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal, {
	asChild: !0,
	...e
});
SelectPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$1 = "SelectContent", SelectContent$1 = import_react.forwardRef((e, t) => {
	let n = useSelectContext(CONTENT_NAME$1, e.__scopeSelect), [i, a] = import_react.useState();
	if (useLayoutEffect2(() => {
		a(new DocumentFragment());
	}, []), !n.open) {
		let t = i;
		return t ? import_react_dom.createPortal(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectContentProvider, {
			scope: e.__scopeSelect,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collection.Slot, {
				scope: e.__scopeSelect,
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: e.children })
			})
		}), t) : null;
	}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectContentImpl, {
		...e,
		ref: t
	});
});
SelectContent$1.displayName = CONTENT_NAME$1;
var CONTENT_MARGIN = 10, [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$1), CONTENT_IMPL_NAME = "SelectContentImpl", Slot$2 = /* @__PURE__ */ createSlot("SelectContent.RemoveScroll"), SelectContentImpl = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, position: i = "item-aligned", onCloseAutoFocus: a, onEscapeKeyDown: o, onPointerDownOutside: s, side: c, sideOffset: l, align: u, alignOffset: d, arrowPadding: f, collisionBoundary: p, collisionPadding: m, sticky: h, hideWhenDetached: g, avoidCollisions: _,...v } = e, y = useSelectContext(CONTENT_NAME$1, n), [b, x] = import_react.useState(null), [C, w] = import_react.useState(null), E = useComposedRefs(t, (e) => x(e)), [O, A] = import_react.useState(null), [j, M] = import_react.useState(null), N = useCollection(n), [P, I] = import_react.useState(!1), ee = import_react.useRef(!1);
	import_react.useEffect(() => {
		if (b) return hideOthers(b);
	}, [b]), useFocusGuards();
	let L = import_react.useCallback((e) => {
		let [t, ...n] = N().map((e) => e.ref.current), [i] = n.slice(-1), a = document.activeElement;
		for (let n of e) if (n === a || (n?.scrollIntoView({ block: "nearest" }), n === t && C && (C.scrollTop = 0), n === i && C && (C.scrollTop = C.scrollHeight), n?.focus(), document.activeElement !== a)) return;
	}, [N, C]), R = import_react.useCallback(() => L([O, b]), [
		L,
		O,
		b
	]);
	import_react.useEffect(() => {
		P && R();
	}, [P, R]);
	let { onOpenChange: te, triggerPointerDownPosRef: ne } = y;
	import_react.useEffect(() => {
		if (b) {
			let e = {
				x: 0,
				y: 0
			}, t = (t) => {
				e = {
					x: Math.abs(Math.round(t.pageX) - (ne.current?.x ?? 0)),
					y: Math.abs(Math.round(t.pageY) - (ne.current?.y ?? 0))
				};
			}, n = (n) => {
				e.x <= 10 && e.y <= 10 ? n.preventDefault() : b.contains(n.target) || te(!1), document.removeEventListener("pointermove", t), ne.current = null;
			};
			return ne.current !== null && (document.addEventListener("pointermove", t), document.addEventListener("pointerup", n, {
				capture: !0,
				once: !0
			})), () => {
				document.removeEventListener("pointermove", t), document.removeEventListener("pointerup", n, { capture: !0 });
			};
		}
	}, [
		b,
		te,
		ne
	]), import_react.useEffect(() => {
		let e = () => te(!1);
		return window.addEventListener("blur", e), window.addEventListener("resize", e), () => {
			window.removeEventListener("blur", e), window.removeEventListener("resize", e);
		};
	}, [te]);
	let [ie, ae] = useTypeaheadSearch((e) => {
		let t = N().filter((e) => !e.disabled), n = t.find((e) => e.ref.current === document.activeElement), i = findNextItem(t, e, n);
		i && setTimeout(() => i.ref.current.focus());
	}), oe = import_react.useCallback((e, t, n) => {
		let i = !ee.current && !n;
		(y.value !== void 0 && y.value === t || i) && (A(e), i && (ee.current = !0));
	}, [y.value]), z = import_react.useCallback(() => b?.focus(), [b]), se = import_react.useCallback((e, t, n) => {
		let i = !ee.current && !n;
		(y.value !== void 0 && y.value === t || i) && M(e);
	}, [y.value]), ce = i === "popper" ? SelectPopperPosition : SelectItemAlignedPosition, le = ce === SelectPopperPosition ? {
		side: c,
		sideOffset: l,
		align: u,
		alignOffset: d,
		arrowPadding: f,
		collisionBoundary: p,
		collisionPadding: m,
		sticky: h,
		hideWhenDetached: g,
		avoidCollisions: _
	} : {};
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectContentProvider, {
		scope: n,
		content: b,
		viewport: C,
		onViewportChange: w,
		itemRefCallback: oe,
		selectedItem: O,
		onItemLeave: z,
		itemTextRefCallback: se,
		focusSelectedItem: R,
		selectedItemText: j,
		position: i,
		isPositioned: P,
		searchRef: ie,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combination_default, {
			as: Slot$2,
			allowPinchZoom: !0,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(FocusScope, {
				asChild: !0,
				trapped: y.open,
				onMountAutoFocus: (e) => {
					e.preventDefault();
				},
				onUnmountAutoFocus: composeEventHandlers(a, (e) => {
					y.trigger?.focus({ preventScroll: !0 }), e.preventDefault();
				}),
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DismissableLayer, {
					asChild: !0,
					disableOutsidePointerEvents: !0,
					onEscapeKeyDown: o,
					onPointerDownOutside: s,
					onFocusOutside: (e) => e.preventDefault(),
					onDismiss: () => y.onOpenChange(!1),
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ce, {
						role: "listbox",
						id: y.contentId,
						"data-state": y.open ? "open" : "closed",
						dir: y.dir,
						onContextMenu: (e) => e.preventDefault(),
						...v,
						...le,
						onPlaced: () => I(!0),
						ref: E,
						style: {
							display: "flex",
							flexDirection: "column",
							outline: "none",
							...v.style
						},
						onKeyDown: composeEventHandlers(v.onKeyDown, (e) => {
							let t = e.ctrlKey || e.altKey || e.metaKey;
							if (e.key === "Tab" && e.preventDefault(), !t && e.key.length === 1 && ae(e.key), [
								"ArrowUp",
								"ArrowDown",
								"Home",
								"End"
							].includes(e.key)) {
								let t = N().filter((e) => !e.disabled).map((e) => e.ref.current);
								if (["ArrowUp", "End"].includes(e.key) && (t = t.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(e.key)) {
									let n = e.target, i = t.indexOf(n);
									t = t.slice(i + 1);
								}
								setTimeout(() => L(t)), e.preventDefault();
							}
						})
					})
				})
			})
		})
	});
});
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition", SelectItemAlignedPosition = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, onPlaced: i,...a } = e, o = useSelectContext(CONTENT_NAME$1, n), s = useSelectContentContext(CONTENT_NAME$1, n), [c, l] = import_react.useState(null), [u, d] = import_react.useState(null), f = useComposedRefs(t, (e) => d(e)), p = useCollection(n), m = import_react.useRef(!1), h = import_react.useRef(!0), { viewport: g, selectedItem: _, selectedItemText: v, focusSelectedItem: y } = s, b = import_react.useCallback(() => {
		if (o.trigger && o.valueNode && c && u && g && _ && v) {
			let e = o.trigger.getBoundingClientRect(), t = u.getBoundingClientRect(), n = o.valueNode.getBoundingClientRect(), a = v.getBoundingClientRect();
			if (o.dir !== "rtl") {
				let i = a.left - t.left, o = n.left - i, s = e.left - o, l = e.width + s, u = Math.max(l, t.width), d = window.innerWidth - CONTENT_MARGIN, f = clamp(o, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, d - u)]);
				c.style.minWidth = l + "px", c.style.left = f + "px";
			} else {
				let i = t.right - a.right, o = window.innerWidth - n.right - i, s = window.innerWidth - e.right - o, l = e.width + s, u = Math.max(l, t.width), d = window.innerWidth - CONTENT_MARGIN, f = clamp(o, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, d - u)]);
				c.style.minWidth = l + "px", c.style.right = f + "px";
			}
			let s = p(), l = window.innerHeight - CONTENT_MARGIN * 2, d = g.scrollHeight, f = window.getComputedStyle(u), h = parseInt(f.borderTopWidth, 10), y = parseInt(f.paddingTop, 10), b = parseInt(f.borderBottomWidth, 10), x = parseInt(f.paddingBottom, 10), S = h + y + d + x + b, C = Math.min(_.offsetHeight * 5, S), T = window.getComputedStyle(g), E = parseInt(T.paddingTop, 10), O = parseInt(T.paddingBottom, 10), k = e.top + e.height / 2 - CONTENT_MARGIN, A = l - k, j = _.offsetHeight / 2, M = _.offsetTop + j, N = h + y + M, P = S - N;
			if (N <= k) {
				let e = s.length > 0 && _ === s[s.length - 1].ref.current;
				c.style.bottom = "0px";
				let t = u.clientHeight - g.offsetTop - g.offsetHeight, n = Math.max(A, j + (e ? O : 0) + t + b), i = N + n;
				c.style.height = i + "px";
			} else {
				let e = s.length > 0 && _ === s[0].ref.current;
				c.style.top = "0px";
				let t = Math.max(k, h + g.offsetTop + (e ? E : 0) + j) + P;
				c.style.height = t + "px", g.scrollTop = N - k + g.offsetTop;
			}
			c.style.margin = `${CONTENT_MARGIN}px 0`, c.style.minHeight = C + "px", c.style.maxHeight = l + "px", i?.(), requestAnimationFrame(() => m.current = !0);
		}
	}, [
		p,
		o.trigger,
		o.valueNode,
		c,
		u,
		g,
		_,
		v,
		o.dir,
		i
	]);
	useLayoutEffect2(() => b(), [b]);
	let [x, C] = import_react.useState();
	useLayoutEffect2(() => {
		u && C(window.getComputedStyle(u).zIndex);
	}, [u]);
	let T = import_react.useCallback((e) => {
		e && h.current === !0 && (b(), y?.(), h.current = !1);
	}, [b, y]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectViewportProvider, {
		scope: n,
		contentWrapper: c,
		shouldExpandOnScrollRef: m,
		onScrollButtonChange: T,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			ref: l,
			style: {
				display: "flex",
				flexDirection: "column",
				position: "fixed",
				zIndex: x
			},
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
				...a,
				ref: f,
				style: {
					boxSizing: "border-box",
					maxHeight: "100%",
					...a.style
				}
			})
		})
	});
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition", SelectPopperPosition = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, align: i = "start", collisionPadding: a = CONTENT_MARGIN,...o } = e, s = usePopperScope(n);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Content$1, {
		...s,
		...o,
		ref: t,
		align: i,
		collisionPadding: a,
		style: {
			boxSizing: "border-box",
			...o.style,
			"--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
			"--radix-select-content-available-width": "var(--radix-popper-available-width)",
			"--radix-select-content-available-height": "var(--radix-popper-available-height)",
			"--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
			"--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
		}
	});
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$1, {}), VIEWPORT_NAME = "SelectViewport", SelectViewport = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, nonce: i,...a } = e, o = useSelectContentContext(VIEWPORT_NAME, n), s = useSelectViewportContext(VIEWPORT_NAME, n), c = useComposedRefs(t, o.onViewportChange), l = import_react.useRef(0);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
		dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" },
		nonce: i
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collection.Slot, {
		scope: n,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
			"data-radix-select-viewport": "",
			role: "presentation",
			...a,
			ref: c,
			style: {
				position: "relative",
				flex: 1,
				overflow: "hidden auto",
				...a.style
			},
			onScroll: composeEventHandlers(a.onScroll, (e) => {
				let t = e.currentTarget, { contentWrapper: n, shouldExpandOnScrollRef: i } = s;
				if (i?.current && n) {
					let e = Math.abs(l.current - t.scrollTop);
					if (e > 0) {
						let i = window.innerHeight - CONTENT_MARGIN * 2, a = parseFloat(n.style.minHeight), o = parseFloat(n.style.height), s = Math.max(a, o);
						if (s < i) {
							let a = s + e, o = Math.min(i, a), c = a - o;
							n.style.height = o + "px", n.style.bottom === "0px" && (t.scrollTop = c > 0 ? c : 0, n.style.justifyContent = "flex-end");
						}
					}
				}
				l.current = t.scrollTop;
			})
		})
	})] });
});
SelectViewport.displayName = VIEWPORT_NAME;
var GROUP_NAME = "SelectGroup", [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME), SelectGroup = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n,...i } = e, a = useId();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectGroupContextProvider, {
		scope: n,
		id: a,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
			role: "group",
			"aria-labelledby": a,
			...i,
			ref: t
		})
	});
});
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel", SelectLabel = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n,...i } = e, a = useSelectGroupContext(LABEL_NAME, n);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		id: a.id,
		...i,
		ref: t
	});
});
SelectLabel.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem", [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME), SelectItem$1 = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, value: i, disabled: a = !1, textValue: o,...s } = e, c = useSelectContext(ITEM_NAME, n), l = useSelectContentContext(ITEM_NAME, n), u = c.value === i, [d, f] = import_react.useState(o ?? ""), [p, m] = import_react.useState(!1), h = useComposedRefs(t, (e) => l.itemRefCallback?.(e, i, a)), g = useId(), _ = import_react.useRef("touch"), v = () => {
		a || (c.onValueChange(i), c.onOpenChange(!1));
	};
	if (i === "") throw Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectItemContextProvider, {
		scope: n,
		value: i,
		disabled: a,
		textId: g,
		isSelected: u,
		onItemTextChange: import_react.useCallback((e) => {
			f((t) => t || (e?.textContent ?? "").trim());
		}, []),
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Collection.ItemSlot, {
			scope: n,
			value: i,
			disabled: a,
			textValue: d,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
				role: "option",
				"aria-labelledby": g,
				"data-highlighted": p ? "" : void 0,
				"aria-selected": u && p,
				"data-state": u ? "checked" : "unchecked",
				"aria-disabled": a || void 0,
				"data-disabled": a ? "" : void 0,
				tabIndex: a ? void 0 : -1,
				...s,
				ref: h,
				onFocus: composeEventHandlers(s.onFocus, () => m(!0)),
				onBlur: composeEventHandlers(s.onBlur, () => m(!1)),
				onClick: composeEventHandlers(s.onClick, () => {
					_.current !== "mouse" && v();
				}),
				onPointerUp: composeEventHandlers(s.onPointerUp, () => {
					_.current === "mouse" && v();
				}),
				onPointerDown: composeEventHandlers(s.onPointerDown, (e) => {
					_.current = e.pointerType;
				}),
				onPointerMove: composeEventHandlers(s.onPointerMove, (e) => {
					_.current = e.pointerType, a ? l.onItemLeave?.() : _.current === "mouse" && e.currentTarget.focus({ preventScroll: !0 });
				}),
				onPointerLeave: composeEventHandlers(s.onPointerLeave, (e) => {
					e.currentTarget === document.activeElement && l.onItemLeave?.();
				}),
				onKeyDown: composeEventHandlers(s.onKeyDown, (e) => {
					l.searchRef?.current !== "" && e.key === " " || (SELECTION_KEYS.includes(e.key) && v(), e.key === " " && e.preventDefault());
				})
			})
		})
	});
});
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText", SelectItemText = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, className: i, style: a,...o } = e, s = useSelectContext(ITEM_TEXT_NAME, n), c = useSelectContentContext(ITEM_TEXT_NAME, n), l = useSelectItemContext(ITEM_TEXT_NAME, n), u = useSelectNativeOptionsContext(ITEM_TEXT_NAME, n), [d, f] = import_react.useState(null), p = useComposedRefs(t, (e) => f(e), l.onItemTextChange, (e) => c.itemTextRefCallback?.(e, l.value, l.disabled)), m = d?.textContent, h = import_react.useMemo(() => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("option", {
		value: l.value,
		disabled: l.disabled,
		children: m
	}, l.value), [
		l.disabled,
		l.value,
		m
	]), { onNativeOptionAdd: g, onNativeOptionRemove: _ } = u;
	return useLayoutEffect2(() => (g(h), () => _(h)), [
		g,
		_,
		h
	]), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.span, {
		id: l.textId,
		...o,
		ref: p
	}), l.isSelected && s.valueNode && !s.valueNodeHasChildren ? import_react_dom.createPortal(o.children, s.valueNode) : null] });
});
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator", SelectItemIndicator = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n,...i } = e;
	return useSelectItemContext(ITEM_INDICATOR_NAME, n).isSelected ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.span, {
		"aria-hidden": !0,
		...i,
		ref: t
	}) : null;
});
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton", SelectScrollUpButton$1 = import_react.forwardRef((e, t) => {
	let n = useSelectContentContext(SCROLL_UP_BUTTON_NAME, e.__scopeSelect), i = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, e.__scopeSelect), [a, o] = import_react.useState(!1), s = useComposedRefs(t, i.onScrollButtonChange);
	return useLayoutEffect2(() => {
		if (n.viewport && n.isPositioned) {
			let e = function() {
				let e = t.scrollTop > 0;
				o(e);
			}, t = n.viewport;
			return e(), t.addEventListener("scroll", e), () => t.removeEventListener("scroll", e);
		}
	}, [n.viewport, n.isPositioned]), a ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectScrollButtonImpl, {
		...e,
		ref: s,
		onAutoScroll: () => {
			let { viewport: e, selectedItem: t } = n;
			e && t && (e.scrollTop -= t.offsetHeight);
		}
	}) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton", SelectScrollDownButton$1 = import_react.forwardRef((e, t) => {
	let n = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, e.__scopeSelect), i = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, e.__scopeSelect), [a, o] = import_react.useState(!1), s = useComposedRefs(t, i.onScrollButtonChange);
	return useLayoutEffect2(() => {
		if (n.viewport && n.isPositioned) {
			let e = function() {
				let e = t.scrollHeight - t.clientHeight, n = Math.ceil(t.scrollTop) < e;
				o(n);
			}, t = n.viewport;
			return e(), t.addEventListener("scroll", e), () => t.removeEventListener("scroll", e);
		}
	}, [n.viewport, n.isPositioned]), a ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectScrollButtonImpl, {
		...e,
		ref: s,
		onAutoScroll: () => {
			let { viewport: e, selectedItem: t } = n;
			e && t && (e.scrollTop += t.offsetHeight);
		}
	}) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n, onAutoScroll: i,...a } = e, o = useSelectContentContext("SelectScrollButton", n), s = import_react.useRef(null), c = useCollection(n), l = import_react.useCallback(() => {
		s.current !== null && (window.clearInterval(s.current), s.current = null);
	}, []);
	return import_react.useEffect(() => () => l(), [l]), useLayoutEffect2(() => {
		c().find((e) => e.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" });
	}, [c]), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		"aria-hidden": !0,
		...a,
		ref: t,
		style: {
			flexShrink: 0,
			...a.style
		},
		onPointerDown: composeEventHandlers(a.onPointerDown, () => {
			s.current === null && (s.current = window.setInterval(i, 50));
		}),
		onPointerMove: composeEventHandlers(a.onPointerMove, () => {
			o.onItemLeave?.(), s.current === null && (s.current = window.setInterval(i, 50));
		}),
		onPointerLeave: composeEventHandlers(a.onPointerLeave, () => {
			l();
		})
	});
}), SEPARATOR_NAME = "SelectSeparator", SelectSeparator = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n,...i } = e;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
		"aria-hidden": !0,
		...i,
		ref: t
	});
});
SelectSeparator.displayName = SEPARATOR_NAME;
var ARROW_NAME = "SelectArrow", SelectArrow = import_react.forwardRef((e, t) => {
	let { __scopeSelect: n,...i } = e, a = usePopperScope(n), o = useSelectContext(ARROW_NAME, n), s = useSelectContentContext(ARROW_NAME, n);
	return o.open && s.position === "popper" ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Arrow, {
		...a,
		...i,
		ref: t
	}) : null;
});
SelectArrow.displayName = ARROW_NAME;
var BUBBLE_INPUT_NAME = "SelectBubbleInput", SelectBubbleInput = import_react.forwardRef(({ __scopeSelect: e, value: t,...n }, i) => {
	let a = import_react.useRef(null), o = useComposedRefs(i, a), s = usePrevious(t);
	return import_react.useEffect(() => {
		let e = a.current;
		if (!e) return;
		let n = window.HTMLSelectElement.prototype, i = Object.getOwnPropertyDescriptor(n, "value").set;
		if (s !== t && i) {
			let n = new Event("change", { bubbles: !0 });
			i.call(e, t), e.dispatchEvent(n);
		}
	}, [s, t]), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.select, {
		...n,
		style: {
			...VISUALLY_HIDDEN_STYLES,
			...n.style
		},
		ref: o,
		defaultValue: t
	});
});
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME;
function shouldShowPlaceholder(e) {
	return e === "" || e === void 0;
}
function useTypeaheadSearch(e) {
	let t = useCallbackRef(e), n = import_react.useRef(""), i = import_react.useRef(0), a = import_react.useCallback((e) => {
		let a = n.current + e;
		t(a), (function e(t) {
			n.current = t, window.clearTimeout(i.current), t !== "" && (i.current = window.setTimeout(() => e(""), 1e3));
		})(a);
	}, [t]), o = import_react.useCallback(() => {
		n.current = "", window.clearTimeout(i.current);
	}, []);
	return import_react.useEffect(() => () => window.clearTimeout(i.current), []), [
		n,
		a,
		o
	];
}
function findNextItem(e, t, n) {
	let i = t.length > 1 && Array.from(t).every((e) => e === t[0]) ? t[0] : t, a = n ? e.indexOf(n) : -1, o = wrapArray(e, Math.max(a, 0));
	i.length === 1 && (o = o.filter((e) => e !== n));
	let s = o.find((e) => e.textValue.toLowerCase().startsWith(i.toLowerCase()));
	return s === n ? void 0 : s;
}
function wrapArray(e, t) {
	return e.map((n, i) => e[(t + i) % e.length]);
}
var Root2 = Select$1, Trigger = SelectTrigger$1, Value = SelectValue$1, Icon$1 = SelectIcon, Portal$2 = SelectPortal, Content2 = SelectContent$1, Viewport = SelectViewport, Item = SelectItem$1, ItemText = SelectItemText, ItemIndicator = SelectItemIndicator, ScrollUpButton = SelectScrollUpButton$1, ScrollDownButton = SelectScrollDownButton$1, toKebabCase = (e) => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), toCamelCase = (e) => e.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, n) => n ? n.toUpperCase() : t.toLowerCase()), toPascalCase = (e) => {
	let t = toCamelCase(e);
	return t.charAt(0).toUpperCase() + t.slice(1);
}, mergeClasses = (...e) => e.filter((e, t, n) => !!e && e.trim() !== "" && n.indexOf(e) === t).join(" ").trim(), hasA11yProp = (e) => {
	for (let t in e) if (t.startsWith("aria-") || t === "role" || t === "title") return !0;
}, defaultAttributes = {
	xmlns: "http://www.w3.org/2000/svg",
	width: 24,
	height: 24,
	viewBox: "0 0 24 24",
	fill: "none",
	stroke: "currentColor",
	strokeWidth: 2,
	strokeLinecap: "round",
	strokeLinejoin: "round"
}, Icon = (0, import_react.forwardRef)(({ color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: i, className: a = "", children: o, iconNode: s,...c }, l) => (0, import_react.createElement)("svg", {
	ref: l,
	...defaultAttributes,
	width: t,
	height: t,
	stroke: e,
	strokeWidth: i ? Number(n) * 24 / Number(t) : n,
	className: mergeClasses("lucide", a),
	...!o && !hasA11yProp(c) && { "aria-hidden": "true" },
	...c
}, [...s.map(([e, t]) => (0, import_react.createElement)(e, t)), ...Array.isArray(o) ? o : [o]])), createLucideIcon = (e, t) => {
	let n = (0, import_react.forwardRef)(({ className: n,...i }, a) => (0, import_react.createElement)(Icon, {
		ref: a,
		iconNode: t,
		className: mergeClasses(`lucide-${toKebabCase(toPascalCase(e))}`, `lucide-${e}`, n),
		...i
	}));
	return n.displayName = toPascalCase(e), n;
}, ArrowUpDown = createLucideIcon("arrow-up-down", [
	["path", {
		d: "m21 16-4 4-4-4",
		key: "f6ql7i"
	}],
	["path", {
		d: "M17 20V4",
		key: "1ejh1v"
	}],
	["path", {
		d: "m3 8 4-4 4 4",
		key: "11wl7u"
	}],
	["path", {
		d: "M7 4v16",
		key: "1glfcx"
	}]
]), Check = createLucideIcon("check", [["path", {
	d: "M20 6 9 17l-5-5",
	key: "1gmf2c"
}]]), ChevronDown = createLucideIcon("chevron-down", [["path", {
	d: "m6 9 6 6 6-6",
	key: "qrunsl"
}]]), ChevronUp = createLucideIcon("chevron-up", [["path", {
	d: "m18 15-6-6-6 6",
	key: "153udz"
}]]), X = createLucideIcon("x", [["path", {
	d: "M18 6 6 18",
	key: "1bl5f8"
}], ["path", {
	d: "m6 6 12 12",
	key: "d8bk6v"
}]]);
function r(e) {
	var t, n, i = "";
	if (typeof e == "string" || typeof e == "number") i += e;
	else if (typeof e == "object") if (Array.isArray(e)) {
		var a = e.length;
		for (t = 0; t < a; t++) e[t] && (n = r(e[t])) && (i && (i += " "), i += n);
	} else for (n in e) e[n] && (i && (i += " "), i += n);
	return i;
}
function clsx() {
	for (var e, t, n = 0, i = "", a = arguments.length; n < a; n++) (e = arguments[n]) && (t = r(e)) && (i && (i += " "), i += t);
	return i;
}
var CLASS_PART_SEPARATOR = "-", createClassGroupUtils = (e) => {
	let t = createClassMap(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: i } = e;
	return {
		getClassGroupId: (e) => {
			let n = e.split(CLASS_PART_SEPARATOR);
			return n[0] === "" && n.length !== 1 && n.shift(), getGroupRecursive(n, t) || getGroupIdForArbitraryProperty(e);
		},
		getConflictingClassGroupIds: (e, t) => {
			let a = n[e] || [];
			return t && i[e] ? [...a, ...i[e]] : a;
		}
	};
}, getGroupRecursive = (e, t) => {
	if (e.length === 0) return t.classGroupId;
	let n = e[0], i = t.nextPart.get(n), a = i ? getGroupRecursive(e.slice(1), i) : void 0;
	if (a) return a;
	if (t.validators.length === 0) return;
	let o = e.join(CLASS_PART_SEPARATOR);
	return t.validators.find(({ validator: e }) => e(o))?.classGroupId;
}, arbitraryPropertyRegex = /^\[(.+)\]$/, getGroupIdForArbitraryProperty = (e) => {
	if (arbitraryPropertyRegex.test(e)) {
		let t = arbitraryPropertyRegex.exec(e)[1], n = t?.substring(0, t.indexOf(":"));
		if (n) return "arbitrary.." + n;
	}
}, createClassMap = (e) => {
	let { theme: t, classGroups: n } = e, i = {
		nextPart: /* @__PURE__ */ new Map(),
		validators: []
	};
	for (let e in n) processClassesRecursively(n[e], i, e, t);
	return i;
}, processClassesRecursively = (e, t, n, i) => {
	e.forEach((e) => {
		if (typeof e == "string") {
			let i = e === "" ? t : getPart(t, e);
			i.classGroupId = n;
			return;
		}
		if (typeof e == "function") {
			if (isThemeGetter(e)) {
				processClassesRecursively(e(i), t, n, i);
				return;
			}
			t.validators.push({
				validator: e,
				classGroupId: n
			});
			return;
		}
		Object.entries(e).forEach(([e, a]) => {
			processClassesRecursively(a, getPart(t, e), n, i);
		});
	});
}, getPart = (e, t) => {
	let n = e;
	return t.split(CLASS_PART_SEPARATOR).forEach((e) => {
		n.nextPart.has(e) || n.nextPart.set(e, {
			nextPart: /* @__PURE__ */ new Map(),
			validators: []
		}), n = n.nextPart.get(e);
	}), n;
}, isThemeGetter = (e) => e.isThemeGetter, createLruCache = (e) => {
	if (e < 1) return {
		get: () => void 0,
		set: () => {}
	};
	let t = 0, n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = (a, o) => {
		n.set(a, o), t++, t > e && (t = 0, i = n, n = /* @__PURE__ */ new Map());
	};
	return {
		get(e) {
			let t = n.get(e);
			if (t !== void 0) return t;
			if ((t = i.get(e)) !== void 0) return a(e, t), t;
		},
		set(e, t) {
			n.has(e) ? n.set(e, t) : a(e, t);
		}
	};
}, IMPORTANT_MODIFIER = "!", MODIFIER_SEPARATOR = ":", MODIFIER_SEPARATOR_LENGTH = 1, createParseClassName = (e) => {
	let { prefix: t, experimentalParseClassName: n } = e, i = (e) => {
		let t = [], n = 0, i = 0, a = 0, o;
		for (let s = 0; s < e.length; s++) {
			let c = e[s];
			if (n === 0 && i === 0) {
				if (c === MODIFIER_SEPARATOR) {
					t.push(e.slice(a, s)), a = s + MODIFIER_SEPARATOR_LENGTH;
					continue;
				}
				if (c === "/") {
					o = s;
					continue;
				}
			}
			c === "[" ? n++ : c === "]" ? n-- : c === "(" ? i++ : c === ")" && i--;
		}
		let s = t.length === 0 ? e : e.substring(a), c = stripImportantModifier(s), l = c !== s, u = o && o > a ? o - a : void 0;
		return {
			modifiers: t,
			hasImportantModifier: l,
			baseClassName: c,
			maybePostfixModifierPosition: u
		};
	};
	if (t) {
		let e = t + MODIFIER_SEPARATOR, n = i;
		i = (t) => t.startsWith(e) ? n(t.substring(e.length)) : {
			isExternal: !0,
			modifiers: [],
			hasImportantModifier: !1,
			baseClassName: t,
			maybePostfixModifierPosition: void 0
		};
	}
	if (n) {
		let e = i;
		i = (t) => n({
			className: t,
			parseClassName: e
		});
	}
	return i;
}, stripImportantModifier = (e) => e.endsWith(IMPORTANT_MODIFIER) ? e.substring(0, e.length - 1) : e.startsWith(IMPORTANT_MODIFIER) ? e.substring(1) : e, createSortModifiers = (e) => {
	let t = Object.fromEntries(e.orderSensitiveModifiers.map((e) => [e, !0]));
	return (e) => {
		if (e.length <= 1) return e;
		let n = [], i = [];
		return e.forEach((e) => {
			e[0] === "[" || t[e] ? (n.push(...i.sort(), e), i = []) : i.push(e);
		}), n.push(...i.sort()), n;
	};
}, createConfigUtils = (e) => ({
	cache: createLruCache(e.cacheSize),
	parseClassName: createParseClassName(e),
	sortModifiers: createSortModifiers(e),
	...createClassGroupUtils(e)
}), SPLIT_CLASSES_REGEX = /\s+/, mergeClassList = (e, t) => {
	let { parseClassName: n, getClassGroupId: i, getConflictingClassGroupIds: a, sortModifiers: o } = t, s = [], c = e.trim().split(SPLIT_CLASSES_REGEX), l = "";
	for (let e = c.length - 1; e >= 0; --e) {
		let t = c[e], { isExternal: u, modifiers: d, hasImportantModifier: f, baseClassName: p, maybePostfixModifierPosition: m } = n(t);
		if (u) {
			l = t + (l.length > 0 ? " " + l : l);
			continue;
		}
		let h = !!m, g = i(h ? p.substring(0, m) : p);
		if (!g) {
			if (!h) {
				l = t + (l.length > 0 ? " " + l : l);
				continue;
			}
			if (g = i(p), !g) {
				l = t + (l.length > 0 ? " " + l : l);
				continue;
			}
			h = !1;
		}
		let _ = o(d).join(":"), v = f ? _ + IMPORTANT_MODIFIER : _, y = v + g;
		if (s.includes(y)) continue;
		s.push(y);
		let b = a(g, h);
		for (let e = 0; e < b.length; ++e) {
			let t = b[e];
			s.push(v + t);
		}
		l = t + (l.length > 0 ? " " + l : l);
	}
	return l;
};
function twJoin() {
	let e = 0, t, n, i = "";
	for (; e < arguments.length;) (t = arguments[e++]) && (n = toValue(t)) && (i && (i += " "), i += n);
	return i;
}
var toValue = (e) => {
	if (typeof e == "string") return e;
	let t, n = "";
	for (let i = 0; i < e.length; i++) e[i] && (t = toValue(e[i])) && (n && (n += " "), n += t);
	return n;
};
function createTailwindMerge(e, ...t) {
	let n, i, a, o = s;
	function s(s) {
		let l = t.reduce((e, t) => t(e), e());
		return n = createConfigUtils(l), i = n.cache.get, a = n.cache.set, o = c, c(s);
	}
	function c(e) {
		let t = i(e);
		if (t) return t;
		let o = mergeClassList(e, n);
		return a(e, o), o;
	}
	return function() {
		return o(twJoin.apply(null, arguments));
	};
}
var fromTheme = (e) => {
	let t = (t) => t[e] || [];
	return t.isThemeGetter = !0, t;
}, arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i, fractionRegex = /^\d+\/\d+$/, tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, isFraction = (e) => fractionRegex.test(e), isNumber = (e) => !!e && !Number.isNaN(Number(e)), isInteger = (e) => !!e && Number.isInteger(Number(e)), isPercent = (e) => e.endsWith("%") && isNumber(e.slice(0, -1)), isTshirtSize = (e) => tshirtUnitRegex.test(e), isAny = () => !0, isLengthOnly = (e) => lengthUnitRegex.test(e) && !colorFunctionRegex.test(e), isNever = () => !1, isShadow = (e) => shadowRegex.test(e), isImage = (e) => imageRegex.test(e), isAnyNonArbitrary = (e) => !isArbitraryValue(e) && !isArbitraryVariable(e), isArbitrarySize = (e) => getIsArbitraryValue(e, isLabelSize, isNever), isArbitraryValue = (e) => arbitraryValueRegex.test(e), isArbitraryLength = (e) => getIsArbitraryValue(e, isLabelLength, isLengthOnly), isArbitraryNumber = (e) => getIsArbitraryValue(e, isLabelNumber, isNumber), isArbitraryPosition = (e) => getIsArbitraryValue(e, isLabelPosition, isNever), isArbitraryImage = (e) => getIsArbitraryValue(e, isLabelImage, isImage), isArbitraryShadow = (e) => getIsArbitraryValue(e, isLabelShadow, isShadow), isArbitraryVariable = (e) => arbitraryVariableRegex.test(e), isArbitraryVariableLength = (e) => getIsArbitraryVariable(e, isLabelLength), isArbitraryVariableFamilyName = (e) => getIsArbitraryVariable(e, isLabelFamilyName), isArbitraryVariablePosition = (e) => getIsArbitraryVariable(e, isLabelPosition), isArbitraryVariableSize = (e) => getIsArbitraryVariable(e, isLabelSize), isArbitraryVariableImage = (e) => getIsArbitraryVariable(e, isLabelImage), isArbitraryVariableShadow = (e) => getIsArbitraryVariable(e, isLabelShadow, !0), getIsArbitraryValue = (e, t, n) => {
	let i = arbitraryValueRegex.exec(e);
	return i ? i[1] ? t(i[1]) : n(i[2]) : !1;
}, getIsArbitraryVariable = (e, t, n = !1) => {
	let i = arbitraryVariableRegex.exec(e);
	return i ? i[1] ? t(i[1]) : n : !1;
}, isLabelPosition = (e) => e === "position" || e === "percentage", isLabelImage = (e) => e === "image" || e === "url", isLabelSize = (e) => e === "length" || e === "size" || e === "bg-size", isLabelLength = (e) => e === "length", isLabelNumber = (e) => e === "number", isLabelFamilyName = (e) => e === "family-name", isLabelShadow = (e) => e === "shadow", twMerge = /* @__PURE__ */ createTailwindMerge(() => {
	let e = fromTheme("color"), t = fromTheme("font"), n = fromTheme("text"), i = fromTheme("font-weight"), a = fromTheme("tracking"), o = fromTheme("leading"), s = fromTheme("breakpoint"), c = fromTheme("container"), l = fromTheme("spacing"), u = fromTheme("radius"), d = fromTheme("shadow"), f = fromTheme("inset-shadow"), p = fromTheme("text-shadow"), m = fromTheme("drop-shadow"), h = fromTheme("blur"), g = fromTheme("perspective"), _ = fromTheme("aspect"), v = fromTheme("ease"), y = fromTheme("animate"), b = () => [
		"auto",
		"avoid",
		"all",
		"avoid-page",
		"page",
		"left",
		"right",
		"column"
	], x = () => [
		"center",
		"top",
		"bottom",
		"left",
		"right",
		"top-left",
		"left-top",
		"top-right",
		"right-top",
		"bottom-right",
		"right-bottom",
		"bottom-left",
		"left-bottom"
	], S = () => [
		...x(),
		isArbitraryVariable,
		isArbitraryValue
	], C = () => [
		"auto",
		"hidden",
		"clip",
		"visible",
		"scroll"
	], w = () => [
		"auto",
		"contain",
		"none"
	], T = () => [
		isArbitraryVariable,
		isArbitraryValue,
		l
	], E = () => [
		isFraction,
		"full",
		"auto",
		...T()
	], O = () => [
		isInteger,
		"none",
		"subgrid",
		isArbitraryVariable,
		isArbitraryValue
	], k = () => [
		"auto",
		{ span: [
			"full",
			isInteger,
			isArbitraryVariable,
			isArbitraryValue
		] },
		isInteger,
		isArbitraryVariable,
		isArbitraryValue
	], A = () => [
		isInteger,
		"auto",
		isArbitraryVariable,
		isArbitraryValue
	], j = () => [
		"auto",
		"min",
		"max",
		"fr",
		isArbitraryVariable,
		isArbitraryValue
	], M = () => [
		"start",
		"end",
		"center",
		"between",
		"around",
		"evenly",
		"stretch",
		"baseline",
		"center-safe",
		"end-safe"
	], N = () => [
		"start",
		"end",
		"center",
		"stretch",
		"center-safe",
		"end-safe"
	], P = () => ["auto", ...T()], F = () => [
		isFraction,
		"auto",
		"full",
		"dvw",
		"dvh",
		"lvw",
		"lvh",
		"svw",
		"svh",
		"min",
		"max",
		"fit",
		...T()
	], I = () => [
		e,
		isArbitraryVariable,
		isArbitraryValue
	], ee = () => [
		...x(),
		isArbitraryVariablePosition,
		isArbitraryPosition,
		{ position: [isArbitraryVariable, isArbitraryValue] }
	], L = () => ["no-repeat", { repeat: [
		"",
		"x",
		"y",
		"space",
		"round"
	] }], R = () => [
		"auto",
		"cover",
		"contain",
		isArbitraryVariableSize,
		isArbitrarySize,
		{ size: [isArbitraryVariable, isArbitraryValue] }
	], te = () => [
		isPercent,
		isArbitraryVariableLength,
		isArbitraryLength
	], ne = () => [
		"",
		"none",
		"full",
		u,
		isArbitraryVariable,
		isArbitraryValue
	], ie = () => [
		"",
		isNumber,
		isArbitraryVariableLength,
		isArbitraryLength
	], ae = () => [
		"solid",
		"dashed",
		"dotted",
		"double"
	], oe = () => [
		"normal",
		"multiply",
		"screen",
		"overlay",
		"darken",
		"lighten",
		"color-dodge",
		"color-burn",
		"hard-light",
		"soft-light",
		"difference",
		"exclusion",
		"hue",
		"saturation",
		"color",
		"luminosity"
	], z = () => [
		isNumber,
		isPercent,
		isArbitraryVariablePosition,
		isArbitraryPosition
	], se = () => [
		"",
		"none",
		h,
		isArbitraryVariable,
		isArbitraryValue
	], ce = () => [
		"none",
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	], le = () => [
		"none",
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	], ue = () => [
		isNumber,
		isArbitraryVariable,
		isArbitraryValue
	], de = () => [
		isFraction,
		"full",
		...T()
	];
	return {
		cacheSize: 500,
		theme: {
			animate: [
				"spin",
				"ping",
				"pulse",
				"bounce"
			],
			aspect: ["video"],
			blur: [isTshirtSize],
			breakpoint: [isTshirtSize],
			color: [isAny],
			container: [isTshirtSize],
			"drop-shadow": [isTshirtSize],
			ease: [
				"in",
				"out",
				"in-out"
			],
			font: [isAnyNonArbitrary],
			"font-weight": [
				"thin",
				"extralight",
				"light",
				"normal",
				"medium",
				"semibold",
				"bold",
				"extrabold",
				"black"
			],
			"inset-shadow": [isTshirtSize],
			leading: [
				"none",
				"tight",
				"snug",
				"normal",
				"relaxed",
				"loose"
			],
			perspective: [
				"dramatic",
				"near",
				"normal",
				"midrange",
				"distant",
				"none"
			],
			radius: [isTshirtSize],
			shadow: [isTshirtSize],
			spacing: ["px", isNumber],
			text: [isTshirtSize],
			"text-shadow": [isTshirtSize],
			tracking: [
				"tighter",
				"tight",
				"normal",
				"wide",
				"wider",
				"widest"
			]
		},
		classGroups: {
			aspect: [{ aspect: [
				"auto",
				"square",
				isFraction,
				isArbitraryValue,
				isArbitraryVariable,
				_
			] }],
			container: ["container"],
			columns: [{ columns: [
				isNumber,
				isArbitraryValue,
				isArbitraryVariable,
				c
			] }],
			"break-after": [{ "break-after": b() }],
			"break-before": [{ "break-before": b() }],
			"break-inside": [{ "break-inside": [
				"auto",
				"avoid",
				"avoid-page",
				"avoid-column"
			] }],
			"box-decoration": [{ "box-decoration": ["slice", "clone"] }],
			box: [{ box: ["border", "content"] }],
			display: [
				"block",
				"inline-block",
				"inline",
				"flex",
				"inline-flex",
				"table",
				"inline-table",
				"table-caption",
				"table-cell",
				"table-column",
				"table-column-group",
				"table-footer-group",
				"table-header-group",
				"table-row-group",
				"table-row",
				"flow-root",
				"grid",
				"inline-grid",
				"contents",
				"list-item",
				"hidden"
			],
			sr: ["sr-only", "not-sr-only"],
			float: [{ float: [
				"right",
				"left",
				"none",
				"start",
				"end"
			] }],
			clear: [{ clear: [
				"left",
				"right",
				"both",
				"none",
				"start",
				"end"
			] }],
			isolation: ["isolate", "isolation-auto"],
			"object-fit": [{ object: [
				"contain",
				"cover",
				"fill",
				"none",
				"scale-down"
			] }],
			"object-position": [{ object: S() }],
			overflow: [{ overflow: C() }],
			"overflow-x": [{ "overflow-x": C() }],
			"overflow-y": [{ "overflow-y": C() }],
			overscroll: [{ overscroll: w() }],
			"overscroll-x": [{ "overscroll-x": w() }],
			"overscroll-y": [{ "overscroll-y": w() }],
			position: [
				"static",
				"fixed",
				"absolute",
				"relative",
				"sticky"
			],
			inset: [{ inset: E() }],
			"inset-x": [{ "inset-x": E() }],
			"inset-y": [{ "inset-y": E() }],
			start: [{ start: E() }],
			end: [{ end: E() }],
			top: [{ top: E() }],
			right: [{ right: E() }],
			bottom: [{ bottom: E() }],
			left: [{ left: E() }],
			visibility: [
				"visible",
				"invisible",
				"collapse"
			],
			z: [{ z: [
				isInteger,
				"auto",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			basis: [{ basis: [
				isFraction,
				"full",
				"auto",
				c,
				...T()
			] }],
			"flex-direction": [{ flex: [
				"row",
				"row-reverse",
				"col",
				"col-reverse"
			] }],
			"flex-wrap": [{ flex: [
				"nowrap",
				"wrap",
				"wrap-reverse"
			] }],
			flex: [{ flex: [
				isNumber,
				isFraction,
				"auto",
				"initial",
				"none",
				isArbitraryValue
			] }],
			grow: [{ grow: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			shrink: [{ shrink: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			order: [{ order: [
				isInteger,
				"first",
				"last",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"grid-cols": [{ "grid-cols": O() }],
			"col-start-end": [{ col: k() }],
			"col-start": [{ "col-start": A() }],
			"col-end": [{ "col-end": A() }],
			"grid-rows": [{ "grid-rows": O() }],
			"row-start-end": [{ row: k() }],
			"row-start": [{ "row-start": A() }],
			"row-end": [{ "row-end": A() }],
			"grid-flow": [{ "grid-flow": [
				"row",
				"col",
				"dense",
				"row-dense",
				"col-dense"
			] }],
			"auto-cols": [{ "auto-cols": j() }],
			"auto-rows": [{ "auto-rows": j() }],
			gap: [{ gap: T() }],
			"gap-x": [{ "gap-x": T() }],
			"gap-y": [{ "gap-y": T() }],
			"justify-content": [{ justify: [...M(), "normal"] }],
			"justify-items": [{ "justify-items": [...N(), "normal"] }],
			"justify-self": [{ "justify-self": ["auto", ...N()] }],
			"align-content": [{ content: ["normal", ...M()] }],
			"align-items": [{ items: [...N(), { baseline: ["", "last"] }] }],
			"align-self": [{ self: [
				"auto",
				...N(),
				{ baseline: ["", "last"] }
			] }],
			"place-content": [{ "place-content": M() }],
			"place-items": [{ "place-items": [...N(), "baseline"] }],
			"place-self": [{ "place-self": ["auto", ...N()] }],
			p: [{ p: T() }],
			px: [{ px: T() }],
			py: [{ py: T() }],
			ps: [{ ps: T() }],
			pe: [{ pe: T() }],
			pt: [{ pt: T() }],
			pr: [{ pr: T() }],
			pb: [{ pb: T() }],
			pl: [{ pl: T() }],
			m: [{ m: P() }],
			mx: [{ mx: P() }],
			my: [{ my: P() }],
			ms: [{ ms: P() }],
			me: [{ me: P() }],
			mt: [{ mt: P() }],
			mr: [{ mr: P() }],
			mb: [{ mb: P() }],
			ml: [{ ml: P() }],
			"space-x": [{ "space-x": T() }],
			"space-x-reverse": ["space-x-reverse"],
			"space-y": [{ "space-y": T() }],
			"space-y-reverse": ["space-y-reverse"],
			size: [{ size: F() }],
			w: [{ w: [
				c,
				"screen",
				...F()
			] }],
			"min-w": [{ "min-w": [
				c,
				"screen",
				"none",
				...F()
			] }],
			"max-w": [{ "max-w": [
				c,
				"screen",
				"none",
				"prose",
				{ screen: [s] },
				...F()
			] }],
			h: [{ h: [
				"screen",
				"lh",
				...F()
			] }],
			"min-h": [{ "min-h": [
				"screen",
				"lh",
				"none",
				...F()
			] }],
			"max-h": [{ "max-h": [
				"screen",
				"lh",
				...F()
			] }],
			"font-size": [{ text: [
				"base",
				n,
				isArbitraryVariableLength,
				isArbitraryLength
			] }],
			"font-smoothing": ["antialiased", "subpixel-antialiased"],
			"font-style": ["italic", "not-italic"],
			"font-weight": [{ font: [
				i,
				isArbitraryVariable,
				isArbitraryNumber
			] }],
			"font-stretch": [{ "font-stretch": [
				"ultra-condensed",
				"extra-condensed",
				"condensed",
				"semi-condensed",
				"normal",
				"semi-expanded",
				"expanded",
				"extra-expanded",
				"ultra-expanded",
				isPercent,
				isArbitraryValue
			] }],
			"font-family": [{ font: [
				isArbitraryVariableFamilyName,
				isArbitraryValue,
				t
			] }],
			"fvn-normal": ["normal-nums"],
			"fvn-ordinal": ["ordinal"],
			"fvn-slashed-zero": ["slashed-zero"],
			"fvn-figure": ["lining-nums", "oldstyle-nums"],
			"fvn-spacing": ["proportional-nums", "tabular-nums"],
			"fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
			tracking: [{ tracking: [
				a,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"line-clamp": [{ "line-clamp": [
				isNumber,
				"none",
				isArbitraryVariable,
				isArbitraryNumber
			] }],
			leading: [{ leading: [o, ...T()] }],
			"list-image": [{ "list-image": [
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"list-style-position": [{ list: ["inside", "outside"] }],
			"list-style-type": [{ list: [
				"disc",
				"decimal",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"text-alignment": [{ text: [
				"left",
				"center",
				"right",
				"justify",
				"start",
				"end"
			] }],
			"placeholder-color": [{ placeholder: I() }],
			"text-color": [{ text: I() }],
			"text-decoration": [
				"underline",
				"overline",
				"line-through",
				"no-underline"
			],
			"text-decoration-style": [{ decoration: [...ae(), "wavy"] }],
			"text-decoration-thickness": [{ decoration: [
				isNumber,
				"from-font",
				"auto",
				isArbitraryVariable,
				isArbitraryLength
			] }],
			"text-decoration-color": [{ decoration: I() }],
			"underline-offset": [{ "underline-offset": [
				isNumber,
				"auto",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"text-transform": [
				"uppercase",
				"lowercase",
				"capitalize",
				"normal-case"
			],
			"text-overflow": [
				"truncate",
				"text-ellipsis",
				"text-clip"
			],
			"text-wrap": [{ text: [
				"wrap",
				"nowrap",
				"balance",
				"pretty"
			] }],
			indent: [{ indent: T() }],
			"vertical-align": [{ align: [
				"baseline",
				"top",
				"middle",
				"bottom",
				"text-top",
				"text-bottom",
				"sub",
				"super",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			whitespace: [{ whitespace: [
				"normal",
				"nowrap",
				"pre",
				"pre-line",
				"pre-wrap",
				"break-spaces"
			] }],
			break: [{ break: [
				"normal",
				"words",
				"all",
				"keep"
			] }],
			wrap: [{ wrap: [
				"break-word",
				"anywhere",
				"normal"
			] }],
			hyphens: [{ hyphens: [
				"none",
				"manual",
				"auto"
			] }],
			content: [{ content: [
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"bg-attachment": [{ bg: [
				"fixed",
				"local",
				"scroll"
			] }],
			"bg-clip": [{ "bg-clip": [
				"border",
				"padding",
				"content",
				"text"
			] }],
			"bg-origin": [{ "bg-origin": [
				"border",
				"padding",
				"content"
			] }],
			"bg-position": [{ bg: ee() }],
			"bg-repeat": [{ bg: L() }],
			"bg-size": [{ bg: R() }],
			"bg-image": [{ bg: [
				"none",
				{
					linear: [
						{ to: [
							"t",
							"tr",
							"r",
							"br",
							"b",
							"bl",
							"l",
							"tl"
						] },
						isInteger,
						isArbitraryVariable,
						isArbitraryValue
					],
					radial: [
						"",
						isArbitraryVariable,
						isArbitraryValue
					],
					conic: [
						isInteger,
						isArbitraryVariable,
						isArbitraryValue
					]
				},
				isArbitraryVariableImage,
				isArbitraryImage
			] }],
			"bg-color": [{ bg: I() }],
			"gradient-from-pos": [{ from: te() }],
			"gradient-via-pos": [{ via: te() }],
			"gradient-to-pos": [{ to: te() }],
			"gradient-from": [{ from: I() }],
			"gradient-via": [{ via: I() }],
			"gradient-to": [{ to: I() }],
			rounded: [{ rounded: ne() }],
			"rounded-s": [{ "rounded-s": ne() }],
			"rounded-e": [{ "rounded-e": ne() }],
			"rounded-t": [{ "rounded-t": ne() }],
			"rounded-r": [{ "rounded-r": ne() }],
			"rounded-b": [{ "rounded-b": ne() }],
			"rounded-l": [{ "rounded-l": ne() }],
			"rounded-ss": [{ "rounded-ss": ne() }],
			"rounded-se": [{ "rounded-se": ne() }],
			"rounded-ee": [{ "rounded-ee": ne() }],
			"rounded-es": [{ "rounded-es": ne() }],
			"rounded-tl": [{ "rounded-tl": ne() }],
			"rounded-tr": [{ "rounded-tr": ne() }],
			"rounded-br": [{ "rounded-br": ne() }],
			"rounded-bl": [{ "rounded-bl": ne() }],
			"border-w": [{ border: ie() }],
			"border-w-x": [{ "border-x": ie() }],
			"border-w-y": [{ "border-y": ie() }],
			"border-w-s": [{ "border-s": ie() }],
			"border-w-e": [{ "border-e": ie() }],
			"border-w-t": [{ "border-t": ie() }],
			"border-w-r": [{ "border-r": ie() }],
			"border-w-b": [{ "border-b": ie() }],
			"border-w-l": [{ "border-l": ie() }],
			"divide-x": [{ "divide-x": ie() }],
			"divide-x-reverse": ["divide-x-reverse"],
			"divide-y": [{ "divide-y": ie() }],
			"divide-y-reverse": ["divide-y-reverse"],
			"border-style": [{ border: [
				...ae(),
				"hidden",
				"none"
			] }],
			"divide-style": [{ divide: [
				...ae(),
				"hidden",
				"none"
			] }],
			"border-color": [{ border: I() }],
			"border-color-x": [{ "border-x": I() }],
			"border-color-y": [{ "border-y": I() }],
			"border-color-s": [{ "border-s": I() }],
			"border-color-e": [{ "border-e": I() }],
			"border-color-t": [{ "border-t": I() }],
			"border-color-r": [{ "border-r": I() }],
			"border-color-b": [{ "border-b": I() }],
			"border-color-l": [{ "border-l": I() }],
			"divide-color": [{ divide: I() }],
			"outline-style": [{ outline: [
				...ae(),
				"none",
				"hidden"
			] }],
			"outline-offset": [{ "outline-offset": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"outline-w": [{ outline: [
				"",
				isNumber,
				isArbitraryVariableLength,
				isArbitraryLength
			] }],
			"outline-color": [{ outline: I() }],
			shadow: [{ shadow: [
				"",
				"none",
				d,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"shadow-color": [{ shadow: I() }],
			"inset-shadow": [{ "inset-shadow": [
				"none",
				f,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"inset-shadow-color": [{ "inset-shadow": I() }],
			"ring-w": [{ ring: ie() }],
			"ring-w-inset": ["ring-inset"],
			"ring-color": [{ ring: I() }],
			"ring-offset-w": [{ "ring-offset": [isNumber, isArbitraryLength] }],
			"ring-offset-color": [{ "ring-offset": I() }],
			"inset-ring-w": [{ "inset-ring": ie() }],
			"inset-ring-color": [{ "inset-ring": I() }],
			"text-shadow": [{ "text-shadow": [
				"none",
				p,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"text-shadow-color": [{ "text-shadow": I() }],
			opacity: [{ opacity: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"mix-blend": [{ "mix-blend": [
				...oe(),
				"plus-darker",
				"plus-lighter"
			] }],
			"bg-blend": [{ "bg-blend": oe() }],
			"mask-clip": [{ "mask-clip": [
				"border",
				"padding",
				"content",
				"fill",
				"stroke",
				"view"
			] }, "mask-no-clip"],
			"mask-composite": [{ mask: [
				"add",
				"subtract",
				"intersect",
				"exclude"
			] }],
			"mask-image-linear-pos": [{ "mask-linear": [isNumber] }],
			"mask-image-linear-from-pos": [{ "mask-linear-from": z() }],
			"mask-image-linear-to-pos": [{ "mask-linear-to": z() }],
			"mask-image-linear-from-color": [{ "mask-linear-from": I() }],
			"mask-image-linear-to-color": [{ "mask-linear-to": I() }],
			"mask-image-t-from-pos": [{ "mask-t-from": z() }],
			"mask-image-t-to-pos": [{ "mask-t-to": z() }],
			"mask-image-t-from-color": [{ "mask-t-from": I() }],
			"mask-image-t-to-color": [{ "mask-t-to": I() }],
			"mask-image-r-from-pos": [{ "mask-r-from": z() }],
			"mask-image-r-to-pos": [{ "mask-r-to": z() }],
			"mask-image-r-from-color": [{ "mask-r-from": I() }],
			"mask-image-r-to-color": [{ "mask-r-to": I() }],
			"mask-image-b-from-pos": [{ "mask-b-from": z() }],
			"mask-image-b-to-pos": [{ "mask-b-to": z() }],
			"mask-image-b-from-color": [{ "mask-b-from": I() }],
			"mask-image-b-to-color": [{ "mask-b-to": I() }],
			"mask-image-l-from-pos": [{ "mask-l-from": z() }],
			"mask-image-l-to-pos": [{ "mask-l-to": z() }],
			"mask-image-l-from-color": [{ "mask-l-from": I() }],
			"mask-image-l-to-color": [{ "mask-l-to": I() }],
			"mask-image-x-from-pos": [{ "mask-x-from": z() }],
			"mask-image-x-to-pos": [{ "mask-x-to": z() }],
			"mask-image-x-from-color": [{ "mask-x-from": I() }],
			"mask-image-x-to-color": [{ "mask-x-to": I() }],
			"mask-image-y-from-pos": [{ "mask-y-from": z() }],
			"mask-image-y-to-pos": [{ "mask-y-to": z() }],
			"mask-image-y-from-color": [{ "mask-y-from": I() }],
			"mask-image-y-to-color": [{ "mask-y-to": I() }],
			"mask-image-radial": [{ "mask-radial": [isArbitraryVariable, isArbitraryValue] }],
			"mask-image-radial-from-pos": [{ "mask-radial-from": z() }],
			"mask-image-radial-to-pos": [{ "mask-radial-to": z() }],
			"mask-image-radial-from-color": [{ "mask-radial-from": I() }],
			"mask-image-radial-to-color": [{ "mask-radial-to": I() }],
			"mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }],
			"mask-image-radial-size": [{ "mask-radial": [{
				closest: ["side", "corner"],
				farthest: ["side", "corner"]
			}] }],
			"mask-image-radial-pos": [{ "mask-radial-at": x() }],
			"mask-image-conic-pos": [{ "mask-conic": [isNumber] }],
			"mask-image-conic-from-pos": [{ "mask-conic-from": z() }],
			"mask-image-conic-to-pos": [{ "mask-conic-to": z() }],
			"mask-image-conic-from-color": [{ "mask-conic-from": I() }],
			"mask-image-conic-to-color": [{ "mask-conic-to": I() }],
			"mask-mode": [{ mask: [
				"alpha",
				"luminance",
				"match"
			] }],
			"mask-origin": [{ "mask-origin": [
				"border",
				"padding",
				"content",
				"fill",
				"stroke",
				"view"
			] }],
			"mask-position": [{ mask: ee() }],
			"mask-repeat": [{ mask: L() }],
			"mask-size": [{ mask: R() }],
			"mask-type": [{ "mask-type": ["alpha", "luminance"] }],
			"mask-image": [{ mask: [
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			filter: [{ filter: [
				"",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			blur: [{ blur: se() }],
			brightness: [{ brightness: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			contrast: [{ contrast: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"drop-shadow": [{ "drop-shadow": [
				"",
				"none",
				m,
				isArbitraryVariableShadow,
				isArbitraryShadow
			] }],
			"drop-shadow-color": [{ "drop-shadow": I() }],
			grayscale: [{ grayscale: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"hue-rotate": [{ "hue-rotate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			invert: [{ invert: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			saturate: [{ saturate: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			sepia: [{ sepia: [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-filter": [{ "backdrop-filter": [
				"",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-blur": [{ "backdrop-blur": se() }],
			"backdrop-brightness": [{ "backdrop-brightness": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-contrast": [{ "backdrop-contrast": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-grayscale": [{ "backdrop-grayscale": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-hue-rotate": [{ "backdrop-hue-rotate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-invert": [{ "backdrop-invert": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-opacity": [{ "backdrop-opacity": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-saturate": [{ "backdrop-saturate": [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"backdrop-sepia": [{ "backdrop-sepia": [
				"",
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"border-collapse": [{ border: ["collapse", "separate"] }],
			"border-spacing": [{ "border-spacing": T() }],
			"border-spacing-x": [{ "border-spacing-x": T() }],
			"border-spacing-y": [{ "border-spacing-y": T() }],
			"table-layout": [{ table: ["auto", "fixed"] }],
			caption: [{ caption: ["top", "bottom"] }],
			transition: [{ transition: [
				"",
				"all",
				"colors",
				"opacity",
				"shadow",
				"transform",
				"none",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"transition-behavior": [{ transition: ["normal", "discrete"] }],
			duration: [{ duration: [
				isNumber,
				"initial",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			ease: [{ ease: [
				"linear",
				"initial",
				v,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			delay: [{ delay: [
				isNumber,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			animate: [{ animate: [
				"none",
				y,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			backface: [{ backface: ["hidden", "visible"] }],
			perspective: [{ perspective: [
				g,
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"perspective-origin": [{ "perspective-origin": S() }],
			rotate: [{ rotate: ce() }],
			"rotate-x": [{ "rotate-x": ce() }],
			"rotate-y": [{ "rotate-y": ce() }],
			"rotate-z": [{ "rotate-z": ce() }],
			scale: [{ scale: le() }],
			"scale-x": [{ "scale-x": le() }],
			"scale-y": [{ "scale-y": le() }],
			"scale-z": [{ "scale-z": le() }],
			"scale-3d": ["scale-3d"],
			skew: [{ skew: ue() }],
			"skew-x": [{ "skew-x": ue() }],
			"skew-y": [{ "skew-y": ue() }],
			transform: [{ transform: [
				isArbitraryVariable,
				isArbitraryValue,
				"",
				"none",
				"gpu",
				"cpu"
			] }],
			"transform-origin": [{ origin: S() }],
			"transform-style": [{ transform: ["3d", "flat"] }],
			translate: [{ translate: de() }],
			"translate-x": [{ "translate-x": de() }],
			"translate-y": [{ "translate-y": de() }],
			"translate-z": [{ "translate-z": de() }],
			"translate-none": ["translate-none"],
			accent: [{ accent: I() }],
			appearance: [{ appearance: ["none", "auto"] }],
			"caret-color": [{ caret: I() }],
			"color-scheme": [{ scheme: [
				"normal",
				"dark",
				"light",
				"light-dark",
				"only-dark",
				"only-light"
			] }],
			cursor: [{ cursor: [
				"auto",
				"default",
				"pointer",
				"wait",
				"text",
				"move",
				"help",
				"not-allowed",
				"none",
				"context-menu",
				"progress",
				"cell",
				"crosshair",
				"vertical-text",
				"alias",
				"copy",
				"no-drop",
				"grab",
				"grabbing",
				"all-scroll",
				"col-resize",
				"row-resize",
				"n-resize",
				"e-resize",
				"s-resize",
				"w-resize",
				"ne-resize",
				"nw-resize",
				"se-resize",
				"sw-resize",
				"ew-resize",
				"ns-resize",
				"nesw-resize",
				"nwse-resize",
				"zoom-in",
				"zoom-out",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			"field-sizing": [{ "field-sizing": ["fixed", "content"] }],
			"pointer-events": [{ "pointer-events": ["auto", "none"] }],
			resize: [{ resize: [
				"none",
				"",
				"y",
				"x"
			] }],
			"scroll-behavior": [{ scroll: ["auto", "smooth"] }],
			"scroll-m": [{ "scroll-m": T() }],
			"scroll-mx": [{ "scroll-mx": T() }],
			"scroll-my": [{ "scroll-my": T() }],
			"scroll-ms": [{ "scroll-ms": T() }],
			"scroll-me": [{ "scroll-me": T() }],
			"scroll-mt": [{ "scroll-mt": T() }],
			"scroll-mr": [{ "scroll-mr": T() }],
			"scroll-mb": [{ "scroll-mb": T() }],
			"scroll-ml": [{ "scroll-ml": T() }],
			"scroll-p": [{ "scroll-p": T() }],
			"scroll-px": [{ "scroll-px": T() }],
			"scroll-py": [{ "scroll-py": T() }],
			"scroll-ps": [{ "scroll-ps": T() }],
			"scroll-pe": [{ "scroll-pe": T() }],
			"scroll-pt": [{ "scroll-pt": T() }],
			"scroll-pr": [{ "scroll-pr": T() }],
			"scroll-pb": [{ "scroll-pb": T() }],
			"scroll-pl": [{ "scroll-pl": T() }],
			"snap-align": [{ snap: [
				"start",
				"end",
				"center",
				"align-none"
			] }],
			"snap-stop": [{ snap: ["normal", "always"] }],
			"snap-type": [{ snap: [
				"none",
				"x",
				"y",
				"both"
			] }],
			"snap-strictness": [{ snap: ["mandatory", "proximity"] }],
			touch: [{ touch: [
				"auto",
				"none",
				"manipulation"
			] }],
			"touch-x": [{ "touch-pan": [
				"x",
				"left",
				"right"
			] }],
			"touch-y": [{ "touch-pan": [
				"y",
				"up",
				"down"
			] }],
			"touch-pz": ["touch-pinch-zoom"],
			select: [{ select: [
				"none",
				"text",
				"all",
				"auto"
			] }],
			"will-change": [{ "will-change": [
				"auto",
				"scroll",
				"contents",
				"transform",
				isArbitraryVariable,
				isArbitraryValue
			] }],
			fill: [{ fill: ["none", ...I()] }],
			"stroke-w": [{ stroke: [
				isNumber,
				isArbitraryVariableLength,
				isArbitraryLength,
				isArbitraryNumber
			] }],
			stroke: [{ stroke: ["none", ...I()] }],
			"forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }]
		},
		conflictingClassGroups: {
			overflow: ["overflow-x", "overflow-y"],
			overscroll: ["overscroll-x", "overscroll-y"],
			inset: [
				"inset-x",
				"inset-y",
				"start",
				"end",
				"top",
				"right",
				"bottom",
				"left"
			],
			"inset-x": ["right", "left"],
			"inset-y": ["top", "bottom"],
			flex: [
				"basis",
				"grow",
				"shrink"
			],
			gap: ["gap-x", "gap-y"],
			p: [
				"px",
				"py",
				"ps",
				"pe",
				"pt",
				"pr",
				"pb",
				"pl"
			],
			px: ["pr", "pl"],
			py: ["pt", "pb"],
			m: [
				"mx",
				"my",
				"ms",
				"me",
				"mt",
				"mr",
				"mb",
				"ml"
			],
			mx: ["mr", "ml"],
			my: ["mt", "mb"],
			size: ["w", "h"],
			"font-size": ["leading"],
			"fvn-normal": [
				"fvn-ordinal",
				"fvn-slashed-zero",
				"fvn-figure",
				"fvn-spacing",
				"fvn-fraction"
			],
			"fvn-ordinal": ["fvn-normal"],
			"fvn-slashed-zero": ["fvn-normal"],
			"fvn-figure": ["fvn-normal"],
			"fvn-spacing": ["fvn-normal"],
			"fvn-fraction": ["fvn-normal"],
			"line-clamp": ["display", "overflow"],
			rounded: [
				"rounded-s",
				"rounded-e",
				"rounded-t",
				"rounded-r",
				"rounded-b",
				"rounded-l",
				"rounded-ss",
				"rounded-se",
				"rounded-ee",
				"rounded-es",
				"rounded-tl",
				"rounded-tr",
				"rounded-br",
				"rounded-bl"
			],
			"rounded-s": ["rounded-ss", "rounded-es"],
			"rounded-e": ["rounded-se", "rounded-ee"],
			"rounded-t": ["rounded-tl", "rounded-tr"],
			"rounded-r": ["rounded-tr", "rounded-br"],
			"rounded-b": ["rounded-br", "rounded-bl"],
			"rounded-l": ["rounded-tl", "rounded-bl"],
			"border-spacing": ["border-spacing-x", "border-spacing-y"],
			"border-w": [
				"border-w-x",
				"border-w-y",
				"border-w-s",
				"border-w-e",
				"border-w-t",
				"border-w-r",
				"border-w-b",
				"border-w-l"
			],
			"border-w-x": ["border-w-r", "border-w-l"],
			"border-w-y": ["border-w-t", "border-w-b"],
			"border-color": [
				"border-color-x",
				"border-color-y",
				"border-color-s",
				"border-color-e",
				"border-color-t",
				"border-color-r",
				"border-color-b",
				"border-color-l"
			],
			"border-color-x": ["border-color-r", "border-color-l"],
			"border-color-y": ["border-color-t", "border-color-b"],
			translate: [
				"translate-x",
				"translate-y",
				"translate-none"
			],
			"translate-none": [
				"translate",
				"translate-x",
				"translate-y",
				"translate-z"
			],
			"scroll-m": [
				"scroll-mx",
				"scroll-my",
				"scroll-ms",
				"scroll-me",
				"scroll-mt",
				"scroll-mr",
				"scroll-mb",
				"scroll-ml"
			],
			"scroll-mx": ["scroll-mr", "scroll-ml"],
			"scroll-my": ["scroll-mt", "scroll-mb"],
			"scroll-p": [
				"scroll-px",
				"scroll-py",
				"scroll-ps",
				"scroll-pe",
				"scroll-pt",
				"scroll-pr",
				"scroll-pb",
				"scroll-pl"
			],
			"scroll-px": ["scroll-pr", "scroll-pl"],
			"scroll-py": ["scroll-pt", "scroll-pb"],
			touch: [
				"touch-x",
				"touch-y",
				"touch-pz"
			],
			"touch-x": ["touch"],
			"touch-y": ["touch"],
			"touch-pz": ["touch"]
		},
		conflictingClassGroupModifiers: { "font-size": ["leading"] },
		orderSensitiveModifiers: [
			"*",
			"**",
			"after",
			"backdrop",
			"before",
			"details-content",
			"file",
			"first-letter",
			"first-line",
			"marker",
			"placeholder",
			"selection"
		]
	};
});
function cn(...e) {
	return twMerge(clsx(e));
}
function Select({ ...e }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Root2, {
		"data-slot": "select",
		...e
	});
}
function SelectValue({ ...e }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Value, {
		"data-slot": "select-value",
		...e
	});
}
function SelectTrigger({ className: e, size: t = "default", children: n,...i }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Trigger, {
		"data-slot": "select-trigger",
		"data-size": t,
		className: cn("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", e),
		...i,
		children: [n, /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Icon$1, {
			asChild: !0,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, { className: "size-4 opacity-50" })
		})]
	});
}
function SelectContent({ className: e, children: t, position: n = "popper", align: i = "center",...a }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal$2, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Content2, {
		"data-slot": "select-content",
		className: cn("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md", n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", e),
		position: n,
		align: i,
		...a,
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectScrollUpButton, {}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Viewport, {
				className: cn("p-1", n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"),
				children: t
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectScrollDownButton, {})
		]
	}) });
}
function SelectItem({ className: e, children: t,...n }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Item, {
		"data-slot": "select-item",
		className: cn("focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", e),
		...n,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			className: "absolute right-2 flex size-3.5 items-center justify-center",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ItemIndicator, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Check, { className: "size-4" }) })
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ItemText, { children: t })]
	});
}
function SelectScrollUpButton({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollUpButton, {
		"data-slot": "select-scroll-up-button",
		className: cn("flex cursor-default items-center justify-center py-1", e),
		...t,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronUp, { className: "size-4" })
	});
}
function SelectScrollDownButton({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollDownButton, {
		"data-slot": "select-scroll-down-button",
		className: cn("flex cursor-default items-center justify-center py-1", e),
		...t,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ChevronDown, { className: "size-4" })
	});
}
const mpaValues = [
	"17.5",
	"20",
	"25",
	"30",
	"35",
	"40",
	"45",
	"50"
];
var NAME = "Label", Label$1 = import_react.forwardRef((e, t) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.label, {
	...e,
	ref: t,
	onMouseDown: (t) => {
		t.target.closest("button, input, select, textarea") || (e.onMouseDown?.(t), !t.defaultPrevented && t.detail > 1 && t.preventDefault());
	}
}));
Label$1.displayName = NAME;
var Root$1 = Label$1;
function Label({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Root$1, {
		"data-slot": "label",
		className: cn("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", e),
		...t
	});
}
const MpaSelect = ({ mpa: e, onMpaChange: t }) => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
	className: "flex flex-col gap-1",
	children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Label, {
		htmlFor: "mpa",
		children: "Minimum MPa"
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Select, {
		value: e,
		onValueChange: t,
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectTrigger, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectValue, { placeholder: "Select an MPA" }) }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectContent, { children: mpaValues.map((e) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SelectItem, {
			value: e,
			children: e
		}, e)) })]
	})]
});
function Input({ className: e, type: t,...n }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("input", {
		type: t,
		"data-slot": "input",
		className: cn("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", e),
		...n
	});
}
const QuantityRequired = ({ quantity: e, onQuantityChange: t, label: n = "Quantity required" }) => {
	let [i, a] = (0, import_react.useState)(e ?? "");
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "flex flex-col gap-1",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Label, {
			htmlFor: "quantity",
			children: n
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "flex items-center gap-2",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(Input, {
				id: "quantity",
				type: "number",
				inputMode: "numeric",
				placeholder: "100",
				value: i,
				onChange: (e) => {
					let n = e.target.value;
					a(n);
					let i = parseFloat(n);
					isNaN(i) || t(i);
				},
				className: "w-24",
				min: 0,
				step: 25
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
				className: "text-sm text-muted-foreground",
				children: "m"
			})]
		})]
	});
};
var densityOfConcreteTonnePerMCubed = 2.35, urbanTravelEmissionFactor = .39, longTravelEmissionFactor = .11, urbanTravelCutOffDistanceKm = 30, estimatedPayloadPerTripTonnes = 18, travelEmissionFactor = 1.49, calculateDistanceBetweenLocationsInKm = (e, t) => {
	let n = (t.lat - e.lat) * (Math.PI / 180), i = (t.lon - e.lon) * (Math.PI / 180), a = Math.sin(n / 2) * Math.sin(n / 2) + Math.cos(e.lat * (Math.PI / 180)) * Math.cos(t.lat * (Math.PI / 180)) * Math.sin(i / 2) * Math.sin(i / 2);
	return 6371 * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
};
const calculateEmissions = (e, t, n, i) => {
	let a = n * densityOfConcreteTonnePerMCubed, o = {}, s = [];
	return e.forEach((e) => {
		let c = t[e.town];
		if (!c) return;
		if (!o[e.town]) {
			let t = calculateDistanceBetweenLocationsInKm(i, c), n = a * t, s = urbanTravelCutOffDistanceKm / t, l = n / estimatedPayloadPerTripTonnes, u = 2 * l * t, d = 2 * l * t * travelEmissionFactor, f = u * s, p = u * (1 - s), m = f * urbanTravelEmissionFactor, h = p * longTravelEmissionFactor, g = m + h;
			o[e.town] = {
				plantToSiteTransportEmissions: g,
				theOtherTravelEmissions: d
			};
		}
		let l = o[e.town], u = n * e.kg_co2e_per_m3;
		s.push({
			...e,
			total_weight: a,
			embodied_emissions: u,
			plant_to_site_transport_emissions: l.theOtherTravelEmissions + l.plantToSiteTransportEmissions,
			total_emissions: l.theOtherTravelEmissions + u + l.plantToSiteTransportEmissions
		});
	}), s.sort((e, t) => e.total_emissions - t.total_emissions);
};
var import_maplibre_gl = /* @__PURE__ */ __toESM((/* @__PURE__ */ __commonJSMin(((e, t) => {
	/**
	* MapLibre GL JS
	* @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.10.0/LICENSE.txt
	*/
	(function(n, i) {
		typeof e == "object" && t !== void 0 ? t.exports = i() : typeof define == "function" && define.amd ? define(i) : (n = typeof globalThis < "u" ? globalThis : n || self, n.maplibregl = i());
	})(e, (function() {
		var e = {}, t = {};
		function n(n, i, a) {
			if (t[n] = a, n === "index") {
				var o = "var sharedModule = {}; (" + t.shared + ")(sharedModule); (" + t.worker + ")(sharedModule);", s = {};
				return t.shared(s), t.index(e, s), typeof window < "u" && e.setWorkerUrl(window.URL.createObjectURL(new Blob([o], { type: "text/javascript" }))), e;
			}
		}
		return n("shared", ["exports"], (function(e) {
			function t(e, t, n, i) {
				return new (n ||= Promise)((function(a, o) {
					function s(e) {
						try {
							l(i.next(e));
						} catch (e) {
							o(e);
						}
					}
					function c(e) {
						try {
							l(i.throw(e));
						} catch (e) {
							o(e);
						}
					}
					function l(e) {
						var t;
						e.done ? a(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
							e(t);
						}))).then(s, c);
					}
					l((i = i.apply(e, t || [])).next());
				}));
			}
			function n(e, t) {
				this.x = e, this.y = t;
			}
			function i(e) {
				return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
			}
			var a, o;
			n.prototype = {
				clone() {
					return new n(this.x, this.y);
				},
				add(e) {
					return this.clone()._add(e);
				},
				sub(e) {
					return this.clone()._sub(e);
				},
				multByPoint(e) {
					return this.clone()._multByPoint(e);
				},
				divByPoint(e) {
					return this.clone()._divByPoint(e);
				},
				mult(e) {
					return this.clone()._mult(e);
				},
				div(e) {
					return this.clone()._div(e);
				},
				rotate(e) {
					return this.clone()._rotate(e);
				},
				rotateAround(e, t) {
					return this.clone()._rotateAround(e, t);
				},
				matMult(e) {
					return this.clone()._matMult(e);
				},
				unit() {
					return this.clone()._unit();
				},
				perp() {
					return this.clone()._perp();
				},
				round() {
					return this.clone()._round();
				},
				mag() {
					return Math.sqrt(this.x * this.x + this.y * this.y);
				},
				equals(e) {
					return this.x === e.x && this.y === e.y;
				},
				dist(e) {
					return Math.sqrt(this.distSqr(e));
				},
				distSqr(e) {
					let t = e.x - this.x, n = e.y - this.y;
					return t * t + n * n;
				},
				angle() {
					return Math.atan2(this.y, this.x);
				},
				angleTo(e) {
					return Math.atan2(this.y - e.y, this.x - e.x);
				},
				angleWith(e) {
					return this.angleWithSep(e.x, e.y);
				},
				angleWithSep(e, t) {
					return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t);
				},
				_matMult(e) {
					let t = e[2] * this.x + e[3] * this.y;
					return this.x = e[0] * this.x + e[1] * this.y, this.y = t, this;
				},
				_add(e) {
					return this.x += e.x, this.y += e.y, this;
				},
				_sub(e) {
					return this.x -= e.x, this.y -= e.y, this;
				},
				_mult(e) {
					return this.x *= e, this.y *= e, this;
				},
				_div(e) {
					return this.x /= e, this.y /= e, this;
				},
				_multByPoint(e) {
					return this.x *= e.x, this.y *= e.y, this;
				},
				_divByPoint(e) {
					return this.x /= e.x, this.y /= e.y, this;
				},
				_unit() {
					return this._div(this.mag()), this;
				},
				_perp() {
					let e = this.y;
					return this.y = this.x, this.x = -e, this;
				},
				_rotate(e) {
					let t = Math.cos(e), n = Math.sin(e), i = n * this.x + t * this.y;
					return this.x = t * this.x - n * this.y, this.y = i, this;
				},
				_rotateAround(e, t) {
					let n = Math.cos(e), i = Math.sin(e), a = t.y + i * (this.x - t.x) + n * (this.y - t.y);
					return this.x = t.x + n * (this.x - t.x) - i * (this.y - t.y), this.y = a, this;
				},
				_round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
				},
				constructor: n
			}, n.convert = function(e) {
				if (e instanceof n) return e;
				if (Array.isArray(e)) return new n(+e[0], +e[1]);
				if (e.x !== void 0 && e.y !== void 0) return new n(+e.x, +e.y);
				throw Error("Expected [x, y] or {x, y} point format");
			};
			var s = function() {
				if (o) return a;
				function e(e, t, n, i) {
					this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (i - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = i;
				}
				return o = 1, a = e, e.prototype = {
					sampleCurveX: function(e) {
						return ((this.ax * e + this.bx) * e + this.cx) * e;
					},
					sampleCurveY: function(e) {
						return ((this.ay * e + this.by) * e + this.cy) * e;
					},
					sampleCurveDerivativeX: function(e) {
						return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
					},
					solveCurveX: function(e, t) {
						if (t === void 0 && (t = 1e-6), e < 0) return 0;
						if (e > 1) return 1;
						for (var n = e, i = 0; i < 8; i++) {
							var a = this.sampleCurveX(n) - e;
							if (Math.abs(a) < t) return n;
							var o = this.sampleCurveDerivativeX(n);
							if (Math.abs(o) < 1e-6) break;
							n -= a / o;
						}
						var s = 0, c = 1;
						for (n = e, i = 0; i < 20 && (a = this.sampleCurveX(n), !(Math.abs(a - e) < t)); i++) e > a ? s = n : c = n, n = .5 * (c - s) + s;
						return n;
					},
					solve: function(e, t) {
						return this.sampleCurveY(this.solveCurveX(e, t));
					}
				}, a;
			}(), c = i(s);
			let l, u;
			function d() {
				return l ??= typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function", l;
			}
			function f() {
				if (u == null && (u = !1, d())) {
					let e = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
					if (e) {
						for (let t = 0; t < 25; t++) {
							let n = 4 * t;
							e.fillStyle = `rgb(${n},${n + 1},${n + 2})`, e.fillRect(t % 5, Math.floor(t / 5), 1, 1);
						}
						let t = e.getImageData(0, 0, 5, 5).data;
						for (let e = 0; e < 100; e++) if (e % 4 != 3 && t[e] !== e) {
							u = !0;
							break;
						}
					}
				}
				return u || !1;
			}
			var p = 1e-6, m = typeof Float32Array < "u" ? Float32Array : Array;
			function h() {
				var e = new m(9);
				return m != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;
			}
			function g(e) {
				return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
			}
			function _() {
				var e = new m(3);
				return m != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e;
			}
			function v(e) {
				var t = e[0], n = e[1], i = e[2];
				return Math.sqrt(t * t + n * n + i * i);
			}
			function y(e, t, n) {
				var i = new m(3);
				return i[0] = e, i[1] = t, i[2] = n, i;
			}
			function b(e, t, n) {
				return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e[2] = t[2] + n[2], e;
			}
			function x(e, t, n) {
				return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e;
			}
			function S(e, t, n) {
				var i = t[0], a = t[1], o = t[2], s = n[0], c = n[1], l = n[2];
				return e[0] = a * l - o * c, e[1] = o * s - i * l, e[2] = i * c - a * s, e;
			}
			var C, w = v;
			function T(e, t, n) {
				var i = t[0], a = t[1], o = t[2], s = t[3];
				return e[0] = n[0] * i + n[4] * a + n[8] * o + n[12] * s, e[1] = n[1] * i + n[5] * a + n[9] * o + n[13] * s, e[2] = n[2] * i + n[6] * a + n[10] * o + n[14] * s, e[3] = n[3] * i + n[7] * a + n[11] * o + n[15] * s, e;
			}
			function E() {
				var e = new m(4);
				return m != Float32Array && (e[0] = 0, e[1] = 0, e[2] = 0), e[3] = 1, e;
			}
			function O(e, t, n, i) {
				var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "zyx", o = Math.PI / 360;
				t *= o, i *= o, n *= o;
				var s = Math.sin(t), c = Math.cos(t), l = Math.sin(n), u = Math.cos(n), d = Math.sin(i), f = Math.cos(i);
				switch (a) {
					case "xyz":
						e[0] = s * u * f + c * l * d, e[1] = c * l * f - s * u * d, e[2] = c * u * d + s * l * f, e[3] = c * u * f - s * l * d;
						break;
					case "xzy":
						e[0] = s * u * f - c * l * d, e[1] = c * l * f - s * u * d, e[2] = c * u * d + s * l * f, e[3] = c * u * f + s * l * d;
						break;
					case "yxz":
						e[0] = s * u * f + c * l * d, e[1] = c * l * f - s * u * d, e[2] = c * u * d - s * l * f, e[3] = c * u * f + s * l * d;
						break;
					case "yzx":
						e[0] = s * u * f + c * l * d, e[1] = c * l * f + s * u * d, e[2] = c * u * d - s * l * f, e[3] = c * u * f - s * l * d;
						break;
					case "zxy":
						e[0] = s * u * f - c * l * d, e[1] = c * l * f + s * u * d, e[2] = c * u * d + s * l * f, e[3] = c * u * f - s * l * d;
						break;
					case "zyx":
						e[0] = s * u * f - c * l * d, e[1] = c * l * f + s * u * d, e[2] = c * u * d - s * l * f, e[3] = c * u * f + s * l * d;
						break;
					default: throw Error("Unknown angle order " + a);
				}
				return e;
			}
			function k() {
				var e = new m(2);
				return m != Float32Array && (e[0] = 0, e[1] = 0), e;
			}
			function A(e, t) {
				var n = new m(2);
				return n[0] = e, n[1] = t, n;
			}
			_(), C = new m(4), m != Float32Array && (C[0] = 0, C[1] = 0, C[2] = 0, C[3] = 0), _(), y(1, 0, 0), y(0, 1, 0), E(), E(), h(), k();
			let j = 8192;
			function M(e, t, n) {
				return t * (j / (e.tileSize * 2 ** (n - e.tileID.overscaledZ)));
			}
			function N(e, t) {
				return (e % t + t) % t;
			}
			function P(e, t, n) {
				return e * (1 - n) + t * n;
			}
			function F(e) {
				if (e <= 0) return 0;
				if (e >= 1) return 1;
				let t = e * e, n = t * e;
				return 4 * (e < .5 ? n : 3 * (e - t) + n - .75);
			}
			function I(e, t, n, i) {
				let a = new c(e, t, n, i);
				return (e) => a.solve(e);
			}
			let ee = I(.25, .1, .25, 1);
			function L(e, t, n) {
				return Math.min(n, Math.max(t, e));
			}
			function R(e, t, n) {
				let i = n - t, a = ((e - t) % i + i) % i + t;
				return a === t ? n : a;
			}
			function te(e, ...t) {
				for (let n of t) for (let t in n) e[t] = n[t];
				return e;
			}
			let ne = 1;
			function ie(e, t, n) {
				let i = {};
				for (let n in e) i[n] = t.call(this, e[n], n, e);
				return i;
			}
			function ae(e, t, n) {
				let i = {};
				for (let n in e) t.call(this, e[n], n, e) && (i[n] = e[n]);
				return i;
			}
			function oe(e) {
				return Array.isArray(e) ? e.map(oe) : typeof e == "object" && e ? ie(e, oe) : e;
			}
			let z = {};
			function se(e) {
				z[e] || (typeof console < "u" && console.warn(e), z[e] = !0);
			}
			function ce(e, t, n) {
				return (n.y - e.y) * (t.x - e.x) > (t.y - e.y) * (n.x - e.x);
			}
			function le(e) {
				return typeof WorkerGlobalScope < "u" && e !== void 0 && e instanceof WorkerGlobalScope;
			}
			let ue = null;
			function de(e) {
				if (ue == null) {
					let t = e.navigator ? e.navigator.userAgent : null;
					ue = !!e.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")));
				}
				return ue;
			}
			function fe(e) {
				return typeof ImageBitmap < "u" && e instanceof ImageBitmap;
			}
			let pe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
			function V(e, n, i, a, o) {
				return t(this, void 0, void 0, (function* () {
					if (typeof VideoFrame > "u") throw Error("VideoFrame not supported");
					let t = new VideoFrame(e, { timestamp: 0 });
					try {
						let s = t?.format;
						if (!s || !s.startsWith("BGR") && !s.startsWith("RGB")) throw Error(`Unrecognized format ${s}`);
						let c = s.startsWith("BGR"), l = new Uint8ClampedArray(a * o * 4);
						if (yield t.copyTo(l, function(e, t, n, i, a) {
							let o = 4 * Math.max(-t, 0), s = (Math.max(0, n) - n) * i * 4 + o, c = 4 * i, l = Math.max(0, t), u = Math.max(0, n);
							return {
								rect: {
									x: l,
									y: u,
									width: Math.min(e.width, t + i) - l,
									height: Math.min(e.height, n + a) - u
								},
								layout: [{
									offset: s,
									stride: c
								}]
							};
						}(e, n, i, a, o)), c) for (let e = 0; e < l.length; e += 4) {
							let t = l[e];
							l[e] = l[e + 2], l[e + 2] = t;
						}
						return l;
					} finally {
						t.close();
					}
				}));
			}
			let me, he;
			function ge(e, t, n, i) {
				return e.addEventListener(t, n, i), { unsubscribe: () => {
					e.removeEventListener(t, n, i);
				} };
			}
			function _e(e) {
				return e * Math.PI / 180;
			}
			function H(e) {
				return e / Math.PI * 180;
			}
			let ve = {
				touchstart: !0,
				touchmove: !0,
				touchmoveWindow: !0,
				touchend: !0,
				touchcancel: !0
			}, ye = {
				dblclick: !0,
				click: !0,
				mouseover: !0,
				mouseout: !0,
				mousedown: !0,
				mousemove: !0,
				mousemoveWindow: !0,
				mouseup: !0,
				mouseupWindow: !0,
				contextmenu: !0,
				wheel: !0
			}, be = "AbortError";
			function xe() {
				return Error(be);
			}
			let Se = {
				MAX_PARALLEL_IMAGE_REQUESTS: 16,
				MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
				MAX_TILE_CACHE_ZOOM_LEVELS: 5,
				REGISTERED_PROTOCOLS: {},
				WORKER_URL: ""
			};
			function Ce(e) {
				return Se.REGISTERED_PROTOCOLS[e.substring(0, e.indexOf("://"))];
			}
			let we = "global-dispatcher";
			class Te extends Error {
				constructor(e, t, n, i) {
					super(`AJAXError: ${t} (${e}): ${n}`), this.status = e, this.statusText = t, this.url = n, this.body = i;
				}
			}
			let Ee = () => le(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, De = function(e, n) {
				if (/:\/\//.test(e.url) && !/^https?:|^file:/.test(e.url)) {
					let t = Ce(e.url);
					if (t) return t(e, n);
					if (le(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: e,
						targetMapId: we
					}, n);
				}
				if (!(/^file:/.test(i = e.url) || /^file:/.test(Ee()) && !/^\w+:/.test(i))) {
					if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(e, n) {
						return t(this, void 0, void 0, (function* () {
							let t = new Request(e.url, {
								method: e.method || "GET",
								body: e.body,
								credentials: e.credentials,
								headers: e.headers,
								cache: e.cache,
								referrer: Ee(),
								signal: n.signal
							}), i, a;
							e.type !== "json" || t.headers.has("Accept") || t.headers.set("Accept", "application/json");
							try {
								i = yield fetch(t);
							} catch (t) {
								throw new Te(0, t.message, e.url, new Blob());
							}
							if (!i.ok) {
								let t = yield i.blob();
								throw new Te(i.status, i.statusText, e.url, t);
							}
							a = e.type === "arrayBuffer" || e.type === "image" ? i.arrayBuffer() : e.type === "json" ? i.json() : i.text();
							let o = yield a;
							if (n.signal.aborted) throw xe();
							return {
								data: o,
								cacheControl: i.headers.get("Cache-Control"),
								expires: i.headers.get("Expires")
							};
						}));
					}(e, n);
					if (le(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({
						type: "GR",
						data: e,
						mustQueue: !0,
						targetMapId: we
					}, n);
				}
				var i;
				return function(e, t) {
					return new Promise(((n, i) => {
						var a;
						let o = new XMLHttpRequest();
						for (let t in o.open(e.method || "GET", e.url, !0), e.type !== "arrayBuffer" && e.type !== "image" || (o.responseType = "arraybuffer"), e.headers) o.setRequestHeader(t, e.headers[t]);
						e.type === "json" && (o.responseType = "text", (a = e.headers) != null && a.Accept || o.setRequestHeader("Accept", "application/json")), o.withCredentials = e.credentials === "include", o.onerror = () => {
							i(Error(o.statusText));
						}, o.onload = () => {
							if (!t.signal.aborted) if ((o.status >= 200 && o.status < 300 || o.status === 0) && o.response !== null) {
								let t = o.response;
								if (e.type === "json") try {
									t = JSON.parse(o.response);
								} catch (e) {
									i(e);
									return;
								}
								n({
									data: t,
									cacheControl: o.getResponseHeader("Cache-Control"),
									expires: o.getResponseHeader("Expires")
								});
							} else {
								let t = new Blob([o.response], { type: o.getResponseHeader("Content-Type") });
								i(new Te(o.status, o.statusText, e.url, t));
							}
						}, t.signal.addEventListener("abort", (() => {
							o.abort(), i(xe());
						})), o.send(e.body);
					}));
				}(e, n);
			};
			function Oe(e) {
				if (!e || e.indexOf("://") <= 0 || e.indexOf("data:image/") === 0 || e.indexOf("blob:") === 0) return !0;
				let t = new URL(e), n = window.location;
				return t.protocol === n.protocol && t.host === n.host;
			}
			function ke(e, t, n) {
				n[e] && n[e].indexOf(t) !== -1 || (n[e] = n[e] || [], n[e].push(t));
			}
			function Ae(e, t, n) {
				if (n && n[e]) {
					let i = n[e].indexOf(t);
					i !== -1 && n[e].splice(i, 1);
				}
			}
			class je {
				constructor(e, t = {}) {
					te(this, t), this.type = e;
				}
			}
			class Me extends je {
				constructor(e, t = {}) {
					super("error", te({ error: e }, t));
				}
			}
			class Ne {
				on(e, t) {
					return this._listeners = this._listeners || {}, ke(e, t, this._listeners), { unsubscribe: () => {
						this.off(e, t);
					} };
				}
				off(e, t) {
					return Ae(e, t, this._listeners), Ae(e, t, this._oneTimeListeners), this;
				}
				once(e, t) {
					return t ? (this._oneTimeListeners = this._oneTimeListeners || {}, ke(e, t, this._oneTimeListeners), this) : new Promise(((t) => this.once(e, t)));
				}
				fire(e, t) {
					typeof e == "string" && (e = new je(e, t || {}));
					let n = e.type;
					if (this.listens(n)) {
						e.target = this;
						let t = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
						for (let n of t) n.call(this, e);
						let i = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
						for (let t of i) Ae(n, t, this._oneTimeListeners), t.call(this, e);
						let a = this._eventedParent;
						a && (te(e, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), a.fire(e));
					} else e instanceof Me && console.error(e.error);
					return this;
				}
				listens(e) {
					return this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e);
				}
				setEventedParent(e, t) {
					return this._eventedParent = e, this._eventedParentData = t, this;
				}
			}
			var U = {
				$version: 8,
				$root: {
					version: {
						required: !0,
						type: "enum",
						values: [8]
					},
					name: { type: "string" },
					metadata: { type: "*" },
					center: {
						type: "array",
						value: "number"
					},
					centerAltitude: { type: "number" },
					zoom: { type: "number" },
					bearing: {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees"
					},
					pitch: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					roll: {
						type: "number",
						default: 0,
						units: "degrees"
					},
					state: {
						type: "state",
						default: {}
					},
					light: { type: "light" },
					sky: { type: "sky" },
					projection: { type: "projection" },
					terrain: { type: "terrain" },
					sources: {
						required: !0,
						type: "sources"
					},
					sprite: { type: "sprite" },
					glyphs: { type: "string" },
					"font-faces": {
						type: "array",
						value: "fontFaces"
					},
					transition: { type: "transition" },
					layers: {
						required: !0,
						type: "array",
						value: "layer"
					}
				},
				sources: { "*": { type: "source" } },
				source: [
					"source_vector",
					"source_raster",
					"source_raster_dem",
					"source_geojson",
					"source_video",
					"source_image"
				],
				source_vector: {
					type: {
						required: !0,
						type: "enum",
						values: { vector: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					attribution: { type: "string" },
					promoteId: { type: "promoteId" },
					volatile: {
						type: "boolean",
						default: !1
					},
					encoding: {
						type: "enum",
						values: {
							mvt: {},
							mlt: {}
						},
						default: "mvt"
					},
					"*": { type: "*" }
				},
				source_raster: {
					type: {
						required: !0,
						type: "enum",
						values: { raster: {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					scheme: {
						type: "enum",
						values: {
							xyz: {},
							tms: {}
						},
						default: "xyz"
					},
					attribution: { type: "string" },
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_raster_dem: {
					type: {
						required: !0,
						type: "enum",
						values: { "raster-dem": {} }
					},
					url: { type: "string" },
					tiles: {
						type: "array",
						value: "string"
					},
					bounds: {
						type: "array",
						value: "number",
						length: 4,
						default: [
							-180,
							-85.051129,
							180,
							85.051129
						]
					},
					minzoom: {
						type: "number",
						default: 0
					},
					maxzoom: {
						type: "number",
						default: 22
					},
					tileSize: {
						type: "number",
						default: 512,
						units: "pixels"
					},
					attribution: { type: "string" },
					encoding: {
						type: "enum",
						values: {
							terrarium: {},
							mapbox: {},
							custom: {}
						},
						default: "mapbox"
					},
					redFactor: {
						type: "number",
						default: 1
					},
					blueFactor: {
						type: "number",
						default: 1
					},
					greenFactor: {
						type: "number",
						default: 1
					},
					baseShift: {
						type: "number",
						default: 0
					},
					volatile: {
						type: "boolean",
						default: !1
					},
					"*": { type: "*" }
				},
				source_geojson: {
					type: {
						required: !0,
						type: "enum",
						values: { geojson: {} }
					},
					data: {
						required: !0,
						type: "*"
					},
					maxzoom: {
						type: "number",
						default: 18
					},
					attribution: { type: "string" },
					buffer: {
						type: "number",
						default: 128,
						maximum: 512,
						minimum: 0
					},
					filter: { type: "*" },
					tolerance: {
						type: "number",
						default: .375
					},
					cluster: {
						type: "boolean",
						default: !1
					},
					clusterRadius: {
						type: "number",
						default: 50,
						minimum: 0
					},
					clusterMaxZoom: { type: "number" },
					clusterMinPoints: { type: "number" },
					clusterProperties: { type: "*" },
					lineMetrics: {
						type: "boolean",
						default: !1
					},
					generateId: {
						type: "boolean",
						default: !1
					},
					promoteId: { type: "promoteId" }
				},
				source_video: {
					type: {
						required: !0,
						type: "enum",
						values: { video: {} }
					},
					urls: {
						required: !0,
						type: "array",
						value: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				source_image: {
					type: {
						required: !0,
						type: "enum",
						values: { image: {} }
					},
					url: {
						required: !0,
						type: "string"
					},
					coordinates: {
						required: !0,
						type: "array",
						length: 4,
						value: {
							type: "array",
							length: 2,
							value: "number"
						}
					}
				},
				layer: {
					id: {
						type: "string",
						required: !0
					},
					type: {
						type: "enum",
						values: {
							fill: {},
							line: {},
							symbol: {},
							circle: {},
							heatmap: {},
							"fill-extrusion": {},
							raster: {},
							hillshade: {},
							"color-relief": {},
							background: {}
						},
						required: !0
					},
					metadata: { type: "*" },
					source: { type: "string" },
					"source-layer": { type: "string" },
					minzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					maxzoom: {
						type: "number",
						minimum: 0,
						maximum: 24
					},
					filter: { type: "filter" },
					layout: { type: "layout" },
					paint: { type: "paint" }
				},
				layout: [
					"layout_fill",
					"layout_line",
					"layout_circle",
					"layout_heatmap",
					"layout_fill-extrusion",
					"layout_symbol",
					"layout_raster",
					"layout_hillshade",
					"layout_color-relief",
					"layout_background"
				],
				layout_background: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_fill: {
					"fill-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_circle: {
					"circle-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_heatmap: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				"layout_fill-extrusion": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_line: {
					"line-cap": {
						type: "enum",
						values: {
							butt: {},
							round: {},
							square: {}
						},
						default: "butt",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-join": {
						type: "enum",
						values: {
							bevel: {},
							round: {},
							miter: {}
						},
						default: "miter",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"line-miter-limit": {
						type: "number",
						default: 2,
						requires: [{ "line-join": "miter" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-round-limit": {
						type: "number",
						default: 1.05,
						requires: [{ "line-join": "round" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_symbol: {
					"symbol-placement": {
						type: "enum",
						values: {
							point: {},
							line: {},
							"line-center": {}
						},
						default: "point",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-spacing": {
						type: "number",
						default: 250,
						minimum: 1,
						units: "pixels",
						requires: [{ "symbol-placement": "line" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-avoid-edges": {
						type: "boolean",
						default: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"symbol-sort-key": {
						type: "number",
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"symbol-z-order": {
						type: "enum",
						values: {
							auto: {},
							"viewport-y": {},
							source: {}
						},
						default: "auto",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", { "!": "icon-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-optional": {
						type: "boolean",
						default: !1,
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-size": {
						type: "number",
						default: 1,
						minimum: 0,
						units: "factor of the original icon size",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-text-fit": {
						type: "enum",
						values: {
							none: {},
							width: {},
							height: {},
							both: {}
						},
						default: "none",
						requires: ["icon-image", "text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-text-fit-padding": {
						type: "array",
						value: "number",
						length: 4,
						default: [
							0,
							0,
							0,
							0
						],
						units: "pixels",
						requires: [
							"icon-image",
							"text-field",
							{ "icon-text-fit": [
								"both",
								"width",
								"height"
							] }
						],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-image": {
						type: "resolvedImage",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-padding": {
						type: "padding",
						default: [2],
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-keep-upright": {
						type: "boolean",
						default: !1,
						requires: [
							"icon-image",
							{ "icon-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-offset": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"icon-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotation-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {},
							"viewport-glyph": {},
							auto: {}
						},
						default: "auto",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-field": {
						type: "formatted",
						default: "",
						tokens: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-font": {
						type: "array",
						value: "string",
						default: ["Open Sans Regular", "Arial Unicode MS Regular"],
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-size": {
						type: "number",
						default: 16,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-width": {
						type: "number",
						default: 10,
						minimum: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-line-height": {
						type: "number",
						default: 1.2,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-letter-spacing": {
						type: "number",
						default: 0,
						units: "ems",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-justify": {
						type: "enum",
						values: {
							auto: {},
							left: {},
							center: {},
							right: {}
						},
						default: "center",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-radial-offset": {
						type: "number",
						units: "ems",
						default: 0,
						requires: ["text-field"],
						"property-type": "data-driven",
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						}
					},
					"text-variable-anchor": {
						type: "array",
						value: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-variable-anchor-offset": {
						type: "variableAnchorOffsetCollection",
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-anchor": {
						type: "enum",
						values: {
							center: {},
							left: {},
							right: {},
							top: {},
							bottom: {},
							"top-left": {},
							"top-right": {},
							"bottom-left": {},
							"bottom-right": {}
						},
						default: "center",
						requires: ["text-field", { "!": "text-variable-anchor" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-max-angle": {
						type: "number",
						default: 45,
						units: "degrees",
						requires: ["text-field", { "symbol-placement": ["line", "line-center"] }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-writing-mode": {
						type: "array",
						value: "enum",
						values: {
							horizontal: {},
							vertical: {}
						},
						requires: ["text-field", { "symbol-placement": ["point"] }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-rotate": {
						type: "number",
						default: 0,
						period: 360,
						units: "degrees",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-padding": {
						type: "number",
						default: 2,
						minimum: 0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-keep-upright": {
						type: "boolean",
						default: !0,
						requires: [
							"text-field",
							{ "text-rotation-alignment": "map" },
							{ "symbol-placement": ["line", "line-center"] }
						],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-transform": {
						type: "enum",
						values: {
							none: {},
							uppercase: {},
							lowercase: {}
						},
						default: "none",
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-offset": {
						type: "array",
						value: "number",
						units: "ems",
						length: 2,
						default: [0, 0],
						requires: ["text-field", { "!": "text-radial-offset" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom", "feature"]
						},
						"property-type": "data-driven"
					},
					"text-allow-overlap": {
						type: "boolean",
						default: !1,
						requires: ["text-field", { "!": "text-overlap" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-overlap": {
						type: "enum",
						values: {
							never: {},
							always: {},
							cooperative: {}
						},
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-ignore-placement": {
						type: "boolean",
						default: !1,
						requires: ["text-field"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-optional": {
						type: "boolean",
						default: !1,
						requires: ["text-field", "icon-image"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					visibility: {
						type: "enum",
						values: {
							visible: {},
							none: {}
						},
						default: "visible",
						"property-type": "constant"
					}
				},
				layout_raster: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				layout_hillshade: { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				"layout_color-relief": { visibility: {
					type: "enum",
					values: {
						visible: {},
						none: {}
					},
					default: "visible",
					"property-type": "constant"
				} },
				filter: {
					type: "array",
					value: "*"
				},
				filter_operator: {
					type: "enum",
					values: {
						"==": {},
						"!=": {},
						">": {},
						">=": {},
						"<": {},
						"<=": {},
						in: {},
						"!in": {},
						all: {},
						any: {},
						none: {},
						has: {},
						"!has": {}
					}
				},
				geometry_type: {
					type: "enum",
					values: {
						Point: {},
						LineString: {},
						Polygon: {}
					}
				},
				function: {
					expression: { type: "expression" },
					stops: {
						type: "array",
						value: "function_stop"
					},
					base: {
						type: "number",
						default: 1,
						minimum: 0
					},
					property: {
						type: "string",
						default: "$zoom"
					},
					type: {
						type: "enum",
						values: {
							identity: {},
							exponential: {},
							interval: {},
							categorical: {}
						},
						default: "exponential"
					},
					colorSpace: {
						type: "enum",
						values: {
							rgb: {},
							lab: {},
							hcl: {}
						},
						default: "rgb"
					},
					default: {
						type: "*",
						required: !1
					}
				},
				function_stop: {
					type: "array",
					minimum: 0,
					maximum: 24,
					value: ["number", "color"],
					length: 2
				},
				expression: {
					type: "array",
					value: "*",
					minimum: 1
				},
				light: {
					anchor: {
						type: "enum",
						default: "viewport",
						values: {
							map: {},
							viewport: {}
						},
						"property-type": "data-constant",
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						}
					},
					position: {
						type: "array",
						default: [
							1.15,
							210,
							30
						],
						length: 3,
						value: "number",
						"property-type": "data-constant",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						}
					},
					color: {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					intensity: {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				sky: {
					"sky-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#88C6FC",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-color": {
						type: "color",
						"property-type": "data-constant",
						default: "#ffffff",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"fog-ground-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .5,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"horizon-fog-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"sky-horizon-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					},
					"atmosphere-blend": {
						type: "number",
						"property-type": "data-constant",
						default: .8,
						minimum: 0,
						maximum: 1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						transition: !0
					}
				},
				terrain: {
					source: {
						type: "string",
						required: !0
					},
					exaggeration: {
						type: "number",
						minimum: 0,
						default: 1
					}
				},
				projection: { type: {
					type: "projectionDefinition",
					default: "mercator",
					"property-type": "data-constant",
					transition: !1,
					expression: {
						interpolated: !0,
						parameters: ["zoom"]
					}
				} },
				paint: [
					"paint_fill",
					"paint_line",
					"paint_circle",
					"paint_heatmap",
					"paint_fill-extrusion",
					"paint_symbol",
					"paint_raster",
					"paint_hillshade",
					"paint_color-relief",
					"paint_background"
				],
				paint_fill: {
					"fill-antialias": {
						type: "boolean",
						default: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-outline-color": {
						type: "color",
						transition: !0,
						requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					}
				},
				"paint_fill-extrusion": {
					"fill-extrusion-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "fill-extrusion-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["fill-extrusion-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"fill-extrusion-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"fill-extrusion-height": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-base": {
						type: "number",
						default: 0,
						minimum: 0,
						units: "meters",
						transition: !0,
						requires: ["fill-extrusion-height"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"fill-extrusion-vertical-gradient": {
						type: "boolean",
						default: !0,
						transition: !1,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_line: {
					"line-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["line-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"line-width": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-gap-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-offset": {
						type: "number",
						default: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"line-dasharray": {
						type: "array",
						value: "number",
						minimum: 0,
						transition: !0,
						units: "line widths",
						requires: [{ "!": "line-pattern" }],
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom", "feature"]
						},
						"property-type": "cross-faded-data-driven"
					},
					"line-gradient": {
						type: "color",
						transition: !1,
						requires: [
							{ "!": "line-dasharray" },
							{ "!": "line-pattern" },
							{
								source: "geojson",
								has: { lineMetrics: !0 }
							}
						],
						expression: {
							interpolated: !0,
							parameters: ["line-progress"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_circle: {
					"circle-radius": {
						type: "number",
						default: 5,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-blur": {
						type: "number",
						default: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["circle-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-scale": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-pitch-alignment": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"circle-stroke-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"circle-stroke-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					}
				},
				paint_heatmap: {
					"heatmap-radius": {
						type: "number",
						default: 30,
						minimum: 1,
						transition: !0,
						units: "pixels",
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-weight": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"heatmap-intensity": {
						type: "number",
						default: 1,
						minimum: 0,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"heatmap-color": {
						type: "color",
						default: [
							"interpolate",
							["linear"],
							["heatmap-density"],
							0,
							"rgba(0, 0, 255, 0)",
							.1,
							"royalblue",
							.3,
							"cyan",
							.5,
							"lime",
							.7,
							"yellow",
							1,
							"red"
						],
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["heatmap-density"]
						},
						"property-type": "color-ramp"
					},
					"heatmap-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_symbol: {
					"icon-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"icon-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["icon-image"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"icon-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["icon-image", "icon-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						overridable: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-color": {
						type: "color",
						default: "rgba(0, 0, 0, 0)",
						transition: !0,
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-width": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-halo-blur": {
						type: "number",
						default: 0,
						minimum: 0,
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: [
								"zoom",
								"feature",
								"feature-state"
							]
						},
						"property-type": "data-driven"
					},
					"text-translate": {
						type: "array",
						value: "number",
						length: 2,
						default: [0, 0],
						transition: !0,
						units: "pixels",
						requires: ["text-field"],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"text-translate-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "map",
						requires: ["text-field", "text-translate"],
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_raster: {
					"raster-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-hue-rotate": {
						type: "number",
						default: 0,
						period: 360,
						transition: !0,
						units: "degrees",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-min": {
						type: "number",
						default: 0,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-brightness-max": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-saturation": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-contrast": {
						type: "number",
						default: 0,
						minimum: -1,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-resampling": {
						type: "enum",
						values: {
							linear: {},
							nearest: {}
						},
						default: "linear",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"raster-fade-duration": {
						type: "number",
						default: 300,
						minimum: 0,
						transition: !1,
						units: "milliseconds",
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				paint_hillshade: {
					"hillshade-illumination-direction": {
						type: "numberArray",
						default: 335,
						minimum: 0,
						maximum: 359,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-altitude": {
						type: "numberArray",
						default: 45,
						minimum: 0,
						maximum: 90,
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-illumination-anchor": {
						type: "enum",
						values: {
							map: {},
							viewport: {}
						},
						default: "viewport",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-exaggeration": {
						type: "number",
						default: .5,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-shadow-color": {
						type: "colorArray",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-highlight-color": {
						type: "colorArray",
						default: "#FFFFFF",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-accent-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"hillshade-method": {
						type: "enum",
						values: {
							standard: {},
							basic: {},
							combined: {},
							igor: {},
							multidirectional: {}
						},
						default: "standard",
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				"paint_color-relief": {
					"color-relief-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"color-relief-color": {
						type: "color",
						transition: !1,
						expression: {
							interpolated: !0,
							parameters: ["elevation"]
						},
						"property-type": "color-ramp"
					}
				},
				paint_background: {
					"background-color": {
						type: "color",
						default: "#000000",
						transition: !0,
						requires: [{ "!": "background-pattern" }],
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					},
					"background-pattern": {
						type: "resolvedImage",
						transition: !0,
						expression: {
							interpolated: !1,
							parameters: ["zoom"]
						},
						"property-type": "cross-faded"
					},
					"background-opacity": {
						type: "number",
						default: 1,
						minimum: 0,
						maximum: 1,
						transition: !0,
						expression: {
							interpolated: !0,
							parameters: ["zoom"]
						},
						"property-type": "data-constant"
					}
				},
				transition: {
					duration: {
						type: "number",
						default: 300,
						minimum: 0,
						units: "milliseconds"
					},
					delay: {
						type: "number",
						default: 0,
						minimum: 0,
						units: "milliseconds"
					}
				},
				"property-type": {
					"data-driven": { type: "property-type" },
					"cross-faded": { type: "property-type" },
					"cross-faded-data-driven": { type: "property-type" },
					"color-ramp": { type: "property-type" },
					"data-constant": { type: "property-type" },
					constant: { type: "property-type" }
				},
				promoteId: { "*": { type: "string" } }
			};
			let Pe = [
				"type",
				"source",
				"source-layer",
				"minzoom",
				"maxzoom",
				"filter",
				"layout"
			];
			function Fe(e, t) {
				let n = {};
				for (let t in e) t !== "ref" && (n[t] = e[t]);
				return Pe.forEach(((e) => {
					e in t && (n[e] = t[e]);
				})), n;
			}
			function Ie(e, t) {
				if (Array.isArray(e)) {
					if (!Array.isArray(t) || e.length !== t.length) return !1;
					for (let n = 0; n < e.length; n++) if (!Ie(e[n], t[n])) return !1;
					return !0;
				}
				if (typeof e == "object" && e && t !== null) {
					if (typeof t != "object" || Object.keys(e).length !== Object.keys(t).length) return !1;
					for (let n in e) if (!Ie(e[n], t[n])) return !1;
					return !0;
				}
				return e === t;
			}
			function Le(e, t) {
				e.push(t);
			}
			function Re(e, t, n) {
				Le(n, {
					command: "addSource",
					args: [e, t[e]]
				});
			}
			function ze(e, t, n) {
				Le(t, {
					command: "removeSource",
					args: [e]
				}), n[e] = !0;
			}
			function Be(e, t, n, i) {
				ze(e, n, i), Re(e, t, n);
			}
			function Ve(e, t, n) {
				let i;
				for (i in e[n]) if (Object.prototype.hasOwnProperty.call(e[n], i) && i !== "data" && !Ie(e[n][i], t[n][i])) return !1;
				for (i in t[n]) if (Object.prototype.hasOwnProperty.call(t[n], i) && i !== "data" && !Ie(e[n][i], t[n][i])) return !1;
				return !0;
			}
			function He(e, t, n, i, a, o) {
				for (let s in e ||= {}, t ||= {}, e) Object.prototype.hasOwnProperty.call(e, s) && (Ie(e[s], t[s]) || n.push({
					command: o,
					args: [
						i,
						s,
						t[s],
						a
					]
				}));
				for (let s in t) Object.prototype.hasOwnProperty.call(t, s) && !Object.prototype.hasOwnProperty.call(e, s) && (Ie(e[s], t[s]) || n.push({
					command: o,
					args: [
						i,
						s,
						t[s],
						a
					]
				}));
			}
			function Ue(e) {
				return e.id;
			}
			function We(e, t) {
				return e[t.id] = t, e;
			}
			class W {
				constructor(e, t, n, i) {
					this.message = (e ? `${e}: ` : "") + n, i && (this.identifier = i), t != null && t.__line__ && (this.line = t.__line__);
				}
			}
			function Ge(e, ...t) {
				for (let n of t) for (let t in n) e[t] = n[t];
				return e;
			}
			class Ke extends Error {
				constructor(e, t) {
					super(t), this.message = t, this.key = e;
				}
			}
			class qe {
				constructor(e, t = []) {
					this.parent = e, this.bindings = {};
					for (let [e, n] of t) this.bindings[e] = n;
				}
				concat(e) {
					return new qe(this, e);
				}
				get(e) {
					if (this.bindings[e]) return this.bindings[e];
					if (this.parent) return this.parent.get(e);
					throw Error(`${e} not found in scope.`);
				}
				has(e) {
					return !!this.bindings[e] || !!this.parent && this.parent.has(e);
				}
			}
			let Je = { kind: "null" }, G = { kind: "number" }, Ye = { kind: "string" }, Xe = { kind: "boolean" }, Ze = { kind: "color" }, Qe = { kind: "projectionDefinition" }, $e = { kind: "object" }, et = { kind: "value" }, tt = { kind: "collator" }, nt = { kind: "formatted" }, rt = { kind: "padding" }, it = { kind: "colorArray" }, at = { kind: "numberArray" }, ot = { kind: "resolvedImage" }, st = { kind: "variableAnchorOffsetCollection" };
			function ct(e, t) {
				return {
					kind: "array",
					itemType: e,
					N: t
				};
			}
			function lt(e) {
				if (e.kind === "array") {
					let t = lt(e.itemType);
					return typeof e.N == "number" ? `array<${t}, ${e.N}>` : e.itemType.kind === "value" ? "array" : `array<${t}>`;
				}
				return e.kind;
			}
			let ut = [
				Je,
				G,
				Ye,
				Xe,
				Ze,
				Qe,
				nt,
				$e,
				ct(et),
				rt,
				at,
				it,
				ot,
				st
			];
			function dt(e, t) {
				if (t.kind === "error") return null;
				if (e.kind === "array") {
					if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !dt(e.itemType, t.itemType)) && (typeof e.N != "number" || e.N === t.N)) return null;
				} else {
					if (e.kind === t.kind) return null;
					if (e.kind === "value") {
						for (let e of ut) if (!dt(e, t)) return null;
					}
				}
				return `Expected ${lt(e)} but found ${lt(t)} instead.`;
			}
			function ft(e, t) {
				return t.some(((t) => t.kind === e.kind));
			}
			function pt(e, t) {
				return t.some(((t) => t === "null" ? e === null : t === "array" ? Array.isArray(e) : t === "object" ? e && !Array.isArray(e) && typeof e == "object" : t === typeof e));
			}
			function mt(e, t) {
				return e.kind === "array" && t.kind === "array" ? e.itemType.kind === t.itemType.kind && typeof e.N == "number" : e.kind === t.kind;
			}
			let ht = .96422, gt = .82521, _t = 4 / 29, vt = 6 / 29, yt = 3 * vt * vt;
			vt * vt * vt;
			let bt = Math.PI / 180, xt = 180 / Math.PI;
			function St(e) {
				return (e %= 360) < 0 && (e += 360), e;
			}
			function Ct([e, t, n, i]) {
				let a, o, s = Tt((.2225045 * (e = wt(e)) + .7168786 * (t = wt(t)) + .0606169 * (n = wt(n))) / 1);
				e === t && t === n ? a = o = s : (a = Tt((.4360747 * e + .3850649 * t + .1430804 * n) / ht), o = Tt((.0139322 * e + .0971045 * t + .7141733 * n) / gt));
				let c = 116 * s - 16;
				return [
					c < 0 ? 0 : c,
					500 * (a - s),
					200 * (s - o),
					i
				];
			}
			function wt(e) {
				return e <= .04045 ? e / 12.92 : ((e + .055) / 1.055) ** 2.4;
			}
			function Tt(e) {
				return e > .008856451679035631 ? e ** (1 / 3) : e / yt + _t;
			}
			function Et([e, t, n, i]) {
				let a = (e + 16) / 116, o = isNaN(t) ? a : a + t / 500, s = isNaN(n) ? a : a - n / 200;
				return a = 1 * Ot(a), o = ht * Ot(o), s = gt * Ot(s), [
					Dt(3.1338561 * o - 1.6168667 * a - .4906146 * s),
					Dt(-.9787684 * o + 1.9161415 * a + .033454 * s),
					Dt(.0719453 * o - .2289914 * a + 1.4052427 * s),
					i
				];
			}
			function Dt(e) {
				return (e = e <= .00304 ? 12.92 * e : 1.055 * e ** (1 / 2.4) - .055) < 0 ? 0 : e > 1 ? 1 : e;
			}
			function Ot(e) {
				return e > vt ? e * e * e : yt * (e - _t);
			}
			let kt = Object.hasOwn || function(e, t) {
				return Object.prototype.hasOwnProperty.call(e, t);
			};
			function At(e, t) {
				return kt(e, t) ? e[t] : void 0;
			}
			function jt(e) {
				return parseInt(e.padEnd(2, e), 16) / 255;
			}
			function Mt(e, t) {
				return Nt(t ? e / 100 : e, 0, 1);
			}
			function Nt(e, t, n) {
				return Math.min(Math.max(t, e), n);
			}
			function Pt(e) {
				return !e.some(Number.isNaN);
			}
			let Ft = {
				aliceblue: [
					240,
					248,
					255
				],
				antiquewhite: [
					250,
					235,
					215
				],
				aqua: [
					0,
					255,
					255
				],
				aquamarine: [
					127,
					255,
					212
				],
				azure: [
					240,
					255,
					255
				],
				beige: [
					245,
					245,
					220
				],
				bisque: [
					255,
					228,
					196
				],
				black: [
					0,
					0,
					0
				],
				blanchedalmond: [
					255,
					235,
					205
				],
				blue: [
					0,
					0,
					255
				],
				blueviolet: [
					138,
					43,
					226
				],
				brown: [
					165,
					42,
					42
				],
				burlywood: [
					222,
					184,
					135
				],
				cadetblue: [
					95,
					158,
					160
				],
				chartreuse: [
					127,
					255,
					0
				],
				chocolate: [
					210,
					105,
					30
				],
				coral: [
					255,
					127,
					80
				],
				cornflowerblue: [
					100,
					149,
					237
				],
				cornsilk: [
					255,
					248,
					220
				],
				crimson: [
					220,
					20,
					60
				],
				cyan: [
					0,
					255,
					255
				],
				darkblue: [
					0,
					0,
					139
				],
				darkcyan: [
					0,
					139,
					139
				],
				darkgoldenrod: [
					184,
					134,
					11
				],
				darkgray: [
					169,
					169,
					169
				],
				darkgreen: [
					0,
					100,
					0
				],
				darkgrey: [
					169,
					169,
					169
				],
				darkkhaki: [
					189,
					183,
					107
				],
				darkmagenta: [
					139,
					0,
					139
				],
				darkolivegreen: [
					85,
					107,
					47
				],
				darkorange: [
					255,
					140,
					0
				],
				darkorchid: [
					153,
					50,
					204
				],
				darkred: [
					139,
					0,
					0
				],
				darksalmon: [
					233,
					150,
					122
				],
				darkseagreen: [
					143,
					188,
					143
				],
				darkslateblue: [
					72,
					61,
					139
				],
				darkslategray: [
					47,
					79,
					79
				],
				darkslategrey: [
					47,
					79,
					79
				],
				darkturquoise: [
					0,
					206,
					209
				],
				darkviolet: [
					148,
					0,
					211
				],
				deeppink: [
					255,
					20,
					147
				],
				deepskyblue: [
					0,
					191,
					255
				],
				dimgray: [
					105,
					105,
					105
				],
				dimgrey: [
					105,
					105,
					105
				],
				dodgerblue: [
					30,
					144,
					255
				],
				firebrick: [
					178,
					34,
					34
				],
				floralwhite: [
					255,
					250,
					240
				],
				forestgreen: [
					34,
					139,
					34
				],
				fuchsia: [
					255,
					0,
					255
				],
				gainsboro: [
					220,
					220,
					220
				],
				ghostwhite: [
					248,
					248,
					255
				],
				gold: [
					255,
					215,
					0
				],
				goldenrod: [
					218,
					165,
					32
				],
				gray: [
					128,
					128,
					128
				],
				green: [
					0,
					128,
					0
				],
				greenyellow: [
					173,
					255,
					47
				],
				grey: [
					128,
					128,
					128
				],
				honeydew: [
					240,
					255,
					240
				],
				hotpink: [
					255,
					105,
					180
				],
				indianred: [
					205,
					92,
					92
				],
				indigo: [
					75,
					0,
					130
				],
				ivory: [
					255,
					255,
					240
				],
				khaki: [
					240,
					230,
					140
				],
				lavender: [
					230,
					230,
					250
				],
				lavenderblush: [
					255,
					240,
					245
				],
				lawngreen: [
					124,
					252,
					0
				],
				lemonchiffon: [
					255,
					250,
					205
				],
				lightblue: [
					173,
					216,
					230
				],
				lightcoral: [
					240,
					128,
					128
				],
				lightcyan: [
					224,
					255,
					255
				],
				lightgoldenrodyellow: [
					250,
					250,
					210
				],
				lightgray: [
					211,
					211,
					211
				],
				lightgreen: [
					144,
					238,
					144
				],
				lightgrey: [
					211,
					211,
					211
				],
				lightpink: [
					255,
					182,
					193
				],
				lightsalmon: [
					255,
					160,
					122
				],
				lightseagreen: [
					32,
					178,
					170
				],
				lightskyblue: [
					135,
					206,
					250
				],
				lightslategray: [
					119,
					136,
					153
				],
				lightslategrey: [
					119,
					136,
					153
				],
				lightsteelblue: [
					176,
					196,
					222
				],
				lightyellow: [
					255,
					255,
					224
				],
				lime: [
					0,
					255,
					0
				],
				limegreen: [
					50,
					205,
					50
				],
				linen: [
					250,
					240,
					230
				],
				magenta: [
					255,
					0,
					255
				],
				maroon: [
					128,
					0,
					0
				],
				mediumaquamarine: [
					102,
					205,
					170
				],
				mediumblue: [
					0,
					0,
					205
				],
				mediumorchid: [
					186,
					85,
					211
				],
				mediumpurple: [
					147,
					112,
					219
				],
				mediumseagreen: [
					60,
					179,
					113
				],
				mediumslateblue: [
					123,
					104,
					238
				],
				mediumspringgreen: [
					0,
					250,
					154
				],
				mediumturquoise: [
					72,
					209,
					204
				],
				mediumvioletred: [
					199,
					21,
					133
				],
				midnightblue: [
					25,
					25,
					112
				],
				mintcream: [
					245,
					255,
					250
				],
				mistyrose: [
					255,
					228,
					225
				],
				moccasin: [
					255,
					228,
					181
				],
				navajowhite: [
					255,
					222,
					173
				],
				navy: [
					0,
					0,
					128
				],
				oldlace: [
					253,
					245,
					230
				],
				olive: [
					128,
					128,
					0
				],
				olivedrab: [
					107,
					142,
					35
				],
				orange: [
					255,
					165,
					0
				],
				orangered: [
					255,
					69,
					0
				],
				orchid: [
					218,
					112,
					214
				],
				palegoldenrod: [
					238,
					232,
					170
				],
				palegreen: [
					152,
					251,
					152
				],
				paleturquoise: [
					175,
					238,
					238
				],
				palevioletred: [
					219,
					112,
					147
				],
				papayawhip: [
					255,
					239,
					213
				],
				peachpuff: [
					255,
					218,
					185
				],
				peru: [
					205,
					133,
					63
				],
				pink: [
					255,
					192,
					203
				],
				plum: [
					221,
					160,
					221
				],
				powderblue: [
					176,
					224,
					230
				],
				purple: [
					128,
					0,
					128
				],
				rebeccapurple: [
					102,
					51,
					153
				],
				red: [
					255,
					0,
					0
				],
				rosybrown: [
					188,
					143,
					143
				],
				royalblue: [
					65,
					105,
					225
				],
				saddlebrown: [
					139,
					69,
					19
				],
				salmon: [
					250,
					128,
					114
				],
				sandybrown: [
					244,
					164,
					96
				],
				seagreen: [
					46,
					139,
					87
				],
				seashell: [
					255,
					245,
					238
				],
				sienna: [
					160,
					82,
					45
				],
				silver: [
					192,
					192,
					192
				],
				skyblue: [
					135,
					206,
					235
				],
				slateblue: [
					106,
					90,
					205
				],
				slategray: [
					112,
					128,
					144
				],
				slategrey: [
					112,
					128,
					144
				],
				snow: [
					255,
					250,
					250
				],
				springgreen: [
					0,
					255,
					127
				],
				steelblue: [
					70,
					130,
					180
				],
				tan: [
					210,
					180,
					140
				],
				teal: [
					0,
					128,
					128
				],
				thistle: [
					216,
					191,
					216
				],
				tomato: [
					255,
					99,
					71
				],
				turquoise: [
					64,
					224,
					208
				],
				violet: [
					238,
					130,
					238
				],
				wheat: [
					245,
					222,
					179
				],
				white: [
					255,
					255,
					255
				],
				whitesmoke: [
					245,
					245,
					245
				],
				yellow: [
					255,
					255,
					0
				],
				yellowgreen: [
					154,
					205,
					50
				]
			};
			function It(e, t, n) {
				return e + n * (t - e);
			}
			function Lt(e, t, n) {
				return e.map(((e, i) => It(e, t[i], n)));
			}
			class Rt {
				constructor(e, t, n, i = 1, a = !0) {
					this.r = e, this.g = t, this.b = n, this.a = i, a || (this.r *= i, this.g *= i, this.b *= i, i || this.overwriteGetter("rgb", [
						e,
						t,
						n,
						i
					]));
				}
				static parse(e) {
					if (e instanceof Rt) return e;
					if (typeof e != "string") return;
					let t = function(e) {
						if ((e = e.toLowerCase().trim()) === "transparent") return [
							0,
							0,
							0,
							0
						];
						let t = At(Ft, e);
						if (t) {
							let [e, n, i] = t;
							return [
								e / 255,
								n / 255,
								i / 255,
								1
							];
						}
						if (e.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(e)) {
							let t = e.length < 6 ? 1 : 2, n = 1;
							return [
								jt(e.slice(n, n += t)),
								jt(e.slice(n, n += t)),
								jt(e.slice(n, n += t)),
								jt(e.slice(n, n + t) || "ff")
							];
						}
						if (e.startsWith("rgb")) {
							let t = e.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
							if (t) {
								let [e, n, i, a, o, s, c, l, u, d, f, p] = t, m = [
									a || " ",
									c || " ",
									d
								].join("");
								if (m === "  " || m === "  /" || m === ",," || m === ",,,") {
									let e = [
										i,
										s,
										u
									].join(""), t = e === "%%%" ? 100 : e === "" ? 255 : 0;
									if (t) {
										let e = [
											Nt(+n / t, 0, 1),
											Nt(+o / t, 0, 1),
											Nt(+l / t, 0, 1),
											f ? Mt(+f, p) : 1
										];
										if (Pt(e)) return e;
									}
								}
								return;
							}
						}
						let n = e.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
						if (n) {
							let [e, t, i, a, o, s, c, l, u] = n, d = [
								i || " ",
								o || " ",
								c
							].join("");
							if (d === "  " || d === "  /" || d === ",," || d === ",,,") {
								let e = [
									+t,
									Nt(+a, 0, 100),
									Nt(+s, 0, 100),
									l ? Mt(+l, u) : 1
								];
								if (Pt(e)) return function([e, t, n, i]) {
									function a(i) {
										let a = (i + e / 30) % 12, o = t * Math.min(n, 1 - n);
										return n - o * Math.max(-1, Math.min(a - 3, 9 - a, 1));
									}
									return e = St(e), t /= 100, n /= 100, [
										a(0),
										a(8),
										a(4),
										i
									];
								}(e);
							}
						}
					}(e);
					return t ? new Rt(...t, !1) : void 0;
				}
				get rgb() {
					let { r: e, g: t, b: n, a: i } = this, a = i || Infinity;
					return this.overwriteGetter("rgb", [
						e / a,
						t / a,
						n / a,
						i
					]);
				}
				get hcl() {
					return this.overwriteGetter("hcl", function(e) {
						let [t, n, i, a] = Ct(e), o = Math.sqrt(n * n + i * i);
						return [
							Math.round(1e4 * o) ? St(Math.atan2(i, n) * xt) : NaN,
							o,
							t,
							a
						];
					}(this.rgb));
				}
				get lab() {
					return this.overwriteGetter("lab", Ct(this.rgb));
				}
				overwriteGetter(e, t) {
					return Object.defineProperty(this, e, { value: t }), t;
				}
				toString() {
					let [e, t, n, i] = this.rgb;
					return `rgba(${[
						e,
						t,
						n
					].map(((e) => Math.round(255 * e))).join(",")},${i})`;
				}
				static interpolate(e, t, n, i = "rgb") {
					switch (i) {
						case "rgb": {
							let [i, a, o, s] = Lt(e.rgb, t.rgb, n);
							return new Rt(i, a, o, s, !1);
						}
						case "hcl": {
							let [i, a, o, s] = e.hcl, [c, l, u, d] = t.hcl, f, p;
							if (isNaN(i) || isNaN(c)) isNaN(i) ? isNaN(c) ? f = NaN : (f = c, o !== 1 && o !== 0 || (p = l)) : (f = i, u !== 1 && u !== 0 || (p = a));
							else {
								let e = c - i;
								c > i && e > 180 ? e -= 360 : c < i && i - c > 180 && (e += 360), f = i + n * e;
							}
							let [m, h, g, _] = function([e, t, n, i]) {
								return e = isNaN(e) ? 0 : e * bt, Et([
									n,
									Math.cos(e) * t,
									Math.sin(e) * t,
									i
								]);
							}([
								f,
								p ?? It(a, l, n),
								It(o, u, n),
								It(s, d, n)
							]);
							return new Rt(m, h, g, _, !1);
						}
						case "lab": {
							let [i, a, o, s] = Et(Lt(e.lab, t.lab, n));
							return new Rt(i, a, o, s, !1);
						}
					}
				}
			}
			Rt.black = new Rt(0, 0, 0, 1), Rt.white = new Rt(1, 1, 1, 1), Rt.transparent = new Rt(0, 0, 0, 0), Rt.red = new Rt(1, 0, 0, 1);
			class zt {
				constructor(e, t, n) {
					this.sensitivity = e ? t ? "variant" : "case" : t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
						sensitivity: this.sensitivity,
						usage: "search"
					});
				}
				compare(e, t) {
					return this.collator.compare(e, t);
				}
				resolvedLocale() {
					return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
				}
			}
			let Bt = [
				"bottom",
				"center",
				"top"
			];
			class Vt {
				constructor(e, t, n, i, a, o) {
					this.text = e, this.image = t, this.scale = n, this.fontStack = i, this.textColor = a, this.verticalAlign = o;
				}
			}
			class Ht {
				constructor(e) {
					this.sections = e;
				}
				static fromString(e) {
					return new Ht([new Vt(e, null, null, null, null, null)]);
				}
				isEmpty() {
					return this.sections.length === 0 || !this.sections.some(((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0));
				}
				static factory(e) {
					return e instanceof Ht ? e : Ht.fromString(e);
				}
				toString() {
					return this.sections.length === 0 ? "" : this.sections.map(((e) => e.text)).join("");
				}
			}
			class Ut {
				constructor(e) {
					this.values = e.slice();
				}
				static parse(e) {
					if (e instanceof Ut) return e;
					if (typeof e == "number") return new Ut([
						e,
						e,
						e,
						e
					]);
					if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
						for (let t of e) if (typeof t != "number") return;
						switch (e.length) {
							case 1:
								e = [
									e[0],
									e[0],
									e[0],
									e[0]
								];
								break;
							case 2:
								e = [
									e[0],
									e[1],
									e[0],
									e[1]
								];
								break;
							case 3: e = [
								e[0],
								e[1],
								e[2],
								e[1]
							];
						}
						return new Ut(e);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(e, t, n) {
					return new Ut(Lt(e.values, t.values, n));
				}
			}
			class Wt {
				constructor(e) {
					this.values = e.slice();
				}
				static parse(e) {
					if (e instanceof Wt) return e;
					if (typeof e == "number") return new Wt([e]);
					if (Array.isArray(e)) {
						for (let t of e) if (typeof t != "number") return;
						return new Wt(e);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(e, t, n) {
					return new Wt(Lt(e.values, t.values, n));
				}
			}
			class Gt {
				constructor(e) {
					this.values = e.slice();
				}
				static parse(e) {
					if (e instanceof Gt) return e;
					if (typeof e == "string") {
						let t = Rt.parse(e);
						return t ? new Gt([t]) : void 0;
					}
					if (!Array.isArray(e)) return;
					let t = [];
					for (let n of e) {
						if (typeof n != "string") return;
						let e = Rt.parse(n);
						if (!e) return;
						t.push(e);
					}
					return new Gt(t);
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(e, t, n, i = "rgb") {
					let a = [];
					if (e.values.length != t.values.length) throw Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);
					for (let o = 0; o < e.values.length; o++) a.push(Rt.interpolate(e.values[o], t.values[o], n, i));
					return new Gt(a);
				}
			}
			class Kt extends Error {
				constructor(e) {
					super(e), this.name = "RuntimeError";
				}
				toJSON() {
					return this.message;
				}
			}
			let qt = new Set([
				"center",
				"left",
				"right",
				"top",
				"bottom",
				"top-left",
				"top-right",
				"bottom-left",
				"bottom-right"
			]);
			class Jt {
				constructor(e) {
					this.values = e.slice();
				}
				static parse(e) {
					if (e instanceof Jt) return e;
					if (Array.isArray(e) && !(e.length < 1) && e.length % 2 == 0) {
						for (let t = 0; t < e.length; t += 2) {
							let n = e[t], i = e[t + 1];
							if (typeof n != "string" || !qt.has(n) || !Array.isArray(i) || i.length !== 2 || typeof i[0] != "number" || typeof i[1] != "number") return;
						}
						return new Jt(e);
					}
				}
				toString() {
					return JSON.stringify(this.values);
				}
				static interpolate(e, t, n) {
					let i = e.values, a = t.values;
					if (i.length !== a.length) throw new Kt(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);
					let o = [];
					for (let e = 0; e < i.length; e += 2) {
						if (i[e] !== a[e]) throw new Kt(`Cannot interpolate values containing mismatched anchors. from[${e}]: ${i[e]}, to[${e}]: ${a[e]}`);
						o.push(i[e]);
						let [t, s] = i[e + 1], [c, l] = a[e + 1];
						o.push([It(t, c, n), It(s, l, n)]);
					}
					return new Jt(o);
				}
			}
			class Yt {
				constructor(e) {
					this.name = e.name, this.available = e.available;
				}
				toString() {
					return this.name;
				}
				static fromString(e) {
					return e ? new Yt({
						name: e,
						available: !1
					}) : null;
				}
			}
			class Xt {
				constructor(e, t, n) {
					this.from = e, this.to = t, this.transition = n;
				}
				static interpolate(e, t, n) {
					return new Xt(e, t, n);
				}
				static parse(e) {
					return e instanceof Xt ? e : Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number" ? new Xt(e[0], e[1], e[2]) : typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number" ? new Xt(e.from, e.to, e.transition) : typeof e == "string" ? new Xt(e, e, 1) : void 0;
				}
			}
			function Zt(e, t, n, i) {
				return typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? i === void 0 || typeof i == "number" && i >= 0 && i <= 1 ? null : `Invalid rgba value [${[
					e,
					t,
					n,
					i
				].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof i == "number" ? [
					e,
					t,
					n,
					i
				] : [
					e,
					t,
					n
				]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
			}
			function Qt(e) {
				if (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || e instanceof Xt || e instanceof Rt || e instanceof zt || e instanceof Ht || e instanceof Ut || e instanceof Wt || e instanceof Gt || e instanceof Jt || e instanceof Yt) return !0;
				if (Array.isArray(e)) {
					for (let t of e) if (!Qt(t)) return !1;
					return !0;
				}
				if (typeof e == "object") {
					for (let t in e) if (!Qt(e[t])) return !1;
					return !0;
				}
				return !1;
			}
			function K(e) {
				if (e === null) return Je;
				if (typeof e == "string") return Ye;
				if (typeof e == "boolean") return Xe;
				if (typeof e == "number") return G;
				if (e instanceof Rt) return Ze;
				if (e instanceof Xt) return Qe;
				if (e instanceof zt) return tt;
				if (e instanceof Ht) return nt;
				if (e instanceof Ut) return rt;
				if (e instanceof Wt) return at;
				if (e instanceof Gt) return it;
				if (e instanceof Jt) return st;
				if (e instanceof Yt) return ot;
				if (Array.isArray(e)) {
					let t = e.length, n;
					for (let t of e) {
						let e = K(t);
						if (n) {
							if (n === e) continue;
							n = et;
							break;
						}
						n = e;
					}
					return ct(n || et, t);
				}
				return $e;
			}
			function $t(e) {
				let t = typeof e;
				return e === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(e) : e instanceof Rt || e instanceof Xt || e instanceof Ht || e instanceof Ut || e instanceof Wt || e instanceof Gt || e instanceof Jt || e instanceof Yt ? e.toString() : JSON.stringify(e);
			}
			class en {
				constructor(e, t) {
					this.type = e, this.value = t;
				}
				static parse(e, t) {
					if (e.length !== 2) return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
					if (!Qt(e[1])) return t.error("invalid value");
					let n = e[1], i = K(n), a = t.expectedType;
					return i.kind !== "array" || i.N !== 0 || !a || a.kind !== "array" || typeof a.N == "number" && a.N !== 0 || (i = a), new en(i, n);
				}
				evaluate() {
					return this.value;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			let tn = {
				string: Ye,
				number: G,
				boolean: Xe,
				object: $e
			};
			class nn {
				constructor(e, t) {
					this.type = e, this.args = t;
				}
				static parse(e, t) {
					if (e.length < 2) return t.error("Expected at least one argument.");
					let n, i = 1, a = e[0];
					if (a === "array") {
						let a, o;
						if (e.length > 2) {
							let n = e[1];
							if (typeof n != "string" || !(n in tn) || n === "object") return t.error("The item type argument of \"array\" must be one of string, number, boolean", 1);
							a = tn[n], i++;
						} else a = et;
						if (e.length > 3) {
							if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t.error("The length argument to \"array\" must be a positive integer literal", 2);
							o = e[2], i++;
						}
						n = ct(a, o);
					} else {
						if (!tn[a]) throw Error(`Types doesn't contain name = ${a}`);
						n = tn[a];
					}
					let o = [];
					for (; i < e.length; i++) {
						let n = t.parse(e[i], i, et);
						if (!n) return null;
						o.push(n);
					}
					return new nn(n, o);
				}
				evaluate(e) {
					for (let t = 0; t < this.args.length; t++) {
						let n = this.args[t].evaluate(e);
						if (!dt(this.type, K(n))) return n;
						if (t === this.args.length - 1) throw new Kt(`Expected value to be of type ${lt(this.type)}, but found ${lt(K(n))} instead.`);
					}
					throw Error();
				}
				eachChild(e) {
					this.args.forEach(e);
				}
				outputDefined() {
					return this.args.every(((e) => e.outputDefined()));
				}
			}
			let rn = {
				"to-boolean": Xe,
				"to-color": Ze,
				"to-number": G,
				"to-string": Ye
			};
			class an {
				constructor(e, t) {
					this.type = e, this.args = t;
				}
				static parse(e, t) {
					if (e.length < 2) return t.error("Expected at least one argument.");
					let n = e[0];
					if (!rn[n]) throw Error(`Can't parse ${n} as it is not part of the known types`);
					if ((n === "to-boolean" || n === "to-string") && e.length !== 2) return t.error("Expected one argument.");
					let i = rn[n], a = [];
					for (let n = 1; n < e.length; n++) {
						let i = t.parse(e[n], n, et);
						if (!i) return null;
						a.push(i);
					}
					return new an(i, a);
				}
				evaluate(e) {
					switch (this.type.kind) {
						case "boolean": return !!this.args[0].evaluate(e);
						case "color": {
							let t, n;
							for (let i of this.args) {
								if (t = i.evaluate(e), n = null, t instanceof Rt) return t;
								if (typeof t == "string") {
									let n = e.parseColor(t);
									if (n) return n;
								} else if (Array.isArray(t) && (n = t.length < 3 || t.length > 4 ? `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : Zt(t[0], t[1], t[2], t[3]), !n)) return new Rt(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
							}
							throw new Kt(n || `Could not parse color from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
						}
						case "padding": {
							let t;
							for (let n of this.args) {
								t = n.evaluate(e);
								let i = Ut.parse(t);
								if (i) return i;
							}
							throw new Kt(`Could not parse padding from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
						}
						case "numberArray": {
							let t;
							for (let n of this.args) {
								t = n.evaluate(e);
								let i = Wt.parse(t);
								if (i) return i;
							}
							throw new Kt(`Could not parse numberArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
						}
						case "colorArray": {
							let t;
							for (let n of this.args) {
								t = n.evaluate(e);
								let i = Gt.parse(t);
								if (i) return i;
							}
							throw new Kt(`Could not parse colorArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
						}
						case "variableAnchorOffsetCollection": {
							let t;
							for (let n of this.args) {
								t = n.evaluate(e);
								let i = Jt.parse(t);
								if (i) return i;
							}
							throw new Kt(`Could not parse variableAnchorOffsetCollection from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
						}
						case "number": {
							let t = null;
							for (let n of this.args) {
								if (t = n.evaluate(e), t === null) return 0;
								let i = Number(t);
								if (!isNaN(i)) return i;
							}
							throw new Kt(`Could not convert ${JSON.stringify(t)} to number.`);
						}
						case "formatted": return Ht.fromString($t(this.args[0].evaluate(e)));
						case "resolvedImage": return Yt.fromString($t(this.args[0].evaluate(e)));
						case "projectionDefinition": return this.args[0].evaluate(e);
						default: return $t(this.args[0].evaluate(e));
					}
				}
				eachChild(e) {
					this.args.forEach(e);
				}
				outputDefined() {
					return this.args.every(((e) => e.outputDefined()));
				}
			}
			let on = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class sn {
				constructor() {
					this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
				}
				id() {
					return this.feature && "id" in this.feature ? this.feature.id : null;
				}
				geometryType() {
					return this.feature ? typeof this.feature.type == "number" ? on[this.feature.type] : this.feature.type : null;
				}
				geometry() {
					return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
				}
				canonicalID() {
					return this.canonical;
				}
				properties() {
					return this.feature && this.feature.properties || {};
				}
				parseColor(e) {
					let t = this._parseColorCache.get(e);
					return t || (t = Rt.parse(e), this._parseColorCache.set(e, t)), t;
				}
			}
			class ln {
				constructor(e, t, n = [], i, a = new qe(), o = []) {
					this.registry = e, this.path = n, this.key = n.map(((e) => `[${e}]`)).join(""), this.scope = a, this.errors = o, this.expectedType = i, this._isConstant = t;
				}
				parse(e, t, n, i, a = {}) {
					return t ? this.concat(t, n, i)._parse(e, a) : this._parse(e, a);
				}
				_parse(e, t) {
					function n(e, t, n) {
						return n === "assert" ? new nn(t, [e]) : n === "coerce" ? new an(t, [e]) : e;
					}
					if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
						if (e.length === 0) return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
						let i = e[0];
						if (typeof i != "string") return this.error(`Expression name must be a string, but found ${typeof i} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
						let a = this.registry[i];
						if (a) {
							let i = a.parse(e, this);
							if (!i) return null;
							if (this.expectedType) {
								let e = this.expectedType, a = i.type;
								if (e.kind !== "string" && e.kind !== "number" && e.kind !== "boolean" && e.kind !== "object" && e.kind !== "array" || a.kind !== "value") {
									if (e.kind === "projectionDefinition" && ["string", "array"].includes(a.kind) || [
										"color",
										"formatted",
										"resolvedImage"
									].includes(e.kind) && ["value", "string"].includes(a.kind) || ["padding", "numberArray"].includes(e.kind) && [
										"value",
										"number",
										"array"
									].includes(a.kind) || e.kind === "colorArray" && [
										"value",
										"string",
										"array"
									].includes(a.kind) || e.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(a.kind)) i = n(i, e, t.typeAnnotation || "coerce");
									else if (this.checkSubtype(e, a)) return null;
								} else i = n(i, e, t.typeAnnotation || "assert");
							}
							if (!(i instanceof en) && i.type.kind !== "resolvedImage" && this._isConstant(i)) {
								let e = new sn();
								try {
									i = new en(i.type, i.evaluate(e));
								} catch (e) {
									return this.error(e.message), null;
								}
							}
							return i;
						}
						return this.error(`Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`, 0);
					}
					return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? "Bare objects invalid. Use [\"literal\", {...}] instead." : `Expected an array, but found ${typeof e} instead.`);
				}
				concat(e, t, n) {
					let i = typeof e == "number" ? this.path.concat(e) : this.path, a = n ? this.scope.concat(n) : this.scope;
					return new ln(this.registry, this._isConstant, i, t || null, a, this.errors);
				}
				error(e, ...t) {
					let n = `${this.key}${t.map(((e) => `[${e}]`)).join("")}`;
					this.errors.push(new Ke(n, e));
				}
				checkSubtype(e, t) {
					let n = dt(e, t);
					return n && this.error(n), n;
				}
			}
			class un {
				constructor(e, t) {
					this.type = t.type, this.bindings = [].concat(e), this.result = t;
				}
				evaluate(e) {
					return this.result.evaluate(e);
				}
				eachChild(e) {
					for (let t of this.bindings) e(t[1]);
					e(this.result);
				}
				static parse(e, t) {
					if (e.length < 4) return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
					let n = [];
					for (let i = 1; i < e.length - 1; i += 2) {
						let a = e[i];
						if (typeof a != "string") return t.error(`Expected string, but found ${typeof a} instead.`, i);
						if (/[^a-zA-Z0-9_]/.test(a)) return t.error("Variable names must contain only alphanumeric characters or '_'.", i);
						let o = t.parse(e[i + 1], i + 1);
						if (!o) return null;
						n.push([a, o]);
					}
					let i = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
					return i ? new un(n, i) : null;
				}
				outputDefined() {
					return this.result.outputDefined();
				}
			}
			class dn {
				constructor(e, t) {
					this.type = t.type, this.name = e, this.boundExpression = t;
				}
				static parse(e, t) {
					if (e.length !== 2 || typeof e[1] != "string") return t.error("'var' expression requires exactly one string literal argument.");
					let n = e[1];
					return t.scope.has(n) ? new dn(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
				}
				evaluate(e) {
					return this.boundExpression.evaluate(e);
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			class fn {
				constructor(e, t, n) {
					this.type = e, this.index = t, this.input = n;
				}
				static parse(e, t) {
					if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
					let n = t.parse(e[1], 1, G), i = t.parse(e[2], 2, ct(t.expectedType || et));
					return n && i ? new fn(i.type.itemType, n, i) : null;
				}
				evaluate(e) {
					let t = this.index.evaluate(e), n = this.input.evaluate(e);
					if (t < 0) throw new Kt(`Array index out of bounds: ${t} < 0.`);
					if (t >= n.length) throw new Kt(`Array index out of bounds: ${t} > ${n.length - 1}.`);
					if (t !== Math.floor(t)) throw new Kt(`Array index must be an integer, but found ${t} instead.`);
					return n[t];
				}
				eachChild(e) {
					e(this.index), e(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class pn {
				constructor(e, t) {
					this.type = Xe, this.needle = e, this.haystack = t;
				}
				static parse(e, t) {
					if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
					let n = t.parse(e[1], 1, et), i = t.parse(e[2], 2, et);
					return n && i ? ft(n.type, [
						Xe,
						Ye,
						G,
						Je,
						et
					]) ? new pn(n, i) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${lt(n.type)} instead`) : null;
				}
				evaluate(e) {
					let t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
					if (!n) return !1;
					if (!pt(t, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Kt(`Expected first argument to be of type boolean, string, number or null, but found ${lt(K(t))} instead.`);
					if (!pt(n, ["string", "array"])) throw new Kt(`Expected second argument to be of type array or string, but found ${lt(K(n))} instead.`);
					return n.indexOf(t) >= 0;
				}
				eachChild(e) {
					e(this.needle), e(this.haystack);
				}
				outputDefined() {
					return !0;
				}
			}
			class mn {
				constructor(e, t, n) {
					this.type = G, this.needle = e, this.haystack = t, this.fromIndex = n;
				}
				static parse(e, t) {
					if (e.length <= 2 || e.length >= 5) return t.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
					let n = t.parse(e[1], 1, et), i = t.parse(e[2], 2, et);
					if (!n || !i) return null;
					if (!ft(n.type, [
						Xe,
						Ye,
						G,
						Je,
						et
					])) return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${lt(n.type)} instead`);
					if (e.length === 4) {
						let a = t.parse(e[3], 3, G);
						return a ? new mn(n, i, a) : null;
					}
					return new mn(n, i);
				}
				evaluate(e) {
					let t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
					if (!pt(t, [
						"boolean",
						"string",
						"number",
						"null"
					])) throw new Kt(`Expected first argument to be of type boolean, string, number or null, but found ${lt(K(t))} instead.`);
					let i;
					if (this.fromIndex && (i = this.fromIndex.evaluate(e)), pt(n, ["string"])) {
						let e = n.indexOf(t, i);
						return e === -1 ? -1 : [...n.slice(0, e)].length;
					}
					if (pt(n, ["array"])) return n.indexOf(t, i);
					throw new Kt(`Expected second argument to be of type array or string, but found ${lt(K(n))} instead.`);
				}
				eachChild(e) {
					e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			class hn {
				constructor(e, t, n, i, a, o) {
					this.inputType = e, this.type = t, this.input = n, this.cases = i, this.outputs = a, this.otherwise = o;
				}
				static parse(e, t) {
					if (e.length < 5) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
					if (e.length % 2 != 1) return t.error("Expected an even number of arguments.");
					let n, i;
					t.expectedType && t.expectedType.kind !== "value" && (i = t.expectedType);
					let a = {}, o = [];
					for (let s = 2; s < e.length - 1; s += 2) {
						let c = e[s], l = e[s + 1];
						Array.isArray(c) || (c = [c]);
						let u = t.concat(s);
						if (c.length === 0) return u.error("Expected at least one branch label.");
						for (let e of c) {
							if (typeof e != "number" && typeof e != "string") return u.error("Branch labels must be numbers or strings.");
							if (typeof e == "number" && Math.abs(e) > 2 ** 53 - 1) return u.error(`Branch labels must be integers no larger than ${2 ** 53 - 1}.`);
							if (typeof e == "number" && Math.floor(e) !== e) return u.error("Numeric branch labels must be integer values.");
							if (n) {
								if (u.checkSubtype(n, K(e))) return null;
							} else n = K(e);
							if (a[String(e)] !== void 0) return u.error("Branch labels must be unique.");
							a[String(e)] = o.length;
						}
						let d = t.parse(l, s, i);
						if (!d) return null;
						i ||= d.type, o.push(d);
					}
					let s = t.parse(e[1], 1, et);
					if (!s) return null;
					let c = t.parse(e[e.length - 1], e.length - 1, i);
					return c ? s.type.kind !== "value" && t.concat(1).checkSubtype(n, s.type) ? null : new hn(n, i, s, a, o, c) : null;
				}
				evaluate(e) {
					let t = this.input.evaluate(e);
					return (K(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
				}
				eachChild(e) {
					e(this.input), this.outputs.forEach(e), e(this.otherwise);
				}
				outputDefined() {
					return this.outputs.every(((e) => e.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class gn {
				constructor(e, t, n) {
					this.type = e, this.branches = t, this.otherwise = n;
				}
				static parse(e, t) {
					if (e.length < 4) return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
					if (e.length % 2 != 0) return t.error("Expected an odd number of arguments.");
					let n;
					t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
					let i = [];
					for (let a = 1; a < e.length - 1; a += 2) {
						let o = t.parse(e[a], a, Xe);
						if (!o) return null;
						let s = t.parse(e[a + 1], a + 1, n);
						if (!s) return null;
						i.push([o, s]), n ||= s.type;
					}
					let a = t.parse(e[e.length - 1], e.length - 1, n);
					if (!a) return null;
					if (!n) throw Error("Can't infer output type");
					return new gn(n, i, a);
				}
				evaluate(e) {
					for (let [t, n] of this.branches) if (t.evaluate(e)) return n.evaluate(e);
					return this.otherwise.evaluate(e);
				}
				eachChild(e) {
					for (let [t, n] of this.branches) e(t), e(n);
					e(this.otherwise);
				}
				outputDefined() {
					return this.branches.every((([e, t]) => t.outputDefined())) && this.otherwise.outputDefined();
				}
			}
			class _n {
				constructor(e, t, n, i) {
					this.type = e, this.input = t, this.beginIndex = n, this.endIndex = i;
				}
				static parse(e, t) {
					if (e.length <= 2 || e.length >= 5) return t.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
					let n = t.parse(e[1], 1, et), i = t.parse(e[2], 2, G);
					if (!n || !i) return null;
					if (!ft(n.type, [
						ct(et),
						Ye,
						et
					])) return t.error(`Expected first argument to be of type array or string, but found ${lt(n.type)} instead`);
					if (e.length === 4) {
						let a = t.parse(e[3], 3, G);
						return a ? new _n(n.type, n, i, a) : null;
					}
					return new _n(n.type, n, i);
				}
				evaluate(e) {
					let t = this.input.evaluate(e), n = this.beginIndex.evaluate(e), i;
					if (this.endIndex && (i = this.endIndex.evaluate(e)), pt(t, ["string"])) return [...t].slice(n, i).join("");
					if (pt(t, ["array"])) return t.slice(n, i);
					throw new Kt(`Expected first argument to be of type array or string, but found ${lt(K(t))} instead.`);
				}
				eachChild(e) {
					e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
				}
				outputDefined() {
					return !1;
				}
			}
			function vn(e, t) {
				let n = e.length - 1, i, a, o = 0, s = n, c = 0;
				for (; o <= s;) if (c = Math.floor((o + s) / 2), i = e[c], a = e[c + 1], i <= t) {
					if (c === n || t < a) return c;
					o = c + 1;
				} else {
					if (!(i > t)) throw new Kt("Input is not a number.");
					s = c - 1;
				}
				return 0;
			}
			class yn {
				constructor(e, t, n) {
					this.type = e, this.input = t, this.labels = [], this.outputs = [];
					for (let [e, t] of n) this.labels.push(e), this.outputs.push(t);
				}
				static parse(e, t) {
					if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
					if ((e.length - 1) % 2 != 0) return t.error("Expected an even number of arguments.");
					let n = t.parse(e[1], 1, G);
					if (!n) return null;
					let i = [], a = null;
					t.expectedType && t.expectedType.kind !== "value" && (a = t.expectedType);
					for (let n = 1; n < e.length; n += 2) {
						let o = n === 1 ? -Infinity : e[n], s = e[n + 1], c = n, l = n + 1;
						if (typeof o != "number") return t.error("Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", c);
						if (i.length && i[i.length - 1][0] >= o) return t.error("Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.", c);
						let u = t.parse(s, l, a);
						if (!u) return null;
						a ||= u.type, i.push([o, u]);
					}
					return new yn(a, n, i);
				}
				evaluate(e) {
					let t = this.labels, n = this.outputs;
					if (t.length === 1) return n[0].evaluate(e);
					let i = this.input.evaluate(e);
					if (i <= t[0]) return n[0].evaluate(e);
					let a = t.length;
					return i >= t[a - 1] ? n[a - 1].evaluate(e) : n[vn(t, i)].evaluate(e);
				}
				eachChild(e) {
					e(this.input);
					for (let t of this.outputs) e(t);
				}
				outputDefined() {
					return this.outputs.every(((e) => e.outputDefined()));
				}
			}
			function bn(e) {
				return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
			}
			var xn, Sn, Cn = function() {
				if (Sn) return xn;
				function e(e, t, n, i) {
					this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (i - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = i;
				}
				return Sn = 1, xn = e, e.prototype = {
					sampleCurveX: function(e) {
						return ((this.ax * e + this.bx) * e + this.cx) * e;
					},
					sampleCurveY: function(e) {
						return ((this.ay * e + this.by) * e + this.cy) * e;
					},
					sampleCurveDerivativeX: function(e) {
						return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
					},
					solveCurveX: function(e, t) {
						if (t === void 0 && (t = 1e-6), e < 0) return 0;
						if (e > 1) return 1;
						for (var n = e, i = 0; i < 8; i++) {
							var a = this.sampleCurveX(n) - e;
							if (Math.abs(a) < t) return n;
							var o = this.sampleCurveDerivativeX(n);
							if (Math.abs(o) < 1e-6) break;
							n -= a / o;
						}
						var s = 0, c = 1;
						for (n = e, i = 0; i < 20 && (a = this.sampleCurveX(n), !(Math.abs(a - e) < t)); i++) e > a ? s = n : c = n, n = .5 * (c - s) + s;
						return n;
					},
					solve: function(e, t) {
						return this.sampleCurveY(this.solveCurveX(e, t));
					}
				}, xn;
			}(), wn = bn(Cn);
			class Tn {
				constructor(e, t, n, i, a) {
					this.type = e, this.operator = t, this.interpolation = n, this.input = i, this.labels = [], this.outputs = [];
					for (let [e, t] of a) this.labels.push(e), this.outputs.push(t);
				}
				static interpolationFactor(e, t, n, i) {
					let a = 0;
					if (e.name === "exponential") a = En(t, e.base, n, i);
					else if (e.name === "linear") a = En(t, 1, n, i);
					else if (e.name === "cubic-bezier") {
						let o = e.controlPoints;
						a = new wn(o[0], o[1], o[2], o[3]).solve(En(t, 1, n, i));
					}
					return a;
				}
				static parse(e, t) {
					let [n, i, a, ...o] = e;
					if (!Array.isArray(i) || i.length === 0) return t.error("Expected an interpolation type expression.", 1);
					if (i[0] === "linear") i = { name: "linear" };
					else if (i[0] === "exponential") {
						let e = i[1];
						if (typeof e != "number") return t.error("Exponential interpolation requires a numeric base.", 1, 1);
						i = {
							name: "exponential",
							base: e
						};
					} else {
						if (i[0] !== "cubic-bezier") return t.error(`Unknown interpolation type ${String(i[0])}`, 1, 0);
						{
							let e = i.slice(1);
							if (e.length !== 4 || e.some(((e) => typeof e != "number" || e < 0 || e > 1))) return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
							i = {
								name: "cubic-bezier",
								controlPoints: e
							};
						}
					}
					if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
					if ((e.length - 1) % 2 != 0) return t.error("Expected an even number of arguments.");
					if (a = t.parse(a, 2, G), !a) return null;
					let s = [], c = null;
					n !== "interpolate-hcl" && n !== "interpolate-lab" || t.expectedType == it ? t.expectedType && t.expectedType.kind !== "value" && (c = t.expectedType) : c = Ze;
					for (let e = 0; e < o.length; e += 2) {
						let n = o[e], i = o[e + 1], a = e + 3, l = e + 4;
						if (typeof n != "number") return t.error("Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.", a);
						if (s.length && s[s.length - 1][0] >= n) return t.error("Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.", a);
						let u = t.parse(i, l, c);
						if (!u) return null;
						c ||= u.type, s.push([n, u]);
					}
					return mt(c, G) || mt(c, Qe) || mt(c, Ze) || mt(c, rt) || mt(c, at) || mt(c, it) || mt(c, st) || mt(c, ct(G)) ? new Tn(c, n, i, a, s) : t.error(`Type ${lt(c)} is not interpolatable.`);
				}
				evaluate(e) {
					let t = this.labels, n = this.outputs;
					if (t.length === 1) return n[0].evaluate(e);
					let i = this.input.evaluate(e);
					if (i <= t[0]) return n[0].evaluate(e);
					let a = t.length;
					if (i >= t[a - 1]) return n[a - 1].evaluate(e);
					let o = vn(t, i), s = Tn.interpolationFactor(this.interpolation, i, t[o], t[o + 1]), c = n[o].evaluate(e), l = n[o + 1].evaluate(e);
					switch (this.operator) {
						case "interpolate": switch (this.type.kind) {
							case "number": return It(c, l, s);
							case "color": return Rt.interpolate(c, l, s);
							case "padding": return Ut.interpolate(c, l, s);
							case "colorArray": return Gt.interpolate(c, l, s);
							case "numberArray": return Wt.interpolate(c, l, s);
							case "variableAnchorOffsetCollection": return Jt.interpolate(c, l, s);
							case "array": return Lt(c, l, s);
							case "projectionDefinition": return Xt.interpolate(c, l, s);
						}
						case "interpolate-hcl": switch (this.type.kind) {
							case "color": return Rt.interpolate(c, l, s, "hcl");
							case "colorArray": return Gt.interpolate(c, l, s, "hcl");
						}
						case "interpolate-lab": switch (this.type.kind) {
							case "color": return Rt.interpolate(c, l, s, "lab");
							case "colorArray": return Gt.interpolate(c, l, s, "lab");
						}
					}
				}
				eachChild(e) {
					e(this.input);
					for (let t of this.outputs) e(t);
				}
				outputDefined() {
					return this.outputs.every(((e) => e.outputDefined()));
				}
			}
			function En(e, t, n, i) {
				let a = i - n, o = e - n;
				return a === 0 ? 0 : t === 1 ? o / a : (t ** +o - 1) / (t ** +a - 1);
			}
			let Dn = {
				color: Rt.interpolate,
				number: It,
				padding: Ut.interpolate,
				numberArray: Wt.interpolate,
				colorArray: Gt.interpolate,
				variableAnchorOffsetCollection: Jt.interpolate,
				array: Lt
			};
			class On {
				constructor(e, t) {
					this.type = e, this.args = t;
				}
				static parse(e, t) {
					if (e.length < 2) return t.error("Expected at least one argument.");
					let n = null, i = t.expectedType;
					i && i.kind !== "value" && (n = i);
					let a = [];
					for (let i of e.slice(1)) {
						let e = t.parse(i, 1 + a.length, n, void 0, { typeAnnotation: "omit" });
						if (!e) return null;
						n ||= e.type, a.push(e);
					}
					if (!n) throw Error("No output type");
					let o = i && a.some(((e) => dt(i, e.type)));
					return new On(o ? et : n, a);
				}
				evaluate(e) {
					let t, n = null, i = 0;
					for (let a of this.args) if (i++, n = a.evaluate(e), n && n instanceof Yt && !n.available && (t ||= n.name, n = null, i === this.args.length && (n = t)), n !== null) break;
					return n;
				}
				eachChild(e) {
					this.args.forEach(e);
				}
				outputDefined() {
					return this.args.every(((e) => e.outputDefined()));
				}
			}
			function kn(e, t) {
				return e === "==" || e === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value";
			}
			function An(e, t, n, i) {
				return i.compare(t, n) === 0;
			}
			function jn(e, t, n) {
				let i = e !== "==" && e !== "!=";
				return class a {
					constructor(e, t, n) {
						this.type = Xe, this.lhs = e, this.rhs = t, this.collator = n, this.hasUntypedArgument = e.type.kind === "value" || t.type.kind === "value";
					}
					static parse(e, t) {
						if (e.length !== 3 && e.length !== 4) return t.error("Expected two or three arguments.");
						let n = e[0], o = t.parse(e[1], 1, et);
						if (!o) return null;
						if (!kn(n, o.type)) return t.concat(1).error(`"${n}" comparisons are not supported for type '${lt(o.type)}'.`);
						let s = t.parse(e[2], 2, et);
						if (!s) return null;
						if (!kn(n, s.type)) return t.concat(2).error(`"${n}" comparisons are not supported for type '${lt(s.type)}'.`);
						if (o.type.kind !== s.type.kind && o.type.kind !== "value" && s.type.kind !== "value") return t.error(`Cannot compare types '${lt(o.type)}' and '${lt(s.type)}'.`);
						i && (o.type.kind === "value" && s.type.kind !== "value" ? o = new nn(s.type, [o]) : o.type.kind !== "value" && s.type.kind === "value" && (s = new nn(o.type, [s])));
						let c = null;
						if (e.length === 4) {
							if (o.type.kind !== "string" && s.type.kind !== "string" && o.type.kind !== "value" && s.type.kind !== "value") return t.error("Cannot use collator to compare non-string types.");
							if (c = t.parse(e[3], 3, tt), !c) return null;
						}
						return new a(o, s, c);
					}
					evaluate(a) {
						let o = this.lhs.evaluate(a), s = this.rhs.evaluate(a);
						if (i && this.hasUntypedArgument) {
							let t = K(o), n = K(s);
							if (t.kind !== n.kind || t.kind !== "string" && t.kind !== "number") throw new Kt(`Expected arguments for "${e}" to be (string, string) or (number, number), but found (${t.kind}, ${n.kind}) instead.`);
						}
						if (this.collator && !i && this.hasUntypedArgument) {
							let e = K(o), n = K(s);
							if (e.kind !== "string" || n.kind !== "string") return t(a, o, s);
						}
						return this.collator ? n(a, o, s, this.collator.evaluate(a)) : t(a, o, s);
					}
					eachChild(e) {
						e(this.lhs), e(this.rhs), this.collator && e(this.collator);
					}
					outputDefined() {
						return !0;
					}
				};
			}
			let Mn = jn("==", (function(e, t, n) {
				return t === n;
			}), An), Nn = jn("!=", (function(e, t, n) {
				return t !== n;
			}), (function(e, t, n, i) {
				return !An(0, t, n, i);
			})), Pn = jn("<", (function(e, t, n) {
				return t < n;
			}), (function(e, t, n, i) {
				return i.compare(t, n) < 0;
			})), Fn = jn(">", (function(e, t, n) {
				return t > n;
			}), (function(e, t, n, i) {
				return i.compare(t, n) > 0;
			})), In = jn("<=", (function(e, t, n) {
				return t <= n;
			}), (function(e, t, n, i) {
				return i.compare(t, n) <= 0;
			})), Ln = jn(">=", (function(e, t, n) {
				return t >= n;
			}), (function(e, t, n, i) {
				return i.compare(t, n) >= 0;
			}));
			class Rn {
				constructor(e, t, n) {
					this.type = tt, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;
				}
				static parse(e, t) {
					if (e.length !== 2) return t.error("Expected one argument.");
					let n = e[1];
					if (typeof n != "object" || Array.isArray(n)) return t.error("Collator options argument must be an object.");
					let i = t.parse(n["case-sensitive"] !== void 0 && n["case-sensitive"], 1, Xe);
					if (!i) return null;
					let a = t.parse(n["diacritic-sensitive"] !== void 0 && n["diacritic-sensitive"], 1, Xe);
					if (!a) return null;
					let o = null;
					return n.locale && (o = t.parse(n.locale, 1, Ye), !o) ? null : new Rn(i, a, o);
				}
				evaluate(e) {
					return new zt(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
				}
				eachChild(e) {
					e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
				}
				outputDefined() {
					return !1;
				}
			}
			class zn {
				constructor(e, t, n, i, a) {
					this.type = Ye, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = i, this.maxFractionDigits = a;
				}
				static parse(e, t) {
					if (e.length !== 3) return t.error("Expected two arguments.");
					let n = t.parse(e[1], 1, G);
					if (!n) return null;
					let i = e[2];
					if (typeof i != "object" || Array.isArray(i)) return t.error("NumberFormat options argument must be an object.");
					let a = null;
					if (i.locale && (a = t.parse(i.locale, 1, Ye), !a)) return null;
					let o = null;
					if (i.currency && (o = t.parse(i.currency, 1, Ye), !o)) return null;
					let s = null;
					if (i["min-fraction-digits"] && (s = t.parse(i["min-fraction-digits"], 1, G), !s)) return null;
					let c = null;
					return i["max-fraction-digits"] && (c = t.parse(i["max-fraction-digits"], 1, G), !c) ? null : new zn(n, a, o, s, c);
				}
				evaluate(e) {
					return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
						style: this.currency ? "currency" : "decimal",
						currency: this.currency ? this.currency.evaluate(e) : void 0,
						minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
						maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
					}).format(this.number.evaluate(e));
				}
				eachChild(e) {
					e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
				}
				outputDefined() {
					return !1;
				}
			}
			class Bn {
				constructor(e) {
					this.type = nt, this.sections = e;
				}
				static parse(e, t) {
					if (e.length < 2) return t.error("Expected at least one argument.");
					let n = e[1];
					if (!Array.isArray(n) && typeof n == "object") return t.error("First argument must be an image or text section.");
					let i = [], a = !1;
					for (let n = 1; n <= e.length - 1; ++n) {
						let o = e[n];
						if (a && typeof o == "object" && !Array.isArray(o)) {
							a = !1;
							let e = null;
							if (o["font-scale"] && (e = t.parse(o["font-scale"], 1, G), !e)) return null;
							let n = null;
							if (o["text-font"] && (n = t.parse(o["text-font"], 1, ct(Ye)), !n)) return null;
							let s = null;
							if (o["text-color"] && (s = t.parse(o["text-color"], 1, Ze), !s)) return null;
							let c = null;
							if (o["vertical-align"]) {
								if (typeof o["vertical-align"] == "string" && !Bt.includes(o["vertical-align"])) return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${o["vertical-align"]}' instead.`);
								if (c = t.parse(o["vertical-align"], 1, Ye), !c) return null;
							}
							let l = i[i.length - 1];
							l.scale = e, l.font = n, l.textColor = s, l.verticalAlign = c;
						} else {
							let o = t.parse(e[n], 1, et);
							if (!o) return null;
							let s = o.type.kind;
							if (s !== "string" && s !== "value" && s !== "null" && s !== "resolvedImage") return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
							a = !0, i.push({
								content: o,
								scale: null,
								font: null,
								textColor: null,
								verticalAlign: null
							});
						}
					}
					return new Bn(i);
				}
				evaluate(e) {
					return new Ht(this.sections.map(((t) => {
						let n = t.content.evaluate(e);
						return K(n) === ot ? new Vt("", n, null, null, null, t.verticalAlign ? t.verticalAlign.evaluate(e) : null) : new Vt($t(n), null, t.scale ? t.scale.evaluate(e) : null, t.font ? t.font.evaluate(e).join(",") : null, t.textColor ? t.textColor.evaluate(e) : null, t.verticalAlign ? t.verticalAlign.evaluate(e) : null);
					})));
				}
				eachChild(e) {
					for (let t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);
				}
				outputDefined() {
					return !1;
				}
			}
			class Vn {
				constructor(e) {
					this.type = ot, this.input = e;
				}
				static parse(e, t) {
					if (e.length !== 2) return t.error("Expected two arguments.");
					let n = t.parse(e[1], 1, Ye);
					return n ? new Vn(n) : t.error("No image name provided.");
				}
				evaluate(e) {
					let t = this.input.evaluate(e), n = Yt.fromString(t);
					return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;
				}
				eachChild(e) {
					e(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			class Hn {
				constructor(e) {
					this.type = G, this.input = e;
				}
				static parse(e, t) {
					if (e.length !== 2) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
					let n = t.parse(e[1], 1);
					return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? t.error(`Expected argument of type string or array, but found ${lt(n.type)} instead.`) : new Hn(n) : null;
				}
				evaluate(e) {
					let t = this.input.evaluate(e);
					if (typeof t == "string") return [...t].length;
					if (Array.isArray(t)) return t.length;
					throw new Kt(`Expected value to be of type string or array, but found ${lt(K(t))} instead.`);
				}
				eachChild(e) {
					e(this.input);
				}
				outputDefined() {
					return !1;
				}
			}
			let Un = 8192;
			function Wn(e, t) {
				let n = (180 + e[0]) / 360, i = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e[1] * Math.PI / 360))) / 360, a = 2 ** t.z;
				return [Math.round(n * a * Un), Math.round(i * a * Un)];
			}
			function Gn(e, t) {
				let n = 2 ** t.z;
				return [(a = (e[0] / Un + t.x) / n, 360 * a - 180), (i = (e[1] / Un + t.y) / n, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * i) * Math.PI / 180)) - 90)];
				var i, a;
			}
			function Kn(e, t) {
				e[0] = Math.min(e[0], t[0]), e[1] = Math.min(e[1], t[1]), e[2] = Math.max(e[2], t[0]), e[3] = Math.max(e[3], t[1]);
			}
			function qn(e, t) {
				return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3]);
			}
			function Jn(e, t, n) {
				let i = e[0] - t[0], a = e[1] - t[1], o = e[0] - n[0], s = e[1] - n[1];
				return i * s - o * a == 0 && i * o <= 0 && a * s <= 0;
			}
			function Yn(e, t, n, i) {
				return (a = [i[0] - n[0], i[1] - n[1]])[0] * (o = [t[0] - e[0], t[1] - e[1]])[1] - a[1] * o[0] != 0 && !(!tr(e, t, n, i) || !tr(n, i, e, t));
				var a, o;
			}
			function Xn(e, t, n) {
				for (let i of n) for (let n = 0; n < i.length - 1; ++n) if (Yn(e, t, i[n], i[n + 1])) return !0;
				return !1;
			}
			function Zn(e, t, n = !1) {
				let i = !1;
				for (let c of t) for (let t = 0; t < c.length - 1; t++) {
					if (Jn(e, c[t], c[t + 1])) return n;
					(o = c[t])[1] > (a = e)[1] != (s = c[t + 1])[1] > a[1] && a[0] < (s[0] - o[0]) * (a[1] - o[1]) / (s[1] - o[1]) + o[0] && (i = !i);
				}
				var a, o, s;
				return i;
			}
			function Qn(e, t) {
				for (let n of t) if (Zn(e, n)) return !0;
				return !1;
			}
			function $n(e, t) {
				for (let n of e) if (!Zn(n, t)) return !1;
				for (let n = 0; n < e.length - 1; ++n) if (Xn(e[n], e[n + 1], t)) return !1;
				return !0;
			}
			function er(e, t) {
				for (let n of t) if ($n(e, n)) return !0;
				return !1;
			}
			function tr(e, t, n, i) {
				let a = i[0] - n[0], o = i[1] - n[1], s = (e[0] - n[0]) * o - a * (e[1] - n[1]), c = (t[0] - n[0]) * o - a * (t[1] - n[1]);
				return s > 0 && c < 0 || s < 0 && c > 0;
			}
			function nr(e, t, n) {
				let i = [];
				for (let a = 0; a < e.length; a++) {
					let o = [];
					for (let i = 0; i < e[a].length; i++) {
						let s = Wn(e[a][i], n);
						Kn(t, s), o.push(s);
					}
					i.push(o);
				}
				return i;
			}
			function rr(e, t, n) {
				let i = [];
				for (let a = 0; a < e.length; a++) {
					let o = nr(e[a], t, n);
					i.push(o);
				}
				return i;
			}
			function ir(e, t, n, i) {
				if (e[0] < n[0] || e[0] > n[2]) {
					let t = .5 * i, a = e[0] - n[0] > t ? -i : n[0] - e[0] > t ? i : 0;
					a === 0 && (a = e[0] - n[2] > t ? -i : n[2] - e[0] > t ? i : 0), e[0] += a;
				}
				Kn(t, e);
			}
			function ar(e, t, n, i) {
				let a = 2 ** i.z * Un, o = [i.x * Un, i.y * Un], s = [];
				for (let i of e) for (let e of i) {
					let i = [e.x + o[0], e.y + o[1]];
					ir(i, t, n, a), s.push(i);
				}
				return s;
			}
			function or(e, t, n, i) {
				let a = 2 ** i.z * Un, o = [i.x * Un, i.y * Un], s = [];
				for (let n of e) {
					let e = [];
					for (let i of n) {
						let n = [i.x + o[0], i.y + o[1]];
						Kn(t, n), e.push(n);
					}
					s.push(e);
				}
				if (t[2] - t[0] <= a / 2) {
					(c = t)[0] = c[1] = Infinity, c[2] = c[3] = -Infinity;
					for (let e of s) for (let i of e) ir(i, t, n, a);
				}
				var c;
				return s;
			}
			class sr {
				constructor(e, t) {
					this.type = Xe, this.geojson = e, this.geometries = t;
				}
				static parse(e, t) {
					if (e.length !== 2) return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
					if (Qt(e[1])) {
						let t = e[1];
						if (t.type === "FeatureCollection") {
							let e = [];
							for (let n of t.features) {
								let { type: t, coordinates: i } = n.geometry;
								t === "Polygon" && e.push(i), t === "MultiPolygon" && e.push(...i);
							}
							if (e.length) return new sr(t, {
								type: "MultiPolygon",
								coordinates: e
							});
						} else if (t.type === "Feature") {
							let e = t.geometry.type;
							if (e === "Polygon" || e === "MultiPolygon") return new sr(t, t.geometry);
						} else if (t.type === "Polygon" || t.type === "MultiPolygon") return new sr(t, t);
					}
					return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(e) {
					if (e.geometry() != null && e.canonicalID() != null) {
						if (e.geometryType() === "Point") return function(e, t) {
							let n = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], a = e.canonicalID();
							if (t.type === "Polygon") {
								let o = nr(t.coordinates, i, a), s = ar(e.geometry(), n, i, a);
								if (!qn(n, i)) return !1;
								for (let e of s) if (!Zn(e, o)) return !1;
							}
							if (t.type === "MultiPolygon") {
								let o = rr(t.coordinates, i, a), s = ar(e.geometry(), n, i, a);
								if (!qn(n, i)) return !1;
								for (let e of s) if (!Qn(e, o)) return !1;
							}
							return !0;
						}(e, this.geometries);
						if (e.geometryType() === "LineString") return function(e, t) {
							let n = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], i = [
								Infinity,
								Infinity,
								-Infinity,
								-Infinity
							], a = e.canonicalID();
							if (t.type === "Polygon") {
								let o = nr(t.coordinates, i, a), s = or(e.geometry(), n, i, a);
								if (!qn(n, i)) return !1;
								for (let e of s) if (!$n(e, o)) return !1;
							}
							if (t.type === "MultiPolygon") {
								let o = rr(t.coordinates, i, a), s = or(e.geometry(), n, i, a);
								if (!qn(n, i)) return !1;
								for (let e of s) if (!er(e, o)) return !1;
							}
							return !0;
						}(e, this.geometries);
					}
					return !1;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			let cr = class {
				constructor(e = [], t = (e, t) => e < t ? -1 : e > t ? 1 : 0) {
					if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let e = (this.length >> 1) - 1; e >= 0; e--) this._down(e);
				}
				push(e) {
					this.data.push(e), this._up(this.length++);
				}
				pop() {
					if (this.length === 0) return;
					let e = this.data[0], t = this.data.pop();
					return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
				}
				peek() {
					return this.data[0];
				}
				_up(e) {
					let { data: t, compare: n } = this, i = t[e];
					for (; e > 0;) {
						let a = e - 1 >> 1, o = t[a];
						if (n(i, o) >= 0) break;
						t[e] = o, e = a;
					}
					t[e] = i;
				}
				_down(e) {
					let { data: t, compare: n } = this, i = this.length >> 1, a = t[e];
					for (; e < i;) {
						let i = 1 + (e << 1), o = i + 1;
						if (o < this.length && n(t[o], t[i]) < 0 && (i = o), n(t[i], a) >= 0) break;
						t[e] = t[i], e = i;
					}
					t[e] = a;
				}
			};
			function lr(e, t, n = 0, i = e.length - 1, a = dr) {
				for (; i > n;) {
					if (i - n > 600) {
						let o = i - n + 1, s = t - n + 1, c = Math.log(o), l = .5 * Math.exp(2 * c / 3), u = .5 * Math.sqrt(c * l * (o - l) / o) * (s - o / 2 < 0 ? -1 : 1);
						lr(e, t, Math.max(n, Math.floor(t - s * l / o + u)), Math.min(i, Math.floor(t + (o - s) * l / o + u)), a);
					}
					let o = e[t], s = n, c = i;
					for (ur(e, n, t), a(e[i], o) > 0 && ur(e, n, i); s < c;) {
						for (ur(e, s, c), s++, c--; a(e[s], o) < 0;) s++;
						for (; a(e[c], o) > 0;) c--;
					}
					a(e[n], o) === 0 ? ur(e, n, c) : (c++, ur(e, c, i)), c <= t && (n = c + 1), t <= c && (i = c - 1);
				}
			}
			function ur(e, t, n) {
				let i = e[t];
				e[t] = e[n], e[n] = i;
			}
			function dr(e, t) {
				return e < t ? -1 : e > t ? 1 : 0;
			}
			function fr(e, t) {
				if (e.length <= 1) return [e];
				let n = [], i, a;
				for (let t of e) {
					let e = mr(t);
					e !== 0 && (t.area = Math.abs(e), a === void 0 && (a = e < 0), a === e < 0 ? (i && n.push(i), i = [t]) : i.push(t));
				}
				if (i && n.push(i), t > 1) for (let e = 0; e < n.length; e++) n[e].length <= t || (lr(n[e], t, 1, n[e].length - 1, pr), n[e] = n[e].slice(0, t));
				return n;
			}
			function pr(e, t) {
				return t.area - e.area;
			}
			function mr(e) {
				let t = 0;
				for (let n, i, a = 0, o = e.length, s = o - 1; a < o; s = a++) n = e[a], i = e[s], t += (i.x - n.x) * (n.y + i.y);
				return t;
			}
			let hr = 1 / 298.257223563, gr = hr * (2 - hr), _r = Math.PI / 180;
			class vr {
				constructor(e) {
					let t = 6378.137 * _r * 1e3, n = Math.cos(e * _r), i = 1 / (1 - gr * (1 - n * n)), a = Math.sqrt(i);
					this.kx = t * a * n, this.ky = t * a * i * (1 - gr);
				}
				distance(e, t) {
					let n = this.wrap(e[0] - t[0]) * this.kx, i = (e[1] - t[1]) * this.ky;
					return Math.sqrt(n * n + i * i);
				}
				pointOnLine(e, t) {
					let n, i, a, o, s = Infinity;
					for (let c = 0; c < e.length - 1; c++) {
						let l = e[c][0], u = e[c][1], d = this.wrap(e[c + 1][0] - l) * this.kx, f = (e[c + 1][1] - u) * this.ky, p = 0;
						d === 0 && f === 0 || (p = (this.wrap(t[0] - l) * this.kx * d + (t[1] - u) * this.ky * f) / (d * d + f * f), p > 1 ? (l = e[c + 1][0], u = e[c + 1][1]) : p > 0 && (l += d / this.kx * p, u += f / this.ky * p)), d = this.wrap(t[0] - l) * this.kx, f = (t[1] - u) * this.ky;
						let m = d * d + f * f;
						m < s && (s = m, n = l, i = u, a = c, o = p);
					}
					return {
						point: [n, i],
						index: a,
						t: Math.max(0, Math.min(1, o))
					};
				}
				wrap(e) {
					for (; e < -180;) e += 360;
					for (; e > 180;) e -= 360;
					return e;
				}
			}
			function yr(e, t) {
				return t[0] - e[0];
			}
			function br(e) {
				return e[1] - e[0] + 1;
			}
			function xr(e, t) {
				return e[1] >= e[0] && e[1] < t;
			}
			function Sr(e, t) {
				if (e[0] > e[1]) return [null, null];
				let n = br(e);
				if (t) {
					if (n === 2) return [e, null];
					let t = Math.floor(n / 2);
					return [[e[0], e[0] + t], [e[0] + t, e[1]]];
				}
				if (n === 1) return [e, null];
				let i = Math.floor(n / 2) - 1;
				return [[e[0], e[0] + i], [e[0] + i + 1, e[1]]];
			}
			function Cr(e, t) {
				if (!xr(t, e.length)) return [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				let n = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (let i = t[0]; i <= t[1]; ++i) Kn(n, e[i]);
				return n;
			}
			function wr(e) {
				let t = [
					Infinity,
					Infinity,
					-Infinity,
					-Infinity
				];
				for (let n of e) for (let e of n) Kn(t, e);
				return t;
			}
			function Tr(e) {
				return e[0] !== -Infinity && e[1] !== -Infinity && e[2] !== Infinity && e[3] !== Infinity;
			}
			function Er(e, t, n) {
				if (!Tr(e) || !Tr(t)) return NaN;
				let i = 0, a = 0;
				return e[2] < t[0] && (i = t[0] - e[2]), e[0] > t[2] && (i = e[0] - t[2]), e[1] > t[3] && (a = e[1] - t[3]), e[3] < t[1] && (a = t[1] - e[3]), n.distance([0, 0], [i, a]);
			}
			function Dr(e, t, n) {
				let i = n.pointOnLine(t, e);
				return n.distance(e, i.point);
			}
			function Or(e, t, n, i, a) {
				let o = Math.min(Dr(e, [n, i], a), Dr(t, [n, i], a)), s = Math.min(Dr(n, [e, t], a), Dr(i, [e, t], a));
				return Math.min(o, s);
			}
			function kr(e, t, n, i, a) {
				if (!xr(t, e.length) || !xr(i, n.length)) return Infinity;
				let o = Infinity;
				for (let s = t[0]; s < t[1]; ++s) {
					let t = e[s], c = e[s + 1];
					for (let e = i[0]; e < i[1]; ++e) {
						let i = n[e], s = n[e + 1];
						if (Yn(t, c, i, s)) return 0;
						o = Math.min(o, Or(t, c, i, s, a));
					}
				}
				return o;
			}
			function Ar(e, t, n, i, a) {
				if (!xr(t, e.length) || !xr(i, n.length)) return NaN;
				let o = Infinity;
				for (let s = t[0]; s <= t[1]; ++s) for (let t = i[0]; t <= i[1]; ++t) if (o = Math.min(o, a.distance(e[s], n[t])), o === 0) return o;
				return o;
			}
			function jr(e, t, n) {
				if (Zn(e, t, !0)) return 0;
				let i = Infinity;
				for (let a of t) {
					let t = a[0], o = a[a.length - 1];
					if (t !== o && (i = Math.min(i, Dr(e, [o, t], n)), i === 0)) return i;
					let s = n.pointOnLine(a, e);
					if (i = Math.min(i, n.distance(e, s.point)), i === 0) return i;
				}
				return i;
			}
			function Mr(e, t, n, i) {
				if (!xr(t, e.length)) return NaN;
				for (let i = t[0]; i <= t[1]; ++i) if (Zn(e[i], n, !0)) return 0;
				let a = Infinity;
				for (let o = t[0]; o < t[1]; ++o) {
					let t = e[o], s = e[o + 1];
					for (let e of n) for (let n = 0, o = e.length, c = o - 1; n < o; c = n++) {
						let o = e[c], l = e[n];
						if (Yn(t, s, o, l)) return 0;
						a = Math.min(a, Or(t, s, o, l, i));
					}
				}
				return a;
			}
			function Nr(e, t) {
				for (let n of e) for (let e of n) if (Zn(e, t, !0)) return !0;
				return !1;
			}
			function Pr(e, t, n, i = Infinity) {
				let a = wr(e), o = wr(t);
				if (i !== Infinity && Er(a, o, n) >= i) return i;
				if (qn(a, o)) {
					if (Nr(e, t)) return 0;
				} else if (Nr(t, e)) return 0;
				let s = Infinity;
				for (let i of e) for (let e = 0, a = i.length, o = a - 1; e < a; o = e++) {
					let a = i[o], c = i[e];
					for (let e of t) for (let t = 0, i = e.length, o = i - 1; t < i; o = t++) {
						let i = e[o], l = e[t];
						if (Yn(a, c, i, l)) return 0;
						s = Math.min(s, Or(a, c, i, l, n));
					}
				}
				return s;
			}
			function Fr(e, t, n, i, a, o) {
				if (!o) return;
				let s = Er(Cr(i, o), a, n);
				s < t && e.push([
					s,
					o,
					[0, 0]
				]);
			}
			function Ir(e, t, n, i, a, o, s) {
				if (!o || !s) return;
				let c = Er(Cr(i, o), Cr(a, s), n);
				c < t && e.push([
					c,
					o,
					s
				]);
			}
			function Lr(e, t, n, i, a = Infinity) {
				let o = Math.min(i.distance(e[0], n[0][0]), a);
				if (o === 0) return o;
				let s = new cr([[
					0,
					[0, e.length - 1],
					[0, 0]
				]], yr), c = wr(n);
				for (; s.length > 0;) {
					let a = s.pop();
					if (a[0] >= o) continue;
					let l = a[1], u = t ? 50 : 100;
					if (br(l) <= u) {
						if (!xr(l, e.length)) return NaN;
						if (t) {
							let t = Mr(e, l, n, i);
							if (isNaN(t) || t === 0) return t;
							o = Math.min(o, t);
						} else for (let t = l[0]; t <= l[1]; ++t) {
							let a = jr(e[t], n, i);
							if (o = Math.min(o, a), o === 0) return 0;
						}
					} else {
						let n = Sr(l, t);
						Fr(s, o, i, e, c, n[0]), Fr(s, o, i, e, c, n[1]);
					}
				}
				return o;
			}
			function Rr(e, t, n, i, a, o = Infinity) {
				let s = Math.min(o, a.distance(e[0], n[0]));
				if (s === 0) return s;
				let c = new cr([[
					0,
					[0, e.length - 1],
					[0, n.length - 1]
				]], yr);
				for (; c.length > 0;) {
					let o = c.pop();
					if (o[0] >= s) continue;
					let l = o[1], u = o[2], d = t ? 50 : 100, f = i ? 50 : 100;
					if (br(l) <= d && br(u) <= f) {
						if (!xr(l, e.length) && xr(u, n.length)) return NaN;
						let o;
						if (t && i) o = kr(e, l, n, u, a), s = Math.min(s, o);
						else if (t && !i) {
							let t = e.slice(l[0], l[1] + 1);
							for (let e = u[0]; e <= u[1]; ++e) if (o = Dr(n[e], t, a), s = Math.min(s, o), s === 0) return s;
						} else if (!t && i) {
							let t = n.slice(u[0], u[1] + 1);
							for (let n = l[0]; n <= l[1]; ++n) if (o = Dr(e[n], t, a), s = Math.min(s, o), s === 0) return s;
						} else o = Ar(e, l, n, u, a), s = Math.min(s, o);
					} else {
						let o = Sr(l, t), d = Sr(u, i);
						Ir(c, s, a, e, n, o[0], d[0]), Ir(c, s, a, e, n, o[0], d[1]), Ir(c, s, a, e, n, o[1], d[0]), Ir(c, s, a, e, n, o[1], d[1]);
					}
				}
				return s;
			}
			function zr(e) {
				return e.type === "MultiPolygon" ? e.coordinates.map(((e) => ({
					type: "Polygon",
					coordinates: e
				}))) : e.type === "MultiLineString" ? e.coordinates.map(((e) => ({
					type: "LineString",
					coordinates: e
				}))) : e.type === "MultiPoint" ? e.coordinates.map(((e) => ({
					type: "Point",
					coordinates: e
				}))) : [e];
			}
			class Br {
				constructor(e, t) {
					this.type = G, this.geojson = e, this.geometries = t;
				}
				static parse(e, t) {
					if (e.length !== 2) return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
					if (Qt(e[1])) {
						let t = e[1];
						if (t.type === "FeatureCollection") return new Br(t, t.features.map(((e) => zr(e.geometry))).flat());
						if (t.type === "Feature") return new Br(t, zr(t.geometry));
						if ("type" in t && "coordinates" in t) return new Br(t, zr(t));
					}
					return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
				}
				evaluate(e) {
					if (e.geometry() != null && e.canonicalID() != null) {
						if (e.geometryType() === "Point") return function(e, t) {
							let n = e.geometry(), i = n.flat().map(((t) => Gn([t.x, t.y], e.canonical)));
							if (n.length === 0) return NaN;
							let a = new vr(i[0][1]), o = Infinity;
							for (let e of t) {
								switch (e.type) {
									case "Point":
										o = Math.min(o, Rr(i, !1, [e.coordinates], !1, a, o));
										break;
									case "LineString":
										o = Math.min(o, Rr(i, !1, e.coordinates, !0, a, o));
										break;
									case "Polygon": o = Math.min(o, Lr(i, !1, e.coordinates, a, o));
								}
								if (o === 0) return o;
							}
							return o;
						}(e, this.geometries);
						if (e.geometryType() === "LineString") return function(e, t) {
							let n = e.geometry(), i = n.flat().map(((t) => Gn([t.x, t.y], e.canonical)));
							if (n.length === 0) return NaN;
							let a = new vr(i[0][1]), o = Infinity;
							for (let e of t) {
								switch (e.type) {
									case "Point":
										o = Math.min(o, Rr(i, !0, [e.coordinates], !1, a, o));
										break;
									case "LineString":
										o = Math.min(o, Rr(i, !0, e.coordinates, !0, a, o));
										break;
									case "Polygon": o = Math.min(o, Lr(i, !0, e.coordinates, a, o));
								}
								if (o === 0) return o;
							}
							return o;
						}(e, this.geometries);
						if (e.geometryType() === "Polygon") return function(e, t) {
							let n = e.geometry();
							if (n.length === 0 || n[0].length === 0) return NaN;
							let i = fr(n, 0).map(((t) => t.map(((t) => t.map(((t) => Gn([t.x, t.y], e.canonical))))))), a = new vr(i[0][0][0][1]), o = Infinity;
							for (let e of t) for (let t of i) {
								switch (e.type) {
									case "Point":
										o = Math.min(o, Lr([e.coordinates], !1, t, a, o));
										break;
									case "LineString":
										o = Math.min(o, Lr(e.coordinates, !0, t, a, o));
										break;
									case "Polygon": o = Math.min(o, Pr(t, e.coordinates, a, o));
								}
								if (o === 0) return o;
							}
							return o;
						}(e, this.geometries);
					}
					return NaN;
				}
				eachChild() {}
				outputDefined() {
					return !0;
				}
			}
			class Vr {
				constructor(e) {
					this.type = et, this.key = e;
				}
				static parse(e, t) {
					if (e.length !== 2) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
					let n = e[1];
					return n == null ? t.error("Global state property must be defined.") : typeof n == "string" ? new Vr(n) : t.error(`Global state property must be string, but found ${typeof e[1]} instead.`);
				}
				evaluate(e) {
					let t = e.globals?.globalState;
					return t && Object.keys(t).length !== 0 ? At(t, this.key) : null;
				}
				eachChild() {}
				outputDefined() {
					return !1;
				}
			}
			let Hr = {
				"==": Mn,
				"!=": Nn,
				">": Fn,
				"<": Pn,
				">=": Ln,
				"<=": In,
				array: nn,
				at: fn,
				boolean: nn,
				case: gn,
				coalesce: On,
				collator: Rn,
				format: Bn,
				image: Vn,
				in: pn,
				"index-of": mn,
				interpolate: Tn,
				"interpolate-hcl": Tn,
				"interpolate-lab": Tn,
				length: Hn,
				let: un,
				literal: en,
				match: hn,
				number: nn,
				"number-format": zn,
				object: nn,
				slice: _n,
				step: yn,
				string: nn,
				"to-boolean": an,
				"to-color": an,
				"to-number": an,
				"to-string": an,
				var: dn,
				within: sr,
				distance: Br,
				"global-state": Vr
			};
			class Ur {
				constructor(e, t, n, i) {
					this.name = e, this.type = t, this._evaluate = n, this.args = i;
				}
				evaluate(e) {
					return this._evaluate(e, this.args);
				}
				eachChild(e) {
					this.args.forEach(e);
				}
				outputDefined() {
					return !1;
				}
				static parse(e, t) {
					let n = e[0], i = Ur.definitions[n];
					if (!i) return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
					let a = Array.isArray(i) ? i[0] : i.type, o = Array.isArray(i) ? [[i[1], i[2]]] : i.overloads, s = o.filter((([t]) => !Array.isArray(t) || t.length === e.length - 1)), c = null;
					for (let [i, o] of s) {
						c = new ln(t.registry, Jr, t.path, null, t.scope);
						let s = [], l = !1;
						for (let t = 1; t < e.length; t++) {
							let n = e[t], a = Array.isArray(i) ? i[t - 1] : i.type, o = c.parse(n, 1 + s.length, a);
							if (!o) {
								l = !0;
								break;
							}
							s.push(o);
						}
						if (!l) if (Array.isArray(i) && i.length !== s.length) c.error(`Expected ${i.length} arguments, but found ${s.length} instead.`);
						else {
							for (let e = 0; e < s.length; e++) {
								let t = Array.isArray(i) ? i[e] : i.type, n = s[e];
								c.concat(e + 1).checkSubtype(t, n.type);
							}
							if (c.errors.length === 0) return new Ur(n, a, o, s);
						}
					}
					if (s.length === 1) t.errors.push(...c.errors);
					else {
						let n = (s.length ? s : o).map((([e]) => {
							return t = e, Array.isArray(t) ? `(${t.map(lt).join(", ")})` : `(${lt(t.type)}...)`;
							var t;
						})).join(" | "), i = [];
						for (let n = 1; n < e.length; n++) {
							let a = t.parse(e[n], 1 + i.length);
							if (!a) return null;
							i.push(lt(a.type));
						}
						t.error(`Expected arguments of type ${n}, but found (${i.join(", ")}) instead.`);
					}
					return null;
				}
				static register(e, t) {
					for (let n in Ur.definitions = t, t) e[n] = Ur;
				}
			}
			function Wr(e, [t, n, i, a]) {
				t = t.evaluate(e), n = n.evaluate(e), i = i.evaluate(e);
				let o = a ? a.evaluate(e) : 1, s = Zt(t, n, i, o);
				if (s) throw new Kt(s);
				return new Rt(t / 255, n / 255, i / 255, o, !1);
			}
			function Gr(e, t) {
				return e in t;
			}
			function Kr(e, t) {
				let n = t[e];
				return n === void 0 ? null : n;
			}
			function qr(e) {
				return { type: e };
			}
			function Jr(e) {
				if (e instanceof dn) return Jr(e.boundExpression);
				if (e instanceof Ur && e.name === "error" || e instanceof Rn || e instanceof sr || e instanceof Br || e instanceof Vr) return !1;
				let t = e instanceof an || e instanceof nn, n = !0;
				return e.eachChild(((e) => {
					n = t ? n && Jr(e) : n && e instanceof en;
				})), !!n && Yr(e) && Zr(e, [
					"zoom",
					"heatmap-density",
					"elevation",
					"line-progress",
					"accumulated",
					"is-supported-script"
				]);
			}
			function Yr(e) {
				if (e instanceof Ur && (e.name === "get" && e.args.length === 1 || e.name === "feature-state" || e.name === "has" && e.args.length === 1 || e.name === "properties" || e.name === "geometry-type" || e.name === "id" || /^filter-/.test(e.name)) || e instanceof sr || e instanceof Br) return !1;
				let t = !0;
				return e.eachChild(((e) => {
					t && !Yr(e) && (t = !1);
				})), t;
			}
			function Xr(e) {
				if (e instanceof Ur && e.name === "feature-state") return !1;
				let t = !0;
				return e.eachChild(((e) => {
					t && !Xr(e) && (t = !1);
				})), t;
			}
			function Zr(e, t) {
				if (e instanceof Ur && t.indexOf(e.name) >= 0) return !1;
				let n = !0;
				return e.eachChild(((e) => {
					n && !Zr(e, t) && (n = !1);
				})), n;
			}
			function Qr(e) {
				return {
					result: "success",
					value: e
				};
			}
			function $r(e) {
				return {
					result: "error",
					value: e
				};
			}
			function ei(e) {
				return e["property-type"] === "data-driven" || e["property-type"] === "cross-faded-data-driven";
			}
			function ti(e) {
				return !!e.expression && e.expression.parameters.indexOf("zoom") > -1;
			}
			function ni(e) {
				return !!e.expression && e.expression.interpolated;
			}
			function ri(e) {
				return e instanceof Number ? "number" : e instanceof String ? "string" : e instanceof Boolean ? "boolean" : Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
			}
			function ii(e) {
				return typeof e == "object" && !!e && !Array.isArray(e) && K(e) === $e;
			}
			function ai(e) {
				return e;
			}
			function oi(e, t) {
				let n = e.stops && typeof e.stops[0][0] == "object", i = n || !(n || e.property !== void 0), a = e.type || (ni(t) ? "exponential" : "interval"), o = function(e) {
					switch (e.type) {
						case "color": return Rt.parse;
						case "padding": return Ut.parse;
						case "numberArray": return Wt.parse;
						case "colorArray": return Gt.parse;
						default: return null;
					}
				}(t);
				if (o && ((e = Ge({}, e)).stops && (e.stops = e.stops.map(((e) => [e[0], o(e[1])]))), e.default = o(e.default ? e.default : t.default)), e.colorSpace && (s = e.colorSpace) !== "rgb" && s !== "hcl" && s !== "lab") throw Error(`Unknown color space: "${e.colorSpace}"`);
				var s;
				let c = function(e) {
					switch (e) {
						case "exponential": return ui;
						case "interval": return li;
						case "categorical": return ci;
						case "identity": return di;
						default: throw Error(`Unknown function type "${e}"`);
					}
				}(a), l, u;
				if (a === "categorical") {
					l = Object.create(null);
					for (let t of e.stops) l[t[0]] = t[1];
					u = typeof e.stops[0][0];
				}
				if (n) {
					let n = {}, i = [];
					for (let t = 0; t < e.stops.length; t++) {
						let a = e.stops[t], o = a[0].zoom;
						n[o] === void 0 && (n[o] = {
							zoom: o,
							type: e.type,
							property: e.property,
							default: e.default,
							stops: []
						}, i.push(o)), n[o].stops.push([a[0].value, a[1]]);
					}
					let a = [];
					for (let e of i) a.push([n[e].zoom, oi(n[e], t)]);
					let o = { name: "linear" };
					return {
						kind: "composite",
						interpolationType: o,
						interpolationFactor: Tn.interpolationFactor.bind(void 0, o),
						zoomStops: a.map(((e) => e[0])),
						evaluate: ({ zoom: n }, i) => ui({
							stops: a,
							base: e.base
						}, t, n).evaluate(n, i)
					};
				}
				if (i) {
					let n = a === "exponential" ? {
						name: "exponential",
						base: e.base === void 0 ? 1 : e.base
					} : null;
					return {
						kind: "camera",
						interpolationType: n,
						interpolationFactor: Tn.interpolationFactor.bind(void 0, n),
						zoomStops: e.stops.map(((e) => e[0])),
						evaluate: ({ zoom: n }) => c(e, t, n, l, u)
					};
				}
				return {
					kind: "source",
					evaluate(n, i) {
						let a = i && i.properties ? i.properties[e.property] : void 0;
						return a === void 0 ? si(e.default, t.default) : c(e, t, a, l, u);
					}
				};
			}
			function si(e, t, n) {
				return e === void 0 ? t === void 0 ? n === void 0 ? void 0 : n : t : e;
			}
			function ci(e, t, n, i, a) {
				return si(typeof n === a ? i[n] : void 0, e.default, t.default);
			}
			function li(e, t, n) {
				if (ri(n) !== "number") return si(e.default, t.default);
				let i = e.stops.length;
				if (i === 1 || n <= e.stops[0][0]) return e.stops[0][1];
				if (n >= e.stops[i - 1][0]) return e.stops[i - 1][1];
				let a = vn(e.stops.map(((e) => e[0])), n);
				return e.stops[a][1];
			}
			function ui(e, t, n) {
				let i = e.base === void 0 ? 1 : e.base;
				if (ri(n) !== "number") return si(e.default, t.default);
				let a = e.stops.length;
				if (a === 1 || n <= e.stops[0][0]) return e.stops[0][1];
				if (n >= e.stops[a - 1][0]) return e.stops[a - 1][1];
				let o = vn(e.stops.map(((e) => e[0])), n), s = function(e, t, n, i) {
					let a = i - n, o = e - n;
					return a === 0 ? 0 : t === 1 ? o / a : (t ** +o - 1) / (t ** +a - 1);
				}(n, i, e.stops[o][0], e.stops[o + 1][0]), c = e.stops[o][1], l = e.stops[o + 1][1], u = Dn[t.type] || ai;
				return typeof c.evaluate == "function" ? { evaluate(...t) {
					let n = c.evaluate.apply(void 0, t), i = l.evaluate.apply(void 0, t);
					if (n !== void 0 && i !== void 0) return u(n, i, s, e.colorSpace);
				} } : u(c, l, s, e.colorSpace);
			}
			function di(e, t, n) {
				switch (t.type) {
					case "color":
						n = Rt.parse(n);
						break;
					case "formatted":
						n = Ht.fromString(n.toString());
						break;
					case "resolvedImage":
						n = Yt.fromString(n.toString());
						break;
					case "padding":
						n = Ut.parse(n);
						break;
					case "colorArray":
						n = Gt.parse(n);
						break;
					case "numberArray":
						n = Wt.parse(n);
						break;
					default: ri(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0);
				}
				return si(n, e.default, t.default);
			}
			Ur.register(Hr, {
				error: [
					{ kind: "error" },
					[Ye],
					(e, [t]) => {
						throw new Kt(t.evaluate(e));
					}
				],
				typeof: [
					Ye,
					[et],
					(e, [t]) => lt(K(t.evaluate(e)))
				],
				"to-rgba": [
					ct(G, 4),
					[Ze],
					(e, [t]) => {
						let [n, i, a, o] = t.evaluate(e).rgb;
						return [
							255 * n,
							255 * i,
							255 * a,
							o
						];
					}
				],
				rgb: [
					Ze,
					[
						G,
						G,
						G
					],
					Wr
				],
				rgba: [
					Ze,
					[
						G,
						G,
						G,
						G
					],
					Wr
				],
				has: {
					type: Xe,
					overloads: [[[Ye], (e, [t]) => Gr(t.evaluate(e), e.properties())], [[Ye, $e], (e, [t, n]) => Gr(t.evaluate(e), n.evaluate(e))]]
				},
				get: {
					type: et,
					overloads: [[[Ye], (e, [t]) => Kr(t.evaluate(e), e.properties())], [[Ye, $e], (e, [t, n]) => Kr(t.evaluate(e), n.evaluate(e))]]
				},
				"feature-state": [
					et,
					[Ye],
					(e, [t]) => Kr(t.evaluate(e), e.featureState || {})
				],
				properties: [
					$e,
					[],
					(e) => e.properties()
				],
				"geometry-type": [
					Ye,
					[],
					(e) => e.geometryType()
				],
				id: [
					et,
					[],
					(e) => e.id()
				],
				zoom: [
					G,
					[],
					(e) => e.globals.zoom
				],
				"heatmap-density": [
					G,
					[],
					(e) => e.globals.heatmapDensity || 0
				],
				elevation: [
					G,
					[],
					(e) => e.globals.elevation || 0
				],
				"line-progress": [
					G,
					[],
					(e) => e.globals.lineProgress || 0
				],
				accumulated: [
					et,
					[],
					(e) => e.globals.accumulated === void 0 ? null : e.globals.accumulated
				],
				"+": [
					G,
					qr(G),
					(e, t) => {
						let n = 0;
						for (let i of t) n += i.evaluate(e);
						return n;
					}
				],
				"*": [
					G,
					qr(G),
					(e, t) => {
						let n = 1;
						for (let i of t) n *= i.evaluate(e);
						return n;
					}
				],
				"-": {
					type: G,
					overloads: [[[G, G], (e, [t, n]) => t.evaluate(e) - n.evaluate(e)], [[G], (e, [t]) => -t.evaluate(e)]]
				},
				"/": [
					G,
					[G, G],
					(e, [t, n]) => t.evaluate(e) / n.evaluate(e)
				],
				"%": [
					G,
					[G, G],
					(e, [t, n]) => t.evaluate(e) % n.evaluate(e)
				],
				ln2: [
					G,
					[],
					() => Math.LN2
				],
				pi: [
					G,
					[],
					() => Math.PI
				],
				e: [
					G,
					[],
					() => Math.E
				],
				"^": [
					G,
					[G, G],
					(e, [t, n]) => t.evaluate(e) ** +n.evaluate(e)
				],
				sqrt: [
					G,
					[G],
					(e, [t]) => Math.sqrt(t.evaluate(e))
				],
				log10: [
					G,
					[G],
					(e, [t]) => Math.log(t.evaluate(e)) / Math.LN10
				],
				ln: [
					G,
					[G],
					(e, [t]) => Math.log(t.evaluate(e))
				],
				log2: [
					G,
					[G],
					(e, [t]) => Math.log(t.evaluate(e)) / Math.LN2
				],
				sin: [
					G,
					[G],
					(e, [t]) => Math.sin(t.evaluate(e))
				],
				cos: [
					G,
					[G],
					(e, [t]) => Math.cos(t.evaluate(e))
				],
				tan: [
					G,
					[G],
					(e, [t]) => Math.tan(t.evaluate(e))
				],
				asin: [
					G,
					[G],
					(e, [t]) => Math.asin(t.evaluate(e))
				],
				acos: [
					G,
					[G],
					(e, [t]) => Math.acos(t.evaluate(e))
				],
				atan: [
					G,
					[G],
					(e, [t]) => Math.atan(t.evaluate(e))
				],
				min: [
					G,
					qr(G),
					(e, t) => Math.min(...t.map(((t) => t.evaluate(e))))
				],
				max: [
					G,
					qr(G),
					(e, t) => Math.max(...t.map(((t) => t.evaluate(e))))
				],
				abs: [
					G,
					[G],
					(e, [t]) => Math.abs(t.evaluate(e))
				],
				round: [
					G,
					[G],
					(e, [t]) => {
						let n = t.evaluate(e);
						return n < 0 ? -Math.round(-n) : Math.round(n);
					}
				],
				floor: [
					G,
					[G],
					(e, [t]) => Math.floor(t.evaluate(e))
				],
				ceil: [
					G,
					[G],
					(e, [t]) => Math.ceil(t.evaluate(e))
				],
				"filter-==": [
					Xe,
					[Ye, et],
					(e, [t, n]) => e.properties()[t.value] === n.value
				],
				"filter-id-==": [
					Xe,
					[et],
					(e, [t]) => e.id() === t.value
				],
				"filter-type-==": [
					Xe,
					[Ye],
					(e, [t]) => e.geometryType() === t.value
				],
				"filter-<": [
					Xe,
					[Ye, et],
					(e, [t, n]) => {
						let i = e.properties()[t.value], a = n.value;
						return typeof i == typeof a && i < a;
					}
				],
				"filter-id-<": [
					Xe,
					[et],
					(e, [t]) => {
						let n = e.id(), i = t.value;
						return typeof n == typeof i && n < i;
					}
				],
				"filter->": [
					Xe,
					[Ye, et],
					(e, [t, n]) => {
						let i = e.properties()[t.value], a = n.value;
						return typeof i == typeof a && i > a;
					}
				],
				"filter-id->": [
					Xe,
					[et],
					(e, [t]) => {
						let n = e.id(), i = t.value;
						return typeof n == typeof i && n > i;
					}
				],
				"filter-<=": [
					Xe,
					[Ye, et],
					(e, [t, n]) => {
						let i = e.properties()[t.value], a = n.value;
						return typeof i == typeof a && i <= a;
					}
				],
				"filter-id-<=": [
					Xe,
					[et],
					(e, [t]) => {
						let n = e.id(), i = t.value;
						return typeof n == typeof i && n <= i;
					}
				],
				"filter->=": [
					Xe,
					[Ye, et],
					(e, [t, n]) => {
						let i = e.properties()[t.value], a = n.value;
						return typeof i == typeof a && i >= a;
					}
				],
				"filter-id->=": [
					Xe,
					[et],
					(e, [t]) => {
						let n = e.id(), i = t.value;
						return typeof n == typeof i && n >= i;
					}
				],
				"filter-has": [
					Xe,
					[et],
					(e, [t]) => t.value in e.properties()
				],
				"filter-has-id": [
					Xe,
					[],
					(e) => e.id() !== null && e.id() !== void 0
				],
				"filter-type-in": [
					Xe,
					[ct(Ye)],
					(e, [t]) => t.value.indexOf(e.geometryType()) >= 0
				],
				"filter-id-in": [
					Xe,
					[ct(et)],
					(e, [t]) => t.value.indexOf(e.id()) >= 0
				],
				"filter-in-small": [
					Xe,
					[Ye, ct(et)],
					(e, [t, n]) => n.value.indexOf(e.properties()[t.value]) >= 0
				],
				"filter-in-large": [
					Xe,
					[Ye, ct(et)],
					(e, [t, n]) => function(e, t, n, i) {
						for (; n <= i;) {
							let a = n + i >> 1;
							if (t[a] === e) return !0;
							t[a] > e ? i = a - 1 : n = a + 1;
						}
						return !1;
					}(e.properties()[t.value], n.value, 0, n.value.length - 1)
				],
				all: {
					type: Xe,
					overloads: [[[Xe, Xe], (e, [t, n]) => t.evaluate(e) && n.evaluate(e)], [qr(Xe), (e, t) => {
						for (let n of t) if (!n.evaluate(e)) return !1;
						return !0;
					}]]
				},
				any: {
					type: Xe,
					overloads: [[[Xe, Xe], (e, [t, n]) => t.evaluate(e) || n.evaluate(e)], [qr(Xe), (e, t) => {
						for (let n of t) if (n.evaluate(e)) return !0;
						return !1;
					}]]
				},
				"!": [
					Xe,
					[Xe],
					(e, [t]) => !t.evaluate(e)
				],
				"is-supported-script": [
					Xe,
					[Ye],
					(e, [t]) => {
						let n = e.globals && e.globals.isSupportedScript;
						return !n || n(t.evaluate(e));
					}
				],
				upcase: [
					Ye,
					[Ye],
					(e, [t]) => t.evaluate(e).toUpperCase()
				],
				downcase: [
					Ye,
					[Ye],
					(e, [t]) => t.evaluate(e).toLowerCase()
				],
				concat: [
					Ye,
					qr(et),
					(e, t) => t.map(((t) => $t(t.evaluate(e)))).join("")
				],
				"resolved-locale": [
					Ye,
					[tt],
					(e, [t]) => t.evaluate(e).resolvedLocale()
				]
			});
			class fi {
				constructor(e, t, n) {
					this.expression = e, this._warningHistory = {}, this._evaluator = new sn(), this._defaultValue = t ? function(e) {
						if (e.type === "color" && ii(e.default)) return new Rt(0, 0, 0, 0);
						switch (e.type) {
							case "color": return Rt.parse(e.default) || null;
							case "padding": return Ut.parse(e.default) || null;
							case "numberArray": return Wt.parse(e.default) || null;
							case "colorArray": return Gt.parse(e.default) || null;
							case "variableAnchorOffsetCollection": return Jt.parse(e.default) || null;
							case "projectionDefinition": return Xt.parse(e.default) || null;
							default: return e.default === void 0 ? null : e.default;
						}
					}(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null, this._globalState = n;
				}
				evaluateWithoutErrorHandling(e, t, n, i, a, o) {
					return this._globalState && (e = xi(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = i, this._evaluator.availableImages = a || null, this._evaluator.formattedSection = o, this.expression.evaluate(this._evaluator);
				}
				evaluate(e, t, n, i, a, o) {
					this._globalState && (e = xi(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = i, this._evaluator.availableImages = a || null, this._evaluator.formattedSection = o || null;
					try {
						let e = this.expression.evaluate(this._evaluator);
						if (e == null || typeof e == "number" && e != e) return this._defaultValue;
						if (this._enumValues && !(e in this._enumValues)) throw new Kt(`Expected value to be one of ${Object.keys(this._enumValues).map(((e) => JSON.stringify(e))).join(", ")}, but found ${JSON.stringify(e)} instead.`);
						return e;
					} catch (e) {
						return this._warningHistory[e.message] || (this._warningHistory[e.message] = !0, typeof console < "u" && console.warn(e.message)), this._defaultValue;
					}
				}
			}
			function pi(e) {
				return Array.isArray(e) && e.length > 0 && typeof e[0] == "string" && e[0] in Hr;
			}
			function mi(e, t, n) {
				let i = new ln(Hr, Jr, [], t ? function(e) {
					let t = {
						color: Ze,
						string: Ye,
						number: G,
						enum: Ye,
						boolean: Xe,
						formatted: nt,
						padding: rt,
						numberArray: at,
						colorArray: it,
						projectionDefinition: Qe,
						resolvedImage: ot,
						variableAnchorOffsetCollection: st
					};
					return e.type === "array" ? ct(t[e.value] || et, e.length) : t[e.type];
				}(t) : void 0), a = i.parse(e, void 0, void 0, void 0, t && t.type === "string" ? { typeAnnotation: "coerce" } : void 0);
				return a ? Qr(new fi(a, t, n)) : $r(i.errors);
			}
			class hi {
				constructor(e, t, n) {
					this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !Xr(t.expression), this.globalStateRefs = bi(t.expression), this._globalState = n;
				}
				evaluateWithoutErrorHandling(e, t, n, i, a, o) {
					return this._globalState && (e = xi(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, t, n, i, a, o);
				}
				evaluate(e, t, n, i, a, o) {
					return this._globalState && (e = xi(e, this._globalState)), this._styleExpression.evaluate(e, t, n, i, a, o);
				}
			}
			class gi {
				constructor(e, t, n, i, a) {
					this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== "camera" && !Xr(t.expression), this.globalStateRefs = bi(t.expression), this.interpolationType = i, this._globalState = a;
				}
				evaluateWithoutErrorHandling(e, t, n, i, a, o) {
					return this._globalState && (e = xi(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, t, n, i, a, o);
				}
				evaluate(e, t, n, i, a, o) {
					return this._globalState && (e = xi(e, this._globalState)), this._styleExpression.evaluate(e, t, n, i, a, o);
				}
				interpolationFactor(e, t, n) {
					return this.interpolationType ? Tn.interpolationFactor(this.interpolationType, e, t, n) : 0;
				}
			}
			function _i(e, t, n) {
				let i = mi(e, t, n);
				if (i.result === "error") return i;
				let a = i.value.expression, o = Yr(a);
				if (!o && !ei(t)) return $r([new Ke("", "data expressions not supported")]);
				let s = Zr(a, ["zoom"]);
				if (!s && !ti(t)) return $r([new Ke("", "zoom expressions not supported")]);
				let c = yi(a);
				return c || s ? c instanceof Ke ? $r([c]) : c instanceof Tn && !ni(t) ? $r([new Ke("", "\"interpolate\" expressions cannot be used with this property")]) : Qr(c ? new gi(o ? "camera" : "composite", i.value, c.labels, c instanceof Tn ? c.interpolation : void 0, n) : new hi(o ? "constant" : "source", i.value, n)) : $r([new Ke("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.")]);
			}
			class vi {
				constructor(e, t) {
					this._parameters = e, this._specification = t, Ge(this, oi(this._parameters, this._specification));
				}
				static deserialize(e) {
					return new vi(e._parameters, e._specification);
				}
				static serialize(e) {
					return {
						_parameters: e._parameters,
						_specification: e._specification
					};
				}
			}
			function yi(e) {
				let t = null;
				if (e instanceof un) t = yi(e.result);
				else if (e instanceof On) {
					for (let n of e.args) if (t = yi(n), t) break;
				} else (e instanceof yn || e instanceof Tn) && e.input instanceof Ur && e.input.name === "zoom" && (t = e);
				return t instanceof Ke || e.eachChild(((e) => {
					let n = yi(e);
					n instanceof Ke ? t = n : !t && n ? t = new Ke("", "\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.") : t && n && t !== n && (t = new Ke("", "Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression."));
				})), t;
			}
			function bi(e, t = /* @__PURE__ */ new Set()) {
				return e instanceof Vr && t.add(e.key), e.eachChild(((e) => {
					bi(e, t);
				})), t;
			}
			function xi(e, t) {
				let { zoom: n, heatmapDensity: i, elevation: a, lineProgress: o, isSupportedScript: s, accumulated: c } = e ?? {};
				return {
					zoom: n,
					heatmapDensity: i,
					elevation: a,
					lineProgress: o,
					isSupportedScript: s,
					accumulated: c,
					globalState: t
				};
			}
			function Si(e) {
				if (!0 === e || !1 === e) return !0;
				if (!Array.isArray(e) || e.length === 0) return !1;
				switch (e[0]) {
					case "has": return e.length >= 2 && e[1] !== "$id" && e[1] !== "$type";
					case "in": return e.length >= 3 && (typeof e[1] != "string" || Array.isArray(e[2]));
					case "!in":
					case "!has":
					case "none": return !1;
					case "==":
					case "!=":
					case ">":
					case ">=":
					case "<":
					case "<=": return e.length !== 3 || Array.isArray(e[1]) || Array.isArray(e[2]);
					case "any":
					case "all":
						for (let t of e.slice(1)) if (!Si(t) && typeof t != "boolean") return !1;
						return !0;
					default: return !0;
				}
			}
			let Ci = {
				type: "boolean",
				default: !1,
				transition: !1,
				"property-type": "data-driven",
				expression: {
					interpolated: !1,
					parameters: ["zoom", "feature"]
				}
			};
			function wi(e, t) {
				if (e == null) return {
					filter: () => !0,
					needGeometry: !1,
					getGlobalStateRefs: () => /* @__PURE__ */ new Set()
				};
				Si(e) || (e = Di(e));
				let n = mi(e, Ci, t);
				if (n.result === "error") throw Error(n.value.map(((e) => `${e.key}: ${e.message}`)).join(", "));
				return {
					filter: (e, t, i) => n.value.evaluate(e, t, {}, i),
					needGeometry: Ei(e),
					getGlobalStateRefs: () => bi(n.value.expression)
				};
			}
			function Ti(e, t) {
				return e < t ? -1 : e > t ? 1 : 0;
			}
			function Ei(e) {
				if (!Array.isArray(e)) return !1;
				if (e[0] === "within" || e[0] === "distance") return !0;
				for (let t = 1; t < e.length; t++) if (Ei(e[t])) return !0;
				return !1;
			}
			function Di(e) {
				if (!e) return !0;
				let t = e[0];
				return e.length <= 1 ? t !== "any" : t === "==" ? Oi(e[1], e[2], "==") : t === "!=" ? ji(Oi(e[1], e[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? Oi(e[1], e[2], t) : t === "any" ? (n = e.slice(1), ["any"].concat(n.map(Di))) : t === "all" ? ["all"].concat(e.slice(1).map(Di)) : t === "none" ? ["all"].concat(e.slice(1).map(Di).map(ji)) : t === "in" ? ki(e[1], e.slice(2)) : t === "!in" ? ji(ki(e[1], e.slice(2))) : t === "has" ? Ai(e[1]) : t !== "!has" || ji(Ai(e[1]));
				var n;
			}
			function Oi(e, t, n) {
				switch (e) {
					case "$type": return [`filter-type-${n}`, t];
					case "$id": return [`filter-id-${n}`, t];
					default: return [
						`filter-${n}`,
						e,
						t
					];
				}
			}
			function ki(e, t) {
				if (t.length === 0) return !1;
				switch (e) {
					case "$type": return ["filter-type-in", ["literal", t]];
					case "$id": return ["filter-id-in", ["literal", t]];
					default: return t.length > 200 && !t.some(((e) => typeof e != typeof t[0])) ? [
						"filter-in-large",
						e,
						["literal", t.sort(Ti)]
					] : [
						"filter-in-small",
						e,
						["literal", t]
					];
				}
			}
			function Ai(e) {
				switch (e) {
					case "$type": return !0;
					case "$id": return ["filter-has-id"];
					default: return ["filter-has", e];
				}
			}
			function ji(e) {
				return ["!", e];
			}
			function Mi(e) {
				let t = typeof e;
				if (t === "number" || t === "boolean" || t === "string" || e == null) return JSON.stringify(e);
				if (Array.isArray(e)) {
					let t = "[";
					for (let n of e) t += `${Mi(n)},`;
					return `${t}]`;
				}
				let n = Object.keys(e).sort(), i = "{";
				for (let t = 0; t < n.length; t++) i += `${JSON.stringify(n[t])}:${Mi(e[n[t]])},`;
				return `${i}}`;
			}
			function Ni(e) {
				let t = "";
				for (let n of Pe) t += `/${Mi(e[n])}`;
				return t;
			}
			function Pi(e) {
				let t = e.value;
				return t ? [new W(e.key, t, "constants have been deprecated as of v8")] : [];
			}
			function Fi(e) {
				return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e;
			}
			function Ii(e) {
				if (Array.isArray(e)) return e.map(Ii);
				if (e instanceof Object && !(e instanceof Number || e instanceof String || e instanceof Boolean)) {
					let t = {};
					for (let n in e) t[n] = Ii(e[n]);
					return t;
				}
				return Fi(e);
			}
			function Li(e) {
				let t = e.key, n = e.value, i = e.valueSpec || {}, a = e.objectElementValidators || {}, o = e.style, s = e.styleSpec, c = e.validateSpec, l = [], u = ri(n);
				if (u !== "object") return [new W(t, n, `object expected, ${u} found`)];
				for (let e in n) {
					let u = e.split(".")[0], d = At(i, u) || i["*"], f;
					if (At(a, u)) f = a[u];
					else if (At(i, u)) f = c;
					else if (a["*"]) f = a["*"];
					else {
						if (!i["*"]) {
							l.push(new W(t, n[e], `unknown property "${e}"`));
							continue;
						}
						f = c;
					}
					l = l.concat(f({
						key: (t && `${t}.`) + e,
						value: n[e],
						valueSpec: d,
						style: o,
						styleSpec: s,
						object: n,
						objectKey: e,
						validateSpec: c
					}, n));
				}
				for (let e in i) a[e] || i[e].required && i[e].default === void 0 && n[e] === void 0 && l.push(new W(t, n, `missing required property "${e}"`));
				return l;
			}
			function Ri(e) {
				let t = e.value, n = e.valueSpec, i = e.style, a = e.styleSpec, o = e.key, s = e.arrayElementValidator || e.validateSpec;
				if (ri(t) !== "array") return [new W(o, t, `array expected, ${ri(t)} found`)];
				if (n.length && t.length !== n.length) return [new W(o, t, `array length ${n.length} expected, length ${t.length} found`)];
				if (n["min-length"] && t.length < n["min-length"]) return [new W(o, t, `array length at least ${n["min-length"]} expected, length ${t.length} found`)];
				let c = {
					type: n.value,
					values: n.values
				};
				a.$version < 7 && (c.function = n.function), ri(n.value) === "object" && (c = n.value);
				let l = [];
				for (let n = 0; n < t.length; n++) l = l.concat(s({
					array: t,
					arrayIndex: n,
					value: t[n],
					valueSpec: c,
					validateSpec: e.validateSpec,
					style: i,
					styleSpec: a,
					key: `${o}[${n}]`
				}));
				return l;
			}
			function zi(e) {
				let t = e.key, n = e.value, i = e.valueSpec, a = ri(n);
				return a === "number" && n != n && (a = "NaN"), a === "number" ? "minimum" in i && n < i.minimum ? [new W(t, n, `${n} is less than the minimum value ${i.minimum}`)] : "maximum" in i && n > i.maximum ? [new W(t, n, `${n} is greater than the maximum value ${i.maximum}`)] : [] : [new W(t, n, `number expected, ${a} found`)];
			}
			function Bi(e) {
				let t = e.valueSpec, n = Fi(e.value.type), i, a, o, s = {}, c = n !== "categorical" && e.value.property === void 0, l = !c, u = ri(e.value.stops) === "array" && ri(e.value.stops[0]) === "array" && ri(e.value.stops[0][0]) === "object", d = Li({
					key: e.key,
					value: e.value,
					valueSpec: e.styleSpec.function,
					validateSpec: e.validateSpec,
					style: e.style,
					styleSpec: e.styleSpec,
					objectElementValidators: {
						stops: function(e) {
							if (n === "identity") return [new W(e.key, e.value, "identity function may not have a \"stops\" property")];
							let t = [], i = e.value;
							return t = t.concat(Ri({
								key: e.key,
								value: i,
								valueSpec: e.valueSpec,
								validateSpec: e.validateSpec,
								style: e.style,
								styleSpec: e.styleSpec,
								arrayElementValidator: f
							})), ri(i) === "array" && i.length === 0 && t.push(new W(e.key, i, "array must have at least one stop")), t;
						},
						default: function(e) {
							return e.validateSpec({
								key: e.key,
								value: e.value,
								valueSpec: t,
								validateSpec: e.validateSpec,
								style: e.style,
								styleSpec: e.styleSpec
							});
						}
					}
				});
				return n === "identity" && c && d.push(new W(e.key, e.value, "missing required property \"property\"")), n === "identity" || e.value.stops || d.push(new W(e.key, e.value, "missing required property \"stops\"")), n === "exponential" && e.valueSpec.expression && !ni(e.valueSpec) && d.push(new W(e.key, e.value, "exponential functions not supported")), e.styleSpec.$version >= 8 && (l && !ei(e.valueSpec) ? d.push(new W(e.key, e.value, "property functions not supported")) : c && !ti(e.valueSpec) && d.push(new W(e.key, e.value, "zoom functions not supported"))), n !== "categorical" && !u || e.value.property !== void 0 || d.push(new W(e.key, e.value, "\"property\" property is required")), d;
				function f(e) {
					let n = [], i = e.value, c = e.key;
					if (ri(i) !== "array") return [new W(c, i, `array expected, ${ri(i)} found`)];
					if (i.length !== 2) return [new W(c, i, `array length 2 expected, length ${i.length} found`)];
					if (u) {
						if (ri(i[0]) !== "object") return [new W(c, i, `object expected, ${ri(i[0])} found`)];
						if (i[0].zoom === void 0) return [new W(c, i, "object stop key must have zoom")];
						if (i[0].value === void 0) return [new W(c, i, "object stop key must have value")];
						if (o && o > Fi(i[0].zoom)) return [new W(c, i[0].zoom, "stop zoom values must appear in ascending order")];
						Fi(i[0].zoom) !== o && (o = Fi(i[0].zoom), a = void 0, s = {}), n = n.concat(Li({
							key: `${c}[0]`,
							value: i[0],
							valueSpec: { zoom: {} },
							validateSpec: e.validateSpec,
							style: e.style,
							styleSpec: e.styleSpec,
							objectElementValidators: {
								zoom: zi,
								value: p
							}
						}));
					} else n = n.concat(p({
						key: `${c}[0]`,
						value: i[0],
						validateSpec: e.validateSpec,
						style: e.style,
						styleSpec: e.styleSpec
					}, i));
					return pi(Ii(i[1])) ? n.concat([new W(`${c}[1]`, i[1], "expressions are not allowed in function stops.")]) : n.concat(e.validateSpec({
						key: `${c}[1]`,
						value: i[1],
						valueSpec: t,
						validateSpec: e.validateSpec,
						style: e.style,
						styleSpec: e.styleSpec
					}));
				}
				function p(e, o) {
					let c = ri(e.value), l = Fi(e.value), u = e.value === null ? o : e.value;
					if (i) {
						if (c !== i) return [new W(e.key, u, `${c} stop domain type must match previous stop domain type ${i}`)];
					} else i = c;
					if (c !== "number" && c !== "string" && c !== "boolean") return [new W(e.key, u, "stop domain value must be a number, string, or boolean")];
					if (c !== "number" && n !== "categorical") {
						let i = `number expected, ${c} found`;
						return ei(t) && n === void 0 && (i += "\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`."), [new W(e.key, u, i)];
					}
					return n !== "categorical" || c !== "number" || isFinite(l) && Math.floor(l) === l ? n !== "categorical" && c === "number" && a !== void 0 && l < a ? [new W(e.key, u, "stop domain values must appear in ascending order")] : (a = l, n === "categorical" && l in s ? [new W(e.key, u, "stop domain values must be unique")] : (s[l] = !0, [])) : [new W(e.key, u, `integer expected, found ${l}`)];
				}
			}
			function Vi(e) {
				let t = (e.expressionContext === "property" ? _i : mi)(Ii(e.value), e.valueSpec);
				if (t.result === "error") return t.value.map(((t) => new W(`${e.key}${t.key}`, e.value, t.message)));
				let n = t.value.expression || t.value._styleExpression.expression;
				if (e.expressionContext === "property" && e.propertyKey === "text-font" && !n.outputDefined()) return [new W(e.key, e.value, `Invalid data expression for "${e.propertyKey}". Output values must be contained as literals within the expression.`)];
				if (e.expressionContext === "property" && e.propertyType === "layout" && !Xr(n)) return [new W(e.key, e.value, "\"feature-state\" data expressions are not supported with layout properties.")];
				if (e.expressionContext === "filter" && !Xr(n)) return [new W(e.key, e.value, "\"feature-state\" data expressions are not supported with filters.")];
				if (e.expressionContext && e.expressionContext.indexOf("cluster") === 0) {
					if (!Zr(n, ["zoom", "feature-state"])) return [new W(e.key, e.value, "\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.")];
					if (e.expressionContext === "cluster-initial" && !Yr(n)) return [new W(e.key, e.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
				}
				return [];
			}
			function Hi(e) {
				let t = e.key, n = e.value, i = ri(n);
				return i === "string" ? Rt.parse(String(n)) ? [] : [new W(t, n, `color expected, "${n}" found`)] : [new W(t, n, `color expected, ${i} found`)];
			}
			function Ui(e) {
				let t = e.key, n = e.value, i = e.valueSpec, a = [];
				return Array.isArray(i.values) ? i.values.indexOf(Fi(n)) === -1 && a.push(new W(t, n, `expected one of [${i.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(i.values).indexOf(Fi(n)) === -1 && a.push(new W(t, n, `expected one of [${Object.keys(i.values).join(", ")}], ${JSON.stringify(n)} found`)), a;
			}
			function Wi(e) {
				return Si(Ii(e.value)) ? Vi(Ge({}, e, {
					expressionContext: "filter",
					valueSpec: { value: "boolean" }
				})) : Gi(e);
			}
			function Gi(e) {
				let t = e.value, n = e.key;
				if (ri(t) !== "array") return [new W(n, t, `array expected, ${ri(t)} found`)];
				let i = e.styleSpec, a, o = [];
				if (t.length < 1) return [new W(n, t, "filter array must have at least 1 element")];
				switch (o = o.concat(Ui({
					key: `${n}[0]`,
					value: t[0],
					valueSpec: i.filter_operator,
					style: e.style,
					styleSpec: e.styleSpec
				})), Fi(t[0])) {
					case "<":
					case "<=":
					case ">":
					case ">=": t.length >= 2 && Fi(t[1]) === "$type" && o.push(new W(n, t, `"$type" cannot be use with operator "${t[0]}"`));
					case "==":
					case "!=": t.length !== 3 && o.push(new W(n, t, `filter array for operator "${t[0]}" must have 3 elements`));
					case "in":
					case "!in":
						t.length >= 2 && (a = ri(t[1]), a !== "string" && o.push(new W(`${n}[1]`, t[1], `string expected, ${a} found`)));
						for (let s = 2; s < t.length; s++) a = ri(t[s]), Fi(t[1]) === "$type" ? o = o.concat(Ui({
							key: `${n}[${s}]`,
							value: t[s],
							valueSpec: i.geometry_type,
							style: e.style,
							styleSpec: e.styleSpec
						})) : a !== "string" && a !== "number" && a !== "boolean" && o.push(new W(`${n}[${s}]`, t[s], `string, number, or boolean expected, ${a} found`));
						break;
					case "any":
					case "all":
					case "none":
						for (let i = 1; i < t.length; i++) o = o.concat(Gi({
							key: `${n}[${i}]`,
							value: t[i],
							style: e.style,
							styleSpec: e.styleSpec
						}));
						break;
					case "has":
					case "!has": a = ri(t[1]), t.length === 2 ? a !== "string" && o.push(new W(`${n}[1]`, t[1], `string expected, ${a} found`)) : o.push(new W(n, t, `filter array for "${t[0]}" operator must have 2 elements`));
				}
				return o;
			}
			function Ki(e, t) {
				let n = e.key, i = e.validateSpec, a = e.style, o = e.styleSpec, s = e.value, c = e.objectKey, l = o[`${t}_${e.layerType}`];
				if (!l) return [];
				let u = c.match(/^(.*)-transition$/);
				if (t === "paint" && u && l[u[1]] && l[u[1]].transition) return i({
					key: n,
					value: s,
					valueSpec: o.transition,
					style: a,
					styleSpec: o
				});
				let d = e.valueSpec || l[c];
				if (!d) return [new W(n, s, `unknown property "${c}"`)];
				let f;
				if (ri(s) === "string" && ei(d) && !d.tokens && (f = /^{([^}]+)}$/.exec(s))) return [new W(n, s, `"${c}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(f[1])} }\`.`)];
				let p = [];
				return e.layerType === "symbol" && (c === "text-field" && a && !a.glyphs && p.push(new W(n, s, "use of \"text-field\" requires a style \"glyphs\" property")), c === "text-font" && ii(Ii(s)) && Fi(s.type) === "identity" && p.push(new W(n, s, "\"text-font\" does not support identity functions"))), p.concat(i({
					key: e.key,
					value: s,
					valueSpec: d,
					style: a,
					styleSpec: o,
					expressionContext: "property",
					propertyType: t,
					propertyKey: c
				}));
			}
			function qi(e) {
				return Ki(e, "paint");
			}
			function Ji(e) {
				return Ki(e, "layout");
			}
			function Yi(e) {
				let t = [], n = e.value, i = e.key, a = e.style, o = e.styleSpec;
				if (ri(n) !== "object") return [new W(i, n, `object expected, ${ri(n)} found`)];
				n.type || n.ref || t.push(new W(i, n, "either \"type\" or \"ref\" is required"));
				let s = Fi(n.type), c = Fi(n.ref);
				if (n.id) {
					let o = Fi(n.id);
					for (let s = 0; s < e.arrayIndex; s++) {
						let e = a.layers[s];
						Fi(e.id) === o && t.push(new W(i, n.id, `duplicate layer id "${n.id}", previously used at line ${e.id.__line__}`));
					}
				}
				if ("ref" in n) {
					let e;
					[
						"type",
						"source",
						"source-layer",
						"filter",
						"layout"
					].forEach(((e) => {
						e in n && t.push(new W(i, n[e], `"${e}" is prohibited for ref layers`));
					})), a.layers.forEach(((t) => {
						Fi(t.id) === c && (e = t);
					})), e ? e.ref ? t.push(new W(i, n.ref, "ref cannot reference another ref layer")) : s = Fi(e.type) : t.push(new W(i, n.ref, `ref layer "${c}" not found`));
				} else if (s !== "background") if (n.source) {
					let e = a.sources && a.sources[n.source], o = e && Fi(e.type);
					e ? o === "vector" && s === "raster" ? t.push(new W(i, n.source, `layer "${n.id}" requires a raster source`)) : o !== "raster-dem" && s === "hillshade" || o !== "raster-dem" && s === "color-relief" ? t.push(new W(i, n.source, `layer "${n.id}" requires a raster-dem source`)) : o === "raster" && s !== "raster" ? t.push(new W(i, n.source, `layer "${n.id}" requires a vector source`)) : o !== "vector" || n["source-layer"] ? o === "raster-dem" && s !== "hillshade" && s !== "color-relief" ? t.push(new W(i, n.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : s !== "line" || !n.paint || !n.paint["line-gradient"] || o === "geojson" && e.lineMetrics || t.push(new W(i, n, `layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new W(i, n, `layer "${n.id}" must specify a "source-layer"`)) : t.push(new W(i, n.source, `source "${n.source}" not found`));
				} else t.push(new W(i, n, "missing required property \"source\""));
				return t = t.concat(Li({
					key: i,
					value: n,
					valueSpec: o.layer,
					style: e.style,
					styleSpec: e.styleSpec,
					validateSpec: e.validateSpec,
					objectElementValidators: {
						"*": () => [],
						type: () => e.validateSpec({
							key: `${i}.type`,
							value: n.type,
							valueSpec: o.layer.type,
							style: e.style,
							styleSpec: e.styleSpec,
							validateSpec: e.validateSpec,
							object: n,
							objectKey: "type"
						}),
						filter: Wi,
						layout: (e) => Li({
							layer: n,
							key: e.key,
							value: e.value,
							style: e.style,
							styleSpec: e.styleSpec,
							validateSpec: e.validateSpec,
							objectElementValidators: { "*": (e) => Ji(Ge({ layerType: s }, e)) }
						}),
						paint: (e) => Li({
							layer: n,
							key: e.key,
							value: e.value,
							style: e.style,
							styleSpec: e.styleSpec,
							validateSpec: e.validateSpec,
							objectElementValidators: { "*": (e) => qi(Ge({ layerType: s }, e)) }
						})
					}
				})), t;
			}
			function Xi(e) {
				let t = e.value, n = e.key, i = ri(t);
				return i === "string" ? [] : [new W(n, t, `string expected, ${i} found`)];
			}
			let Zi = { promoteId: function({ key: e, value: t }) {
				if (ri(t) === "string") return Xi({
					key: e,
					value: t
				});
				{
					let n = [];
					for (let i in t) n.push(...Xi({
						key: `${e}.${i}`,
						value: t[i]
					}));
					return n;
				}
			} };
			function Qi(e) {
				let t = e.value, n = e.key, i = e.styleSpec, a = e.style, o = e.validateSpec;
				if (!t.type) return [new W(n, t, "\"type\" is required")];
				let s = Fi(t.type), c;
				switch (s) {
					case "vector":
					case "raster": return c = Li({
						key: n,
						value: t,
						valueSpec: i[`source_${s.replace("-", "_")}`],
						style: e.style,
						styleSpec: i,
						objectElementValidators: Zi,
						validateSpec: o
					}), c;
					case "raster-dem": return c = function(e) {
						let t = e.sourceName ?? "", n = e.value, i = e.styleSpec, a = i.source_raster_dem, o = e.style, s = [], c = ri(n);
						if (n === void 0) return s;
						if (c !== "object") return s.push(new W("source_raster_dem", n, `object expected, ${c} found`)), s;
						let l = Fi(n.encoding) === "custom", u = [
							"redFactor",
							"greenFactor",
							"blueFactor",
							"baseShift"
						], d = e.value.encoding ? `"${e.value.encoding}"` : "Default";
						for (let c in n) !l && u.includes(c) ? s.push(new W(c, n[c], `In "${t}": "${c}" is only valid when "encoding" is set to "custom". ${d} encoding found`)) : a[c] ? s = s.concat(e.validateSpec({
							key: c,
							value: n[c],
							valueSpec: a[c],
							validateSpec: e.validateSpec,
							style: o,
							styleSpec: i
						})) : s.push(new W(c, n[c], `unknown property "${c}"`));
						return s;
					}({
						sourceName: n,
						value: t,
						style: e.style,
						styleSpec: i,
						validateSpec: o
					}), c;
					case "geojson":
						if (c = Li({
							key: n,
							value: t,
							valueSpec: i.source_geojson,
							style: a,
							styleSpec: i,
							validateSpec: o,
							objectElementValidators: Zi
						}), t.cluster) for (let e in t.clusterProperties) {
							let [i, a] = t.clusterProperties[e], o = typeof i == "string" ? [
								i,
								["accumulated"],
								["get", e]
							] : i;
							c.push(...Vi({
								key: `${n}.${e}.map`,
								value: a,
								expressionContext: "cluster-map"
							})), c.push(...Vi({
								key: `${n}.${e}.reduce`,
								value: o,
								expressionContext: "cluster-reduce"
							}));
						}
						return c;
					case "video": return Li({
						key: n,
						value: t,
						valueSpec: i.source_video,
						style: a,
						validateSpec: o,
						styleSpec: i
					});
					case "image": return Li({
						key: n,
						value: t,
						valueSpec: i.source_image,
						style: a,
						validateSpec: o,
						styleSpec: i
					});
					case "canvas": return [new W(n, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
					default: return Ui({
						key: `${n}.type`,
						value: t.type,
						valueSpec: { values: [
							"vector",
							"raster",
							"raster-dem",
							"geojson",
							"video",
							"image"
						] }
					});
				}
			}
			function $i(e) {
				let t = e.value, n = e.styleSpec, i = n.light, a = e.style, o = [], s = ri(t);
				if (t === void 0) return o;
				if (s !== "object") return o = o.concat([new W("light", t, `object expected, ${s} found`)]), o;
				for (let s in t) {
					let c = s.match(/^(.*)-transition$/);
					o = o.concat(c && i[c[1]] && i[c[1]].transition ? e.validateSpec({
						key: s,
						value: t[s],
						valueSpec: n.transition,
						validateSpec: e.validateSpec,
						style: a,
						styleSpec: n
					}) : i[s] ? e.validateSpec({
						key: s,
						value: t[s],
						valueSpec: i[s],
						validateSpec: e.validateSpec,
						style: a,
						styleSpec: n
					}) : [new W(s, t[s], `unknown property "${s}"`)]);
				}
				return o;
			}
			function ea(e) {
				let t = e.value, n = e.styleSpec, i = n.sky, a = e.style, o = ri(t);
				if (t === void 0) return [];
				if (o !== "object") return [new W("sky", t, `object expected, ${o} found`)];
				let s = [];
				for (let o in t) s = s.concat(i[o] ? e.validateSpec({
					key: o,
					value: t[o],
					valueSpec: i[o],
					style: a,
					styleSpec: n
				}) : [new W(o, t[o], `unknown property "${o}"`)]);
				return s;
			}
			function ta(e) {
				let t = e.value, n = e.styleSpec, i = n.terrain, a = e.style, o = [], s = ri(t);
				if (t === void 0) return o;
				if (s !== "object") return o = o.concat([new W("terrain", t, `object expected, ${s} found`)]), o;
				for (let s in t) o = o.concat(i[s] ? e.validateSpec({
					key: s,
					value: t[s],
					valueSpec: i[s],
					validateSpec: e.validateSpec,
					style: a,
					styleSpec: n
				}) : [new W(s, t[s], `unknown property "${s}"`)]);
				return o;
			}
			function na(e) {
				let t = [], n = e.value, i = e.key;
				if (Array.isArray(n)) {
					let a = [], o = [];
					for (let s in n) n[s].id && a.includes(n[s].id) && t.push(new W(i, n, `all the sprites' ids must be unique, but ${n[s].id} is duplicated`)), a.push(n[s].id), n[s].url && o.includes(n[s].url) && t.push(new W(i, n, `all the sprites' URLs must be unique, but ${n[s].url} is duplicated`)), o.push(n[s].url), t = t.concat(Li({
						key: `${i}[${s}]`,
						value: n[s],
						valueSpec: {
							id: {
								type: "string",
								required: !0
							},
							url: {
								type: "string",
								required: !0
							}
						},
						validateSpec: e.validateSpec
					}));
					return t;
				}
				return Xi({
					key: i,
					value: n
				});
			}
			function ra(e) {
				return t = e.value, t && t.constructor === Object ? [] : [new W(e.key, e.value, `object expected, ${ri(e.value)} found`)];
				var t;
			}
			let ia = {
				"*": () => [],
				array: Ri,
				boolean: function(e) {
					let t = e.value, n = e.key, i = ri(t);
					return i === "boolean" ? [] : [new W(n, t, `boolean expected, ${i} found`)];
				},
				number: zi,
				color: Hi,
				constants: Pi,
				enum: Ui,
				filter: Wi,
				function: Bi,
				layer: Yi,
				object: Li,
				source: Qi,
				light: $i,
				sky: ea,
				terrain: ta,
				projection: function(e) {
					let t = e.value, n = e.styleSpec, i = n.projection, a = e.style, o = ri(t);
					if (t === void 0) return [];
					if (o !== "object") return [new W("projection", t, `object expected, ${o} found`)];
					let s = [];
					for (let o in t) s = s.concat(i[o] ? e.validateSpec({
						key: o,
						value: t[o],
						valueSpec: i[o],
						style: a,
						styleSpec: n
					}) : [new W(o, t[o], `unknown property "${o}"`)]);
					return s;
				},
				projectionDefinition: function(e) {
					let t = e.key, n = e.value;
					n = n instanceof String ? n.valueOf() : n;
					let i = ri(n);
					return i !== "array" || function(e) {
						return Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number";
					}(n) || function(e) {
						return !![
							"interpolate",
							"step",
							"literal"
						].includes(e[0]);
					}(n) ? ["array", "string"].includes(i) ? [] : [new W(t, n, `projection expected, invalid type "${i}" found`)] : [new W(t, n, `projection expected, invalid array ${JSON.stringify(n)} found`)];
				},
				string: Xi,
				formatted: function(e) {
					return Xi(e).length === 0 ? [] : Vi(e);
				},
				resolvedImage: function(e) {
					return Xi(e).length === 0 ? [] : Vi(e);
				},
				padding: function(e) {
					let t = e.key, n = e.value;
					if (ri(n) === "array") {
						if (n.length < 1 || n.length > 4) return [new W(t, n, `padding requires 1 to 4 values; ${n.length} values found`)];
						let i = { type: "number" }, a = [];
						for (let o = 0; o < n.length; o++) a = a.concat(e.validateSpec({
							key: `${t}[${o}]`,
							value: n[o],
							validateSpec: e.validateSpec,
							valueSpec: i
						}));
						return a;
					}
					return zi({
						key: t,
						value: n,
						valueSpec: {}
					});
				},
				numberArray: function(e) {
					let t = e.key, n = e.value;
					if (ri(n) === "array") {
						let i = { type: "number" };
						if (n.length < 1) return [new W(t, n, "array length at least 1 expected, length 0 found")];
						let a = [];
						for (let o = 0; o < n.length; o++) a = a.concat(e.validateSpec({
							key: `${t}[${o}]`,
							value: n[o],
							validateSpec: e.validateSpec,
							valueSpec: i
						}));
						return a;
					}
					return zi({
						key: t,
						value: n,
						valueSpec: {}
					});
				},
				colorArray: function(e) {
					let t = e.key, n = e.value;
					if (ri(n) === "array") {
						if (n.length < 1) return [new W(t, n, "array length at least 1 expected, length 0 found")];
						let e = [];
						for (let i = 0; i < n.length; i++) e = e.concat(Hi({
							key: `${t}[${i}]`,
							value: n[i]
						}));
						return e;
					}
					return Hi({
						key: t,
						value: n
					});
				},
				variableAnchorOffsetCollection: function(e) {
					let t = e.key, n = e.value, i = ri(n), a = e.styleSpec;
					if (i !== "array" || n.length < 1 || n.length % 2 != 0) return [new W(t, n, "variableAnchorOffsetCollection requires a non-empty array of even length")];
					let o = [];
					for (let i = 0; i < n.length; i += 2) o = o.concat(Ui({
						key: `${t}[${i}]`,
						value: n[i],
						valueSpec: a.layout_symbol["text-anchor"]
					})), o = o.concat(Ri({
						key: `${t}[${i + 1}]`,
						value: n[i + 1],
						valueSpec: {
							length: 2,
							value: "number"
						},
						validateSpec: e.validateSpec,
						style: e.style,
						styleSpec: a
					}));
					return o;
				},
				sprite: na,
				state: ra
			};
			function aa(e) {
				let t = e.value, n = e.valueSpec, i = e.styleSpec;
				return e.validateSpec = aa, n.expression && ii(Fi(t)) ? Bi(e) : n.expression && pi(Ii(t)) ? Vi(e) : n.type && ia[n.type] ? ia[n.type](e) : Li(Ge({}, e, { valueSpec: n.type ? i[n.type] : n }));
			}
			function oa(e) {
				let t = e.value, n = e.key, i = Xi(e);
				return i.length || (t.indexOf("{fontstack}") === -1 && i.push(new W(n, t, "\"glyphs\" url must include a \"{fontstack}\" token")), t.indexOf("{range}") === -1 && i.push(new W(n, t, "\"glyphs\" url must include a \"{range}\" token"))), i;
			}
			function sa(e, t = U) {
				let n = [];
				return n = n.concat(aa({
					key: "",
					value: e,
					valueSpec: t.$root,
					styleSpec: t,
					style: e,
					validateSpec: aa,
					objectElementValidators: {
						glyphs: oa,
						"*": () => []
					}
				})), e.constants && (n = n.concat(Pi({
					key: "constants",
					value: e.constants
				}))), la(n);
			}
			function ca(e) {
				return function(t) {
					return e(Object.assign({}, t, { validateSpec: aa }));
				};
			}
			function la(e) {
				return [].concat(e).sort(((e, t) => e.line - t.line));
			}
			function q(e) {
				return function(...t) {
					return la(e.apply(this, t));
				};
			}
			sa.source = q(ca(Qi)), sa.sprite = q(ca(na)), sa.glyphs = q(ca(oa)), sa.light = q(ca($i)), sa.sky = q(ca(ea)), sa.terrain = q(ca(ta)), sa.state = q(ca(ra)), sa.layer = q(ca(Yi)), sa.filter = q(ca(Wi)), sa.paintProperty = q(ca(qi)), sa.layoutProperty = q(ca(Ji));
			let ua = sa, da = ua.light, fa = ua.sky, pa = ua.paintProperty, ma = ua.layoutProperty;
			function ha(e, t) {
				let n = !1;
				if (t && t.length) for (let i of t) e.fire(new Me(Error(i.message))), n = !0;
				return n;
			}
			class ga {
				constructor(e, t, n) {
					let i = this.cells = [];
					if (e instanceof ArrayBuffer) {
						this.arrayBuffer = e;
						let a = new Int32Array(this.arrayBuffer);
						e = a[0], this.d = (t = a[1]) + 2 * (n = a[2]);
						for (let e = 0; e < this.d * this.d; e++) {
							let t = a[3 + e], n = a[3 + e + 1];
							i.push(t === n ? null : a.subarray(t, n));
						}
						let o = a[3 + i.length + 1];
						this.keys = a.subarray(a[3 + i.length], o), this.bboxes = a.subarray(o), this.insert = this._insertReadonly;
					} else {
						this.d = t + 2 * n;
						for (let e = 0; e < this.d * this.d; e++) i.push([]);
						this.keys = [], this.bboxes = [];
					}
					this.n = t, this.extent = e, this.padding = n, this.scale = t / e, this.uid = 0;
					let a = n / t * e;
					this.min = -a, this.max = e + a;
				}
				insert(e, t, n, i, a) {
					this._forEachCell(t, n, i, a, this._insertCell, this.uid++, void 0, void 0), this.keys.push(e), this.bboxes.push(t), this.bboxes.push(n), this.bboxes.push(i), this.bboxes.push(a);
				}
				_insertReadonly() {
					throw Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
				}
				_insertCell(e, t, n, i, a, o) {
					this.cells[a].push(o);
				}
				query(e, t, n, i, a) {
					let o = this.min, s = this.max;
					if (e <= o && t <= o && s <= n && s <= i && !a) return Array.prototype.slice.call(this.keys);
					{
						let o = [];
						return this._forEachCell(e, t, n, i, this._queryCell, o, {}, a), o;
					}
				}
				_queryCell(e, t, n, i, a, o, s, c) {
					let l = this.cells[a];
					if (l !== null) {
						let a = this.keys, u = this.bboxes;
						for (let d = 0; d < l.length; d++) {
							let f = l[d];
							if (s[f] === void 0) {
								let l = 4 * f;
								(c ? c(u[l + 0], u[l + 1], u[l + 2], u[l + 3]) : e <= u[l + 2] && t <= u[l + 3] && n >= u[l + 0] && i >= u[l + 1]) ? (s[f] = !0, o.push(a[f])) : s[f] = !1;
							}
						}
					}
				}
				_forEachCell(e, t, n, i, a, o, s, c) {
					let l = this._convertToCellCoord(e), u = this._convertToCellCoord(t), d = this._convertToCellCoord(n), f = this._convertToCellCoord(i);
					for (let p = l; p <= d; p++) for (let l = u; l <= f; l++) {
						let u = this.d * l + p;
						if ((!c || c(this._convertFromCellCoord(p), this._convertFromCellCoord(l), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(l + 1))) && a.call(this, e, t, n, i, u, o, s, c)) return;
					}
				}
				_convertFromCellCoord(e) {
					return (e - this.padding) / this.scale;
				}
				_convertToCellCoord(e) {
					return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
				}
				toArrayBuffer() {
					if (this.arrayBuffer) return this.arrayBuffer;
					let e = this.cells, t = 3 + this.cells.length + 1 + 1, n = 0;
					for (let e = 0; e < this.cells.length; e++) n += this.cells[e].length;
					let i = new Int32Array(t + n + this.keys.length + this.bboxes.length);
					i[0] = this.extent, i[1] = this.n, i[2] = this.padding;
					let a = t;
					for (let t = 0; t < e.length; t++) {
						let n = e[t];
						i[3 + t] = a, i.set(n, a), a += n.length;
					}
					return i[3 + e.length] = a, i.set(this.keys, a), a += this.keys.length, i[3 + e.length + 1] = a, i.set(this.bboxes, a), a += this.bboxes.length, i.buffer;
				}
				static serialize(e, t) {
					let n = e.toArrayBuffer();
					return t && t.push(n), { buffer: n };
				}
				static deserialize(e) {
					return new ga(e.buffer);
				}
			}
			let _a = {};
			function J(e, t, n = {}) {
				if (_a[e]) throw Error(`${e} is already registered.`);
				Object.defineProperty(t, "_classRegistryKey", {
					value: e,
					writeable: !1
				}), _a[e] = {
					klass: t,
					omit: n.omit || [],
					shallow: n.shallow || []
				};
			}
			for (let e in J("Object", Object), J("Set", Set), J("TransferableGridIndex", ga), J("Color", Rt), J("Error", Error), J("AJAXError", Te), J("ResolvedImage", Yt), J("StylePropertyFunction", vi), J("StyleExpression", fi, { omit: ["_evaluator"] }), J("ZoomDependentExpression", gi), J("ZoomConstantExpression", hi), J("CompoundExpression", Ur, { omit: ["_evaluate"] }), Hr) Hr[e]._classRegistryKey || J(`Expression_${e}`, Hr[e]);
			function va(e) {
				return e && typeof ArrayBuffer < "u" && (e instanceof ArrayBuffer || e.constructor && e.constructor.name === "ArrayBuffer");
			}
			function ya(e) {
				return e.$name || e.constructor._classRegistryKey;
			}
			function ba(e) {
				return !function(e) {
					if (typeof e != "object" || !e) return !1;
					let t = ya(e);
					return !(!t || t === "Object");
				}(e) && (e == null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp || e instanceof Blob || e instanceof Error || va(e) || fe(e) || ArrayBuffer.isView(e) || e instanceof ImageData);
			}
			function xa(e, t) {
				if (ba(e)) return (va(e) || fe(e)) && t && t.push(e), ArrayBuffer.isView(e) && t && t.push(e.buffer), e instanceof ImageData && t && t.push(e.data.buffer), e;
				if (Array.isArray(e)) {
					let n = [];
					for (let i of e) n.push(xa(i, t));
					return n;
				}
				if (typeof e != "object") throw Error("can't serialize object of type " + typeof e);
				let n = ya(e);
				if (!n) throw Error(`can't serialize object of unregistered class ${e.constructor.name}`);
				if (!_a[n]) throw Error(`${n} is not registered.`);
				let { klass: i } = _a[n], a = i.serialize ? i.serialize(e, t) : {};
				if (i.serialize) {
					if (t && a === t[t.length - 1]) throw Error("statically serialized object won't survive transfer of $name property");
				} else {
					for (let i in e) {
						if (!e.hasOwnProperty(i) || _a[n].omit.indexOf(i) >= 0) continue;
						let o = e[i];
						a[i] = _a[n].shallow.indexOf(i) >= 0 ? o : xa(o, t);
					}
					e instanceof Error && (a.message = e.message);
				}
				if (a.$name) throw Error("$name property is reserved for worker serialization logic.");
				return n !== "Object" && (a.$name = n), a;
			}
			function Sa(e) {
				if (ba(e)) return e;
				if (Array.isArray(e)) return e.map(Sa);
				if (typeof e != "object") throw Error("can't deserialize object of type " + typeof e);
				let t = ya(e) || "Object";
				if (!_a[t]) throw Error(`can't deserialize unregistered class ${t}`);
				let { klass: n } = _a[t];
				if (!n) throw Error(`can't deserialize unregistered class ${t}`);
				if (n.deserialize) return n.deserialize(e);
				let i = Object.create(n.prototype);
				for (let n of Object.keys(e)) {
					if (n === "$name") continue;
					let a = e[n];
					i[n] = _a[t].shallow.indexOf(n) >= 0 ? a : Sa(a);
				}
				return i;
			}
			class Ca {
				constructor() {
					this.first = !0;
				}
				update(e, t) {
					let n = Math.floor(e);
					return this.first ? (this.first = !1, this.lastIntegerZoom = n, this.lastIntegerZoomTime = 0, this.lastZoom = e, this.lastFloorZoom = n, !0) : (this.lastFloorZoom > n ? (this.lastIntegerZoom = n + 1, this.lastIntegerZoomTime = t) : this.lastFloorZoom < n && (this.lastIntegerZoom = n, this.lastIntegerZoomTime = t), e !== this.lastZoom && (this.lastZoom = e, this.lastFloorZoom = n, !0));
				}
			}
			let wa = {
				"Latin-1 Supplement": (e) => e >= 128 && e <= 255,
				"Hangul Jamo": (e) => e >= 4352 && e <= 4607,
				Khmer: (e) => e >= 6016 && e <= 6143,
				"General Punctuation": (e) => e >= 8192 && e <= 8303,
				"Letterlike Symbols": (e) => e >= 8448 && e <= 8527,
				"Number Forms": (e) => e >= 8528 && e <= 8591,
				"Miscellaneous Technical": (e) => e >= 8960 && e <= 9215,
				"Control Pictures": (e) => e >= 9216 && e <= 9279,
				"Optical Character Recognition": (e) => e >= 9280 && e <= 9311,
				"Enclosed Alphanumerics": (e) => e >= 9312 && e <= 9471,
				"Geometric Shapes": (e) => e >= 9632 && e <= 9727,
				"Miscellaneous Symbols": (e) => e >= 9728 && e <= 9983,
				"Miscellaneous Symbols and Arrows": (e) => e >= 11008 && e <= 11263,
				"Ideographic Description Characters": (e) => e >= 12272 && e <= 12287,
				"CJK Symbols and Punctuation": (e) => e >= 12288 && e <= 12351,
				Hiragana: (e) => e >= 12352 && e <= 12447,
				Katakana: (e) => e >= 12448 && e <= 12543,
				Kanbun: (e) => e >= 12688 && e <= 12703,
				"CJK Strokes": (e) => e >= 12736 && e <= 12783,
				"Enclosed CJK Letters and Months": (e) => e >= 12800 && e <= 13055,
				"CJK Compatibility": (e) => e >= 13056 && e <= 13311,
				"Yijing Hexagram Symbols": (e) => e >= 19904 && e <= 19967,
				"CJK Unified Ideographs": (e) => e >= 19968 && e <= 40959,
				"Hangul Syllables": (e) => e >= 44032 && e <= 55215,
				"Private Use Area": (e) => e >= 57344 && e <= 63743,
				"Vertical Forms": (e) => e >= 65040 && e <= 65055,
				"CJK Compatibility Forms": (e) => e >= 65072 && e <= 65103,
				"Small Form Variants": (e) => e >= 65104 && e <= 65135,
				"Halfwidth and Fullwidth Forms": (e) => e >= 65280 && e <= 65519
			};
			function Ta(e) {
				for (let t of e) if (ja(t.charCodeAt(0))) return !0;
				return !1;
			}
			function Ea(e) {
				for (let t of e) if (!ka(t.charCodeAt(0))) return !1;
				return !0;
			}
			function Da(e) {
				let t = e.map(((e) => {
					try {
						return RegExp(`\\p{sc=${e}}`, "u").source;
					} catch {
						return null;
					}
				})).filter(((e) => e));
				return new RegExp(t.join("|"), "u");
			}
			let Oa = Da([
				"Arab",
				"Dupl",
				"Mong",
				"Ougr",
				"Syrc"
			]);
			function ka(e) {
				return !Oa.test(String.fromCodePoint(e));
			}
			let Aa = Da([
				"Bopo",
				"Hani",
				"Hira",
				"Kana",
				"Kits",
				"Nshu",
				"Tang",
				"Yiii"
			]);
			function ja(e) {
				return !(e !== 746 && e !== 747 && (e < 4352 || !(wa["CJK Compatibility Forms"](e) && !(e >= 65097 && e <= 65103) || wa["CJK Compatibility"](e) || wa["CJK Strokes"](e) || !(!wa["CJK Symbols and Punctuation"](e) || e >= 12296 && e <= 12305 || e >= 12308 && e <= 12319 || e === 12336) || wa["Enclosed CJK Letters and Months"](e) || wa["Ideographic Description Characters"](e) || wa.Kanbun(e) || wa.Katakana(e) && e !== 12540 || !(!wa["Halfwidth and Fullwidth Forms"](e) || e === 65288 || e === 65289 || e === 65293 || e >= 65306 && e <= 65310 || e === 65339 || e === 65341 || e === 65343 || e >= 65371 && e <= 65503 || e === 65507 || e >= 65512 && e <= 65519) || !(!wa["Small Form Variants"](e) || e >= 65112 && e <= 65118 || e >= 65123 && e <= 65126) || wa["Vertical Forms"](e) || wa["Yijing Hexagram Symbols"](e) || /\p{sc=Cans}/u.test(String.fromCodePoint(e)) || /\p{sc=Hang}/u.test(String.fromCodePoint(e)) || Aa.test(String.fromCodePoint(e)))));
			}
			function Ma(e) {
				return !(ja(e) || function(e) {
					return !!(wa["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || wa["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || wa["Letterlike Symbols"](e) || wa["Number Forms"](e) || wa["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || wa["Control Pictures"](e) && e !== 9251 || wa["Optical Character Recognition"](e) || wa["Enclosed Alphanumerics"](e) || wa["Geometric Shapes"](e) || wa["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || wa["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || wa["CJK Symbols and Punctuation"](e) || wa.Katakana(e) || wa["Private Use Area"](e) || wa["CJK Compatibility Forms"](e) || wa["Small Form Variants"](e) || wa["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
				}(e));
			}
			let Na = Da(/* @__PURE__ */ "Adlm.Arab.Armi.Avst.Chrs.Cprt.Egyp.Elym.Gara.Hatr.Hebr.Hung.Khar.Lydi.Mand.Mani.Mend.Merc.Mero.Narb.Nbat.Nkoo.Orkh.Palm.Phli.Phlp.Phnx.Prti.Rohg.Samr.Sarb.Sogo.Syrc.Thaa.Todr.Yezi".split("."));
			function Pa(e) {
				return Na.test(String.fromCodePoint(e));
			}
			function Fa(e, t) {
				return !(!t && Pa(e) || e >= 2304 && e <= 3583 || e >= 3840 && e <= 4255 || wa.Khmer(e));
			}
			function Ia(e) {
				for (let t of e) if (Pa(t.charCodeAt(0))) return !0;
				return !1;
			}
			let La = new class {
				constructor() {
					this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {};
				}
				setState(e) {
					this.pluginStatus = e.pluginStatus, this.pluginURL = e.pluginURL;
				}
				getState() {
					return {
						pluginStatus: this.pluginStatus,
						pluginURL: this.pluginURL
					};
				}
				setMethods(e) {
					if (La.isParsed()) throw Error("RTL text plugin already registered.");
					this.applyArabicShaping = e.applyArabicShaping, this.processBidirectionalText = e.processBidirectionalText, this.processStyledBidirectionalText = e.processStyledBidirectionalText, this.loadScriptResolve();
				}
				isParsed() {
					return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
				}
				getRTLTextPluginStatus() {
					return this.pluginStatus;
				}
				syncState(e, n) {
					return t(this, void 0, void 0, (function* () {
						if (this.isParsed()) return this.getState();
						if (e.pluginStatus !== "loading") return this.setState(e), e;
						let t = e.pluginURL, i = new Promise(((e) => {
							this.loadScriptResolve = e;
						}));
						n(t);
						let a = new Promise(((e) => setTimeout((() => e()), this.TIMEOUT)));
						if (yield Promise.race([i, a]), this.isParsed()) {
							let e = {
								pluginStatus: "loaded",
								pluginURL: t
							};
							return this.setState(e), e;
						}
						throw this.setState({
							pluginStatus: "error",
							pluginURL: ""
						}), /* @__PURE__ */ Error(`RTL Text Plugin failed to import scripts from ${t}`);
					}));
				}
			}();
			class Ra {
				constructor(e, t) {
					this.isSupportedScript = za, this.zoom = e, t ? (this.now = t.now || 0, this.fadeDuration = t.fadeDuration || 0, this.zoomHistory = t.zoomHistory || new Ca(), this.transition = t.transition || {}) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ca(), this.transition = {});
				}
				crossFadingFactor() {
					return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
				}
				getCrossfadeParameters() {
					let e = this.zoom, t = e - Math.floor(e), n = this.crossFadingFactor();
					return e > this.zoomHistory.lastIntegerZoom ? {
						fromScale: 2,
						toScale: 1,
						t: t + (1 - t) * n
					} : {
						fromScale: .5,
						toScale: 1,
						t: 1 - (1 - n) * t
					};
				}
			}
			function za(e) {
				return function(e, t) {
					for (let n of e) if (!Fa(n.charCodeAt(0), t)) return !1;
					return !0;
				}(e, La.getRTLTextPluginStatus() === "loaded");
			}
			class Ba {
				constructor(e, t, n) {
					this.property = e, this.value = t, this.expression = function(e, t, n) {
						if (ii(e)) return new vi(e, t);
						if (pi(e)) {
							let i = _i(e, t, n);
							if (i.result === "error") throw Error(i.value.map(((e) => `${e.key}: ${e.message}`)).join(", "));
							return i.value;
						}
						{
							let n = e;
							return t.type === "color" && typeof e == "string" ? n = Rt.parse(e) : t.type !== "padding" || typeof e != "number" && !Array.isArray(e) ? t.type !== "numberArray" || typeof e != "number" && !Array.isArray(e) ? t.type !== "colorArray" || typeof e != "string" && !Array.isArray(e) ? t.type === "variableAnchorOffsetCollection" && Array.isArray(e) ? n = Jt.parse(e) : t.type === "projectionDefinition" && typeof e == "string" && (n = Xt.parse(e)) : n = Gt.parse(e) : n = Wt.parse(e) : n = Ut.parse(e), {
								globalStateRefs: /* @__PURE__ */ new Set(),
								_globalState: null,
								kind: "constant",
								evaluate: () => n
							};
						}
					}(t === void 0 ? e.specification.default : t, e.specification, n);
				}
				isDataDriven() {
					return this.expression.kind === "source" || this.expression.kind === "composite";
				}
				getGlobalStateRefs() {
					return this.expression.globalStateRefs || /* @__PURE__ */ new Set();
				}
				possiblyEvaluate(e, t, n) {
					return this.property.possiblyEvaluate(this, e, t, n);
				}
			}
			class Va {
				constructor(e, t) {
					this.property = e, this.value = new Ba(e, void 0, t);
				}
				transitioned(e, t) {
					return new Ua(this.property, this.value, t, te({}, e.transition, this.transition), e.now);
				}
				untransitioned() {
					return new Ua(this.property, this.value, null, {}, 0);
				}
			}
			class Ha {
				constructor(e, t) {
					this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._globalState = t;
				}
				getValue(e) {
					return oe(this._values[e].value.value);
				}
				setValue(e, t) {
					Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new Va(this._values[e].property, this._globalState)), this._values[e].value = new Ba(this._values[e].property, t === null ? void 0 : oe(t), this._globalState);
				}
				getTransition(e) {
					return oe(this._values[e].transition);
				}
				setTransition(e, t) {
					Object.prototype.hasOwnProperty.call(this._values, e) || (this._values[e] = new Va(this._values[e].property, this._globalState)), this._values[e].transition = oe(t) || void 0;
				}
				serialize() {
					let e = {};
					for (let t of Object.keys(this._values)) {
						let n = this.getValue(t);
						n !== void 0 && (e[t] = n);
						let i = this.getTransition(t);
						i !== void 0 && (e[`${t}-transition`] = i);
					}
					return e;
				}
				transitioned(e, t) {
					let n = new Wa(this._properties);
					for (let i of Object.keys(this._values)) n._values[i] = this._values[i].transitioned(e, t._values[i]);
					return n;
				}
				untransitioned() {
					let e = new Wa(this._properties);
					for (let t of Object.keys(this._values)) e._values[t] = this._values[t].untransitioned();
					return e;
				}
			}
			class Ua {
				constructor(e, t, n, i, a) {
					this.property = e, this.value = t, this.begin = a + i.delay || 0, this.end = this.begin + i.duration || 0, e.specification.transition && (i.delay || i.duration) && (this.prior = n);
				}
				possiblyEvaluate(e, t, n) {
					let i = e.now || 0, a = this.value.possiblyEvaluate(e, t, n), o = this.prior;
					if (o) {
						if (i > this.end || this.value.isDataDriven()) return this.prior = null, a;
						if (i < this.begin) return o.possiblyEvaluate(e, t, n);
						{
							let s = (i - this.begin) / (this.end - this.begin);
							return this.property.interpolate(o.possiblyEvaluate(e, t, n), a, F(s));
						}
					}
					return a;
				}
			}
			class Wa {
				constructor(e) {
					this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
				}
				possiblyEvaluate(e, t, n) {
					let i = new qa(this._properties);
					for (let a of Object.keys(this._values)) i._values[a] = this._values[a].possiblyEvaluate(e, t, n);
					return i;
				}
				hasTransition() {
					for (let e of Object.keys(this._values)) if (this._values[e].prior) return !0;
					return !1;
				}
			}
			class Ga {
				constructor(e, t) {
					this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._globalState = t;
				}
				hasValue(e) {
					return this._values[e].value !== void 0;
				}
				getValue(e) {
					return oe(this._values[e].value);
				}
				setValue(e, t) {
					this._values[e] = new Ba(this._values[e].property, t === null ? void 0 : oe(t), this._globalState);
				}
				serialize() {
					let e = {};
					for (let t of Object.keys(this._values)) {
						let n = this.getValue(t);
						n !== void 0 && (e[t] = n);
					}
					return e;
				}
				possiblyEvaluate(e, t, n) {
					let i = new qa(this._properties);
					for (let a of Object.keys(this._values)) i._values[a] = this._values[a].possiblyEvaluate(e, t, n);
					return i;
				}
			}
			class Ka {
				constructor(e, t, n) {
					this.property = e, this.value = t, this.parameters = n;
				}
				isConstant() {
					return this.value.kind === "constant";
				}
				constantOr(e) {
					return this.value.kind === "constant" ? this.value.value : e;
				}
				evaluate(e, t, n, i) {
					return this.property.evaluate(this.value, this.parameters, e, t, n, i);
				}
			}
			class qa {
				constructor(e) {
					this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
				}
				get(e) {
					return this._values[e];
				}
			}
			class Y {
				constructor(e) {
					this.specification = e;
				}
				possiblyEvaluate(e, t) {
					if (e.isDataDriven()) throw Error("Value should not be data driven");
					return e.expression.evaluate(t);
				}
				interpolate(e, t, n) {
					let i = Dn[this.specification.type];
					return i ? i(e, t, n) : e;
				}
			}
			class Z {
				constructor(e, t) {
					this.specification = e, this.overrides = t;
				}
				possiblyEvaluate(e, t, n, i) {
					return new Ka(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? {
						kind: "constant",
						value: e.expression.evaluate(t, null, {}, n, i)
					} : e.expression, t);
				}
				interpolate(e, t, n) {
					if (e.value.kind !== "constant" || t.value.kind !== "constant") return e;
					if (e.value.value === void 0 || t.value.value === void 0) return new Ka(this, {
						kind: "constant",
						value: void 0
					}, e.parameters);
					let i = Dn[this.specification.type];
					if (i) {
						let a = i(e.value.value, t.value.value, n);
						return new Ka(this, {
							kind: "constant",
							value: a
						}, e.parameters);
					}
					return e;
				}
				evaluate(e, t, n, i, a, o) {
					return e.kind === "constant" ? e.value : e.evaluate(t, n, i, a, o);
				}
			}
			class Ja extends Z {
				possiblyEvaluate(e, t, n, i) {
					if (e.value === void 0) return new Ka(this, {
						kind: "constant",
						value: void 0
					}, t);
					if (e.expression.kind === "constant") {
						let a = e.expression.evaluate(t, null, {}, n, i), o = e.property.specification.type === "resolvedImage" && typeof a != "string" ? a.name : a, s = this._calculate(o, o, o, t);
						return new Ka(this, {
							kind: "constant",
							value: s
						}, t);
					}
					if (e.expression.kind === "camera") {
						let n = this._calculate(e.expression.evaluate({ zoom: t.zoom - 1 }), e.expression.evaluate({ zoom: t.zoom }), e.expression.evaluate({ zoom: t.zoom + 1 }), t);
						return new Ka(this, {
							kind: "constant",
							value: n
						}, t);
					}
					return new Ka(this, e.expression, t);
				}
				evaluate(e, t, n, i, a, o) {
					if (e.kind === "source") {
						let s = e.evaluate(t, n, i, a, o);
						return this._calculate(s, s, s, t);
					}
					return e.kind === "composite" ? this._calculate(e.evaluate({ zoom: Math.floor(t.zoom) - 1 }, n, i), e.evaluate({ zoom: Math.floor(t.zoom) }, n, i), e.evaluate({ zoom: Math.floor(t.zoom) + 1 }, n, i), t) : e.value;
				}
				_calculate(e, t, n, i) {
					return i.zoom > i.zoomHistory.lastIntegerZoom ? {
						from: e,
						to: t
					} : {
						from: n,
						to: t
					};
				}
				interpolate(e) {
					return e;
				}
			}
			class Ya {
				constructor(e) {
					this.specification = e;
				}
				possiblyEvaluate(e, t, n, i) {
					if (e.value !== void 0) {
						if (e.expression.kind === "constant") {
							let a = e.expression.evaluate(t, null, {}, n, i);
							return this._calculate(a, a, a, t);
						}
						return this._calculate(e.expression.evaluate(new Ra(Math.floor(t.zoom - 1), t)), e.expression.evaluate(new Ra(Math.floor(t.zoom), t)), e.expression.evaluate(new Ra(Math.floor(t.zoom + 1), t)), t);
					}
				}
				_calculate(e, t, n, i) {
					return i.zoom > i.zoomHistory.lastIntegerZoom ? {
						from: e,
						to: t
					} : {
						from: n,
						to: t
					};
				}
				interpolate(e) {
					return e;
				}
			}
			class Xa {
				constructor(e) {
					this.specification = e;
				}
				possiblyEvaluate(e, t, n, i) {
					return !!e.expression.evaluate(t, null, {}, n, i);
				}
				interpolate() {
					return !1;
				}
			}
			class Za {
				constructor(e) {
					for (let t in this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], e) {
						let n = e[t];
						n.specification.overridable && this.overridableProperties.push(t);
						let i = this.defaultPropertyValues[t] = new Ba(n, void 0, void 0), a = this.defaultTransitionablePropertyValues[t] = new Va(n, void 0);
						this.defaultTransitioningPropertyValues[t] = a.untransitioned(), this.defaultPossiblyEvaluatedValues[t] = i.possiblyEvaluate({});
					}
				}
			}
			J("DataDrivenProperty", Z), J("DataConstantProperty", Y), J("CrossFadedDataDrivenProperty", Ja), J("CrossFadedProperty", Ya), J("ColorRampProperty", Xa);
			let Qa = "-transition";
			class $a extends Ne {
				constructor(e, t, n) {
					if (super(), this.id = e.id, this.type = e.type, this._globalState = n, this._featureFilter = {
						filter: () => !0,
						needGeometry: !1,
						getGlobalStateRefs: () => /* @__PURE__ */ new Set()
					}, e.type !== "custom" && (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type !== "background" && (this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter, this._featureFilter = wi(e.filter, n)), t.layout && (this._unevaluatedLayout = new Ga(t.layout, n)), t.paint)) {
						for (let i in this._transitionablePaint = new Ha(t.paint, n), e.paint) this.setPaintProperty(i, e.paint[i], { validate: !1 });
						for (let t in e.layout) this.setLayoutProperty(t, e.layout[t], { validate: !1 });
						this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new qa(t.paint);
					}
				}
				setFilter(e) {
					this.filter = e, this._featureFilter = wi(e, this._globalState);
				}
				getCrossfadeParameters() {
					return this._crossfadeParameters;
				}
				getLayoutProperty(e) {
					return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
				}
				getLayoutAffectingGlobalStateRefs() {
					let e = /* @__PURE__ */ new Set();
					if (this._unevaluatedLayout) for (let t in this._unevaluatedLayout._values) {
						let n = this._unevaluatedLayout._values[t];
						for (let t of n.getGlobalStateRefs()) e.add(t);
					}
					for (let t of this._featureFilter.getGlobalStateRefs()) e.add(t);
					return e;
				}
				getPaintAffectingGlobalStateRefs() {
					let e = new globalThis.Map();
					if (this._transitionablePaint) for (let t in this._transitionablePaint._values) {
						let n = this._transitionablePaint._values[t].value;
						for (let i of n.getGlobalStateRefs()) {
							let a = e.get(i) ?? [];
							a.push({
								name: t,
								value: n.value
							}), e.set(i, a);
						}
					}
					return e;
				}
				setLayoutProperty(e, t, n = {}) {
					t != null && this._validate(ma, `layers.${this.id}.layout.${e}`, e, t, n) || (e === "visibility" ? this.visibility = t : this._unevaluatedLayout.setValue(e, t));
				}
				getPaintProperty(e) {
					return e.endsWith(Qa) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
				}
				setPaintProperty(e, t, n = {}) {
					if (t != null && this._validate(pa, `layers.${this.id}.paint.${e}`, e, t, n)) return !1;
					if (e.endsWith(Qa)) return this._transitionablePaint.setTransition(e.slice(0, -11), t || void 0), !1;
					{
						let n = this._transitionablePaint._values[e], i = n.property.specification["property-type"] === "cross-faded-data-driven", a = n.value.isDataDriven(), o = n.value;
						this._transitionablePaint.setValue(e, t), this._handleSpecialPaintPropertyUpdate(e);
						let s = this._transitionablePaint._values[e].value;
						return s.isDataDriven() || a || i || this._handleOverridablePaintPropertyUpdate(e, o, s);
					}
				}
				_handleSpecialPaintPropertyUpdate(e) {}
				_handleOverridablePaintPropertyUpdate(e, t, n) {
					return !1;
				}
				isHidden(e, t = !1) {
					return !!(this.minzoom && e < (t ? Math.floor(this.minzoom) : this.minzoom)) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
				}
				updateTransitions(e) {
					this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
				}
				hasTransition() {
					return this._transitioningPaint.hasTransition();
				}
				recalculate(e, t) {
					e.getCrossfadeParameters && (this._crossfadeParameters = e.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, t)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, t);
				}
				serialize() {
					let e = {
						id: this.id,
						type: this.type,
						source: this.source,
						"source-layer": this.sourceLayer,
						metadata: this.metadata,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						filter: this.filter,
						layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
						paint: this._transitionablePaint && this._transitionablePaint.serialize()
					};
					return this.visibility && (e.layout = e.layout || {}, e.layout.visibility = this.visibility), ae(e, ((e, t) => !(e === void 0 || t === "layout" && !Object.keys(e).length || t === "paint" && !Object.keys(e).length)));
				}
				_validate(e, t, n, i, a = {}) {
					return (!a || !1 !== a.validate) && ha(this, e.call(ua, {
						key: t,
						layerType: this.type,
						objectKey: n,
						value: i,
						styleSpec: U,
						style: {
							glyphs: !0,
							sprite: !0
						}
					}));
				}
				is3D() {
					return !1;
				}
				isTileClipped() {
					return !1;
				}
				hasOffscreenPass() {
					return !1;
				}
				resize() {}
				isStateDependent() {
					for (let e in this.paint._values) {
						let t = this.paint.get(e);
						if (t instanceof Ka && ei(t.property.specification) && (t.value.kind === "source" || t.value.kind === "composite") && t.value.isStateDependent) return !0;
					}
					return !1;
				}
			}
			let eo;
			var to = { get paint() {
				return eo ||= new Za({
					"raster-opacity": new Y(U.paint_raster["raster-opacity"]),
					"raster-hue-rotate": new Y(U.paint_raster["raster-hue-rotate"]),
					"raster-brightness-min": new Y(U.paint_raster["raster-brightness-min"]),
					"raster-brightness-max": new Y(U.paint_raster["raster-brightness-max"]),
					"raster-saturation": new Y(U.paint_raster["raster-saturation"]),
					"raster-contrast": new Y(U.paint_raster["raster-contrast"]),
					"raster-resampling": new Y(U.paint_raster["raster-resampling"]),
					"raster-fade-duration": new Y(U.paint_raster["raster-fade-duration"])
				});
			} };
			class no extends $a {
				constructor(e, t) {
					super(e, to, t);
				}
			}
			let ro = {
				Int8: Int8Array,
				Uint8: Uint8Array,
				Int16: Int16Array,
				Uint16: Uint16Array,
				Int32: Int32Array,
				Uint32: Uint32Array,
				Float32: Float32Array
			};
			class io {
				constructor(e, t) {
					this._structArray = e, this._pos1 = t * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
				}
			}
			class ao {
				constructor() {
					this.isTransferred = !1, this.capacity = -1, this.resize(0);
				}
				static serialize(e, t) {
					return e._trim(), t && (e.isTransferred = !0, t.push(e.arrayBuffer)), {
						length: e.length,
						arrayBuffer: e.arrayBuffer
					};
				}
				static deserialize(e) {
					let t = Object.create(this.prototype);
					return t.arrayBuffer = e.arrayBuffer, t.length = e.length, t.capacity = e.arrayBuffer.byteLength / t.bytesPerElement, t._refreshViews(), t;
				}
				_trim() {
					this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
				}
				clear() {
					this.length = 0;
				}
				resize(e) {
					this.reserve(e), this.length = e;
				}
				reserve(e) {
					if (e > this.capacity) {
						this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
						let t = this.uint8;
						this._refreshViews(), t && this.uint8.set(t);
					}
				}
				_refreshViews() {
					throw Error("_refreshViews() must be implemented by each concrete StructArray layout");
				}
			}
			function oo(e, t = 1) {
				let n = 0, i = 0;
				return {
					members: e.map(((e) => {
						let a = ro[e.type].BYTES_PER_ELEMENT, o = n = so(n, Math.max(t, a)), s = e.components || 1;
						return i = Math.max(i, a), n += a * s, {
							name: e.name,
							type: e.type,
							components: s,
							offset: o
						};
					})),
					size: so(n, Math.max(i, t)),
					alignment: t
				};
			}
			function so(e, t) {
				return Math.ceil(e / t) * t;
			}
			class co extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(e, t) {
					let n = this.length;
					return this.resize(n + 1), this.emplace(n, e, t);
				}
				emplace(e, t, n) {
					let i = 2 * e;
					return this.int16[i + 0] = t, this.int16[i + 1] = n, e;
				}
			}
			co.prototype.bytesPerElement = 4, J("StructArrayLayout2i4", co);
			class lo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n) {
					let i = this.length;
					return this.resize(i + 1), this.emplace(i, e, t, n);
				}
				emplace(e, t, n, i) {
					let a = 3 * e;
					return this.int16[a + 0] = t, this.int16[a + 1] = n, this.int16[a + 2] = i, e;
				}
			}
			lo.prototype.bytesPerElement = 6, J("StructArrayLayout3i6", lo);
			class uo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i) {
					let a = this.length;
					return this.resize(a + 1), this.emplace(a, e, t, n, i);
				}
				emplace(e, t, n, i, a) {
					let o = 4 * e;
					return this.int16[o + 0] = t, this.int16[o + 1] = n, this.int16[o + 2] = i, this.int16[o + 3] = a, e;
				}
			}
			uo.prototype.bytesPerElement = 8, J("StructArrayLayout4i8", uo);
			class fo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o) {
					let s = this.length;
					return this.resize(s + 1), this.emplace(s, e, t, n, i, a, o);
				}
				emplace(e, t, n, i, a, o, s) {
					let c = 6 * e;
					return this.int16[c + 0] = t, this.int16[c + 1] = n, this.int16[c + 2] = i, this.int16[c + 3] = a, this.int16[c + 4] = o, this.int16[c + 5] = s, e;
				}
			}
			fo.prototype.bytesPerElement = 12, J("StructArrayLayout2i4i12", fo);
			class po extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o) {
					let s = this.length;
					return this.resize(s + 1), this.emplace(s, e, t, n, i, a, o);
				}
				emplace(e, t, n, i, a, o, s) {
					let c = 4 * e, l = 8 * e;
					return this.int16[c + 0] = t, this.int16[c + 1] = n, this.uint8[l + 4] = i, this.uint8[l + 5] = a, this.uint8[l + 6] = o, this.uint8[l + 7] = s, e;
				}
			}
			po.prototype.bytesPerElement = 8, J("StructArrayLayout2i4ub8", po);
			class mo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(e, t) {
					let n = this.length;
					return this.resize(n + 1), this.emplace(n, e, t);
				}
				emplace(e, t, n) {
					let i = 2 * e;
					return this.float32[i + 0] = t, this.float32[i + 1] = n, e;
				}
			}
			mo.prototype.bytesPerElement = 8, J("StructArrayLayout2f8", mo);
			class ho extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o, s, c, l, u) {
					let d = this.length;
					return this.resize(d + 1), this.emplace(d, e, t, n, i, a, o, s, c, l, u);
				}
				emplace(e, t, n, i, a, o, s, c, l, u, d) {
					let f = 10 * e;
					return this.uint16[f + 0] = t, this.uint16[f + 1] = n, this.uint16[f + 2] = i, this.uint16[f + 3] = a, this.uint16[f + 4] = o, this.uint16[f + 5] = s, this.uint16[f + 6] = c, this.uint16[f + 7] = l, this.uint16[f + 8] = u, this.uint16[f + 9] = d, e;
				}
			}
			ho.prototype.bytesPerElement = 20, J("StructArrayLayout10ui20", ho);
			class go extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o, s, c) {
					let l = this.length;
					return this.resize(l + 1), this.emplace(l, e, t, n, i, a, o, s, c);
				}
				emplace(e, t, n, i, a, o, s, c, l) {
					let u = 8 * e;
					return this.uint16[u + 0] = t, this.uint16[u + 1] = n, this.uint16[u + 2] = i, this.uint16[u + 3] = a, this.uint16[u + 4] = o, this.uint16[u + 5] = s, this.uint16[u + 6] = c, this.uint16[u + 7] = l, e;
				}
			}
			go.prototype.bytesPerElement = 16, J("StructArrayLayout8ui16", go);
			class _o extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o, s, c, l, u, d, f) {
					let p = this.length;
					return this.resize(p + 1), this.emplace(p, e, t, n, i, a, o, s, c, l, u, d, f);
				}
				emplace(e, t, n, i, a, o, s, c, l, u, d, f, p) {
					let m = 12 * e;
					return this.int16[m + 0] = t, this.int16[m + 1] = n, this.int16[m + 2] = i, this.int16[m + 3] = a, this.uint16[m + 4] = o, this.uint16[m + 5] = s, this.uint16[m + 6] = c, this.uint16[m + 7] = l, this.int16[m + 8] = u, this.int16[m + 9] = d, this.int16[m + 10] = f, this.int16[m + 11] = p, e;
				}
			}
			_o.prototype.bytesPerElement = 24, J("StructArrayLayout4i4ui4i24", _o);
			class vo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n) {
					let i = this.length;
					return this.resize(i + 1), this.emplace(i, e, t, n);
				}
				emplace(e, t, n, i) {
					let a = 3 * e;
					return this.float32[a + 0] = t, this.float32[a + 1] = n, this.float32[a + 2] = i, e;
				}
			}
			vo.prototype.bytesPerElement = 12, J("StructArrayLayout3f12", vo);
			class yo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
				}
				emplaceBack(e) {
					let t = this.length;
					return this.resize(t + 1), this.emplace(t, e);
				}
				emplace(e, t) {
					return this.uint32[1 * e + 0] = t, e;
				}
			}
			yo.prototype.bytesPerElement = 4, J("StructArrayLayout1ul4", yo);
			class bo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o, s, c, l) {
					let u = this.length;
					return this.resize(u + 1), this.emplace(u, e, t, n, i, a, o, s, c, l);
				}
				emplace(e, t, n, i, a, o, s, c, l, u) {
					let d = 10 * e, f = 5 * e;
					return this.int16[d + 0] = t, this.int16[d + 1] = n, this.int16[d + 2] = i, this.int16[d + 3] = a, this.int16[d + 4] = o, this.int16[d + 5] = s, this.uint32[f + 3] = c, this.uint16[d + 8] = l, this.uint16[d + 9] = u, e;
				}
			}
			bo.prototype.bytesPerElement = 20, J("StructArrayLayout6i1ul2ui20", bo);
			class xo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o) {
					let s = this.length;
					return this.resize(s + 1), this.emplace(s, e, t, n, i, a, o);
				}
				emplace(e, t, n, i, a, o, s) {
					let c = 6 * e;
					return this.int16[c + 0] = t, this.int16[c + 1] = n, this.int16[c + 2] = i, this.int16[c + 3] = a, this.int16[c + 4] = o, this.int16[c + 5] = s, e;
				}
			}
			xo.prototype.bytesPerElement = 12, J("StructArrayLayout2i2i2i12", xo);
			class So extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a) {
					let o = this.length;
					return this.resize(o + 1), this.emplace(o, e, t, n, i, a);
				}
				emplace(e, t, n, i, a, o) {
					let s = 4 * e, c = 8 * e;
					return this.float32[s + 0] = t, this.float32[s + 1] = n, this.float32[s + 2] = i, this.int16[c + 6] = a, this.int16[c + 7] = o, e;
				}
			}
			So.prototype.bytesPerElement = 16, J("StructArrayLayout2f1f2i16", So);
			class Co extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o) {
					let s = this.length;
					return this.resize(s + 1), this.emplace(s, e, t, n, i, a, o);
				}
				emplace(e, t, n, i, a, o, s) {
					let c = 16 * e, l = 4 * e, u = 8 * e;
					return this.uint8[c + 0] = t, this.uint8[c + 1] = n, this.float32[l + 1] = i, this.float32[l + 2] = a, this.int16[u + 6] = o, this.int16[u + 7] = s, e;
				}
			}
			Co.prototype.bytesPerElement = 16, J("StructArrayLayout2ub2f2i16", Co);
			class wo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n) {
					let i = this.length;
					return this.resize(i + 1), this.emplace(i, e, t, n);
				}
				emplace(e, t, n, i) {
					let a = 3 * e;
					return this.uint16[a + 0] = t, this.uint16[a + 1] = n, this.uint16[a + 2] = i, e;
				}
			}
			wo.prototype.bytesPerElement = 6, J("StructArrayLayout3ui6", wo);
			class To extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _) {
					let v = this.length;
					return this.resize(v + 1), this.emplace(v, e, t, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _);
				}
				emplace(e, t, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _, v) {
					let y = 24 * e, b = 12 * e, x = 48 * e;
					return this.int16[y + 0] = t, this.int16[y + 1] = n, this.uint16[y + 2] = i, this.uint16[y + 3] = a, this.uint32[b + 2] = o, this.uint32[b + 3] = s, this.uint32[b + 4] = c, this.uint16[y + 10] = l, this.uint16[y + 11] = u, this.uint16[y + 12] = d, this.float32[b + 7] = f, this.float32[b + 8] = p, this.uint8[x + 36] = m, this.uint8[x + 37] = h, this.uint8[x + 38] = g, this.uint32[b + 10] = _, this.int16[y + 22] = v, e;
				}
			}
			To.prototype.bytesPerElement = 48, J("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", To);
			class Eo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _, v, y, b, x, S, C, w, T, E, O, k) {
					let A = this.length;
					return this.resize(A + 1), this.emplace(A, e, t, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _, v, y, b, x, S, C, w, T, E, O, k);
				}
				emplace(e, t, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _, v, y, b, x, S, C, w, T, E, O, k, A) {
					let j = 32 * e, M = 16 * e;
					return this.int16[j + 0] = t, this.int16[j + 1] = n, this.int16[j + 2] = i, this.int16[j + 3] = a, this.int16[j + 4] = o, this.int16[j + 5] = s, this.int16[j + 6] = c, this.int16[j + 7] = l, this.uint16[j + 8] = u, this.uint16[j + 9] = d, this.uint16[j + 10] = f, this.uint16[j + 11] = p, this.uint16[j + 12] = m, this.uint16[j + 13] = h, this.uint16[j + 14] = g, this.uint16[j + 15] = _, this.uint16[j + 16] = v, this.uint16[j + 17] = y, this.uint16[j + 18] = b, this.uint16[j + 19] = x, this.uint16[j + 20] = S, this.uint16[j + 21] = C, this.uint16[j + 22] = w, this.uint32[M + 12] = T, this.float32[M + 13] = E, this.float32[M + 14] = O, this.uint16[j + 30] = k, this.uint16[j + 31] = A, e;
				}
			}
			Eo.prototype.bytesPerElement = 64, J("StructArrayLayout8i15ui1ul2f2ui64", Eo);
			class Do extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(e) {
					let t = this.length;
					return this.resize(t + 1), this.emplace(t, e);
				}
				emplace(e, t) {
					return this.float32[1 * e + 0] = t, e;
				}
			}
			Do.prototype.bytesPerElement = 4, J("StructArrayLayout1f4", Do);
			class Oo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n) {
					let i = this.length;
					return this.resize(i + 1), this.emplace(i, e, t, n);
				}
				emplace(e, t, n, i) {
					let a = 3 * e;
					return this.uint16[6 * e + 0] = t, this.float32[a + 1] = n, this.float32[a + 2] = i, e;
				}
			}
			Oo.prototype.bytesPerElement = 12, J("StructArrayLayout1ui2f12", Oo);
			class ko extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n) {
					let i = this.length;
					return this.resize(i + 1), this.emplace(i, e, t, n);
				}
				emplace(e, t, n, i) {
					let a = 4 * e;
					return this.uint32[2 * e + 0] = t, this.uint16[a + 2] = n, this.uint16[a + 3] = i, e;
				}
			}
			ko.prototype.bytesPerElement = 8, J("StructArrayLayout1ul2ui8", ko);
			class Ao extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(e, t) {
					let n = this.length;
					return this.resize(n + 1), this.emplace(n, e, t);
				}
				emplace(e, t, n) {
					let i = 2 * e;
					return this.uint16[i + 0] = t, this.uint16[i + 1] = n, e;
				}
			}
			Ao.prototype.bytesPerElement = 4, J("StructArrayLayout2ui4", Ao);
			class jo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
				}
				emplaceBack(e) {
					let t = this.length;
					return this.resize(t + 1), this.emplace(t, e);
				}
				emplace(e, t) {
					return this.uint16[1 * e + 0] = t, e;
				}
			}
			jo.prototype.bytesPerElement = 2, J("StructArrayLayout1ui2", jo);
			class Mo extends ao {
				_refreshViews() {
					this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
				}
				emplaceBack(e, t, n, i) {
					let a = this.length;
					return this.resize(a + 1), this.emplace(a, e, t, n, i);
				}
				emplace(e, t, n, i, a) {
					let o = 4 * e;
					return this.float32[o + 0] = t, this.float32[o + 1] = n, this.float32[o + 2] = i, this.float32[o + 3] = a, e;
				}
			}
			Mo.prototype.bytesPerElement = 16, J("StructArrayLayout4f16", Mo);
			class No extends io {
				get anchorPointX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorPointY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get x1() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get y1() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get x2() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get y2() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get anchorPoint() {
					return new n(this.anchorPointX, this.anchorPointY);
				}
			}
			No.prototype.size = 20;
			class Po extends bo {
				get(e) {
					return new No(this, e);
				}
			}
			J("CollisionBoxArray", Po);
			class Fo extends io {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get glyphStartIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get numGlyphs() {
					return this._structArray.uint16[this._pos2 + 3];
				}
				get vertexStartIndex() {
					return this._structArray.uint32[this._pos4 + 2];
				}
				get lineStartIndex() {
					return this._structArray.uint32[this._pos4 + 3];
				}
				get lineLength() {
					return this._structArray.uint32[this._pos4 + 4];
				}
				get segment() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get lowerSize() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get upperSize() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get lineOffsetX() {
					return this._structArray.float32[this._pos4 + 7];
				}
				get lineOffsetY() {
					return this._structArray.float32[this._pos4 + 8];
				}
				get writingMode() {
					return this._structArray.uint8[this._pos1 + 36];
				}
				get placedOrientation() {
					return this._structArray.uint8[this._pos1 + 37];
				}
				set placedOrientation(e) {
					this._structArray.uint8[this._pos1 + 37] = e;
				}
				get hidden() {
					return this._structArray.uint8[this._pos1 + 38];
				}
				set hidden(e) {
					this._structArray.uint8[this._pos1 + 38] = e;
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 10];
				}
				set crossTileID(e) {
					this._structArray.uint32[this._pos4 + 10] = e;
				}
				get associatedIconIndex() {
					return this._structArray.int16[this._pos2 + 22];
				}
			}
			Fo.prototype.size = 48;
			class Io extends To {
				get(e) {
					return new Fo(this, e);
				}
			}
			J("PlacedSymbolArray", Io);
			class Lo extends io {
				get anchorX() {
					return this._structArray.int16[this._pos2 + 0];
				}
				get anchorY() {
					return this._structArray.int16[this._pos2 + 1];
				}
				get rightJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 2];
				}
				get centerJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 3];
				}
				get leftJustifiedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 4];
				}
				get verticalPlacedTextSymbolIndex() {
					return this._structArray.int16[this._pos2 + 5];
				}
				get placedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 6];
				}
				get verticalPlacedIconSymbolIndex() {
					return this._structArray.int16[this._pos2 + 7];
				}
				get key() {
					return this._structArray.uint16[this._pos2 + 8];
				}
				get textBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 9];
				}
				get textBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 10];
				}
				get verticalTextBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 11];
				}
				get verticalTextBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 12];
				}
				get iconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 13];
				}
				get iconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 14];
				}
				get verticalIconBoxStartIndex() {
					return this._structArray.uint16[this._pos2 + 15];
				}
				get verticalIconBoxEndIndex() {
					return this._structArray.uint16[this._pos2 + 16];
				}
				get featureIndex() {
					return this._structArray.uint16[this._pos2 + 17];
				}
				get numHorizontalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 18];
				}
				get numVerticalGlyphVertices() {
					return this._structArray.uint16[this._pos2 + 19];
				}
				get numIconVertices() {
					return this._structArray.uint16[this._pos2 + 20];
				}
				get numVerticalIconVertices() {
					return this._structArray.uint16[this._pos2 + 21];
				}
				get useRuntimeCollisionCircles() {
					return this._structArray.uint16[this._pos2 + 22];
				}
				get crossTileID() {
					return this._structArray.uint32[this._pos4 + 12];
				}
				set crossTileID(e) {
					this._structArray.uint32[this._pos4 + 12] = e;
				}
				get textBoxScale() {
					return this._structArray.float32[this._pos4 + 13];
				}
				get collisionCircleDiameter() {
					return this._structArray.float32[this._pos4 + 14];
				}
				get textAnchorOffsetStartIndex() {
					return this._structArray.uint16[this._pos2 + 30];
				}
				get textAnchorOffsetEndIndex() {
					return this._structArray.uint16[this._pos2 + 31];
				}
			}
			Lo.prototype.size = 64;
			class Ro extends Eo {
				get(e) {
					return new Lo(this, e);
				}
			}
			J("SymbolInstanceArray", Ro);
			class zo extends Do {
				getoffsetX(e) {
					return this.float32[1 * e + 0];
				}
			}
			J("GlyphOffsetArray", zo);
			class Bo extends lo {
				getx(e) {
					return this.int16[3 * e + 0];
				}
				gety(e) {
					return this.int16[3 * e + 1];
				}
				gettileUnitDistanceFromAnchor(e) {
					return this.int16[3 * e + 2];
				}
			}
			J("SymbolLineVertexArray", Bo);
			class Vo extends io {
				get textAnchor() {
					return this._structArray.uint16[this._pos2 + 0];
				}
				get textOffset0() {
					return this._structArray.float32[this._pos4 + 1];
				}
				get textOffset1() {
					return this._structArray.float32[this._pos4 + 2];
				}
			}
			Vo.prototype.size = 12;
			class Ho extends Oo {
				get(e) {
					return new Vo(this, e);
				}
			}
			J("TextAnchorOffsetArray", Ho);
			class Uo extends io {
				get featureIndex() {
					return this._structArray.uint32[this._pos4 + 0];
				}
				get sourceLayerIndex() {
					return this._structArray.uint16[this._pos2 + 2];
				}
				get bucketIndex() {
					return this._structArray.uint16[this._pos2 + 3];
				}
			}
			Uo.prototype.size = 8;
			class Wo extends ko {
				get(e) {
					return new Uo(this, e);
				}
			}
			J("FeatureIndexArray", Wo);
			class Go extends co {}
			class Ko extends co {}
			class qo extends co {}
			class Jo extends fo {}
			class Yo extends po {}
			class Xo extends mo {}
			class Zo extends ho {}
			class Qo extends go {}
			class $o extends _o {}
			class es extends vo {}
			class ts extends yo {}
			class ns extends xo {}
			class rs extends Co {}
			class os extends wo {}
			class ss extends Ao {}
			let { members: cs } = oo([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			class ls {
				constructor(e = []) {
					this._forceNewSegmentOnNextPrepare = !1, this.segments = e;
				}
				prepareSegment(e, t, n, i) {
					let a = this.segments[this.segments.length - 1];
					return e > ls.MAX_VERTEX_ARRAY_LENGTH && se(`Max vertices per segment is ${ls.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${ls.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !a || a.vertexLength + e > ls.MAX_VERTEX_ARRAY_LENGTH || a.sortKey !== i ? this.createNewSegment(t, n, i) : a;
				}
				createNewSegment(e, t, n) {
					let i = {
						vertexOffset: e.length,
						primitiveOffset: t.length,
						vertexLength: 0,
						primitiveLength: 0,
						vaos: {}
					};
					return n !== void 0 && (i.sortKey = n), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(i), i;
				}
				getOrCreateLatestSegment(e, t, n) {
					return this.prepareSegment(0, e, t, n);
				}
				forceNewSegmentOnNextPrepare() {
					this._forceNewSegmentOnNextPrepare = !0;
				}
				get() {
					return this.segments;
				}
				destroy() {
					for (let e of this.segments) for (let t in e.vaos) e.vaos[t].destroy();
				}
				static simpleSegment(e, t, n, i) {
					return new ls([{
						vertexOffset: e,
						primitiveOffset: t,
						vertexLength: n,
						primitiveLength: i,
						vaos: {},
						sortKey: 0
					}]);
				}
			}
			function us(e, t) {
				return 256 * (e = L(Math.floor(e), 0, 255)) + L(Math.floor(t), 0, 255);
			}
			ls.MAX_VERTEX_ARRAY_LENGTH = 2 ** 16 - 1, J("SegmentVector", ls);
			let ds = oo([
				{
					name: "a_pattern_from",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pattern_to",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_from",
					components: 1,
					type: "Uint16"
				},
				{
					name: "a_pixel_ratio_to",
					components: 1,
					type: "Uint16"
				}
			]), fs = oo([{
				name: "a_dasharray_from",
				components: 4,
				type: "Uint16"
			}, {
				name: "a_dasharray_to",
				components: 4,
				type: "Uint16"
			}]);
			var ps, ms, hs, gs = { exports: {} }, _s = { exports: {} }, vs = { exports: {} }, ys = function() {
				if (hs) return gs.exports;
				hs = 1;
				var e = (ps || (ps = 1, _s.exports = function(e, t) {
					var n, i, a, o, s, c, l, u;
					for (i = e.length - (n = 3 & e.length), a = t, s = 3432918353, c = 461845907, u = 0; u < i;) l = 255 & e.charCodeAt(u) | (255 & e.charCodeAt(++u)) << 8 | (255 & e.charCodeAt(++u)) << 16 | (255 & e.charCodeAt(++u)) << 24, ++u, a = 27492 + (65535 & (o = 5 * (65535 & (a = (a ^= l = (65535 & (l = (l = (65535 & l) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * c + (((l >>> 16) * c & 65535) << 16) & 4294967295) << 13 | a >>> 19)) + ((5 * (a >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (o >>> 16) & 65535) << 16);
					switch (l = 0, n) {
						case 3: l ^= (255 & e.charCodeAt(u + 2)) << 16;
						case 2: l ^= (255 & e.charCodeAt(u + 1)) << 8;
						case 1: a ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & e.charCodeAt(u))) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * c + (((l >>> 16) * c & 65535) << 16) & 4294967295;
					}
					return a ^= e.length, a = 2246822507 * (65535 & (a ^= a >>> 16)) + ((2246822507 * (a >>> 16) & 65535) << 16) & 4294967295, a = 3266489909 * (65535 & (a ^= a >>> 13)) + ((3266489909 * (a >>> 16) & 65535) << 16) & 4294967295, (a ^= a >>> 16) >>> 0;
				}), _s.exports), t = (ms || (ms = 1, vs.exports = function(e, t) {
					for (var n, i = e.length, a = t ^ i, o = 0; i >= 4;) n = 1540483477 * (65535 & (n = 255 & e.charCodeAt(o) | (255 & e.charCodeAt(++o)) << 8 | (255 & e.charCodeAt(++o)) << 16 | (255 & e.charCodeAt(++o)) << 24)) + ((1540483477 * (n >>> 16) & 65535) << 16), a = 1540483477 * (65535 & a) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ (n = 1540483477 * (65535 & (n ^= n >>> 24)) + ((1540483477 * (n >>> 16) & 65535) << 16)), i -= 4, ++o;
					switch (i) {
						case 3: a ^= (255 & e.charCodeAt(o + 2)) << 16;
						case 2: a ^= (255 & e.charCodeAt(o + 1)) << 8;
						case 1: a = 1540483477 * (65535 & (a ^= 255 & e.charCodeAt(o))) + ((1540483477 * (a >>> 16) & 65535) << 16);
					}
					return a = 1540483477 * (65535 & (a ^= a >>> 13)) + ((1540483477 * (a >>> 16) & 65535) << 16), (a ^= a >>> 15) >>> 0;
				}), vs.exports);
				return gs.exports = e, gs.exports.murmur3 = e, gs.exports.murmur2 = t, gs.exports;
			}(), bs = i(ys);
			class xs {
				constructor() {
					this.ids = [], this.positions = [], this.indexed = !1;
				}
				add(e, t, n, i) {
					this.ids.push(Ss(e)), this.positions.push(t, n, i);
				}
				getPositions(e) {
					if (!this.indexed) throw Error("Trying to get index, but feature positions are not indexed");
					let t = Ss(e), n = 0, i = this.ids.length - 1;
					for (; n < i;) {
						let e = n + i >> 1;
						this.ids[e] >= t ? i = e : n = e + 1;
					}
					let a = [];
					for (; this.ids[n] === t;) a.push({
						index: this.positions[3 * n],
						start: this.positions[3 * n + 1],
						end: this.positions[3 * n + 2]
					}), n++;
					return a;
				}
				static serialize(e, t) {
					let n = new Float64Array(e.ids), i = new Uint32Array(e.positions);
					return Cs(n, i, 0, n.length - 1), t && t.push(n.buffer, i.buffer), {
						ids: n,
						positions: i
					};
				}
				static deserialize(e) {
					let t = new xs();
					return t.ids = e.ids, t.positions = e.positions, t.indexed = !0, t;
				}
			}
			function Ss(e) {
				let t = +e;
				return !isNaN(t) && t <= 2 ** 53 - 1 ? t : bs(String(e));
			}
			function Cs(e, t, n, i) {
				for (; n < i;) {
					let a = e[n + i >> 1], o = n - 1, s = i + 1;
					for (;;) {
						do
							o++;
						while (e[o] < a);
						do
							s--;
						while (e[s] > a);
						if (o >= s) break;
						ws(e, o, s), ws(t, 3 * o, 3 * s), ws(t, 3 * o + 1, 3 * s + 1), ws(t, 3 * o + 2, 3 * s + 2);
					}
					s - n < i - s ? (Cs(e, t, n, s), n = s + 1) : (Cs(e, t, s + 1, i), i = s);
				}
			}
			function ws(e, t, n) {
				let i = e[t];
				e[t] = e[n], e[n] = i;
			}
			J("FeaturePositionMap", xs);
			class Ts {
				constructor(e, t) {
					this.gl = e.gl, this.location = t;
				}
			}
			class Es extends Ts {
				constructor(e, t) {
					super(e, t), this.current = 0;
				}
				set(e) {
					this.current !== e && (this.current = e, this.gl.uniform1f(this.location, e));
				}
			}
			class Ds extends Ts {
				constructor(e, t) {
					super(e, t), this.current = [
						0,
						0,
						0,
						0
					];
				}
				set(e) {
					e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] && e[3] === this.current[3] || (this.current = e, this.gl.uniform4f(this.location, e[0], e[1], e[2], e[3]));
				}
			}
			class Os extends Ts {
				constructor(e, t) {
					super(e, t), this.current = Rt.transparent;
				}
				set(e) {
					e.r === this.current.r && e.g === this.current.g && e.b === this.current.b && e.a === this.current.a || (this.current = e, this.gl.uniform4f(this.location, e.r, e.g, e.b, e.a));
				}
			}
			let ks = new Float32Array(16);
			function As(e) {
				return [us(255 * e.r, 255 * e.g), us(255 * e.b, 255 * e.a)];
			}
			class js {
				constructor(e, t, n) {
					this.value = e, this.uniformNames = t.map(((e) => `u_${e}`)), this.type = n;
				}
				setUniform(e, t, n) {
					e.set(n.constantOr(this.value));
				}
				getBinding(e, t, n) {
					return this.type === "color" ? new Os(e, t) : new Es(e, t);
				}
			}
			class Ms {
				constructor(e, t) {
					this.uniformNames = t.map(((e) => `u_${e}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
				}
				setConstantPatternPositions(e, t) {
					this.pixelRatioFrom = t.pixelRatio, this.pixelRatioTo = e.pixelRatio, this.patternFrom = t.tlbr, this.patternTo = e.tlbr;
				}
				setConstantDashPositions(e, t) {
					this.dashTo = [
						0,
						e.y,
						e.height,
						e.width
					], this.dashFrom = [
						0,
						t.y,
						t.height,
						t.width
					];
				}
				setUniform(e, t, n, i) {
					let a = null;
					i === "u_pattern_to" ? a = this.patternTo : i === "u_pattern_from" ? a = this.patternFrom : i === "u_dasharray_to" ? a = this.dashTo : i === "u_dasharray_from" ? a = this.dashFrom : i === "u_pixel_ratio_to" ? a = this.pixelRatioTo : i === "u_pixel_ratio_from" && (a = this.pixelRatioFrom), a !== null && e.set(a);
				}
				getBinding(e, t, n) {
					return n.substr(0, 9) === "u_pattern" || n.substr(0, 12) === "u_dasharray_" ? new Ds(e, t) : new Es(e, t);
				}
			}
			class Ns {
				constructor(e, t, n, i) {
					this.expression = e, this.type = n, this.maxValue = 0, this.paintVertexAttributes = t.map(((e) => ({
						name: `a_${e}`,
						type: "Float32",
						components: n === "color" ? 2 : 1,
						offset: 0
					}))), this.paintVertexArray = new i();
				}
				populatePaintArray(e, t, n) {
					let i = this.paintVertexArray.length, a = this.expression.evaluate(new Ra(0, n), t, {}, n.canonical, [], n.formattedSection);
					this.paintVertexArray.resize(e), this._setPaintValue(i, e, a);
				}
				updatePaintArray(e, t, n, i, a) {
					let o = this.expression.evaluate(new Ra(0, a), n, i);
					this._setPaintValue(e, t, o);
				}
				_setPaintValue(e, t, n) {
					if (this.type === "color") {
						let i = As(n);
						for (let n = e; n < t; n++) this.paintVertexArray.emplace(n, i[0], i[1]);
					} else {
						for (let i = e; i < t; i++) this.paintVertexArray.emplace(i, n);
						this.maxValue = Math.max(this.maxValue, Math.abs(n));
					}
				}
				upload(e) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
			}
			class Ps {
				constructor(e, t, n, i, a, o) {
					this.expression = e, this.uniformNames = t.map(((e) => `u_${e}_t`)), this.type = n, this.useIntegerZoom = i, this.zoom = a, this.maxValue = 0, this.paintVertexAttributes = t.map(((e) => ({
						name: `a_${e}`,
						type: "Float32",
						components: n === "color" ? 4 : 2,
						offset: 0
					}))), this.paintVertexArray = new o();
				}
				populatePaintArray(e, t, n) {
					let i = this.expression.evaluate(new Ra(this.zoom, n), t, {}, n.canonical, [], n.formattedSection), a = this.expression.evaluate(new Ra(this.zoom + 1, n), t, {}, n.canonical, [], n.formattedSection), o = this.paintVertexArray.length;
					this.paintVertexArray.resize(e), this._setPaintValue(o, e, i, a);
				}
				updatePaintArray(e, t, n, i, a) {
					let o = this.expression.evaluate(new Ra(this.zoom, a), n, i), s = this.expression.evaluate(new Ra(this.zoom + 1, a), n, i);
					this._setPaintValue(e, t, o, s);
				}
				_setPaintValue(e, t, n, i) {
					if (this.type === "color") {
						let a = As(n), o = As(i);
						for (let n = e; n < t; n++) this.paintVertexArray.emplace(n, a[0], a[1], o[0], o[1]);
					} else {
						for (let a = e; a < t; a++) this.paintVertexArray.emplace(a, n, i);
						this.maxValue = Math.max(this.maxValue, Math.abs(n), Math.abs(i));
					}
				}
				upload(e) {
					this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
				}
				destroy() {
					this.paintVertexBuffer && this.paintVertexBuffer.destroy();
				}
				setUniform(e, t) {
					let n = this.useIntegerZoom ? Math.floor(t.zoom) : t.zoom, i = L(this.expression.interpolationFactor(n, this.zoom, this.zoom + 1), 0, 1);
					e.set(i);
				}
				getBinding(e, t, n) {
					return new Es(e, t);
				}
			}
			class Fs {
				constructor(e, t, n, i, a, o) {
					this.expression = e, this.type = t, this.useIntegerZoom = n, this.zoom = i, this.layerId = o, this.zoomInPaintVertexArray = new a(), this.zoomOutPaintVertexArray = new a();
				}
				populatePaintArray(e, t, n) {
					let i = this.zoomInPaintVertexArray.length;
					this.zoomInPaintVertexArray.resize(e), this.zoomOutPaintVertexArray.resize(e), this._setPaintValues(i, e, this.getPositionIds(t), n);
				}
				updatePaintArray(e, t, n, i, a) {
					this._setPaintValues(e, t, this.getPositionIds(n), a);
				}
				_setPaintValues(e, t, n, i) {
					let a = this.getPositions(i);
					if (!a || !n) return;
					let o = a[n.min], s = a[n.mid], c = a[n.max];
					if (o && s && c) for (let n = e; n < t; n++) this.emplace(this.zoomInPaintVertexArray, n, s, o), this.emplace(this.zoomOutPaintVertexArray, n, s, c);
				}
				upload(e) {
					if (this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer) {
						let t = this.getVertexAttributes();
						this.zoomInPaintVertexBuffer = e.createVertexBuffer(this.zoomInPaintVertexArray, t, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = e.createVertexBuffer(this.zoomOutPaintVertexArray, t, this.expression.isStateDependent);
					}
				}
				destroy() {
					this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
				}
			}
			class Is extends Fs {
				getPositions(e) {
					return e.imagePositions;
				}
				getPositionIds(e) {
					return e.patterns && e.patterns[this.layerId];
				}
				getVertexAttributes() {
					return ds.members;
				}
				emplace(e, t, n, i) {
					e.emplace(t, n.tlbr[0], n.tlbr[1], n.tlbr[2], n.tlbr[3], i.tlbr[0], i.tlbr[1], i.tlbr[2], i.tlbr[3], n.pixelRatio, i.pixelRatio);
				}
			}
			class Ls extends Fs {
				getPositions(e) {
					return e.dashPositions;
				}
				getPositionIds(e) {
					return e.dashes && e.dashes[this.layerId];
				}
				getVertexAttributes() {
					return fs.members;
				}
				emplace(e, t, n, i) {
					e.emplace(t, 0, n.y, n.height, n.width, 0, i.y, i.height, i.width);
				}
			}
			class Rs {
				constructor(e, t, n) {
					this.binders = {}, this._buffers = [];
					let i = [];
					for (let a in e.paint._values) {
						if (!n(a)) continue;
						let o = e.paint.get(a);
						if (!(o instanceof Ka && ei(o.property.specification))) continue;
						let s = Bs(a, e.type), c = o.value, l = o.property.specification.type, u = o.property.useIntegerZoom, d = o.property.specification["property-type"], f = d === "cross-faded" || d === "cross-faded-data-driven";
						if (c.kind === "constant") this.binders[a] = f ? new Ms(c.value, s) : new js(c.value, s, l), i.push(`/u_${a}`);
						else if (c.kind === "source" || f) {
							let n = Vs(a, l, "source");
							this.binders[a] = f ? a === "line-dasharray" ? new Ls(c, l, u, t, n, e.id) : new Is(c, l, u, t, n, e.id) : new Ns(c, s, l, n), i.push(`/a_${a}`);
						} else {
							let e = Vs(a, l, "composite");
							this.binders[a] = new Ps(c, s, l, u, t, e), i.push(`/z_${a}`);
						}
					}
					this.cacheKey = i.sort().join("");
				}
				getMaxValue(e) {
					let t = this.binders[e];
					return t instanceof Ns || t instanceof Ps ? t.maxValue : 0;
				}
				populatePaintArrays(e, t, n) {
					for (let i in this.binders) {
						let a = this.binders[i];
						(a instanceof Ns || a instanceof Ps || a instanceof Fs) && a.populatePaintArray(e, t, n);
					}
				}
				setConstantPatternPositions(e, t) {
					for (let n in this.binders) {
						let i = this.binders[n];
						i instanceof Ms && i.setConstantPatternPositions(e, t);
					}
				}
				setConstantDashPositions(e, t) {
					for (let n in this.binders) {
						let i = this.binders[n];
						i instanceof Ms && i.setConstantDashPositions(e, t);
					}
				}
				updatePaintArrays(e, t, n, i, a) {
					let o = !1;
					for (let s in e) {
						let c = t.getPositions(s);
						for (let t of c) {
							let c = n.feature(t.index);
							for (let n in this.binders) {
								let l = this.binders[n];
								(l instanceof Ns || l instanceof Ps || l instanceof Fs) && !0 === l.expression.isStateDependent && (l.expression = i.paint.get(n).value, l.updatePaintArray(t.start, t.end, c, e[s], a), o = !0);
							}
						}
					}
					return o;
				}
				defines() {
					let e = [];
					for (let t in this.binders) {
						let n = this.binders[t];
						(n instanceof js || n instanceof Ms) && e.push(...n.uniformNames.map(((e) => `#define HAS_UNIFORM_${e}`)));
					}
					return e;
				}
				getBinderAttributes() {
					let e = [];
					for (let t in this.binders) {
						let n = this.binders[t];
						if (n instanceof Ns || n instanceof Ps) for (let t = 0; t < n.paintVertexAttributes.length; t++) e.push(n.paintVertexAttributes[t].name);
						else if (n instanceof Fs) {
							let t = n.getVertexAttributes();
							for (let n of t) e.push(n.name);
						}
					}
					return e;
				}
				getBinderUniforms() {
					let e = [];
					for (let t in this.binders) {
						let n = this.binders[t];
						if (n instanceof js || n instanceof Ms || n instanceof Ps) for (let t of n.uniformNames) e.push(t);
					}
					return e;
				}
				getPaintVertexBuffers() {
					return this._buffers;
				}
				getUniforms(e, t) {
					let n = [];
					for (let i in this.binders) {
						let a = this.binders[i];
						if (a instanceof js || a instanceof Ms || a instanceof Ps) {
							for (let o of a.uniformNames) if (t[o]) {
								let s = a.getBinding(e, t[o], o);
								n.push({
									name: o,
									property: i,
									binding: s
								});
							}
						}
					}
					return n;
				}
				setUniforms(e, t, n, i) {
					for (let { name: e, property: a, binding: o } of t) this.binders[a].setUniform(o, i, n.get(a), e);
				}
				updatePaintBuffers(e) {
					for (let t in this._buffers = [], this.binders) {
						let n = this.binders[t];
						if (e && n instanceof Fs) {
							let t = e.fromScale === 2 ? n.zoomInPaintVertexBuffer : n.zoomOutPaintVertexBuffer;
							t && this._buffers.push(t);
						} else (n instanceof Ns || n instanceof Ps) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer);
					}
				}
				upload(e) {
					for (let t in this.binders) {
						let n = this.binders[t];
						(n instanceof Ns || n instanceof Ps || n instanceof Fs) && n.upload(e);
					}
					this.updatePaintBuffers();
				}
				destroy() {
					for (let e in this.binders) {
						let t = this.binders[e];
						(t instanceof Ns || t instanceof Ps || t instanceof Fs) && t.destroy();
					}
				}
			}
			class zs {
				constructor(e, t, n = () => !0) {
					this.programConfigurations = {};
					for (let i of e) this.programConfigurations[i.id] = new Rs(i, t, n);
					this.needsUpload = !1, this._featureMap = new xs(), this._bufferOffset = 0;
				}
				populatePaintArrays(e, t, n, i) {
					for (let n in this.programConfigurations) this.programConfigurations[n].populatePaintArrays(e, t, i);
					t.id !== void 0 && this._featureMap.add(t.id, n, this._bufferOffset, e), this._bufferOffset = e, this.needsUpload = !0;
				}
				updatePaintArrays(e, t, n, i) {
					for (let a of n) this.needsUpload = this.programConfigurations[a.id].updatePaintArrays(e, this._featureMap, t, a, i) || this.needsUpload;
				}
				get(e) {
					return this.programConfigurations[e];
				}
				upload(e) {
					if (this.needsUpload) {
						for (let t in this.programConfigurations) this.programConfigurations[t].upload(e);
						this.needsUpload = !1;
					}
				}
				destroy() {
					for (let e in this.programConfigurations) this.programConfigurations[e].destroy();
				}
			}
			function Bs(e, t) {
				return {
					"text-opacity": ["opacity"],
					"icon-opacity": ["opacity"],
					"text-color": ["fill_color"],
					"icon-color": ["fill_color"],
					"text-halo-color": ["halo_color"],
					"icon-halo-color": ["halo_color"],
					"text-halo-blur": ["halo_blur"],
					"icon-halo-blur": ["halo_blur"],
					"text-halo-width": ["halo_width"],
					"icon-halo-width": ["halo_width"],
					"line-gap-width": ["gapwidth"],
					"line-dasharray": ["dasharray_to", "dasharray_from"],
					"line-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					],
					"fill-extrusion-pattern": [
						"pattern_to",
						"pattern_from",
						"pixel_ratio_to",
						"pixel_ratio_from"
					]
				}[e] || [e.replace(`${t}-`, "").replace(/-/g, "_")];
			}
			function Vs(e, t, n) {
				let i = {
					color: {
						source: mo,
						composite: Mo
					},
					number: {
						source: Do,
						composite: mo
					}
				}, a = function(e) {
					return {
						"line-pattern": {
							source: Zo,
							composite: Zo
						},
						"fill-pattern": {
							source: Zo,
							composite: Zo
						},
						"fill-extrusion-pattern": {
							source: Zo,
							composite: Zo
						},
						"line-dasharray": {
							source: Qo,
							composite: Qo
						}
					}[e];
				}(e);
				return a && a[n] || i[t][n];
			}
			J("ConstantBinder", js), J("CrossFadedConstantBinder", Ms), J("SourceExpressionBinder", Ns), J("CrossFadedPatternBinder", Is), J("CrossFadedDasharrayBinder", Ls), J("CompositeExpressionBinder", Ps), J("ProgramConfiguration", Rs, { omit: ["_buffers"] }), J("ProgramConfigurationSet", zs);
			let Hs = 2 ** 14 - 1, Us = -Hs - 1;
			function Ws(e) {
				let t = j / e.extent, n = e.loadGeometry();
				for (let e = 0; e < n.length; e++) {
					let i = n[e];
					for (let e = 0; e < i.length; e++) {
						let n = i[e], a = Math.round(n.x * t), o = Math.round(n.y * t);
						n.x = L(a, Us, Hs), n.y = L(o, Us, Hs), (a < n.x || a > n.x + 1 || o < n.y || o > n.y + 1) && se("Geometry exceeds allowed extent, reduce your vector tile buffer size");
					}
				}
				return n;
			}
			function Gs(e, t) {
				return {
					type: e.type,
					id: e.id,
					properties: e.properties,
					geometry: t ? Ws(e) : []
				};
			}
			let Ks = -32768;
			function qs(e, t, n, i, a) {
				e.emplaceBack(Ks + 8 * t + i, Ks + 8 * n + a);
			}
			class Js {
				constructor(e) {
					this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((e) => e.id)), this.index = e.index, this.hasDependencies = !1, this.layoutVertexArray = new Ko(), this.indexArray = new os(), this.segments = new ls(), this.programConfigurations = new zs(e.layers, e.zoom), this.stateDependentLayerIds = this.layers.filter(((e) => e.isStateDependent())).map(((e) => e.id));
				}
				populate(e, t, n) {
					let i = this.layers[0], a = [], o = null, s = !1, c = i.type === "heatmap";
					if (i.type === "circle") {
						let e = i;
						o = e.layout.get("circle-sort-key"), s = !o.isConstant(), c ||= e.paint.get("circle-pitch-alignment") === "map";
					}
					let l = c ? t.subdivisionGranularity.circle : 1;
					for (let { feature: t, id: i, index: c, sourceLayerIndex: l } of e) {
						let e = this.layers[0]._featureFilter.needGeometry, u = Gs(t, e);
						if (!this.layers[0]._featureFilter.filter(new Ra(this.zoom), u, n)) continue;
						let d = s ? o.evaluate(u, {}, n) : void 0, f = {
							id: i,
							properties: t.properties,
							type: t.type,
							sourceLayerIndex: l,
							index: c,
							geometry: e ? u.geometry : Ws(t),
							patterns: {},
							sortKey: d
						};
						a.push(f);
					}
					s && a.sort(((e, t) => e.sortKey - t.sortKey));
					for (let i of a) {
						let { geometry: a, index: o, sourceLayerIndex: s } = i, c = e[o].feature;
						this.addFeature(i, a, o, n, l), t.featureIndex.insert(c, a, o, s, this.index);
					}
				}
				update(e, t, n) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, { imagePositions: n });
				}
				isEmpty() {
					return this.layoutVertexArray.length === 0;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(e) {
					this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, cs), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				addFeature(e, t, n, i, a = 1) {
					let o;
					switch (a) {
						case 1:
							o = [0, 7];
							break;
						case 3:
							o = [
								0,
								2,
								5,
								7
							];
							break;
						case 5:
							o = [
								0,
								1,
								3,
								4,
								6,
								7
							];
							break;
						case 7:
							o = [
								0,
								1,
								2,
								3,
								4,
								5,
								6,
								7
							];
							break;
						default: throw Error(`Invalid circle bucket granularity: ${a}; valid values are 1, 3, 5, 7.`);
					}
					let s = o.length;
					for (let n of t) for (let t of n) {
						let n = t.x, i = t.y;
						if (n < 0 || n >= j || i < 0 || i >= j) continue;
						let a = this.segments.prepareSegment(s * s, this.layoutVertexArray, this.indexArray, e.sortKey), c = a.vertexLength;
						for (let e = 0; e < s; e++) for (let t = 0; t < s; t++) qs(this.layoutVertexArray, n, i, o[t], o[e]);
						for (let e = 0; e < s - 1; e++) for (let t = 0; t < s - 1; t++) {
							let n = c + e * s + t, i = c + (e + 1) * s + t;
							this.indexArray.emplaceBack(n, i + 1, n + 1), this.indexArray.emplaceBack(n, i, i + 1);
						}
						a.vertexLength += s * s, a.primitiveLength += (s - 1) * (s - 1) * 2;
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, {
						imagePositions: {},
						canonical: i
					});
				}
			}
			function Ys(e, t) {
				for (let n = 0; n < e.length; n++) if (ic(t, e[n])) return !0;
				for (let n = 0; n < t.length; n++) if (ic(e, t[n])) return !0;
				return !!$s(e, t);
			}
			function Xs(e, t, n) {
				return !!ic(e, t) || !!tc(t, e, n);
			}
			function Zs(e, t) {
				if (e.length === 1) return rc(t, e[0]);
				for (let n = 0; n < t.length; n++) {
					let i = t[n];
					for (let t = 0; t < i.length; t++) if (ic(e, i[t])) return !0;
				}
				for (let n = 0; n < e.length; n++) if (rc(t, e[n])) return !0;
				for (let n = 0; n < t.length; n++) if ($s(e, t[n])) return !0;
				return !1;
			}
			function Qs(e, t, n) {
				if (e.length > 1) {
					if ($s(e, t)) return !0;
					for (let i = 0; i < t.length; i++) if (tc(t[i], e, n)) return !0;
				}
				for (let i = 0; i < e.length; i++) if (tc(e[i], t, n)) return !0;
				return !1;
			}
			function $s(e, t) {
				if (e.length === 0 || t.length === 0) return !1;
				for (let n = 0; n < e.length - 1; n++) {
					let i = e[n], a = e[n + 1];
					for (let e = 0; e < t.length - 1; e++) if (ec(i, a, t[e], t[e + 1])) return !0;
				}
				return !1;
			}
			function ec(e, t, n, i) {
				return ce(e, n, i) !== ce(t, n, i) && ce(e, t, n) !== ce(e, t, i);
			}
			function tc(e, t, n) {
				let i = n * n;
				if (t.length === 1) return e.distSqr(t[0]) < i;
				for (let n = 1; n < t.length; n++) if (nc(e, t[n - 1], t[n]) < i) return !0;
				return !1;
			}
			function nc(e, t, n) {
				let i = t.distSqr(n);
				if (i === 0) return e.distSqr(t);
				let a = ((e.x - t.x) * (n.x - t.x) + (e.y - t.y) * (n.y - t.y)) / i;
				return e.distSqr(a < 0 ? t : a > 1 ? n : n.sub(t)._mult(a)._add(t));
			}
			function rc(e, t) {
				let n, i, a, o = !1;
				for (let s = 0; s < e.length; s++) {
					n = e[s];
					for (let e = 0, s = n.length - 1; e < n.length; s = e++) i = n[e], a = n[s], i.y > t.y != a.y > t.y && t.x < (a.x - i.x) * (t.y - i.y) / (a.y - i.y) + i.x && (o = !o);
				}
				return o;
			}
			function ic(e, t) {
				let n = !1;
				for (let i = 0, a = e.length - 1; i < e.length; a = i++) {
					let o = e[i], s = e[a];
					o.y > t.y != s.y > t.y && t.x < (s.x - o.x) * (t.y - o.y) / (s.y - o.y) + o.x && (n = !n);
				}
				return n;
			}
			function ac(e, t, n) {
				let i = n[0], a = n[2];
				if (e.x < i.x && t.x < i.x || e.x > a.x && t.x > a.x || e.y < i.y && t.y < i.y || e.y > a.y && t.y > a.y) return !1;
				let o = ce(e, t, n[0]);
				return o !== ce(e, t, n[1]) || o !== ce(e, t, n[2]) || o !== ce(e, t, n[3]);
			}
			function oc(e, t, n) {
				let i = t.paint.get(e).value;
				return i.kind === "constant" ? i.value : n.programConfigurations.get(t.id).getMaxValue(e);
			}
			function sc(e) {
				return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
			}
			function cc(e, t, i, a, o) {
				if (!t[0] && !t[1]) return e;
				let s = n.convert(t)._mult(o);
				i === "viewport" && s._rotate(-a);
				let c = [];
				for (let t = 0; t < e.length; t++) c.push(e[t].sub(s));
				return c;
			}
			function lc({ queryGeometry: e, size: t }, n) {
				return Xs(e, n, t);
			}
			function uc({ queryGeometry: e, size: t, transform: n, unwrappedTileID: i, getElevation: a }, o) {
				return Xs(e, o, t * (n.projectTileCoordinates(o.x, o.y, i, a).signedDistanceFromCamera / n.cameraToCenterDistance));
			}
			function dc({ queryGeometry: e, size: t, transform: n, unwrappedTileID: i, getElevation: a }, o) {
				let s = n.projectTileCoordinates(o.x, o.y, i, a).signedDistanceFromCamera, c = t * (n.cameraToCenterDistance / s);
				return Xs(e, mc(o, n, i, a), c);
			}
			function fc({ queryGeometry: e, size: t, transform: n, unwrappedTileID: i, getElevation: a }, o) {
				return Xs(e, mc(o, n, i, a), t);
			}
			function pc({ queryGeometry: e, size: t, transform: n, unwrappedTileID: i, getElevation: a, pitchAlignment: o = "map", pitchScale: s = "map" }, c) {
				let l = o === "map" ? s === "map" ? lc : uc : s === "map" ? dc : fc, u = {
					queryGeometry: e,
					size: t,
					transform: n,
					unwrappedTileID: i,
					getElevation: a
				};
				for (let e of c) for (let t of e) if (l(u, t)) return !0;
				return !1;
			}
			function mc(e, t, i, a) {
				let o = t.projectTileCoordinates(e.x, e.y, i, a).point;
				return new n((.5 * o.x + .5) * t.width, (.5 * -o.y + .5) * t.height);
			}
			let hc, gc;
			J("CircleBucket", Js, { omit: ["layers"] });
			var _c = {
				get paint() {
					return gc ||= new Za({
						"circle-radius": new Z(U.paint_circle["circle-radius"]),
						"circle-color": new Z(U.paint_circle["circle-color"]),
						"circle-blur": new Z(U.paint_circle["circle-blur"]),
						"circle-opacity": new Z(U.paint_circle["circle-opacity"]),
						"circle-translate": new Y(U.paint_circle["circle-translate"]),
						"circle-translate-anchor": new Y(U.paint_circle["circle-translate-anchor"]),
						"circle-pitch-scale": new Y(U.paint_circle["circle-pitch-scale"]),
						"circle-pitch-alignment": new Y(U.paint_circle["circle-pitch-alignment"]),
						"circle-stroke-width": new Z(U.paint_circle["circle-stroke-width"]),
						"circle-stroke-color": new Z(U.paint_circle["circle-stroke-color"]),
						"circle-stroke-opacity": new Z(U.paint_circle["circle-stroke-opacity"])
					});
				},
				get layout() {
					return hc ||= new Za({ "circle-sort-key": new Z(U.layout_circle["circle-sort-key"]) });
				}
			};
			class vc extends $a {
				constructor(e, t) {
					super(e, _c, t);
				}
				createBucket(e) {
					return new Js(e);
				}
				queryRadius(e) {
					let t = e;
					return oc("circle-radius", this, t) + oc("circle-stroke-width", this, t) + sc(this.paint.get("circle-translate"));
				}
				queryIntersectsFeature({ queryGeometry: e, feature: t, featureState: n, geometry: i, transform: a, pixelsToTileUnits: o, unwrappedTileID: s, getElevation: c }) {
					let l = cc(e, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -a.bearingInRadians, o), u = this.paint.get("circle-radius").evaluate(t, n) + this.paint.get("circle-stroke-width").evaluate(t, n), d = this.paint.get("circle-pitch-scale"), f = this.paint.get("circle-pitch-alignment"), p, m;
					return f === "map" ? (p = l, m = u * o) : (p = function(e, t, n, i) {
						return e.map(((e) => mc(e, t, n, i)));
					}(l, a, s, c), m = u), pc({
						queryGeometry: p,
						size: m,
						transform: a,
						unwrappedTileID: s,
						getElevation: c,
						pitchAlignment: f,
						pitchScale: d
					}, i);
				}
			}
			class yc extends Js {}
			let bc;
			J("HeatmapBucket", yc, { omit: ["layers"] });
			var xc = { get paint() {
				return bc ||= new Za({
					"heatmap-radius": new Z(U.paint_heatmap["heatmap-radius"]),
					"heatmap-weight": new Z(U.paint_heatmap["heatmap-weight"]),
					"heatmap-intensity": new Y(U.paint_heatmap["heatmap-intensity"]),
					"heatmap-color": new Xa(U.paint_heatmap["heatmap-color"]),
					"heatmap-opacity": new Y(U.paint_heatmap["heatmap-opacity"])
				});
			} };
			function Sc(e, { width: t, height: n }, i, a) {
				if (a) {
					if (a instanceof Uint8ClampedArray) a = new Uint8Array(a.buffer);
					else if (a.length !== t * n * i) throw RangeError(`mismatched image size. expected: ${a.length} but got: ${t * n * i}`);
				} else a = new Uint8Array(t * n * i);
				return e.width = t, e.height = n, e.data = a, e;
			}
			function Cc(e, { width: t, height: n }, i) {
				if (t === e.width && n === e.height) return;
				let a = Sc({}, {
					width: t,
					height: n
				}, i);
				wc(e, a, {
					x: 0,
					y: 0
				}, {
					x: 0,
					y: 0
				}, {
					width: Math.min(e.width, t),
					height: Math.min(e.height, n)
				}, i), e.width = t, e.height = n, e.data = a.data;
			}
			function wc(e, t, n, i, a, o) {
				if (a.width === 0 || a.height === 0) return t;
				if (a.width > e.width || a.height > e.height || n.x > e.width - a.width || n.y > e.height - a.height) throw RangeError("out of range source coordinates for image copy");
				if (a.width > t.width || a.height > t.height || i.x > t.width - a.width || i.y > t.height - a.height) throw RangeError("out of range destination coordinates for image copy");
				let s = e.data, c = t.data;
				if (s === c) throw Error("srcData equals dstData, so image is already copied");
				for (let l = 0; l < a.height; l++) {
					let u = ((n.y + l) * e.width + n.x) * o, d = ((i.y + l) * t.width + i.x) * o;
					for (let e = 0; e < a.width * o; e++) c[d + e] = s[u + e];
				}
				return t;
			}
			class Tc {
				constructor(e, t) {
					Sc(this, e, 1, t);
				}
				resize(e) {
					Cc(this, e, 1);
				}
				clone() {
					return new Tc({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(e, t, n, i, a) {
					wc(e, t, n, i, a, 1);
				}
			}
			class Ec {
				constructor(e, t) {
					Sc(this, e, 4, t);
				}
				resize(e) {
					Cc(this, e, 4);
				}
				replace(e, t) {
					t ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
				}
				clone() {
					return new Ec({
						width: this.width,
						height: this.height
					}, new Uint8Array(this.data));
				}
				static copy(e, t, n, i, a) {
					wc(e, t, n, i, a, 4);
				}
				setPixel(e, t, n) {
					let i = 4 * (e * this.width + t);
					this.data[i + 0] = Math.round(255 * n.r / n.a), this.data[i + 1] = Math.round(255 * n.g / n.a), this.data[i + 2] = Math.round(255 * n.b / n.a), this.data[i + 3] = Math.round(255 * n.a);
				}
			}
			function Dc(e) {
				let t = {}, n = e.resolution || 256, i = e.clips ? e.clips.length : 1, a = e.image || new Ec({
					width: n,
					height: i
				});
				if (Math.log(n) / Math.LN2 % 1 != 0) throw Error(`width is not a power of 2 - ${n}`);
				let o = (i, o, s) => {
					t[e.evaluationKey] = s;
					let c = e.expression.evaluate(t);
					a.setPixel(i / 4 / n, o / 4, c);
				};
				if (e.clips) for (let t = 0, a = 0; t < i; ++t, a += 4 * n) for (let i = 0, s = 0; i < n; i++, s += 4) {
					let c = i / (n - 1), { start: l, end: u } = e.clips[t];
					o(a, s, l * (1 - c) + u * c);
				}
				else for (let e = 0, t = 0; e < n; e++, t += 4) o(0, t, e / (n - 1));
				return a;
			}
			J("AlphaImage", Tc), J("RGBAImage", Ec);
			let Oc = "big-fb";
			class kc extends $a {
				createBucket(e) {
					return new yc(e);
				}
				constructor(e, t) {
					super(e, xc, t), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
				}
				_handleSpecialPaintPropertyUpdate(e) {
					e === "heatmap-color" && this._updateColorRamp();
				}
				_updateColorRamp() {
					this.colorRamp = Dc({
						expression: this._transitionablePaint._values["heatmap-color"].value.expression,
						evaluationKey: "heatmapDensity",
						image: this.colorRamp
					}), this.colorRampTexture = null;
				}
				resize() {
					this.heatmapFbos.has(Oc) && this.heatmapFbos.delete(Oc);
				}
				queryRadius(e) {
					return oc("heatmap-radius", this, e);
				}
				queryIntersectsFeature({ queryGeometry: e, feature: t, featureState: n, geometry: i, transform: a, pixelsToTileUnits: o, unwrappedTileID: s, getElevation: c }) {
					return pc({
						queryGeometry: e,
						size: this.paint.get("heatmap-radius").evaluate(t, n) * o,
						transform: a,
						unwrappedTileID: s,
						getElevation: c
					}, i);
				}
				hasOffscreenPass() {
					return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
				}
			}
			let Ac;
			var jc = { get paint() {
				return Ac ||= new Za({
					"hillshade-illumination-direction": new Y(U.paint_hillshade["hillshade-illumination-direction"]),
					"hillshade-illumination-altitude": new Y(U.paint_hillshade["hillshade-illumination-altitude"]),
					"hillshade-illumination-anchor": new Y(U.paint_hillshade["hillshade-illumination-anchor"]),
					"hillshade-exaggeration": new Y(U.paint_hillshade["hillshade-exaggeration"]),
					"hillshade-shadow-color": new Y(U.paint_hillshade["hillshade-shadow-color"]),
					"hillshade-highlight-color": new Y(U.paint_hillshade["hillshade-highlight-color"]),
					"hillshade-accent-color": new Y(U.paint_hillshade["hillshade-accent-color"]),
					"hillshade-method": new Y(U.paint_hillshade["hillshade-method"])
				});
			} };
			class Mc extends $a {
				constructor(e, t) {
					super(e, jc, t), this.recalculate({
						zoom: 0,
						zoomHistory: {}
					}, void 0);
				}
				getIlluminationProperties() {
					let e = this.paint.get("hillshade-illumination-direction").values, t = this.paint.get("hillshade-illumination-altitude").values, n = this.paint.get("hillshade-highlight-color").values, i = this.paint.get("hillshade-shadow-color").values, a = Math.max(e.length, t.length, n.length, i.length);
					e = e.concat(Array(a - e.length).fill(e.at(-1))), t = t.concat(Array(a - t.length).fill(t.at(-1))), n = n.concat(Array(a - n.length).fill(n.at(-1))), i = i.concat(Array(a - i.length).fill(i.at(-1)));
					let o = t.map(_e);
					return {
						directionRadians: e.map(_e),
						altitudeRadians: o,
						shadowColor: i,
						highlightColor: n
					};
				}
				hasOffscreenPass() {
					return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
				}
			}
			let Nc;
			var Pc = { get paint() {
				return Nc ||= new Za({
					"color-relief-opacity": new Y(U["paint_color-relief"]["color-relief-opacity"]),
					"color-relief-color": new Xa(U["paint_color-relief"]["color-relief-color"])
				});
			} };
			class Fc {
				constructor(e, t, n, i) {
					this.context = e, this.format = n, this.texture = e.gl.createTexture(), this.update(t, i);
				}
				update(e, t, n) {
					let { width: i, height: a } = e, o = !(this.size && this.size[0] === i && this.size[1] === a || n), { context: s } = this, { gl: c } = s;
					if (this.useMipmap = !!(t && t.useMipmap), c.bindTexture(c.TEXTURE_2D, this.texture), s.pixelStoreUnpackFlipY.set(!1), s.pixelStoreUnpack.set(1), s.pixelStoreUnpackPremultiplyAlpha.set(this.format === c.RGBA && (!t || !1 !== t.premultiply)), o) this.size = [i, a], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || fe(e) ? c.texImage2D(c.TEXTURE_2D, 0, this.format, this.format, c.UNSIGNED_BYTE, e) : c.texImage2D(c.TEXTURE_2D, 0, this.format, i, a, 0, this.format, c.UNSIGNED_BYTE, e.data);
					else {
						let { x: t, y: o } = n || {
							x: 0,
							y: 0
						};
						e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || fe(e) ? c.texSubImage2D(c.TEXTURE_2D, 0, t, o, c.RGBA, c.UNSIGNED_BYTE, e) : c.texSubImage2D(c.TEXTURE_2D, 0, t, o, i, a, c.RGBA, c.UNSIGNED_BYTE, e.data);
					}
					this.useMipmap && this.isSizePowerOfTwo() && c.generateMipmap(c.TEXTURE_2D), s.pixelStoreUnpackFlipY.setDefault(), s.pixelStoreUnpack.setDefault(), s.pixelStoreUnpackPremultiplyAlpha.setDefault();
				}
				bind(e, t, n) {
					let { context: i } = this, { gl: a } = i;
					a.bindTexture(a.TEXTURE_2D, this.texture), n !== a.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (n = a.LINEAR), e !== this.filter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, n || e), this.filter = e), t !== this.wrap && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, t), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, t), this.wrap = t);
				}
				isSizePowerOfTwo() {
					return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
				}
				destroy() {
					let { gl: e } = this.context;
					e.deleteTexture(this.texture), this.texture = null;
				}
			}
			class Ic {
				constructor(e, t, n, i = 1, a = 1, o = 1, s = 0) {
					if (this.uid = e, t.height !== t.width) throw RangeError("DEM tiles must be square");
					if (n && ![
						"mapbox",
						"terrarium",
						"custom"
					].includes(n)) return void se(`"${n}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
					this.stride = t.height;
					let c = this.dim = t.height - 2;
					switch (this.data = new Uint32Array(t.data.buffer), n) {
						case "terrarium":
							this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
							break;
						case "custom":
							this.redFactor = i, this.greenFactor = a, this.blueFactor = o, this.baseShift = s;
							break;
						default: this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4;
					}
					for (let e = 0; e < c; e++) this.data[this._idx(-1, e)] = this.data[this._idx(0, e)], this.data[this._idx(c, e)] = this.data[this._idx(c - 1, e)], this.data[this._idx(e, -1)] = this.data[this._idx(e, 0)], this.data[this._idx(e, c)] = this.data[this._idx(e, c - 1)];
					this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(c, -1)] = this.data[this._idx(c - 1, 0)], this.data[this._idx(-1, c)] = this.data[this._idx(0, c - 1)], this.data[this._idx(c, c)] = this.data[this._idx(c - 1, c - 1)], this.min = 2 ** 53 - 1, this.max = -(2 ** 53 - 1);
					for (let e = 0; e < c; e++) for (let t = 0; t < c; t++) {
						let n = this.get(e, t);
						n > this.max && (this.max = n), n < this.min && (this.min = n);
					}
				}
				get(e, t) {
					let n = new Uint8Array(this.data.buffer), i = 4 * this._idx(e, t);
					return this.unpack(n[i], n[i + 1], n[i + 2]);
				}
				getUnpackVector() {
					return [
						this.redFactor,
						this.greenFactor,
						this.blueFactor,
						this.baseShift
					];
				}
				_idx(e, t) {
					if (e < -1 || e >= this.dim + 1 || t < -1 || t >= this.dim + 1) throw RangeError("out of range source coordinates for DEM data");
					return (t + 1) * this.stride + (e + 1);
				}
				unpack(e, t, n) {
					return e * this.redFactor + t * this.greenFactor + n * this.blueFactor - this.baseShift;
				}
				pack(e) {
					return Lc(e, this.getUnpackVector());
				}
				getPixels() {
					return new Ec({
						width: this.stride,
						height: this.stride
					}, new Uint8Array(this.data.buffer));
				}
				backfillBorder(e, t, n) {
					if (this.dim !== e.dim) throw Error("dem dimension mismatch");
					let i = t * this.dim, a = t * this.dim + this.dim, o = n * this.dim, s = n * this.dim + this.dim;
					switch (t) {
						case -1:
							i = a - 1;
							break;
						case 1: a = i + 1;
					}
					switch (n) {
						case -1:
							o = s - 1;
							break;
						case 1: s = o + 1;
					}
					let c = -t * this.dim, l = -n * this.dim;
					for (let t = o; t < s; t++) for (let n = i; n < a; n++) this.data[this._idx(n, t)] = e.data[this._idx(n + c, t + l)];
				}
			}
			function Lc(e, t) {
				let n = t[0], i = t[1], a = t[2], o = t[3], s = Math.min(n, i, a), c = Math.round((e + o) / s);
				return {
					r: Math.floor(c * s / n) % 256,
					g: Math.floor(c * s / i) % 256,
					b: Math.floor(c * s / a) % 256
				};
			}
			J("DEMData", Ic);
			class Rc extends $a {
				constructor(e, t) {
					super(e, Pc, t);
				}
				_createColorRamp(e) {
					let t = {
						elevationStops: [],
						colorStops: []
					}, n = this._transitionablePaint._values["color-relief-color"].value.expression;
					if (n instanceof hi && n._styleExpression.expression instanceof Tn) {
						this.colorRampExpression = n;
						let e = n._styleExpression.expression;
						t.elevationStops = e.labels, t.colorStops = [];
						for (let n of t.elevationStops) t.colorStops.push(e.evaluate({ globals: { elevation: n } }));
					}
					if (t.elevationStops.length < 1 && (t.elevationStops = [0], t.colorStops = [Rt.transparent]), t.elevationStops.length < 2 && (t.elevationStops.push(t.elevationStops[0] + 1), t.colorStops.push(t.colorStops[0])), t.elevationStops.length <= e) return t;
					let i = {
						elevationStops: [],
						colorStops: []
					}, a = (t.elevationStops.length - 1) / (e - 1);
					for (let e = 0; e < t.elevationStops.length - .5; e += a) i.elevationStops.push(t.elevationStops[Math.round(e)]), i.colorStops.push(t.colorStops[Math.round(e)]);
					return se(`Too many colors in specification of ${this.id} color-relief layer, may not render properly.`), i;
				}
				_colorRampChanged() {
					return this.colorRampExpression != this._transitionablePaint._values["color-relief-color"].value.expression;
				}
				getColorRampTextures(e, t, n) {
					if (this.colorRampTextures && !this._colorRampChanged()) return this.colorRampTextures;
					let i = this._createColorRamp(t), a = new Ec({
						width: i.colorStops.length,
						height: 1
					}), o = new Ec({
						width: i.colorStops.length,
						height: 1
					});
					for (let e = 0; e < i.elevationStops.length; e++) {
						let t = Lc(i.elevationStops[e], n);
						o.setPixel(0, e, new Rt(t.r / 255, t.g / 255, t.b / 255, 1)), a.setPixel(0, e, i.colorStops[e]);
					}
					return this.colorRampTextures = {
						elevationTexture: new Fc(e, o, e.gl.RGBA),
						colorTexture: new Fc(e, a, e.gl.RGBA)
					}, this.colorRampTextures;
				}
				hasOffscreenPass() {
					return this.visibility !== "none" && !!this.colorRampTextures;
				}
			}
			let { members: zc } = oo([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}], 4);
			function Bc(e, t, n) {
				let i = n.patternDependencies, a = !1;
				for (let n of t) {
					let t = n.paint.get(`${e}-pattern`);
					t.isConstant() || (a = !0);
					let o = t.constantOr(null);
					o && (a = !0, i[o.to] = !0, i[o.from] = !0);
				}
				return a;
			}
			function Vc(e, t, n, i, a) {
				let { zoom: o } = i, s = a.patternDependencies;
				for (let i of t) {
					let t = i.paint.get(`${e}-pattern`).value;
					if (t.kind !== "constant") {
						let e = t.evaluate({ zoom: o - 1 }, n, {}, a.availableImages), c = t.evaluate({ zoom: o }, n, {}, a.availableImages), l = t.evaluate({ zoom: o + 1 }, n, {}, a.availableImages);
						e = e && e.name ? e.name : e, c = c && c.name ? c.name : c, l = l && l.name ? l.name : l, s[e] = !0, s[c] = !0, s[l] = !0, n.patterns[i.id] = {
							min: e,
							mid: c,
							max: l
						};
					}
				}
				return n;
			}
			function Hc(e, t, n, i, a) {
				let o;
				if (a === function(e, t, n, i) {
					let a = 0;
					for (let o = t, s = n - i; o < n; o += i) a += (e[s] - e[o]) * (e[o + 1] + e[s + 1]), s = o;
					return a;
				}(e, t, n, i) > 0) for (let a = t; a < n; a += i) o = ul(a / i | 0, e[a], e[a + 1], o);
				else for (let a = n - i; a >= t; a -= i) o = ul(a / i | 0, e[a], e[a + 1], o);
				return o && il(o, o.next) && (dl(o), o = o.next), o;
			}
			function Uc(e, t) {
				if (!e) return e;
				t ||= e;
				let n, i = e;
				do
					if (n = !1, i.steiner || !il(i, i.next) && rl(i.prev, i, i.next) !== 0) i = i.next;
					else {
						if (dl(i), i = t = i.prev, i === i.next) break;
						n = !0;
					}
				while (n || i !== t);
				return t;
			}
			function Wc(e, t, n, i, a, o, s) {
				if (!e) return;
				!s && o && function(e, t, n, i) {
					let a = e;
					do
						a.z === 0 && (a.z = Qc(a.x, a.y, t, n, i)), a.prevZ = a.prev, a.nextZ = a.next, a = a.next;
					while (a !== e);
					a.prevZ.nextZ = null, a.prevZ = null, function(e) {
						let t, n = 1;
						do {
							let i, a = e;
							e = null;
							let o = null;
							for (t = 0; a;) {
								t++;
								let s = a, c = 0;
								for (let e = 0; e < n && (c++, s = s.nextZ, s); e++);
								let l = n;
								for (; c > 0 || l > 0 && s;) c !== 0 && (l === 0 || !s || a.z <= s.z) ? (i = a, a = a.nextZ, c--) : (i = s, s = s.nextZ, l--), o ? o.nextZ = i : e = i, i.prevZ = o, o = i;
								a = s;
							}
							o.nextZ = null, n *= 2;
						} while (t > 1);
					}(a);
				}(e, i, a, o);
				let c = e;
				for (; e.prev !== e.next;) {
					let l = e.prev, u = e.next;
					if (o ? Kc(e, i, a, o) : Gc(e)) t.push(l.i, e.i, u.i), dl(e), e = u.next, c = u.next;
					else if ((e = u) === c) {
						s ? s === 1 ? Wc(e = qc(Uc(e), t), t, n, i, a, o, 2) : s === 2 && Jc(e, t, n, i, a, o) : Wc(Uc(e), t, n, i, a, o, 1);
						break;
					}
				}
			}
			function Gc(e) {
				let t = e.prev, n = e, i = e.next;
				if (rl(t, n, i) >= 0) return !1;
				let a = t.x, o = n.x, s = i.x, c = t.y, l = n.y, u = i.y, d = Math.min(a, o, s), f = Math.min(c, l, u), p = Math.max(a, o, s), m = Math.max(c, l, u), h = i.next;
				for (; h !== t;) {
					if (h.x >= d && h.x <= p && h.y >= f && h.y <= m && tl(a, c, o, l, s, u, h.x, h.y) && rl(h.prev, h, h.next) >= 0) return !1;
					h = h.next;
				}
				return !0;
			}
			function Kc(e, t, n, i) {
				let a = e.prev, o = e, s = e.next;
				if (rl(a, o, s) >= 0) return !1;
				let c = a.x, l = o.x, u = s.x, d = a.y, f = o.y, p = s.y, m = Math.min(c, l, u), h = Math.min(d, f, p), g = Math.max(c, l, u), _ = Math.max(d, f, p), v = Qc(m, h, t, n, i), y = Qc(g, _, t, n, i), b = e.prevZ, x = e.nextZ;
				for (; b && b.z >= v && x && x.z <= y;) {
					if (b.x >= m && b.x <= g && b.y >= h && b.y <= _ && b !== a && b !== s && tl(c, d, l, f, u, p, b.x, b.y) && rl(b.prev, b, b.next) >= 0 || (b = b.prevZ, x.x >= m && x.x <= g && x.y >= h && x.y <= _ && x !== a && x !== s && tl(c, d, l, f, u, p, x.x, x.y) && rl(x.prev, x, x.next) >= 0)) return !1;
					x = x.nextZ;
				}
				for (; b && b.z >= v;) {
					if (b.x >= m && b.x <= g && b.y >= h && b.y <= _ && b !== a && b !== s && tl(c, d, l, f, u, p, b.x, b.y) && rl(b.prev, b, b.next) >= 0) return !1;
					b = b.prevZ;
				}
				for (; x && x.z <= y;) {
					if (x.x >= m && x.x <= g && x.y >= h && x.y <= _ && x !== a && x !== s && tl(c, d, l, f, u, p, x.x, x.y) && rl(x.prev, x, x.next) >= 0) return !1;
					x = x.nextZ;
				}
				return !0;
			}
			function qc(e, t) {
				let n = e;
				do {
					let i = n.prev, a = n.next.next;
					!il(i, a) && al(i, n, n.next, a) && cl(i, a) && cl(a, i) && (t.push(i.i, n.i, a.i), dl(n), dl(n.next), n = e = a), n = n.next;
				} while (n !== e);
				return Uc(n);
			}
			function Jc(e, t, n, i, a, o) {
				let s = e;
				do {
					let e = s.next.next;
					for (; e !== s.prev;) {
						if (s.i !== e.i && nl(s, e)) {
							let c = ll(s, e);
							s = Uc(s, s.next), c = Uc(c, c.next), Wc(s, t, n, i, a, o, 0), Wc(c, t, n, i, a, o, 0);
							return;
						}
						e = e.next;
					}
					s = s.next;
				} while (s !== e);
			}
			function Yc(e, t) {
				let n = e.x - t.x;
				return n === 0 && (n = e.y - t.y, n === 0) && (n = (e.next.y - e.y) / (e.next.x - e.x) - (t.next.y - t.y) / (t.next.x - t.x)), n;
			}
			function Xc(e, t) {
				let n = function(e, t) {
					let n = t, i = e.x, a = e.y, o, s = -Infinity;
					if (il(e, n)) return n;
					do {
						if (il(e, n.next)) return n.next;
						if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
							let e = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
							if (e <= i && e > s && (s = e, o = n.x < n.next.x ? n : n.next, e === i)) return o;
						}
						n = n.next;
					} while (n !== t);
					if (!o) return null;
					let c = o, l = o.x, u = o.y, d = Infinity;
					n = o;
					do {
						if (i >= n.x && n.x >= l && i !== n.x && el(a < u ? i : s, a, l, u, a < u ? s : i, a, n.x, n.y)) {
							let t = Math.abs(a - n.y) / (i - n.x);
							cl(n, e) && (t < d || t === d && (n.x > o.x || n.x === o.x && Zc(o, n))) && (o = n, d = t);
						}
						n = n.next;
					} while (n !== c);
					return o;
				}(e, t);
				if (!n) return t;
				let i = ll(n, e);
				return Uc(i, i.next), Uc(n, n.next);
			}
			function Zc(e, t) {
				return rl(e.prev, e, t.prev) < 0 && rl(t.next, e, e.next) < 0;
			}
			function Qc(e, t, n, i, a) {
				return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * a | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * a | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1;
			}
			function $c(e) {
				let t = e, n = e;
				do
					(t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next;
				while (t !== e);
				return n;
			}
			function el(e, t, n, i, a, o, s, c) {
				return (a - s) * (t - c) >= (e - s) * (o - c) && (e - s) * (i - c) >= (n - s) * (t - c) && (n - s) * (o - c) >= (a - s) * (i - c);
			}
			function tl(e, t, n, i, a, o, s, c) {
				return !(e === s && t === c) && el(e, t, n, i, a, o, s, c);
			}
			function nl(e, t) {
				return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
					let n = e;
					do {
						if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && al(n, n.next, e, t)) return !0;
						n = n.next;
					} while (n !== e);
					return !1;
				}(e, t) && (cl(e, t) && cl(t, e) && function(e, t) {
					let n = e, i = !1, a = (e.x + t.x) / 2, o = (e.y + t.y) / 2;
					do
						n.y > o != n.next.y > o && n.next.y !== n.y && a < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
					while (n !== e);
					return i;
				}(e, t) && (rl(e.prev, e, t.prev) || rl(e, t.prev, t)) || il(e, t) && rl(e.prev, e, e.next) > 0 && rl(t.prev, t, t.next) > 0);
			}
			function rl(e, t, n) {
				return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
			}
			function il(e, t) {
				return e.x === t.x && e.y === t.y;
			}
			function al(e, t, n, i) {
				let a = sl(rl(e, t, n)), o = sl(rl(e, t, i)), s = sl(rl(n, i, e)), c = sl(rl(n, i, t));
				return a !== o && s !== c || !(a !== 0 || !ol(e, n, t)) || !(o !== 0 || !ol(e, i, t)) || !(s !== 0 || !ol(n, e, i)) || !(c !== 0 || !ol(n, t, i));
			}
			function ol(e, t, n) {
				return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y);
			}
			function sl(e) {
				return e > 0 ? 1 : e < 0 ? -1 : 0;
			}
			function cl(e, t) {
				return rl(e.prev, e, e.next) < 0 ? rl(e, t, e.next) >= 0 && rl(e, e.prev, t) >= 0 : rl(e, t, e.prev) < 0 || rl(e, e.next, t) < 0;
			}
			function ll(e, t) {
				let n = fl(e.i, e.x, e.y), i = fl(t.i, t.x, t.y), a = e.next, o = t.prev;
				return e.next = t, t.prev = e, n.next = a, a.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i;
			}
			function ul(e, t, n, i) {
				let a = fl(e, t, n);
				return i ? (a.next = i.next, a.prev = i, i.next.prev = a, i.next = a) : (a.prev = a, a.next = a), a;
			}
			function dl(e) {
				e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
			}
			function fl(e, t, n) {
				return {
					i: e,
					x: t,
					y: n,
					prev: null,
					next: null,
					z: 0,
					prevZ: null,
					nextZ: null,
					steiner: !1
				};
			}
			class pl {
				constructor(e, t) {
					if (t > e) throw Error("Min granularity must not be greater than base granularity.");
					this._baseZoomGranularity = e, this._minGranularity = t;
				}
				getGranularityForZoomLevel(e) {
					return Math.max(Math.floor(this._baseZoomGranularity / (1 << e)), this._minGranularity, 1);
				}
			}
			class ml {
				constructor(e) {
					this.fill = e.fill, this.line = e.line, this.tile = e.tile, this.stencil = e.stencil, this.circle = e.circle;
				}
			}
			ml.noSubdivision = new ml({
				fill: new pl(0, 0),
				line: new pl(0, 0),
				tile: new pl(0, 0),
				stencil: new pl(0, 0),
				circle: 1
			}), J("SubdivisionGranularityExpression", pl), J("SubdivisionGranularitySetting", ml);
			let hl = -32768, gl = 32767;
			class _l {
				constructor(e, t) {
					this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = e, this._granularityCellSize = j / e, this._canonical = t;
				}
				_getKey(e, t) {
					return (e += 32768) << 16 | t + 32768;
				}
				_vertexToIndex(e, t) {
					if (e < -32768 || t < -32768 || e > 32767 || t > 32767) throw Error("Vertex coordinates are out of signed 16 bit integer range.");
					let n = 0 | Math.round(e), i = 0 | Math.round(t), a = this._getKey(n, i);
					if (this._vertexDictionary.has(a)) return this._vertexDictionary.get(a);
					let o = this._vertexBuffer.length / 2;
					return this._vertexDictionary.set(a, o), this._vertexBuffer.push(n, i), o;
				}
				_subdivideTrianglesScanline(e) {
					if (this._granularity < 2) return function(e, t) {
						let n = [];
						for (let i = 0; i < t.length; i += 3) {
							let a = t[i], o = t[i + 1], s = t[i + 2], c = e[2 * a], l = e[2 * a + 1];
							(e[2 * o] - c) * (e[2 * s + 1] - l) - (e[2 * o + 1] - l) * (e[2 * s] - c) > 0 ? (n.push(a), n.push(s), n.push(o)) : (n.push(a), n.push(o), n.push(s));
						}
						return n;
					}(this._vertexBuffer, e);
					let t = [], n = e.length;
					for (let i = 0; i < n; i += 3) {
						let n = [
							e[i + 0],
							e[i + 1],
							e[i + 2]
						], a = [
							this._vertexBuffer[2 * e[i + 0] + 0],
							this._vertexBuffer[2 * e[i + 0] + 1],
							this._vertexBuffer[2 * e[i + 1] + 0],
							this._vertexBuffer[2 * e[i + 1] + 1],
							this._vertexBuffer[2 * e[i + 2] + 0],
							this._vertexBuffer[2 * e[i + 2] + 1]
						], o = Infinity, s = Infinity, c = -Infinity, l = -Infinity;
						for (let e = 0; e < 3; e++) {
							let t = a[2 * e], n = a[2 * e + 1];
							o = Math.min(o, t), c = Math.max(c, t), s = Math.min(s, n), l = Math.max(l, n);
						}
						if (o === c || s === l) continue;
						let u = Math.floor(o / this._granularityCellSize), d = Math.ceil(c / this._granularityCellSize), f = Math.floor(s / this._granularityCellSize), p = Math.ceil(l / this._granularityCellSize);
						if (u !== d || f !== p) for (let e = f; e < p; e++) {
							let i = this._scanlineGenerateVertexRingForCellRow(e, a, n);
							bl(this._vertexBuffer, i, t);
						}
						else t.push(...n);
					}
					return t;
				}
				_scanlineGenerateVertexRingForCellRow(e, t, n) {
					let i = e * this._granularityCellSize, a = i + this._granularityCellSize, o = [];
					for (let e = 0; e < 3; e++) {
						let s = t[2 * e], c = t[2 * e + 1], l = t[2 * (e + 1) % 6], u = t[(2 * (e + 1) + 1) % 6], d = t[2 * (e + 2) % 6], f = t[(2 * (e + 2) + 1) % 6], p = l - s, m = u - c, h = p === 0, g = m === 0, _ = (i - c) / m, v = (a - c) / m, y = Math.min(_, v), b = Math.max(_, v);
						if (!g && (y >= 1 || b <= 0) || g && (c < i || c > a)) {
							u >= i && u <= a && o.push(n[(e + 1) % 3]);
							continue;
						}
						!g && y > 0 && o.push(this._vertexToIndex(s + p * y, c + m * y));
						let x = s + p * Math.max(y, 0), S = s + p * Math.min(b, 1);
						h || this._generateIntraEdgeVertices(o, s, c, l, u, x, S), !g && b < 1 && o.push(this._vertexToIndex(s + p * b, c + m * b)), (g || u >= i && u <= a) && o.push(n[(e + 1) % 3]), !g && (u <= i || u >= a) && this._generateInterEdgeVertices(o, s, c, l, u, d, f, S, i, a);
					}
					return o;
				}
				_generateIntraEdgeVertices(e, t, n, i, a, o, s) {
					let c = i - t, l = a - n, u = l === 0, d = u ? Math.min(t, i) : Math.min(o, s), f = u ? Math.max(t, i) : Math.max(o, s), p = Math.floor(d / this._granularityCellSize) + 1, m = Math.ceil(f / this._granularityCellSize) - 1;
					if (u ? t < i : o < s) for (let i = p; i <= m; i++) {
						let a = i * this._granularityCellSize;
						e.push(this._vertexToIndex(a, n + l * (a - t) / c));
					}
					else for (let i = m; i >= p; i--) {
						let a = i * this._granularityCellSize;
						e.push(this._vertexToIndex(a, n + l * (a - t) / c));
					}
				}
				_generateInterEdgeVertices(e, t, n, i, a, o, s, c, l, u) {
					let d = a - n, f = o - i, p = s - a, m = (l - a) / p, h = (u - a) / p, g = Math.min(m, h), _ = Math.max(m, h), v = i + f * g, y = Math.floor(Math.min(v, c) / this._granularityCellSize) + 1, b = Math.ceil(Math.max(v, c) / this._granularityCellSize) - 1, x = c < v, S = p === 0;
					if (S && (s === l || s === u)) return;
					if (S || g >= 1 || _ <= 0) {
						let e = n - s, i = o + (t - o) * Math.min((l - s) / e, (u - s) / e);
						y = Math.floor(Math.min(i, c) / this._granularityCellSize) + 1, b = Math.ceil(Math.max(i, c) / this._granularityCellSize) - 1, x = c < i;
					}
					let C = d > 0 ? u : l;
					if (x) for (let t = y; t <= b; t++) e.push(this._vertexToIndex(t * this._granularityCellSize, C));
					else for (let t = b; t >= y; t--) e.push(this._vertexToIndex(t * this._granularityCellSize, C));
				}
				_generateOutline(e) {
					let t = [];
					for (let n of e) {
						let e = yl(n, this._granularity, !0), i = this._pointArrayToIndices(e), a = [];
						for (let e = 1; e < i.length; e++) a.push(i[e - 1]), a.push(i[e]);
						t.push(a);
					}
					return t;
				}
				_handlePoles(e) {
					let t = !1, n = !1;
					this._canonical && (this._canonical.y === 0 && (t = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (n = !0)), (t || n) && this._fillPoles(e, t, n);
				}
				_ensureNoPoleVertices() {
					let e = this._vertexBuffer;
					for (let t = 0; t < e.length; t += 2) {
						let n = e[t + 1];
						n === hl && (e[t + 1] = -32767), n === gl && (e[t + 1] = 32766);
					}
				}
				_generatePoleQuad(e, t, n, i, a, o) {
					i > a == (o === hl) ? (e.push(n), e.push(t), e.push(this._vertexToIndex(i, o)), e.push(this._vertexToIndex(a, o)), e.push(n), e.push(this._vertexToIndex(i, o))) : (e.push(t), e.push(n), e.push(this._vertexToIndex(i, o)), e.push(n), e.push(this._vertexToIndex(a, o)), e.push(this._vertexToIndex(i, o)));
				}
				_fillPoles(e, t, n) {
					let i = this._vertexBuffer, a = j, o = e.length;
					for (let s = 2; s < o; s += 3) {
						let o = e[s - 2], c = e[s - 1], l = e[s], u = i[2 * o], d = i[2 * o + 1], f = i[2 * c], p = i[2 * c + 1], m = i[2 * l], h = i[2 * l + 1];
						t && (d === 0 && p === 0 && this._generatePoleQuad(e, o, c, u, f, hl), p === 0 && h === 0 && this._generatePoleQuad(e, c, l, f, m, hl), h === 0 && d === 0 && this._generatePoleQuad(e, l, o, m, u, hl)), n && (d === a && p === a && this._generatePoleQuad(e, o, c, u, f, gl), p === a && h === a && this._generatePoleQuad(e, c, l, f, m, gl), h === a && d === a && this._generatePoleQuad(e, l, o, m, u, gl));
					}
				}
				_initializeVertices(e) {
					for (let t = 0; t < e.length; t += 2) this._vertexToIndex(e[t], e[t + 1]);
				}
				subdividePolygonInternal(e, t) {
					if (this._used) throw Error("Subdivision: multiple use not allowed.");
					this._used = !0;
					let { flattened: n, holeIndices: i } = function(e) {
						let t = [], n = [];
						for (let i of e) if (i.length !== 0) {
							i !== e[0] && t.push(n.length / 2);
							for (let e = 0; e < i.length; e++) n.push(i[e].x), n.push(i[e].y);
						}
						return {
							flattened: n,
							holeIndices: t
						};
					}(e), a;
					this._initializeVertices(n);
					try {
						let e = function(e, t, n = 2) {
							let i = t && t.length, a = i ? t[0] * n : e.length, o = Hc(e, 0, a, n, !0), s = [];
							if (!o || o.next === o.prev) return s;
							let c, l, u;
							if (i && (o = function(e, t, n, i) {
								let a = [];
								for (let n = 0, o = t.length; n < o; n++) {
									let s = Hc(e, t[n] * i, n < o - 1 ? t[n + 1] * i : e.length, i, !1);
									s === s.next && (s.steiner = !0), a.push($c(s));
								}
								a.sort(Yc);
								for (let e = 0; e < a.length; e++) n = Xc(a[e], n);
								return n;
							}(e, t, o, n)), e.length > 80 * n) {
								c = e[0], l = e[1];
								let t = c, i = l;
								for (let o = n; o < a; o += n) {
									let n = e[o], a = e[o + 1];
									n < c && (c = n), a < l && (l = a), n > t && (t = n), a > i && (i = a);
								}
								u = Math.max(t - c, i - l), u = u === 0 ? 0 : 32767 / u;
							}
							return Wc(o, s, n, c, l, u, 0), s;
						}(n, i), t = this._convertIndices(n, e);
						a = this._subdivideTrianglesScanline(t);
					} catch (e) {
						console.error(e);
					}
					let o = [];
					return t && (o = this._generateOutline(e)), this._ensureNoPoleVertices(), this._handlePoles(a), {
						verticesFlattened: this._vertexBuffer,
						indicesTriangles: a,
						indicesLineList: o
					};
				}
				_convertIndices(e, t) {
					let n = [];
					for (let i = 0; i < t.length; i++) n.push(this._vertexToIndex(e[2 * t[i]], e[2 * t[i] + 1]));
					return n;
				}
				_pointArrayToIndices(e) {
					let t = [];
					for (let n = 0; n < e.length; n++) {
						let i = e[n];
						t.push(this._vertexToIndex(i.x, i.y));
					}
					return t;
				}
			}
			function vl(e, t, n, i = !0) {
				return new _l(n, t).subdividePolygonInternal(e, i);
			}
			function yl(e, t, i = !1) {
				if (!e || e.length < 1 || e.length < 2) return [];
				let a = e[0], o = e[e.length - 1], s = i && (a.x !== o.x || a.y !== o.y);
				if (t < 2) return s ? [...e, e[0]] : [...e];
				let c = Math.floor(j / t), l = [];
				l.push(new n(e[0].x, e[0].y));
				let u = e.length, d = s ? u : u - 1;
				for (let t = 0; t < d; t++) {
					let i = e[t], a = t < u - 1 ? e[t + 1] : e[0], o = i.x, s = i.y, d = a.x, f = a.y, p = o !== d, m = s !== f;
					if (!p && !m) continue;
					let h = d - o, g = f - s, _ = Math.abs(h), v = Math.abs(g), y = o, b = s;
					for (;;) {
						let e = h > 0 ? (Math.floor(y / c) + 1) * c : (Math.ceil(y / c) - 1) * c, t = g > 0 ? (Math.floor(b / c) + 1) * c : (Math.ceil(b / c) - 1) * c, i = Math.abs(y - e), a = Math.abs(b - t), o = Math.abs(y - d), s = Math.abs(b - f), u = p ? i / _ : Infinity, x = m ? a / v : Infinity;
						if ((o <= i || !p) && (s <= a || !m)) break;
						if (u < x && p || !m) {
							y = e, b += g * u;
							let t = new n(y, Math.round(b));
							l[l.length - 1].x === t.x && l[l.length - 1].y === t.y || l.push(t);
						} else {
							y += h * x, b = t;
							let e = new n(Math.round(y), b);
							l[l.length - 1].x === e.x && l[l.length - 1].y === e.y || l.push(e);
						}
					}
					let x = new n(d, f);
					l[l.length - 1].x === x.x && l[l.length - 1].y === x.y || l.push(x);
				}
				return l;
			}
			function bl(e, t, n) {
				if (t.length === 0) throw Error("Subdivision vertex ring is empty.");
				let i = 0, a = e[2 * t[0]];
				for (let n = 1; n < t.length; n++) {
					let o = e[2 * t[n]];
					o < a && (a = o, i = n);
				}
				let o = t.length, s = i, c = (s + 1) % o;
				for (;;) {
					let i = s - 1 >= 0 ? s - 1 : o - 1, a = (c + 1) % o, l = e[2 * t[i]], u = e[2 * t[a]], d = e[2 * t[s]], f = e[2 * t[s] + 1], p = e[2 * t[c] + 1], m = !1;
					if (l < u) m = !0;
					else if (l > u) m = !1;
					else {
						let n = p - f, o = -(e[2 * t[c]] - d), s = f < p ? 1 : -1;
						((l - d) * n + (e[2 * t[i] + 1] - f) * o) * s > ((u - d) * n + (e[2 * t[a] + 1] - f) * o) * s && (m = !0);
					}
					if (m) {
						let e = t[i], a = t[s], l = t[c];
						e !== a && e !== l && a !== l && n.push(l, a, e), s--, s < 0 && (s = o - 1);
					} else {
						let e = t[a], i = t[s], l = t[c];
						e !== i && e !== l && i !== l && n.push(l, i, e), c++, c >= o && (c = 0);
					}
					if (i === a) break;
				}
			}
			function xl(e, t, n, i, a, o, s, c, l) {
				let u = a.length / 2, d = s && c && l;
				if (u < ls.MAX_VERTEX_ARRAY_LENGTH) {
					let f = t.prepareSegment(u, n, i), p = f.vertexLength;
					for (let e = 0; e < o.length; e += 3) i.emplaceBack(p + o[e], p + o[e + 1], p + o[e + 2]);
					let m, h;
					f.vertexLength += u, f.primitiveLength += o.length / 3, d && (h = s.prepareSegment(u, n, c), m = h.vertexLength, h.vertexLength += u);
					for (let t = 0; t < a.length; t += 2) e(a[t], a[t + 1]);
					if (d) for (let e = 0; e < l.length; e++) {
						let t = l[e];
						for (let e = 1; e < t.length; e += 2) c.emplaceBack(m + t[e - 1], m + t[e]);
						h.primitiveLength += t.length / 2;
					}
				} else (function(e, t, n, i, a, o) {
					let s = [];
					for (let e = 0; e < i.length / 2; e++) s.push(-1);
					let c = { count: 0 }, l = 0, u = e.getOrCreateLatestSegment(t, n), d = u.vertexLength;
					for (let f = 2; f < a.length; f += 3) {
						let p = a[f - 2], m = a[f - 1], h = a[f], g = s[p] < l, _ = s[m] < l, v = s[h] < l;
						u.vertexLength + ((g ? 1 : 0) + (_ ? 1 : 0) + (v ? 1 : 0)) > ls.MAX_VERTEX_ARRAY_LENGTH && (u = e.createNewSegment(t, n), l = c.count, g = !0, _ = !0, v = !0, d = 0);
						let y = Sl(s, i, o, c, p, g, u), b = Sl(s, i, o, c, m, _, u), x = Sl(s, i, o, c, h, v, u);
						n.emplaceBack(d + y - l, d + b - l, d + x - l), u.primitiveLength++;
					}
				})(t, n, i, a, o, e), d && function(e, t, n, i, a, o) {
					let s = [];
					for (let e = 0; e < i.length / 2; e++) s.push(-1);
					let c = { count: 0 }, l = 0, u = e.getOrCreateLatestSegment(t, n), d = u.vertexLength;
					for (let f = 0; f < a.length; f++) {
						let p = a[f];
						for (let m = 1; m < a[f].length; m += 2) {
							let a = p[m - 1], f = p[m], h = s[a] < l, g = s[f] < l;
							u.vertexLength + ((h ? 1 : 0) + (g ? 1 : 0)) > ls.MAX_VERTEX_ARRAY_LENGTH && (u = e.createNewSegment(t, n), l = c.count, h = !0, g = !0, d = 0);
							let _ = Sl(s, i, o, c, a, h, u), v = Sl(s, i, o, c, f, g, u);
							n.emplaceBack(d + _ - l, d + v - l), u.primitiveLength++;
						}
					}
				}(s, n, c, a, l, e), t.forceNewSegmentOnNextPrepare(), s?.forceNewSegmentOnNextPrepare();
			}
			function Sl(e, t, n, i, a, o, s) {
				if (o) {
					let o = i.count;
					return n(t[2 * a], t[2 * a + 1]), e[a] = i.count, i.count++, s.vertexLength++, o;
				}
				return e[a];
			}
			class Cl {
				constructor(e) {
					this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((e) => e.id)), this.index = e.index, this.hasDependencies = !1, this.patternFeatures = [], this.layoutVertexArray = new qo(), this.indexArray = new os(), this.indexArray2 = new ss(), this.programConfigurations = new zs(e.layers, e.zoom), this.segments = new ls(), this.segments2 = new ls(), this.stateDependentLayerIds = this.layers.filter(((e) => e.isStateDependent())).map(((e) => e.id));
				}
				populate(e, t, n) {
					this.hasDependencies = Bc("fill", this.layers, t);
					let i = this.layers[0].layout.get("fill-sort-key"), a = !i.isConstant(), o = [];
					for (let { feature: s, id: c, index: l, sourceLayerIndex: u } of e) {
						let e = this.layers[0]._featureFilter.needGeometry, d = Gs(s, e);
						if (!this.layers[0]._featureFilter.filter(new Ra(this.zoom), d, n)) continue;
						let f = a ? i.evaluate(d, {}, n, t.availableImages) : void 0, p = {
							id: c,
							properties: s.properties,
							type: s.type,
							sourceLayerIndex: u,
							index: l,
							geometry: e ? d.geometry : Ws(s),
							patterns: {},
							sortKey: f
						};
						o.push(p);
					}
					a && o.sort(((e, t) => e.sortKey - t.sortKey));
					for (let i of o) {
						let { geometry: a, index: o, sourceLayerIndex: s } = i;
						if (this.hasDependencies) {
							let e = Vc("fill", this.layers, i, { zoom: this.zoom }, t);
							this.patternFeatures.push(e);
						} else this.addFeature(i, a, o, n, {}, t.subdivisionGranularity);
						t.featureIndex.insert(e[o].feature, a, o, s, this.index);
					}
				}
				update(e, t, n) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, { imagePositions: n });
				}
				addFeatures(e, t, n) {
					for (let i of this.patternFeatures) this.addFeature(i, i.geometry, i.index, t, n, e.subdivisionGranularity);
				}
				isEmpty() {
					return this.layoutVertexArray.length === 0;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(e) {
					this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, zc), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
				}
				addFeature(e, t, n, i, a, o) {
					for (let e of fr(t, 500)) {
						let t = vl(e, i, o.fill.getGranularityForZoomLevel(i.z)), n = this.layoutVertexArray;
						xl(((e, t) => {
							n.emplaceBack(e, t);
						}), this.segments, this.layoutVertexArray, this.indexArray, t.verticesFlattened, t.indicesTriangles, this.segments2, this.indexArray2, t.indicesLineList);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, {
						imagePositions: a,
						canonical: i
					});
				}
			}
			let wl, Tl;
			J("FillBucket", Cl, { omit: ["layers", "patternFeatures"] });
			var El = {
				get paint() {
					return Tl ||= new Za({
						"fill-antialias": new Y(U.paint_fill["fill-antialias"]),
						"fill-opacity": new Z(U.paint_fill["fill-opacity"]),
						"fill-color": new Z(U.paint_fill["fill-color"]),
						"fill-outline-color": new Z(U.paint_fill["fill-outline-color"]),
						"fill-translate": new Y(U.paint_fill["fill-translate"]),
						"fill-translate-anchor": new Y(U.paint_fill["fill-translate-anchor"]),
						"fill-pattern": new Ja(U.paint_fill["fill-pattern"])
					});
				},
				get layout() {
					return wl ||= new Za({ "fill-sort-key": new Z(U.layout_fill["fill-sort-key"]) });
				}
			};
			class Dl extends $a {
				constructor(e, t) {
					super(e, El, t);
				}
				recalculate(e, t) {
					super.recalculate(e, t);
					let n = this.paint._values["fill-outline-color"];
					n.value.kind === "constant" && n.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
				}
				createBucket(e) {
					return new Cl(e);
				}
				queryRadius() {
					return sc(this.paint.get("fill-translate"));
				}
				queryIntersectsFeature({ queryGeometry: e, geometry: t, transform: n, pixelsToTileUnits: i }) {
					return Zs(cc(e, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -n.bearingInRadians, i), t);
				}
				isTileClipped() {
					return !0;
				}
			}
			let Ol = oo([{
				name: "a_pos",
				components: 2,
				type: "Int16"
			}, {
				name: "a_normal_ed",
				components: 4,
				type: "Int16"
			}], 4), kl = oo([{
				name: "a_centroid",
				components: 2,
				type: "Int16"
			}], 4), { members: Al } = Ol;
			class jl {
				constructor(e, t, n, i, a) {
					this.properties = {}, this.extent = n, this.type = 0, this.id = void 0, this._pbf = e, this._geometry = -1, this._keys = i, this._values = a, e.readFields(Ml, this, t);
				}
				loadGeometry() {
					let e = this._pbf;
					e.pos = this._geometry;
					let t = e.readVarint() + e.pos, i = [], a, o = 1, s = 0, c = 0, l = 0;
					for (; e.pos < t;) {
						if (s <= 0) {
							let t = e.readVarint();
							o = 7 & t, s = t >> 3;
						}
						if (s--, o === 1 || o === 2) c += e.readSVarint(), l += e.readSVarint(), o === 1 && (a && i.push(a), a = []), a && a.push(new n(c, l));
						else {
							if (o !== 7) throw Error(`unknown command ${o}`);
							a && a.push(a[0].clone());
						}
					}
					return a && i.push(a), i;
				}
				bbox() {
					let e = this._pbf;
					e.pos = this._geometry;
					let t = e.readVarint() + e.pos, n = 1, i = 0, a = 0, o = 0, s = Infinity, c = -Infinity, l = Infinity, u = -Infinity;
					for (; e.pos < t;) {
						if (i <= 0) {
							let t = e.readVarint();
							n = 7 & t, i = t >> 3;
						}
						if (i--, n === 1 || n === 2) a += e.readSVarint(), o += e.readSVarint(), a < s && (s = a), a > c && (c = a), o < l && (l = o), o > u && (u = o);
						else if (n !== 7) throw Error(`unknown command ${n}`);
					}
					return [
						s,
						l,
						c,
						u
					];
				}
				toGeoJSON(e, t, n) {
					let i = this.extent * 2 ** n, a = this.extent * e, o = this.extent * t, s = this.loadGeometry();
					function c(e) {
						return [360 * (e.x + a) / i - 180, 360 / Math.PI * Math.atan(Math.exp((1 - 2 * (e.y + o) / i) * Math.PI)) - 90];
					}
					function l(e) {
						return e.map(c);
					}
					let u;
					if (this.type === 1) {
						let e = [];
						for (let t of s) e.push(t[0]);
						let t = l(e);
						u = e.length === 1 ? {
							type: "Point",
							coordinates: t[0]
						} : {
							type: "MultiPoint",
							coordinates: t
						};
					} else if (this.type === 2) {
						let e = s.map(l);
						u = e.length === 1 ? {
							type: "LineString",
							coordinates: e[0]
						} : {
							type: "MultiLineString",
							coordinates: e
						};
					} else {
						if (this.type !== 3) throw Error("unknown feature type");
						{
							let e = function(e) {
								let t = e.length;
								if (t <= 1) return [e];
								let n = [], i, a;
								for (let o = 0; o < t; o++) {
									let t = Nl(e[o]);
									t !== 0 && (a === void 0 && (a = t < 0), a === t < 0 ? (i && n.push(i), i = [e[o]]) : i && i.push(e[o]));
								}
								return i && n.push(i), n;
							}(s), t = [];
							for (let n of e) t.push(n.map(l));
							u = t.length === 1 ? {
								type: "Polygon",
								coordinates: t[0]
							} : {
								type: "MultiPolygon",
								coordinates: t
							};
						}
					}
					let d = {
						type: "Feature",
						geometry: u,
						properties: this.properties
					};
					return this.id != null && (d.id = this.id), d;
				}
			}
			function Ml(e, t, n) {
				e === 1 ? t.id = n.readVarint() : e === 2 ? function(e, t) {
					let n = e.readVarint() + e.pos;
					for (; e.pos < n;) {
						let n = t._keys[e.readVarint()], i = t._values[e.readVarint()];
						t.properties[n] = i;
					}
				}(n, t) : e === 3 ? t.type = n.readVarint() : e === 4 && (t._geometry = n.pos);
			}
			function Nl(e) {
				let t = 0;
				for (let n, i, a = 0, o = e.length, s = o - 1; a < o; s = a++) n = e[a], i = e[s], t += (i.x - n.x) * (n.y + i.y);
				return t;
			}
			jl.types = [
				"Unknown",
				"Point",
				"LineString",
				"Polygon"
			];
			class Pl {
				constructor(e, t) {
					this.version = 1, this.name = "", this.extent = 4096, this.length = 0, this._pbf = e, this._keys = [], this._values = [], this._features = [], e.readFields(Fl, this, t), this.length = this._features.length;
				}
				feature(e) {
					if (e < 0 || e >= this._features.length) throw Error("feature index out of bounds");
					this._pbf.pos = this._features[e];
					let t = this._pbf.readVarint() + this._pbf.pos;
					return new jl(this._pbf, t, this.extent, this._keys, this._values);
				}
			}
			function Fl(e, t, n) {
				e === 15 ? t.version = n.readVarint() : e === 1 ? t.name = n.readString() : e === 5 ? t.extent = n.readVarint() : e === 2 ? t._features.push(n.pos) : e === 3 ? t._keys.push(n.readString()) : e === 4 && t._values.push(function(e) {
					let t = null, n = e.readVarint() + e.pos;
					for (; e.pos < n;) {
						let n = e.readVarint() >> 3;
						t = n === 1 ? e.readString() : n === 2 ? e.readFloat() : n === 3 ? e.readDouble() : n === 4 ? e.readVarint64() : n === 5 ? e.readVarint() : n === 6 ? e.readSVarint() : n === 7 ? e.readBoolean() : null;
					}
					if (t == null) throw Error("unknown feature value");
					return t;
				}(n));
			}
			class Il {
				constructor(e, t) {
					this.layers = e.readFields(Ll, {}, t);
				}
			}
			function Ll(e, t, n) {
				if (e === 3) {
					let e = new Pl(n, n.readVarint() + n.pos);
					e.length && (t[e.name] = e);
				}
			}
			let Rl = 2 ** 13;
			function zl(e, t, n, i, a, o, s, c) {
				e.emplaceBack(t, n, 2 * Math.floor(i * Rl) + s, a * Rl * 2, o * Rl * 2, Math.round(c));
			}
			class Bl {
				constructor(e) {
					this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((e) => e.id)), this.index = e.index, this.hasDependencies = !1, this.layoutVertexArray = new Jo(), this.centroidVertexArray = new Go(), this.indexArray = new os(), this.programConfigurations = new zs(e.layers, e.zoom), this.segments = new ls(), this.stateDependentLayerIds = this.layers.filter(((e) => e.isStateDependent())).map(((e) => e.id));
				}
				populate(e, t, n) {
					this.features = [], this.hasDependencies = Bc("fill-extrusion", this.layers, t);
					for (let { feature: i, id: a, index: o, sourceLayerIndex: s } of e) {
						let e = this.layers[0]._featureFilter.needGeometry, c = Gs(i, e);
						if (!this.layers[0]._featureFilter.filter(new Ra(this.zoom), c, n)) continue;
						let l = {
							id: a,
							sourceLayerIndex: s,
							index: o,
							geometry: e ? c.geometry : Ws(i),
							properties: i.properties,
							type: i.type,
							patterns: {}
						};
						this.hasDependencies ? this.features.push(Vc("fill-extrusion", this.layers, l, { zoom: this.zoom }, t)) : this.addFeature(l, l.geometry, o, n, {}, t.subdivisionGranularity), t.featureIndex.insert(i, l.geometry, o, s, this.index, !0);
					}
				}
				addFeatures(e, t, n) {
					for (let i of this.features) {
						let { geometry: a } = i;
						this.addFeature(i, a, i.index, t, n, e.subdivisionGranularity);
					}
				}
				update(e, t, n) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, { imagePositions: n });
				}
				isEmpty() {
					return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(e) {
					this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Al), this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, kl.members, !0), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
				}
				addFeature(e, t, n, i, a, o) {
					for (let n of fr(t, 500)) {
						let t = {
							x: 0,
							y: 0,
							sampleCount: 0
						}, a = this.layoutVertexArray.length;
						this.processPolygon(t, i, e, n, o);
						let s = this.layoutVertexArray.length - a, c = Math.floor(t.x / t.sampleCount), l = Math.floor(t.y / t.sampleCount);
						for (let e = 0; e < s; e++) this.centroidVertexArray.emplaceBack(c, l);
					}
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, {
						imagePositions: a,
						canonical: i
					});
				}
				processPolygon(e, t, n, i, a) {
					if (i.length < 1 || Ul(i[0])) return;
					for (let t of i) t.length !== 0 && Vl(e, t);
					let o = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, s = a.fill.getGranularityForZoomLevel(t.z), c = jl.types[n.type] === "Polygon";
					for (let e of i) {
						if (e.length === 0 || Ul(e)) continue;
						let t = yl(e, s, c);
						this._generateSideFaces(t, o);
					}
					if (!c) return;
					let l = vl(i, t, s, !1), u = this.layoutVertexArray;
					xl(((e, t) => {
						zl(u, e, t, 0, 0, 1, 1, 0);
					}), this.segments, this.layoutVertexArray, this.indexArray, l.verticesFlattened, l.indicesTriangles);
				}
				_generateSideFaces(e, t) {
					let n = 0;
					for (let i = 1; i < e.length; i++) {
						let a = e[i], o = e[i - 1];
						if (Hl(a, o)) continue;
						t.segment.vertexLength + 4 > ls.MAX_VERTEX_ARRAY_LENGTH && (t.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
						let s = a.sub(o)._perp()._unit(), c = o.dist(a);
						n + c > 32768 && (n = 0), zl(this.layoutVertexArray, a.x, a.y, s.x, s.y, 0, 0, n), zl(this.layoutVertexArray, a.x, a.y, s.x, s.y, 0, 1, n), n += c, zl(this.layoutVertexArray, o.x, o.y, s.x, s.y, 0, 0, n), zl(this.layoutVertexArray, o.x, o.y, s.x, s.y, 0, 1, n);
						let l = t.segment.vertexLength;
						this.indexArray.emplaceBack(l, l + 2, l + 1), this.indexArray.emplaceBack(l + 1, l + 2, l + 3), t.segment.vertexLength += 4, t.segment.primitiveLength += 2;
					}
				}
			}
			function Vl(e, t) {
				for (let n = 0; n < t.length; n++) {
					let i = t[n];
					n === t.length - 1 && t[0].x === i.x && t[0].y === i.y || (e.x += i.x, e.y += i.y, e.sampleCount++);
				}
			}
			function Hl(e, t) {
				return e.x === t.x && (e.x < 0 || e.x > j) || e.y === t.y && (e.y < 0 || e.y > j);
			}
			function Ul(e) {
				return e.every(((e) => e.x < 0)) || e.every(((e) => e.x > j)) || e.every(((e) => e.y < 0)) || e.every(((e) => e.y > j));
			}
			let Wl;
			J("FillExtrusionBucket", Bl, { omit: ["layers", "features"] });
			var Gl = { get paint() {
				return Wl ||= new Za({
					"fill-extrusion-opacity": new Y(U["paint_fill-extrusion"]["fill-extrusion-opacity"]),
					"fill-extrusion-color": new Z(U["paint_fill-extrusion"]["fill-extrusion-color"]),
					"fill-extrusion-translate": new Y(U["paint_fill-extrusion"]["fill-extrusion-translate"]),
					"fill-extrusion-translate-anchor": new Y(U["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
					"fill-extrusion-pattern": new Ja(U["paint_fill-extrusion"]["fill-extrusion-pattern"]),
					"fill-extrusion-height": new Z(U["paint_fill-extrusion"]["fill-extrusion-height"]),
					"fill-extrusion-base": new Z(U["paint_fill-extrusion"]["fill-extrusion-base"]),
					"fill-extrusion-vertical-gradient": new Y(U["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
				});
			} };
			class Kl extends $a {
				constructor(e, t) {
					super(e, Gl, t);
				}
				createBucket(e) {
					return new Bl(e);
				}
				queryRadius() {
					return sc(this.paint.get("fill-extrusion-translate"));
				}
				is3D() {
					return !0;
				}
				queryIntersectsFeature({ queryGeometry: e, feature: t, featureState: i, geometry: a, transform: o, pixelsToTileUnits: s, pixelPosMatrix: c }) {
					let l = cc(e, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -o.bearingInRadians, s), u = this.paint.get("fill-extrusion-height").evaluate(t, i), d = this.paint.get("fill-extrusion-base").evaluate(t, i), f = function(e, t) {
						let i = [];
						for (let a of e) {
							let e = [
								a.x,
								a.y,
								0,
								1
							];
							T(e, e, t), i.push(new n(e[0] / e[3], e[1] / e[3]));
						}
						return i;
					}(l, c), p = function(e, t, i, a) {
						let o = [], s = [], c = a[8] * t, l = a[9] * t, u = a[10] * t, d = a[11] * t, f = a[8] * i, p = a[9] * i, m = a[10] * i, h = a[11] * i;
						for (let t of e) {
							let e = [], i = [];
							for (let o of t) {
								let t = o.x, s = o.y, g = a[0] * t + a[4] * s + a[12], _ = a[1] * t + a[5] * s + a[13], v = a[2] * t + a[6] * s + a[14], y = a[3] * t + a[7] * s + a[15], b = v + u, x = y + d, S = g + f, C = _ + p, w = v + m, T = y + h, E = new n((g + c) / x, (_ + l) / x);
								E.z = b / x, e.push(E);
								let O = new n(S / T, C / T);
								O.z = w / T, i.push(O);
							}
							o.push(e), s.push(i);
						}
						return [o, s];
					}(a, d, u, c);
					return function(e, t, n) {
						let i = Infinity;
						Zs(n, t) && (i = Jl(n, t[0]));
						for (let a = 0; a < t.length; a++) {
							let o = t[a], s = e[a];
							for (let e = 0; e < o.length - 1; e++) {
								let t = o[e], a = [
									t,
									o[e + 1],
									s[e + 1],
									s[e],
									t
								];
								Ys(n, a) && (i = Math.min(i, Jl(n, a)));
							}
						}
						return i !== Infinity && i;
					}(p[0], p[1], f);
				}
			}
			function ql(e, t) {
				return e.x * t.x + e.y * t.y;
			}
			function Jl(e, t) {
				if (e.length === 1) {
					let n = 0, i = t[n++], a;
					for (; !a || i.equals(a);) if (a = t[n++], !a) return Infinity;
					for (; n < t.length; n++) {
						let o = t[n], s = e[0], c = a.sub(i), l = o.sub(i), u = s.sub(i), d = ql(c, c), f = ql(c, l), p = ql(l, l), m = ql(u, c), h = ql(u, l), g = d * p - f * f, _ = (p * m - f * h) / g, v = (d * h - f * m) / g, y = i.z * (1 - _ - v) + a.z * _ + o.z * v;
						if (isFinite(y)) return y;
					}
					return Infinity;
				}
				{
					let e = Infinity;
					for (let n of t) e = Math.min(e, n.z);
					return e;
				}
			}
			let { members: Yl } = oo([{
				name: "a_pos_normal",
				components: 2,
				type: "Int16"
			}, {
				name: "a_data",
				components: 4,
				type: "Uint8"
			}], 4), { members: Xl } = oo([{
				name: "a_uv_x",
				components: 1,
				type: "Float32"
			}, {
				name: "a_split_index",
				components: 1,
				type: "Float32"
			}]), Zl = Math.cos(Math.PI / 180 * 37.5), Ql = 2 ** 14 / .5;
			class $l {
				constructor(e) {
					this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map(((e) => e.id)), this.index = e.index, this.hasDependencies = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(((e) => {
						this.gradients[e.id] = {};
					})), this.layoutVertexArray = new Yo(), this.layoutVertexArray2 = new Xo(), this.indexArray = new os(), this.programConfigurations = new zs(e.layers, e.zoom), this.segments = new ls(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(((e) => e.isStateDependent())).map(((e) => e.id));
				}
				populate(e, t, n) {
					this.hasDependencies = Bc("line", this.layers, t) || this.hasLineDasharray(this.layers);
					let i = this.layers[0].layout.get("line-sort-key"), a = !i.isConstant(), o = [];
					for (let { feature: t, id: s, index: c, sourceLayerIndex: l } of e) {
						let e = this.layers[0]._featureFilter.needGeometry, u = Gs(t, e);
						if (!this.layers[0]._featureFilter.filter(new Ra(this.zoom), u, n)) continue;
						let d = a ? i.evaluate(u, {}, n) : void 0, f = {
							id: s,
							properties: t.properties,
							type: t.type,
							sourceLayerIndex: l,
							index: c,
							geometry: e ? u.geometry : Ws(t),
							patterns: {},
							dashes: {},
							sortKey: d
						};
						o.push(f);
					}
					a && o.sort(((e, t) => e.sortKey - t.sortKey));
					for (let i of o) {
						let { geometry: a, index: o, sourceLayerIndex: s } = i;
						this.hasDependencies ? (Bc("line", this.layers, t) ? Vc("line", this.layers, i, { zoom: this.zoom }, t) : this.hasLineDasharray(this.layers) && this.addLineDashDependencies(this.layers, i, this.zoom, t), this.patternFeatures.push(i)) : this.addFeature(i, a, o, n, {}, {}, t.subdivisionGranularity), t.featureIndex.insert(e[o].feature, a, o, s, this.index);
					}
				}
				update(e, t, n, i) {
					this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(e, t, this.stateDependentLayers, {
						imagePositions: n,
						dashPositions: i
					});
				}
				addFeatures(e, t, n, i) {
					for (let a of this.patternFeatures) this.addFeature(a, a.geometry, a.index, t, n, i, e.subdivisionGranularity);
				}
				isEmpty() {
					return this.layoutVertexArray.length === 0;
				}
				uploadPending() {
					return !this.uploaded || this.programConfigurations.needsUpload;
				}
				upload(e) {
					this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, Xl)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Yl), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
				}
				lineFeatureClips(e) {
					if (e.properties && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(e.properties, "mapbox_clip_end")) return {
						start: +e.properties.mapbox_clip_start,
						end: +e.properties.mapbox_clip_end
					};
				}
				addFeature(e, t, n, i, a, o, s) {
					let c = this.layers[0].layout, l = c.get("line-join").evaluate(e, {}), u = c.get("line-cap"), d = c.get("line-miter-limit"), f = c.get("line-round-limit");
					this.lineClips = this.lineFeatureClips(e);
					for (let n of t) this.addLine(n, e, l, u, d, f, i, s);
					this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, n, {
						imagePositions: a,
						dashPositions: o,
						canonical: i
					});
				}
				addLine(e, t, n, i, a, o, s, c) {
					if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, e = yl(e, s ? c.line.getGranularityForZoomLevel(s.z) : 1), this.lineClips) {
						this.lineClipsArray.push(this.lineClips);
						for (let t = 0; t < e.length - 1; t++) this.totalDistance += e[t].dist(e[t + 1]);
						this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
					}
					let l = jl.types[t.type] === "Polygon", u = e.length;
					for (; u >= 2 && e[u - 1].equals(e[u - 2]);) u--;
					let d = 0;
					for (; d < u - 1 && e[d].equals(e[d + 1]);) d++;
					if (u < (l ? 3 : 2)) return;
					n === "bevel" && (a = 1.05);
					let f = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, p = this.segments.prepareSegment(10 * u, this.layoutVertexArray, this.indexArray), m, h, g, _, v;
					this.e1 = this.e2 = -1, l && (m = e[u - 2], v = e[d].sub(m)._unit()._perp());
					for (let t = d; t < u; t++) {
						if (g = t === u - 1 ? l ? e[d + 1] : void 0 : e[t + 1], g && e[t].equals(g)) continue;
						v && (_ = v), m && (h = m), m = e[t], v = g ? g.sub(m)._unit()._perp() : _, _ ||= v;
						let s = _.add(v);
						s.x === 0 && s.y === 0 || s._unit();
						let c = _.x * v.x + _.y * v.y, y = s.x * v.x + s.y * v.y, b = y === 0 ? Infinity : 1 / y, x = 2 * Math.sqrt(2 - 2 * y), S = y < Zl && h && g, C = _.x * v.y - _.y * v.x > 0;
						if (S && t > d) {
							let e = m.dist(h);
							if (e > 2 * f) {
								let t = m.sub(m.sub(h)._mult(f / e)._round());
								this.updateDistance(h, t), this.addCurrentVertex(t, _, 0, 0, p), h = t;
							}
						}
						let w = h && g, T = w ? n : l ? "butt" : i;
						if (w && T === "round" && (b < o ? T = "miter" : b <= 2 && (T = "fakeround")), T === "miter" && b > a && (T = "bevel"), T === "bevel" && (b > 2 && (T = "flipbevel"), b < a && (T = "miter")), h && this.updateDistance(h, m), T === "miter") s._mult(b), this.addCurrentVertex(m, s, 0, 0, p);
						else if (T === "flipbevel") {
							if (b > 100) s = v.mult(-1);
							else {
								let e = b * _.add(v).mag() / _.sub(v).mag();
								s._perp()._mult(e * (C ? -1 : 1));
							}
							this.addCurrentVertex(m, s, 0, 0, p), this.addCurrentVertex(m, s.mult(-1), 0, 0, p);
						} else if (T === "bevel" || T === "fakeround") {
							let e = -Math.sqrt(b * b - 1), t = C ? e : 0, n = C ? 0 : e;
							if (h && this.addCurrentVertex(m, _, t, n, p), T === "fakeround") {
								let e = Math.round(180 * x / Math.PI / 20);
								for (let t = 1; t < e; t++) {
									let n = t / e;
									if (n !== .5) {
										let e = n - .5;
										n += n * e * (n - 1) * ((1.0904 + c * (c * (3.55645 - 1.43519 * c) - 3.2452)) * e * e + (.848013 + c * (.215638 * c - 1.06021)));
									}
									let i = v.sub(_)._mult(n)._add(_)._unit()._mult(C ? -1 : 1);
									this.addHalfVertex(m, i.x, i.y, !1, C, 0, p);
								}
							}
							g && this.addCurrentVertex(m, v, -t, -n, p);
						} else if (T === "butt") this.addCurrentVertex(m, s, 0, 0, p);
						else if (T === "square") {
							let e = h ? 1 : -1;
							this.addCurrentVertex(m, s, e, e, p);
						} else T === "round" && (h && (this.addCurrentVertex(m, _, 0, 0, p), this.addCurrentVertex(m, _, 1, 1, p, !0)), g && (this.addCurrentVertex(m, v, -1, -1, p, !0), this.addCurrentVertex(m, v, 0, 0, p)));
						if (S && t < u - 1) {
							let e = m.dist(g);
							if (e > 2 * f) {
								let t = m.add(g.sub(m)._mult(f / e)._round());
								this.updateDistance(m, t), this.addCurrentVertex(t, v, 0, 0, p), m = t;
							}
						}
					}
				}
				addCurrentVertex(e, t, n, i, a, o = !1) {
					let s = t.y * i - t.x, c = -t.y - t.x * i;
					this.addHalfVertex(e, t.x + t.y * n, t.y - t.x * n, o, !1, n, a), this.addHalfVertex(e, s, c, o, !0, -i, a), this.distance > Ql / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(e, t, n, i, a, o));
				}
				addHalfVertex({ x: e, y: t }, n, i, a, o, s, c) {
					let l = .5 * (this.lineClips ? this.scaledDistance * (Ql - 1) : this.scaledDistance);
					this.layoutVertexArray.emplaceBack((e << 1) + (a ? 1 : 0), (t << 1) + (o ? 1 : 0), Math.round(63 * n) + 128, Math.round(63 * i) + 128, 1 + (s === 0 ? 0 : s < 0 ? -1 : 1) | (63 & l) << 2, l >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
					let u = c.vertexLength++;
					this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u, this.e2), c.primitiveLength++), o ? this.e2 = u : this.e1 = u;
				}
				updateScaledDistance() {
					this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
				}
				updateDistance(e, t) {
					this.distance += e.dist(t), this.updateScaledDistance();
				}
				hasLineDasharray(e) {
					for (let t of e) {
						let e = t.paint.get("line-dasharray");
						if (e && !e.isConstant()) return !0;
					}
					return !1;
				}
				addLineDashDependencies(e, t, n, i) {
					for (let a of e) {
						let e = a.paint.get("line-dasharray");
						if (!e || e.value.kind === "constant") continue;
						let o = a.layout.get("line-cap") === "round", s = {
							dasharray: e.value.evaluate({ zoom: n - 1 }, t, {}),
							round: o
						}, c = {
							dasharray: e.value.evaluate({ zoom: n }, t, {}),
							round: o
						}, l = {
							dasharray: e.value.evaluate({ zoom: n + 1 }, t, {}),
							round: o
						}, u = `${s.dasharray.join(",")},${s.round}`, d = `${c.dasharray.join(",")},${c.round}`, f = `${l.dasharray.join(",")},${l.round}`;
						i.dashDependencies[u] = s, i.dashDependencies[d] = c, i.dashDependencies[f] = l, t.dashes[a.id] = {
							min: u,
							mid: d,
							max: f
						};
					}
				}
			}
			let eu, tu;
			J("LineBucket", $l, { omit: ["layers", "patternFeatures"] });
			var nu = {
				get paint() {
					return tu ||= new Za({
						"line-opacity": new Z(U.paint_line["line-opacity"]),
						"line-color": new Z(U.paint_line["line-color"]),
						"line-translate": new Y(U.paint_line["line-translate"]),
						"line-translate-anchor": new Y(U.paint_line["line-translate-anchor"]),
						"line-width": new Z(U.paint_line["line-width"]),
						"line-gap-width": new Z(U.paint_line["line-gap-width"]),
						"line-offset": new Z(U.paint_line["line-offset"]),
						"line-blur": new Z(U.paint_line["line-blur"]),
						"line-dasharray": new Ja(U.paint_line["line-dasharray"]),
						"line-pattern": new Ja(U.paint_line["line-pattern"]),
						"line-gradient": new Xa(U.paint_line["line-gradient"])
					});
				},
				get layout() {
					return eu ||= new Za({
						"line-cap": new Y(U.layout_line["line-cap"]),
						"line-join": new Z(U.layout_line["line-join"]),
						"line-miter-limit": new Y(U.layout_line["line-miter-limit"]),
						"line-round-limit": new Y(U.layout_line["line-round-limit"]),
						"line-sort-key": new Z(U.layout_line["line-sort-key"])
					});
				}
			};
			class ru extends Z {
				possiblyEvaluate(e, t) {
					return t = new Ra(Math.floor(t.zoom), {
						now: t.now,
						fadeDuration: t.fadeDuration,
						zoomHistory: t.zoomHistory,
						transition: t.transition
					}), super.possiblyEvaluate(e, t);
				}
				evaluate(e, t, n, i) {
					return t = te({}, t, { zoom: Math.floor(t.zoom) }), super.evaluate(e, t, n, i);
				}
			}
			let iu;
			class au extends $a {
				constructor(e, t) {
					super(e, nu, t), this.gradientVersion = 0, iu || (iu = new ru(nu.paint.properties["line-width"].specification), iu.useIntegerZoom = !0);
				}
				_handleSpecialPaintPropertyUpdate(e) {
					if (e === "line-gradient") {
						let e = this.gradientExpression();
						this.stepInterpolant = !!function(e) {
							return e._styleExpression !== void 0;
						}(e) && e._styleExpression.expression instanceof yn, this.gradientVersion = (this.gradientVersion + 1) % (2 ** 53 - 1);
					}
				}
				gradientExpression() {
					return this._transitionablePaint._values["line-gradient"].value.expression;
				}
				recalculate(e, t) {
					super.recalculate(e, t), this.paint._values["line-floorwidth"] = iu.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e);
				}
				createBucket(e) {
					return new $l(e);
				}
				queryRadius(e) {
					let t = e, n = ou(oc("line-width", this, t), oc("line-gap-width", this, t)), i = oc("line-offset", this, t);
					return n / 2 + Math.abs(i) + sc(this.paint.get("line-translate"));
				}
				queryIntersectsFeature({ queryGeometry: e, feature: t, featureState: i, geometry: a, transform: o, pixelsToTileUnits: s }) {
					let c = cc(e, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -o.bearingInRadians, s), l = s / 2 * ou(this.paint.get("line-width").evaluate(t, i), this.paint.get("line-gap-width").evaluate(t, i)), u = this.paint.get("line-offset").evaluate(t, i);
					return u && (a = function(e, t) {
						let i = [];
						for (let a = 0; a < e.length; a++) {
							let o = e[a], s = [];
							for (let e = 0; e < o.length; e++) {
								let i = o[e - 1], a = o[e], c = o[e + 1], l = e === 0 ? new n(0, 0) : a.sub(i)._unit()._perp(), u = e === o.length - 1 ? new n(0, 0) : c.sub(a)._unit()._perp(), d = l._add(u)._unit(), f = d.x * u.x + d.y * u.y;
								f !== 0 && d._mult(1 / f), s.push(d._mult(t)._add(a));
							}
							i.push(s);
						}
						return i;
					}(a, u * s)), function(e, t, n) {
						for (let i = 0; i < t.length; i++) {
							let a = t[i];
							if (e.length >= 3) {
								for (let t = 0; t < a.length; t++) if (ic(e, a[t])) return !0;
							}
							if (Qs(e, a, n)) return !0;
						}
						return !1;
					}(c, a, l);
				}
				isTileClipped() {
					return !0;
				}
			}
			function ou(e, t) {
				return t > 0 ? t + 2 * e : e;
			}
			let su = oo([
				{
					name: "a_pos_offset",
					components: 4,
					type: "Int16"
				},
				{
					name: "a_data",
					components: 4,
					type: "Uint16"
				},
				{
					name: "a_pixeloffset",
					components: 4,
					type: "Int16"
				}
			], 4), cu = oo([{
				name: "a_projected_pos",
				components: 3,
				type: "Float32"
			}], 4);
			oo([{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint32"
			}], 4);
			let lu = oo([
				{
					name: "a_placed",
					components: 2,
					type: "Uint8"
				},
				{
					name: "a_shift",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_box_real",
					components: 2,
					type: "Int16"
				}
			]);
			oo([
				{
					type: "Int16",
					name: "anchorPointX"
				},
				{
					type: "Int16",
					name: "anchorPointY"
				},
				{
					type: "Int16",
					name: "x1"
				},
				{
					type: "Int16",
					name: "y1"
				},
				{
					type: "Int16",
					name: "x2"
				},
				{
					type: "Int16",
					name: "y2"
				},
				{
					type: "Uint32",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "sourceLayerIndex"
				},
				{
					type: "Uint16",
					name: "bucketIndex"
				}
			]);
			let uu = oo([
				{
					name: "a_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_anchor_pos",
					components: 2,
					type: "Int16"
				},
				{
					name: "a_extrude",
					components: 2,
					type: "Int16"
				}
			], 4), du = oo([
				{
					name: "a_pos",
					components: 2,
					type: "Float32"
				},
				{
					name: "a_radius",
					components: 1,
					type: "Float32"
				},
				{
					name: "a_flags",
					components: 2,
					type: "Int16"
				}
			], 4);
			function fu(e, t, n) {
				return e.sections.forEach(((e) => {
					e.text = function(e, t, n) {
						let i = t.layout.get("text-transform").evaluate(n, {});
						return i === "uppercase" ? e = e.toLocaleUpperCase() : i === "lowercase" && (e = e.toLocaleLowerCase()), La.applyArabicShaping && (e = La.applyArabicShaping(e)), e;
					}(e.text, t, n);
				})), e;
			}
			oo([{
				name: "triangle",
				components: 3,
				type: "Uint16"
			}]), oo([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Uint16",
					name: "glyphStartIndex"
				},
				{
					type: "Uint16",
					name: "numGlyphs"
				},
				{
					type: "Uint32",
					name: "vertexStartIndex"
				},
				{
					type: "Uint32",
					name: "lineStartIndex"
				},
				{
					type: "Uint32",
					name: "lineLength"
				},
				{
					type: "Uint16",
					name: "segment"
				},
				{
					type: "Uint16",
					name: "lowerSize"
				},
				{
					type: "Uint16",
					name: "upperSize"
				},
				{
					type: "Float32",
					name: "lineOffsetX"
				},
				{
					type: "Float32",
					name: "lineOffsetY"
				},
				{
					type: "Uint8",
					name: "writingMode"
				},
				{
					type: "Uint8",
					name: "placedOrientation"
				},
				{
					type: "Uint8",
					name: "hidden"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Int16",
					name: "associatedIconIndex"
				}
			]), oo([
				{
					type: "Int16",
					name: "anchorX"
				},
				{
					type: "Int16",
					name: "anchorY"
				},
				{
					type: "Int16",
					name: "rightJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "centerJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "leftJustifiedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedTextSymbolIndex"
				},
				{
					type: "Int16",
					name: "placedIconSymbolIndex"
				},
				{
					type: "Int16",
					name: "verticalPlacedIconSymbolIndex"
				},
				{
					type: "Uint16",
					name: "key"
				},
				{
					type: "Uint16",
					name: "textBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "textBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalTextBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "iconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxStartIndex"
				},
				{
					type: "Uint16",
					name: "verticalIconBoxEndIndex"
				},
				{
					type: "Uint16",
					name: "featureIndex"
				},
				{
					type: "Uint16",
					name: "numHorizontalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalGlyphVertices"
				},
				{
					type: "Uint16",
					name: "numIconVertices"
				},
				{
					type: "Uint16",
					name: "numVerticalIconVertices"
				},
				{
					type: "Uint16",
					name: "useRuntimeCollisionCircles"
				},
				{
					type: "Uint32",
					name: "crossTileID"
				},
				{
					type: "Float32",
					name: "textBoxScale"
				},
				{
					type: "Float32",
					name: "collisionCircleDiameter"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetStartIndex"
				},
				{
					type: "Uint16",
					name: "textAnchorOffsetEndIndex"
				}
			]), oo([{
				type: "Float32",
				name: "offsetX"
			}]), oo([
				{
					type: "Int16",
					name: "x"
				},
				{
					type: "Int16",
					name: "y"
				},
				{
					type: "Int16",
					name: "tileUnitDistanceFromAnchor"
				}
			]), oo([{
				type: "Uint16",
				name: "textAnchor"
			}, {
				type: "Float32",
				components: 2,
				name: "textOffset"
			}]);
			let pu = {
				"!": "",
				"#": "",
				$: "",
				"%": "",
				"&": "",
				"(": "",
				")": "",
				"*": "",
				"+": "",
				",": "",
				"-": "",
				".": "",
				"/": "",
				":": "",
				";": "",
				"<": "",
				"=": "",
				">": "",
				"?": "",
				"@": "",
				"[": "",
				"\\": "",
				"]": "",
				"^": "",
				_: "",
				"`": "",
				"{": "",
				"|": "",
				"}": "",
				"~": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": "",
				"": ""
			};
			var mu = 24;
			let hu = 4294967296, gu = 1 / hu, _u = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
			class vu {
				constructor(e = new Uint8Array(16)) {
					this.buf = ArrayBuffer.isView(e) ? e : new Uint8Array(e), this.dataView = new DataView(this.buf.buffer), this.pos = 0, this.type = 0, this.length = this.buf.length;
				}
				readFields(e, t, n = this.length) {
					for (; this.pos < n;) {
						let n = this.readVarint(), i = n >> 3, a = this.pos;
						this.type = 7 & n, e(i, t, this), this.pos === a && this.skip(n);
					}
					return t;
				}
				readMessage(e, t) {
					return this.readFields(e, t, this.readVarint() + this.pos);
				}
				readFixed32() {
					let e = this.dataView.getUint32(this.pos, !0);
					return this.pos += 4, e;
				}
				readSFixed32() {
					let e = this.dataView.getInt32(this.pos, !0);
					return this.pos += 4, e;
				}
				readFixed64() {
					let e = this.dataView.getUint32(this.pos, !0) + this.dataView.getUint32(this.pos + 4, !0) * hu;
					return this.pos += 8, e;
				}
				readSFixed64() {
					let e = this.dataView.getUint32(this.pos, !0) + this.dataView.getInt32(this.pos + 4, !0) * hu;
					return this.pos += 8, e;
				}
				readFloat() {
					let e = this.dataView.getFloat32(this.pos, !0);
					return this.pos += 4, e;
				}
				readDouble() {
					let e = this.dataView.getFloat64(this.pos, !0);
					return this.pos += 8, e;
				}
				readVarint(e) {
					let t = this.buf, n, i;
					return i = t[this.pos++], n = 127 & i, i < 128 ? n : (i = t[this.pos++], n |= (127 & i) << 7, i < 128 ? n : (i = t[this.pos++], n |= (127 & i) << 14, i < 128 ? n : (i = t[this.pos++], n |= (127 & i) << 21, i < 128 ? n : (i = t[this.pos], n |= (15 & i) << 28, function(e, t, n) {
						let i = n.buf, a, o;
						if (o = i[n.pos++], a = (112 & o) >> 4, o < 128 || (o = i[n.pos++], a |= (127 & o) << 3, o < 128) || (o = i[n.pos++], a |= (127 & o) << 10, o < 128) || (o = i[n.pos++], a |= (127 & o) << 17, o < 128) || (o = i[n.pos++], a |= (127 & o) << 24, o < 128) || (o = i[n.pos++], a |= (1 & o) << 31, o < 128)) return yu(e, a, t);
						throw Error("Expected varint not more than 10 bytes");
					}(n, e, this)))));
				}
				readVarint64() {
					return this.readVarint(!0);
				}
				readSVarint() {
					let e = this.readVarint();
					return e % 2 == 1 ? (e + 1) / -2 : e / 2;
				}
				readBoolean() {
					return !!this.readVarint();
				}
				readString() {
					let e = this.readVarint() + this.pos, t = this.pos;
					return this.pos = e, e - t >= 12 && _u ? _u.decode(this.buf.subarray(t, e)) : function(e, t, n) {
						let i = "", a = t;
						for (; a < n;) {
							let t = e[a], o, s, c, l = null, u = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
							if (a + u > n) break;
							u === 1 ? t < 128 && (l = t) : u === 2 ? (o = e[a + 1], (192 & o) == 128 && (l = (31 & t) << 6 | 63 & o, l <= 127 && (l = null))) : u === 3 ? (o = e[a + 1], s = e[a + 2], (192 & o) == 128 && (192 & s) == 128 && (l = (15 & t) << 12 | (63 & o) << 6 | 63 & s, (l <= 2047 || l >= 55296 && l <= 57343) && (l = null))) : u === 4 && (o = e[a + 1], s = e[a + 2], c = e[a + 3], (192 & o) == 128 && (192 & s) == 128 && (192 & c) == 128 && (l = (15 & t) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & c, (l <= 65535 || l >= 1114112) && (l = null))), l === null ? (l = 65533, u = 1) : l > 65535 && (l -= 65536, i += String.fromCharCode(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), i += String.fromCharCode(l), a += u;
						}
						return i;
					}(this.buf, t, e);
				}
				readBytes() {
					let e = this.readVarint() + this.pos, t = this.buf.subarray(this.pos, e);
					return this.pos = e, t;
				}
				readPackedVarint(e = [], t) {
					let n = this.readPackedEnd();
					for (; this.pos < n;) e.push(this.readVarint(t));
					return e;
				}
				readPackedSVarint(e = []) {
					let t = this.readPackedEnd();
					for (; this.pos < t;) e.push(this.readSVarint());
					return e;
				}
				readPackedBoolean(e = []) {
					let t = this.readPackedEnd();
					for (; this.pos < t;) e.push(this.readBoolean());
					return e;
				}
				readPackedFloat(e = []) {
					let t = this.readPackedEnd();
					for (; this.pos < t;) e.push(this.readFloat());
					return e;
				}
				readPackedDouble(e = []) {
					let t = this.readPackedEnd();
					for (; this.pos < t;) e.push(this.readDouble());
					return e;
				}
				readPackedFixed32(e = []) {
					let t = this.readPackedEnd();
					for (; this.pos < t;) e.push(this.readFixed32());
					return e;
				}
				readPackedSFixed32(e = []) {
					let t = this.readPackedEnd();
					for (; this.pos < t;) e.push(this.readSFixed32());
					return e;
				}
				readPackedFixed64(e = []) {
					let t = this.readPackedEnd();
					for (; this.pos < t;) e.push(this.readFixed64());
					return e;
				}
				readPackedSFixed64(e = []) {
					let t = this.readPackedEnd();
					for (; this.pos < t;) e.push(this.readSFixed64());
					return e;
				}
				readPackedEnd() {
					return this.type === 2 ? this.readVarint() + this.pos : this.pos + 1;
				}
				skip(e) {
					let t = 7 & e;
					if (t === 0) for (; this.buf[this.pos++] > 127;);
					else if (t === 2) this.pos = this.readVarint() + this.pos;
					else if (t === 5) this.pos += 4;
					else {
						if (t !== 1) throw Error(`Unimplemented type: ${t}`);
						this.pos += 8;
					}
				}
				writeTag(e, t) {
					this.writeVarint(e << 3 | t);
				}
				realloc(e) {
					let t = this.length || 16;
					for (; t < this.pos + e;) t *= 2;
					if (t !== this.length) {
						let e = new Uint8Array(t);
						e.set(this.buf), this.buf = e, this.dataView = new DataView(e.buffer), this.length = t;
					}
				}
				finish() {
					return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
				}
				writeFixed32(e) {
					this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
				}
				writeSFixed32(e) {
					this.realloc(4), this.dataView.setInt32(this.pos, e, !0), this.pos += 4;
				}
				writeFixed64(e) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * gu), !0), this.pos += 8;
				}
				writeSFixed64(e) {
					this.realloc(8), this.dataView.setInt32(this.pos, -1 & e, !0), this.dataView.setInt32(this.pos + 4, Math.floor(e * gu), !0), this.pos += 8;
				}
				writeVarint(e) {
					(e = +e || 0) > 268435455 || e < 0 ? function(e, t) {
						let n, i;
						if (e >= 0 ? (n = e % 4294967296 | 0, i = e / 4294967296 | 0) : (n = ~(-e % 4294967296), i = ~(-e / 4294967296), 4294967295 ^ n ? n = n + 1 | 0 : (n = 0, i = i + 1 | 0)), e >= 0x10000000000000000 || e < -0x10000000000000000) throw Error("Given varint doesn't fit into 10 bytes");
						t.realloc(10), function(e, t, n) {
							n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, e >>>= 7, n.buf[n.pos++] = 127 & e | 128, n.buf[n.pos] = 127 & (e >>>= 7);
						}(n, 0, t), function(e, t) {
							let n = (7 & e) << 4;
							t.buf[t.pos++] |= n | ((e >>>= 3) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e | ((e >>>= 7) ? 128 : 0), e && (t.buf[t.pos++] = 127 & e)))));
						}(i, t);
					}(e, this) : (this.realloc(4), this.buf[this.pos++] = 127 & e | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = 127 & (e >>>= 7) | (e > 127 ? 128 : 0), e <= 127 || (this.buf[this.pos++] = e >>> 7 & 127))));
				}
				writeSVarint(e) {
					this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
				}
				writeBoolean(e) {
					this.writeVarint(+e);
				}
				writeString(e) {
					e = String(e), this.realloc(4 * e.length), this.pos++;
					let t = this.pos;
					this.pos = function(e, t, n) {
						for (let i, a, o = 0; o < t.length; o++) {
							if (i = t.charCodeAt(o), i > 55295 && i < 57344) {
								if (!a) {
									i > 56319 || o + 1 === t.length ? (e[n++] = 239, e[n++] = 191, e[n++] = 189) : a = i;
									continue;
								}
								if (i < 56320) {
									e[n++] = 239, e[n++] = 191, e[n++] = 189, a = i;
									continue;
								}
								i = a - 55296 << 10 | i - 56320 | 65536, a = null;
							} else a &&= (e[n++] = 239, e[n++] = 191, e[n++] = 189, null);
							i < 128 ? e[n++] = i : (i < 2048 ? e[n++] = i >> 6 | 192 : (i < 65536 ? e[n++] = i >> 12 | 224 : (e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128), e[n++] = i >> 6 & 63 | 128), e[n++] = 63 & i | 128);
						}
						return n;
					}(this.buf, e, this.pos);
					let n = this.pos - t;
					n >= 128 && bu(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n;
				}
				writeFloat(e) {
					this.realloc(4), this.dataView.setFloat32(this.pos, e, !0), this.pos += 4;
				}
				writeDouble(e) {
					this.realloc(8), this.dataView.setFloat64(this.pos, e, !0), this.pos += 8;
				}
				writeBytes(e) {
					let t = e.length;
					this.writeVarint(t), this.realloc(t);
					for (let n = 0; n < t; n++) this.buf[this.pos++] = e[n];
				}
				writeRawMessage(e, t) {
					this.pos++;
					let n = this.pos;
					e(t, this);
					let i = this.pos - n;
					i >= 128 && bu(n, i, this), this.pos = n - 1, this.writeVarint(i), this.pos += i;
				}
				writeMessage(e, t, n) {
					this.writeTag(e, 2), this.writeRawMessage(t, n);
				}
				writePackedVarint(e, t) {
					t.length && this.writeMessage(e, xu, t);
				}
				writePackedSVarint(e, t) {
					t.length && this.writeMessage(e, Su, t);
				}
				writePackedBoolean(e, t) {
					t.length && this.writeMessage(e, Tu, t);
				}
				writePackedFloat(e, t) {
					t.length && this.writeMessage(e, Cu, t);
				}
				writePackedDouble(e, t) {
					t.length && this.writeMessage(e, wu, t);
				}
				writePackedFixed32(e, t) {
					t.length && this.writeMessage(e, Eu, t);
				}
				writePackedSFixed32(e, t) {
					t.length && this.writeMessage(e, Du, t);
				}
				writePackedFixed64(e, t) {
					t.length && this.writeMessage(e, Ou, t);
				}
				writePackedSFixed64(e, t) {
					t.length && this.writeMessage(e, ku, t);
				}
				writeBytesField(e, t) {
					this.writeTag(e, 2), this.writeBytes(t);
				}
				writeFixed32Field(e, t) {
					this.writeTag(e, 5), this.writeFixed32(t);
				}
				writeSFixed32Field(e, t) {
					this.writeTag(e, 5), this.writeSFixed32(t);
				}
				writeFixed64Field(e, t) {
					this.writeTag(e, 1), this.writeFixed64(t);
				}
				writeSFixed64Field(e, t) {
					this.writeTag(e, 1), this.writeSFixed64(t);
				}
				writeVarintField(e, t) {
					this.writeTag(e, 0), this.writeVarint(t);
				}
				writeSVarintField(e, t) {
					this.writeTag(e, 0), this.writeSVarint(t);
				}
				writeStringField(e, t) {
					this.writeTag(e, 2), this.writeString(t);
				}
				writeFloatField(e, t) {
					this.writeTag(e, 5), this.writeFloat(t);
				}
				writeDoubleField(e, t) {
					this.writeTag(e, 1), this.writeDouble(t);
				}
				writeBooleanField(e, t) {
					this.writeVarintField(e, +t);
				}
			}
			function yu(e, t, n) {
				return n ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0);
			}
			function bu(e, t, n) {
				let i = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
				n.realloc(i);
				for (let t = n.pos - 1; t >= e; t--) n.buf[t + i] = n.buf[t];
			}
			function xu(e, t) {
				for (let n = 0; n < e.length; n++) t.writeVarint(e[n]);
			}
			function Su(e, t) {
				for (let n = 0; n < e.length; n++) t.writeSVarint(e[n]);
			}
			function Cu(e, t) {
				for (let n = 0; n < e.length; n++) t.writeFloat(e[n]);
			}
			function wu(e, t) {
				for (let n = 0; n < e.length; n++) t.writeDouble(e[n]);
			}
			function Tu(e, t) {
				for (let n = 0; n < e.length; n++) t.writeBoolean(e[n]);
			}
			function Eu(e, t) {
				for (let n = 0; n < e.length; n++) t.writeFixed32(e[n]);
			}
			function Du(e, t) {
				for (let n = 0; n < e.length; n++) t.writeSFixed32(e[n]);
			}
			function Ou(e, t) {
				for (let n = 0; n < e.length; n++) t.writeFixed64(e[n]);
			}
			function ku(e, t) {
				for (let n = 0; n < e.length; n++) t.writeSFixed64(e[n]);
			}
			function Au(e, t, n) {
				e === 1 && n.readMessage(ju, t);
			}
			function ju(e, t, n) {
				if (e === 3) {
					let { id: e, bitmap: i, width: a, height: o, left: s, top: c, advance: l } = n.readMessage(Mu, {});
					t.push({
						id: e,
						bitmap: new Tc({
							width: a + 6,
							height: o + 6
						}, i),
						metrics: {
							width: a,
							height: o,
							left: s,
							top: c,
							advance: l
						}
					});
				}
			}
			function Mu(e, t, n) {
				e === 1 ? t.id = n.readVarint() : e === 2 ? t.bitmap = n.readBytes() : e === 3 ? t.width = n.readVarint() : e === 4 ? t.height = n.readVarint() : e === 5 ? t.left = n.readSVarint() : e === 6 ? t.top = n.readSVarint() : e === 7 && (t.advance = n.readVarint());
			}
			function Nu(e) {
				let t = 0, n = 0;
				for (let i of e) t += i.w * i.h, n = Math.max(n, i.w);
				e.sort(((e, t) => t.h - e.h));
				let i = [{
					x: 0,
					y: 0,
					w: Math.max(Math.ceil(Math.sqrt(t / .95)), n),
					h: Infinity
				}], a = 0, o = 0;
				for (let t of e) for (let e = i.length - 1; e >= 0; e--) {
					let n = i[e];
					if (!(t.w > n.w || t.h > n.h)) {
						if (t.x = n.x, t.y = n.y, o = Math.max(o, t.y + t.h), a = Math.max(a, t.x + t.w), t.w === n.w && t.h === n.h) {
							let t = i.pop();
							t && e < i.length && (i[e] = t);
						} else t.h === n.h ? (n.x += t.w, n.w -= t.w) : t.w === n.w ? (n.y += t.h, n.h -= t.h) : (i.push({
							x: n.x + t.w,
							y: n.y,
							w: n.w - t.w,
							h: t.h
						}), n.y += t.h, n.h -= t.h);
						break;
					}
				}
				return {
					w: a,
					h: o,
					fill: t / (a * o) || 0
				};
			}
			class Pu {
				constructor(e, { pixelRatio: t, version: n, stretchX: i, stretchY: a, content: o, textFitWidth: s, textFitHeight: c }) {
					this.paddedRect = e, this.pixelRatio = t, this.stretchX = i, this.stretchY = a, this.content = o, this.version = n, this.textFitWidth = s, this.textFitHeight = c;
				}
				get tl() {
					return [this.paddedRect.x + 1, this.paddedRect.y + 1];
				}
				get br() {
					return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
				}
				get tlbr() {
					return this.tl.concat(this.br);
				}
				get displaySize() {
					return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
				}
			}
			class Fu {
				constructor(e, t) {
					let n = {}, i = {};
					this.haveRenderCallbacks = [];
					let a = [];
					this.addImages(e, n, a), this.addImages(t, i, a);
					let { w: o, h: s } = Nu(a), c = new Ec({
						width: o || 1,
						height: s || 1
					});
					for (let t in e) {
						let i = e[t], a = n[t].paddedRect;
						Ec.copy(i.data, c, {
							x: 0,
							y: 0
						}, {
							x: a.x + 1,
							y: a.y + 1
						}, i.data);
					}
					for (let e in t) {
						let n = t[e], a = i[e].paddedRect, o = a.x + 1, s = a.y + 1, l = n.data.width, u = n.data.height;
						Ec.copy(n.data, c, {
							x: 0,
							y: 0
						}, {
							x: o,
							y: s
						}, n.data), Ec.copy(n.data, c, {
							x: 0,
							y: u - 1
						}, {
							x: o,
							y: s - 1
						}, {
							width: l,
							height: 1
						}), Ec.copy(n.data, c, {
							x: 0,
							y: 0
						}, {
							x: o,
							y: s + u
						}, {
							width: l,
							height: 1
						}), Ec.copy(n.data, c, {
							x: l - 1,
							y: 0
						}, {
							x: o - 1,
							y: s
						}, {
							width: 1,
							height: u
						}), Ec.copy(n.data, c, {
							x: 0,
							y: 0
						}, {
							x: o + l,
							y: s
						}, {
							width: 1,
							height: u
						});
					}
					this.image = c, this.iconPositions = n, this.patternPositions = i;
				}
				addImages(e, t, n) {
					for (let i in e) {
						let a = e[i], o = {
							x: 0,
							y: 0,
							w: a.data.width + 2,
							h: a.data.height + 2
						};
						n.push(o), t[i] = new Pu(o, a), a.hasRenderCallback && this.haveRenderCallbacks.push(i);
					}
				}
				patchUpdatedImages(e, t) {
					for (let n in e.dispatchRenderCallbacks(this.haveRenderCallbacks), e.updatedImages) this.patchUpdatedImage(this.iconPositions[n], e.getImage(n), t), this.patchUpdatedImage(this.patternPositions[n], e.getImage(n), t);
				}
				patchUpdatedImage(e, t, n) {
					if (!e || !t || e.version === t.version) return;
					e.version = t.version;
					let [i, a] = e.tl;
					n.update(t.data, void 0, {
						x: i,
						y: a
					});
				}
			}
			var Iu;
			J("ImagePosition", Pu), J("ImageAtlas", Fu), e.ao = void 0, (Iu = e.ao ||= {})[Iu.none = 0] = "none", Iu[Iu.horizontal = 1] = "horizontal", Iu[Iu.vertical = 2] = "vertical", Iu[Iu.horizontalOnly = 3] = "horizontalOnly";
			class Lu {
				constructor() {
					this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
				}
				static forText(e, t, n) {
					let i = new Lu();
					return i.scale = e || 1, i.fontStack = t, i.verticalAlign = n || "bottom", i;
				}
				static forImage(e, t) {
					let n = new Lu();
					return n.imageName = e, n.verticalAlign = t || "bottom", n;
				}
			}
			class Ru {
				constructor() {
					this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
				}
				static fromFeature(e, t) {
					let n = new Ru();
					for (let i = 0; i < e.sections.length; i++) {
						let a = e.sections[i];
						a.image ? n.addImageSection(a) : n.addTextSection(a, t);
					}
					return n;
				}
				length() {
					return this.text.length;
				}
				getSection(e) {
					return this.sections[this.sectionIndex[e]];
				}
				getSectionIndex(e) {
					return this.sectionIndex[e];
				}
				getCharCode(e) {
					return this.text.charCodeAt(e);
				}
				verticalizePunctuation() {
					this.text = function(e) {
						let t = "";
						for (let n = 0; n < e.length; n++) {
							let i = e.charCodeAt(n + 1) || null, a = e.charCodeAt(n - 1) || null;
							t += i && Ma(i) && !pu[e[n + 1]] || a && Ma(a) && !pu[e[n - 1]] || !pu[e[n]] ? e[n] : pu[e[n]];
						}
						return t;
					}(this.text);
				}
				trim() {
					let e = 0;
					for (let t = 0; t < this.text.length && Bu[this.text.charCodeAt(t)]; t++) e++;
					let t = this.text.length;
					for (let n = this.text.length - 1; n >= 0 && n >= e && Bu[this.text.charCodeAt(n)]; n--) t--;
					this.text = this.text.substring(e, t), this.sectionIndex = this.sectionIndex.slice(e, t);
				}
				substring(e, t) {
					let n = new Ru();
					return n.text = this.text.substring(e, t), n.sectionIndex = this.sectionIndex.slice(e, t), n.sections = this.sections, n;
				}
				toString() {
					return this.text;
				}
				getMaxScale() {
					return this.sectionIndex.reduce(((e, t) => Math.max(e, this.sections[t].scale)), 0);
				}
				getMaxImageSize(e) {
					let t = 0, n = 0;
					for (let i = 0; i < this.length(); i++) {
						let a = this.getSection(i);
						if (a.imageName) {
							let i = e[a.imageName];
							if (!i) continue;
							let o = i.displaySize;
							t = Math.max(t, o[0]), n = Math.max(n, o[1]);
						}
					}
					return {
						maxImageWidth: t,
						maxImageHeight: n
					};
				}
				addTextSection(e, t) {
					this.text += e.text, this.sections.push(Lu.forText(e.scale, e.fontStack || t, e.verticalAlign));
					let n = this.sections.length - 1;
					for (let t = 0; t < e.text.length; ++t) this.sectionIndex.push(n);
				}
				addImageSection(e) {
					let t = e.image ? e.image.name : "";
					if (t.length === 0) return void se("Can't add FormattedSection with an empty image.");
					let n = this.getNextImageSectionCharCode();
					n ? (this.text += String.fromCharCode(n), this.sections.push(Lu.forImage(t, e.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : se("Reached maximum number of images 6401");
				}
				getNextImageSectionCharCode() {
					return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
				}
			}
			function zu(t, n, i, a, o, s, c, l, u, d, f, p, m, h, g) {
				let _ = Ru.fromFeature(t, o), v;
				p === e.ao.vertical && _.verticalizePunctuation();
				let { processBidirectionalText: y, processStyledBidirectionalText: b } = La;
				if (y && _.sections.length === 1) {
					v = [];
					let e = y(_.toString(), Ju(_, d, s, n, a, h));
					for (let t of e) {
						let e = new Ru();
						e.text = t, e.sections = _.sections;
						for (let n = 0; n < t.length; n++) e.sectionIndex.push(0);
						v.push(e);
					}
				} else if (b) {
					v = [];
					let e = b(_.text, _.sectionIndex, Ju(_, d, s, n, a, h));
					for (let t of e) {
						let e = new Ru();
						e.text = t[0], e.sectionIndex = t[1], e.sections = _.sections, v.push(e);
					}
				} else v = function(e, t) {
					let n = [], i = e.text, a = 0;
					for (let i of t) n.push(e.substring(a, i)), a = i;
					return a < i.length && n.push(e.substring(a, i.length)), n;
				}(_, Ju(_, d, s, n, a, h));
				let x = [], S = {
					positionedLines: x,
					text: _.toString(),
					top: f[1],
					bottom: f[1],
					left: f[0],
					right: f[0],
					writingMode: p,
					iconsInText: !1,
					verticalizable: !1
				};
				return function(e, t, n, i, a, o, s, c, l, u, d, f) {
					let p = 0, m = 0, h = 0, g = 0, _ = c === "right" ? 1 : c === "left" ? 0 : .5, v = mu / f, y = 0;
					for (let s of a) {
						s.trim();
						let a = s.getMaxScale(), c = {
							positionedGlyphs: [],
							lineOffset: 0
						};
						e.positionedLines[y] = c;
						let f = c.positionedGlyphs, b = 0;
						if (!s.length()) {
							m += o, ++y;
							continue;
						}
						let x = Xu(i, s, v);
						for (let o = 0; o < s.length(); o++) {
							let c = s.getSection(o), h = s.getSectionIndex(o), g = s.getCharCode(o), _ = Qu(l, d, g), y;
							if (c.imageName) {
								if (e.iconsInText = !0, c.scale *= v, y = ed(c, _, a, x, i), !y) continue;
								b = Math.max(b, y.imageOffset);
							} else if (y = $u(c, g, _, x, t, n), !y) continue;
							let { rect: S, metrics: C, baselineOffset: w } = y;
							f.push({
								glyph: g,
								imageName: c.imageName,
								x: p,
								y: m + w + -17,
								vertical: _,
								scale: c.scale,
								fontStack: c.fontStack,
								sectionIndex: h,
								metrics: C,
								rect: S
							}), _ ? (e.verticalizable = !0, p += (c.imageName ? C.advance : mu) * c.scale + u) : p += C.advance * c.scale + u;
						}
						f.length !== 0 && (h = Math.max(p - u, h), td(f, 0, f.length - 1, _)), p = 0, c.lineOffset = Math.max(b, (a - 1) * mu);
						let S = o * a + b;
						m += S, g = Math.max(S, g), ++y;
					}
					let { horizontalAlign: b, verticalAlign: x } = Yu(s);
					(function(e, t, n, i, a, o, s, c, l) {
						let u = (t - n) * a, d = 0;
						d = o === s ? -i * l * s + .5 * s : -c * i - -17;
						for (let t of e) for (let e of t.positionedGlyphs) e.x += u, e.y += d;
					})(e.positionedLines, _, b, x, h, g, o, m, a.length), e.top += -x * m, e.bottom = e.top + m, e.left += -b * h, e.right = e.left + h;
				}(S, n, i, a, v, c, l, u, p, d, m, g), !function(e) {
					for (let t of e) if (t.positionedGlyphs.length !== 0) return !1;
					return !0;
				}(x) && S;
			}
			let Bu = {
				9: !0,
				10: !0,
				11: !0,
				12: !0,
				13: !0,
				32: !0
			}, Vu = {
				10: !0,
				32: !0,
				38: !0,
				41: !0,
				43: !0,
				45: !0,
				47: !0,
				173: !0,
				183: !0,
				8203: !0,
				8208: !0,
				8211: !0,
				8231: !0
			}, Hu = { 40: !0 };
			function Uu(e, t, n, i, a, o) {
				if (t.imageName) {
					let e = i[t.imageName];
					return e ? e.displaySize[0] * t.scale * mu / o + a : 0;
				}
				{
					let i = n[t.fontStack], o = i && i[e];
					return o ? o.metrics.advance * t.scale + a : 0;
				}
			}
			function Wu(e, t, n, i) {
				let a = (e - t) ** 2;
				return i ? e < t ? a / 2 : 2 * a : a + Math.abs(n) * n;
			}
			function Gu(e, t, n) {
				let i = 0;
				return e === 10 && (i -= 1e4), n && (i += 150), e !== 40 && e !== 65288 || (i += 50), t !== 41 && t !== 65289 || (i += 50), i;
			}
			function Ku(e, t, n, i, a, o) {
				let s = null, c = Wu(t, n, a, o);
				for (let e of i) {
					let i = Wu(t - e.x, n, a, o) + e.badness;
					i <= c && (s = e, c = i);
				}
				return {
					index: e,
					x: t,
					priorBreak: s,
					badness: c
				};
			}
			function qu(e) {
				return e ? qu(e.priorBreak).concat(e.index) : [];
			}
			function Ju(e, t, n, i, a, o) {
				if (!e) return [];
				let s = [], c = function(e, t, n, i, a, o) {
					let s = 0;
					for (let n = 0; n < e.length(); n++) {
						let c = e.getSection(n);
						s += Uu(e.getCharCode(n), c, i, a, t, o);
					}
					return s / Math.max(1, Math.ceil(s / n));
				}(e, t, n, i, a, o), l = e.text.indexOf("") >= 0, u = 0;
				for (let n = 0; n < e.length(); n++) {
					let f = e.getSection(n), p = e.getCharCode(n);
					if (Bu[p] || (u += Uu(p, f, i, a, t, o)), n < e.length() - 1) {
						let t = !((d = p) < 11904) && (!!wa["CJK Compatibility Forms"](d) || !!wa["CJK Compatibility"](d) || !!wa["CJK Strokes"](d) || !!wa["CJK Symbols and Punctuation"](d) || !!wa["Enclosed CJK Letters and Months"](d) || !!wa["Halfwidth and Fullwidth Forms"](d) || !!wa["Ideographic Description Characters"](d) || !!wa["Vertical Forms"](d) || Aa.test(String.fromCodePoint(d)));
						(Vu[p] || t || f.imageName || n !== e.length() - 2 && Hu[e.getCharCode(n + 1)]) && s.push(Ku(n + 1, u, c, s, Gu(p, e.getCharCode(n + 1), t && l), !1));
					}
				}
				var d;
				return qu(Ku(e.length(), u, c, s, 0, !0));
			}
			function Yu(e) {
				let t = .5, n = .5;
				switch (e) {
					case "right":
					case "top-right":
					case "bottom-right":
						t = 1;
						break;
					case "left":
					case "top-left":
					case "bottom-left": t = 0;
				}
				switch (e) {
					case "bottom":
					case "bottom-right":
					case "bottom-left":
						n = 1;
						break;
					case "top":
					case "top-right":
					case "top-left": n = 0;
				}
				return {
					horizontalAlign: t,
					verticalAlign: n
				};
			}
			function Xu(e, t, n) {
				let i = t.getMaxScale() * mu, { maxImageWidth: a, maxImageHeight: o } = t.getMaxImageSize(e), s = Math.max(i, o * n);
				return {
					verticalLineContentWidth: Math.max(i, a * n),
					horizontalLineContentHeight: s
				};
			}
			function Zu(e) {
				switch (e) {
					case "top": return 0;
					case "center": return .5;
					default: return 1;
				}
			}
			function Qu(t, n, i) {
				return !(t === e.ao.horizontal || !n && !ja(i) || n && (Bu[i] || (a = i, /\p{sc=Arab}/u.test(String.fromCodePoint(a)))));
				var a;
			}
			function $u(e, t, n, i, a, o) {
				let s = o[e.fontStack], c = function(e, t, n, i) {
					if (e && e.rect) return e;
					let a = t[n.fontStack], o = a && a[i];
					return o ? {
						rect: null,
						metrics: o.metrics
					} : null;
				}(s && s[t], a, e, t);
				if (c === null) return null;
				let l;
				if (n) l = i.verticalLineContentWidth - e.scale * mu;
				else {
					let t = Zu(e.verticalAlign);
					l = (i.horizontalLineContentHeight - e.scale * mu) * t;
				}
				return {
					rect: c.rect,
					metrics: c.metrics,
					baselineOffset: l
				};
			}
			function ed(e, t, n, i, a) {
				let o = a[e.imageName];
				if (!o) return null;
				let s = o.paddedRect, c = o.displaySize, l = {
					width: c[0],
					height: c[1],
					left: 1,
					top: -3,
					advance: t ? c[1] : c[0]
				}, u;
				if (t) u = i.verticalLineContentWidth - c[1] * e.scale;
				else {
					let t = Zu(e.verticalAlign);
					u = (i.horizontalLineContentHeight - c[1] * e.scale) * t;
				}
				return {
					rect: s,
					metrics: l,
					baselineOffset: u,
					imageOffset: (t ? c[0] : c[1]) * e.scale - mu * n
				};
			}
			function td(e, t, n, i) {
				if (i === 0) return;
				let a = e[n], o = (e[n].x + a.metrics.advance * a.scale) * i;
				for (let i = t; i <= n; i++) e[i].x -= o;
			}
			function nd(e, t, n) {
				let { horizontalAlign: i, verticalAlign: a } = Yu(n), o = t[0] - e.displaySize[0] * i, s = t[1] - e.displaySize[1] * a;
				return {
					image: e,
					top: s,
					bottom: s + e.displaySize[1],
					left: o,
					right: o + e.displaySize[0]
				};
			}
			function rd(e) {
				let t = e.left, n = e.top, i = e.right - t, a = e.bottom - n, o = e.image.textFitWidth ?? "stretchOrShrink", s = e.image.textFitHeight ?? "stretchOrShrink", c = (e.image.content[2] - e.image.content[0]) / (e.image.content[3] - e.image.content[1]);
				if (s === "proportional") {
					if (o === "stretchOnly" && i / a < c || o === "proportional") {
						let e = Math.ceil(a * c);
						t *= e / i, i = e;
					}
				} else if (o === "proportional" && s === "stretchOnly" && c !== 0 && i / a > c) {
					let e = Math.ceil(i / c);
					n *= e / a, a = e;
				}
				return {
					x1: t,
					y1: n,
					x2: t + i,
					y2: n + a
				};
			}
			function id(e, t, n, i, a, o) {
				let s = e.image, c;
				if (s.content) {
					let e = s.content, t = s.pixelRatio || 1;
					c = [
						e[0] / t,
						e[1] / t,
						s.displaySize[0] - e[2] / t,
						s.displaySize[1] - e[3] / t
					];
				}
				let l = t.left * o, u = t.right * o, d, f, p, m;
				n === "width" || n === "both" ? (m = a[0] + l - i[3], f = a[0] + u + i[1]) : (m = a[0] + (l + u - s.displaySize[0]) / 2, f = m + s.displaySize[0]);
				let h = t.top * o, g = t.bottom * o;
				return n === "height" || n === "both" ? (d = a[1] + h - i[0], p = a[1] + g + i[2]) : (d = a[1] + (h + g - s.displaySize[1]) / 2, p = d + s.displaySize[1]), {
					image: s,
					top: d,
					right: f,
					bottom: p,
					left: m,
					collisionPadding: c
				};
			}
			let ad = 32640;
			function od(e, t) {
				let { expression: n } = t;
				if (n.kind === "constant") return {
					kind: "constant",
					layoutSize: n.evaluate(new Ra(e + 1))
				};
				if (n.kind === "source") return { kind: "source" };
				{
					let { zoomStops: t, interpolationType: i } = n, a = 0;
					for (; a < t.length && t[a] <= e;) a++;
					a = Math.max(0, a - 1);
					let o = a;
					for (; o < t.length && t[o] < e + 1;) o++;
					o = Math.min(t.length - 1, o);
					let s = t[a], c = t[o];
					return n.kind === "composite" ? {
						kind: "composite",
						minZoom: s,
						maxZoom: c,
						interpolationType: i
					} : {
						kind: "camera",
						minZoom: s,
						maxZoom: c,
						minSize: n.evaluate(new Ra(s)),
						maxSize: n.evaluate(new Ra(c)),
						interpolationType: i
					};
				}
			}
			function sd(e, t, n) {
				let i = "never", a = e.get(t);
				return a ? i = a : e.get(n) && (i = "always"), i;
			}
			let cd = [{
				name: "a_fade_opacity",
				components: 1,
				type: "Uint8",
				offset: 0
			}];
			function ld(e, t, n, i, a, o, s, c, l, u, d, f, p) {
				let m = c ? Math.min(ad, Math.round(c[0])) : 0, h = c ? Math.min(ad, Math.round(c[1])) : 0;
				e.emplaceBack(t, n, Math.round(32 * i), Math.round(32 * a), o, s, (m << 1) + (l ? 1 : 0), h, 16 * u, 16 * d, 256 * f, 256 * p);
			}
			function ud(e, t, n) {
				e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n), e.emplaceBack(t.x, t.y, n);
			}
			function dd(e) {
				for (let t of e.sections) if (Ia(t.text)) return !0;
				return !1;
			}
			class fd {
				constructor(e) {
					this.layoutVertexArray = new $o(), this.indexArray = new os(), this.programConfigurations = e, this.segments = new ls(), this.dynamicLayoutVertexArray = new es(), this.opacityVertexArray = new ts(), this.hasVisibleVertices = !1, this.placedSymbolArray = new Io();
				}
				isEmpty() {
					return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
				}
				upload(e, t, n, i) {
					this.isEmpty() || (n && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, su.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, t), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, cu.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, cd, !0), this.opacityVertexBuffer.itemSize = 1), (n || i) && this.programConfigurations.upload(e));
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
				}
			}
			J("SymbolBuffers", fd);
			class pd {
				constructor(e, t, n) {
					this.layoutVertexArray = new e(), this.layoutAttributes = t, this.indexArray = new n(), this.segments = new ls(), this.collisionVertexArray = new rs();
				}
				upload(e) {
					this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, lu.members, !0);
				}
				destroy() {
					this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
				}
			}
			J("CollisionBuffers", pd);
			class md {
				constructor(t) {
					this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.overscaling = de(globalThis) ? Math.min(t.overscaling, 128) : t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(((e) => e.id)), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasDependencies = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
					let n = this.layers[0]._unevaluatedLayout._values;
					this.textSizeData = od(this.zoom, n["text-size"]), this.iconSizeData = od(this.zoom, n["icon-size"]);
					let i = this.layers[0].layout, a = i.get("symbol-sort-key"), o = i.get("symbol-z-order");
					this.canOverlap = sd(i, "text-overlap", "text-allow-overlap") !== "never" || sd(i, "icon-overlap", "icon-allow-overlap") !== "never" || i.get("text-ignore-placement") || i.get("icon-ignore-placement"), this.sortFeaturesByKey = o !== "viewport-y" && !a.isConstant(), this.sortFeaturesByY = (o === "viewport-y" || o === "auto" && !this.sortFeaturesByKey) && this.canOverlap, i.get("symbol-placement") === "point" && (this.writingModes = i.get("text-writing-mode").map(((t) => e.ao[t]))), this.stateDependentLayerIds = this.layers.filter(((e) => e.isStateDependent())).map(((e) => e.id)), this.sourceID = t.sourceID;
				}
				createArrays() {
					this.text = new fd(new zs(this.layers, this.zoom, ((e) => /^text/.test(e)))), this.icon = new fd(new zs(this.layers, this.zoom, ((e) => /^icon/.test(e)))), this.glyphOffsetArray = new zo(), this.lineVertexArray = new Bo(), this.symbolInstances = new Ro(), this.textAnchorOffsets = new Ho();
				}
				calculateGlyphDependencies(e, t, n, i, a) {
					for (let o = 0; o < e.length; o++) if (t[e.charCodeAt(o)] = !0, (n || i) && a) {
						let n = pu[e.charAt(o)];
						n && (t[n.charCodeAt(0)] = !0);
					}
				}
				populate(t, n, i) {
					let a = this.layers[0], o = a.layout, s = o.get("text-font"), c = o.get("text-field"), l = o.get("icon-image"), u = (c.value.kind !== "constant" || c.value.value instanceof Ht && !c.value.value.isEmpty() || c.value.value.toString().length > 0) && (s.value.kind !== "constant" || s.value.value.length > 0), d = l.value.kind !== "constant" || !!l.value.value || Object.keys(l.parameters).length > 0, f = o.get("symbol-sort-key");
					if (this.features = [], !u && !d) return;
					let p = n.iconDependencies, m = n.glyphDependencies, h = n.availableImages, g = new Ra(this.zoom);
					for (let { feature: n, id: c, index: l, sourceLayerIndex: _ } of t) {
						let t = a._featureFilter.needGeometry, v = Gs(n, t);
						if (!a._featureFilter.filter(g, v, i)) continue;
						let y, b;
						if (t || (v.geometry = Ws(n)), u) {
							let e = a.getValueAndResolveTokens("text-field", v, i, h), t = Ht.factory(e), n = this.hasRTLText = this.hasRTLText || dd(t);
							(!n || La.getRTLTextPluginStatus() === "unavailable" || n && La.isParsed()) && (y = fu(t, a, v));
						}
						if (d) {
							let e = a.getValueAndResolveTokens("icon-image", v, i, h);
							b = e instanceof Yt ? e : Yt.fromString(e);
						}
						if (!y && !b) continue;
						let x = this.sortFeaturesByKey ? f.evaluate(v, {}, i) : void 0;
						if (this.features.push({
							id: c,
							text: y,
							icon: b,
							index: l,
							sourceLayerIndex: _,
							geometry: v.geometry,
							properties: n.properties,
							type: jl.types[n.type],
							sortKey: x
						}), b && (p[b.name] = !0), y) {
							let t = s.evaluate(v, {}, i).join(","), n = o.get("text-rotation-alignment") !== "viewport" && o.get("symbol-placement") !== "point";
							this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(e.ao.vertical) >= 0;
							for (let e of y.sections) if (e.image) p[e.image.name] = !0;
							else {
								let i = Ta(y.toString()), a = e.fontStack || t, o = m[a] = m[a] || {};
								this.calculateGlyphDependencies(e.text, o, n, this.allowVerticalPlacement, i);
							}
						}
					}
					o.get("symbol-placement") === "line" && (this.features = function(e) {
						let t = {}, n = {}, i = [], a = 0;
						function o(t) {
							i.push(e[t]), a++;
						}
						function s(e, t, a) {
							let o = n[e];
							return delete n[e], n[t] = o, i[o].geometry[0].pop(), i[o].geometry[0] = i[o].geometry[0].concat(a[0]), o;
						}
						function c(e, n, a) {
							let o = t[n];
							return delete t[n], t[e] = o, i[o].geometry[0].shift(), i[o].geometry[0] = a[0].concat(i[o].geometry[0]), o;
						}
						function l(e, t, n) {
							let i = n ? t[0][t[0].length - 1] : t[0][0];
							return `${e}:${i.x}:${i.y}`;
						}
						for (let u = 0; u < e.length; u++) {
							let d = e[u], f = d.geometry, p = d.text ? d.text.toString() : null;
							if (!p) {
								o(u);
								continue;
							}
							let m = l(p, f), h = l(p, f, !0);
							if (m in n && h in t && n[m] !== t[h]) {
								let e = c(m, h, f), a = s(m, h, i[e].geometry);
								delete t[m], delete n[h], n[l(p, i[a].geometry, !0)] = a, i[e].geometry = null;
							} else m in n ? s(m, h, f) : h in t ? c(m, h, f) : (o(u), t[m] = a - 1, n[h] = a - 1);
						}
						return i.filter(((e) => e.geometry));
					}(this.features)), this.sortFeaturesByKey && this.features.sort(((e, t) => e.sortKey - t.sortKey));
				}
				update(e, t, n) {
					this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(e, t, this.layers, { imagePositions: n }), this.icon.programConfigurations.updatePaintArrays(e, t, this.layers, { imagePositions: n }));
				}
				isEmpty() {
					return this.symbolInstances.length === 0 && !this.hasRTLText;
				}
				uploadPending() {
					return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
				}
				upload(e) {
					!this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
				}
				destroyDebugData() {
					this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
				}
				destroy() {
					this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
				}
				addToLineVertexArray(e, t) {
					let n = this.lineVertexArray.length;
					if (e.segment !== void 0) {
						let n = e.dist(t[e.segment + 1]), i = e.dist(t[e.segment]), a = {};
						for (let i = e.segment + 1; i < t.length; i++) a[i] = {
							x: t[i].x,
							y: t[i].y,
							tileUnitDistanceFromAnchor: n
						}, i < t.length - 1 && (n += t[i + 1].dist(t[i]));
						for (let n = e.segment || 0; n >= 0; n--) a[n] = {
							x: t[n].x,
							y: t[n].y,
							tileUnitDistanceFromAnchor: i
						}, n > 0 && (i += t[n - 1].dist(t[n]));
						for (let e = 0; e < t.length; e++) {
							let t = a[e];
							this.lineVertexArray.emplaceBack(t.x, t.y, t.tileUnitDistanceFromAnchor);
						}
					}
					return {
						lineStartIndex: n,
						lineLength: this.lineVertexArray.length - n
					};
				}
				addSymbols(t, n, i, a, o, s, c, l, u, d, f, p) {
					let m = t.indexArray, h = t.layoutVertexArray, g = t.segments.prepareSegment(4 * n.length, h, m, this.canOverlap ? s.sortKey : void 0), _ = this.glyphOffsetArray.length, v = g.vertexLength, y = this.allowVerticalPlacement && c === e.ao.vertical ? Math.PI / 2 : 0, b = s.text && s.text.sections;
					for (let e = 0; e < n.length; e++) {
						let { tl: a, tr: o, bl: c, br: u, tex: d, pixelOffsetTL: f, pixelOffsetBR: _, minFontScaleX: v, minFontScaleY: x, glyphOffset: S, isSDF: C, sectionIndex: w } = n[e], T = g.vertexLength, E = S[1];
						ld(h, l.x, l.y, a.x, E + a.y, d.x, d.y, i, C, f.x, f.y, v, x), ld(h, l.x, l.y, o.x, E + o.y, d.x + d.w, d.y, i, C, _.x, f.y, v, x), ld(h, l.x, l.y, c.x, E + c.y, d.x, d.y + d.h, i, C, f.x, _.y, v, x), ld(h, l.x, l.y, u.x, E + u.y, d.x + d.w, d.y + d.h, i, C, _.x, _.y, v, x), ud(t.dynamicLayoutVertexArray, l, y), m.emplaceBack(T, T + 2, T + 1), m.emplaceBack(T + 1, T + 2, T + 3), g.vertexLength += 4, g.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(S[0]), e !== n.length - 1 && w === n[e + 1].sectionIndex || t.programConfigurations.populatePaintArrays(h.length, s, s.index, {
							imagePositions: {},
							canonical: p,
							formattedSection: b && b[w]
						});
					}
					t.placedSymbolArray.emplaceBack(l.x, l.y, _, this.glyphOffsetArray.length - _, v, u, d, l.segment, i ? i[0] : 0, i ? i[1] : 0, a[0], a[1], c, 0, !1, 0, f);
				}
				_addCollisionDebugVertex(e, t, n, i, a, o) {
					return t.emplaceBack(0, 0), e.emplaceBack(n.x, n.y, i, a, Math.round(o.x), Math.round(o.y));
				}
				addCollisionDebugVertices(e, t, i, a, o, s, c) {
					let l = o.segments.prepareSegment(4, o.layoutVertexArray, o.indexArray), u = l.vertexLength, d = o.layoutVertexArray, f = o.collisionVertexArray, p = c.anchorX, m = c.anchorY;
					this._addCollisionDebugVertex(d, f, s, p, m, new n(e, t)), this._addCollisionDebugVertex(d, f, s, p, m, new n(i, t)), this._addCollisionDebugVertex(d, f, s, p, m, new n(i, a)), this._addCollisionDebugVertex(d, f, s, p, m, new n(e, a)), l.vertexLength += 4;
					let h = o.indexArray;
					h.emplaceBack(u, u + 1), h.emplaceBack(u + 1, u + 2), h.emplaceBack(u + 2, u + 3), h.emplaceBack(u + 3, u), l.primitiveLength += 4;
				}
				addDebugCollisionBoxes(e, t, n, i) {
					for (let a = e; a < t; a++) {
						let e = this.collisionBoxArray.get(a);
						this.addCollisionDebugVertices(e.x1, e.y1, e.x2, e.y2, i ? this.textCollisionBox : this.iconCollisionBox, e.anchorPoint, n);
					}
				}
				generateCollisionDebugBuffers() {
					this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new pd(ns, uu.members, ss), this.iconCollisionBox = new pd(ns, uu.members, ss);
					for (let e = 0; e < this.symbolInstances.length; e++) {
						let t = this.symbolInstances.get(e);
						this.addDebugCollisionBoxes(t.textBoxStartIndex, t.textBoxEndIndex, t, !0), this.addDebugCollisionBoxes(t.verticalTextBoxStartIndex, t.verticalTextBoxEndIndex, t, !0), this.addDebugCollisionBoxes(t.iconBoxStartIndex, t.iconBoxEndIndex, t, !1), this.addDebugCollisionBoxes(t.verticalIconBoxStartIndex, t.verticalIconBoxEndIndex, t, !1);
					}
				}
				_deserializeCollisionBoxesForSymbol(e, t, n, i, a, o, s, c, l) {
					let u = {};
					for (let i = t; i < n; i++) {
						let t = e.get(i);
						u.textBox = {
							x1: t.x1,
							y1: t.y1,
							x2: t.x2,
							y2: t.y2,
							anchorPointX: t.anchorPointX,
							anchorPointY: t.anchorPointY
						}, u.textFeatureIndex = t.featureIndex;
						break;
					}
					for (let t = i; t < a; t++) {
						let n = e.get(t);
						u.verticalTextBox = {
							x1: n.x1,
							y1: n.y1,
							x2: n.x2,
							y2: n.y2,
							anchorPointX: n.anchorPointX,
							anchorPointY: n.anchorPointY
						}, u.verticalTextFeatureIndex = n.featureIndex;
						break;
					}
					for (let t = o; t < s; t++) {
						let n = e.get(t);
						u.iconBox = {
							x1: n.x1,
							y1: n.y1,
							x2: n.x2,
							y2: n.y2,
							anchorPointX: n.anchorPointX,
							anchorPointY: n.anchorPointY
						}, u.iconFeatureIndex = n.featureIndex;
						break;
					}
					for (let t = c; t < l; t++) {
						let n = e.get(t);
						u.verticalIconBox = {
							x1: n.x1,
							y1: n.y1,
							x2: n.x2,
							y2: n.y2,
							anchorPointX: n.anchorPointX,
							anchorPointY: n.anchorPointY
						}, u.verticalIconFeatureIndex = n.featureIndex;
						break;
					}
					return u;
				}
				deserializeCollisionBoxes(e) {
					this.collisionArrays = [];
					for (let t = 0; t < this.symbolInstances.length; t++) {
						let n = this.symbolInstances.get(t);
						this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, n.textBoxStartIndex, n.textBoxEndIndex, n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n.iconBoxStartIndex, n.iconBoxEndIndex, n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex));
					}
				}
				hasTextData() {
					return this.text.segments.get().length > 0;
				}
				hasIconData() {
					return this.icon.segments.get().length > 0;
				}
				hasDebugData() {
					return this.textCollisionBox && this.iconCollisionBox;
				}
				hasTextCollisionBoxData() {
					return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
				}
				hasIconCollisionBoxData() {
					return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
				}
				addIndicesForPlacedSymbol(e, t) {
					let n = e.placedSymbolArray.get(t), i = n.vertexStartIndex + 4 * n.numGlyphs;
					for (let t = n.vertexStartIndex; t < i; t += 4) e.indexArray.emplaceBack(t, t + 2, t + 1), e.indexArray.emplaceBack(t + 1, t + 2, t + 3);
				}
				getSortedSymbolIndexes(e) {
					if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
					let t = Math.sin(e), n = Math.cos(e), i = [], a = [], o = [];
					for (let e = 0; e < this.symbolInstances.length; ++e) {
						o.push(e);
						let s = this.symbolInstances.get(e);
						i.push(0 | Math.round(t * s.anchorX + n * s.anchorY)), a.push(s.featureIndex);
					}
					return o.sort(((e, t) => i[e] - i[t] || a[t] - a[e])), o;
				}
				addToSortKeyRanges(e, t) {
					let n = this.sortKeyRanges[this.sortKeyRanges.length - 1];
					n && n.sortKey === t ? n.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({
						sortKey: t,
						symbolInstanceStart: e,
						symbolInstanceEnd: e + 1
					});
				}
				sortFeatures(e) {
					if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
						this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
						for (let e of this.symbolInstanceIndexes) {
							let t = this.symbolInstances.get(e);
							this.featureSortOrder.push(t.featureIndex), [
								t.rightJustifiedTextSymbolIndex,
								t.centerJustifiedTextSymbolIndex,
								t.leftJustifiedTextSymbolIndex
							].forEach(((e, t, n) => {
								e >= 0 && n.indexOf(e) === t && this.addIndicesForPlacedSymbol(this.text, e);
							})), t.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, t.verticalPlacedTextSymbolIndex), t.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t.placedIconSymbolIndex), t.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, t.verticalPlacedIconSymbolIndex);
						}
						this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
					}
				}
			}
			let hd, gd;
			J("SymbolBucket", md, { omit: [
				"layers",
				"collisionBoxArray",
				"features",
				"compareText"
			] }), md.MAX_GLYPHS = 65535, md.addDynamicAttributes = ud;
			var _d = {
				get paint() {
					return gd ||= new Za({
						"icon-opacity": new Z(U.paint_symbol["icon-opacity"]),
						"icon-color": new Z(U.paint_symbol["icon-color"]),
						"icon-halo-color": new Z(U.paint_symbol["icon-halo-color"]),
						"icon-halo-width": new Z(U.paint_symbol["icon-halo-width"]),
						"icon-halo-blur": new Z(U.paint_symbol["icon-halo-blur"]),
						"icon-translate": new Y(U.paint_symbol["icon-translate"]),
						"icon-translate-anchor": new Y(U.paint_symbol["icon-translate-anchor"]),
						"text-opacity": new Z(U.paint_symbol["text-opacity"]),
						"text-color": new Z(U.paint_symbol["text-color"], {
							runtimeType: Ze,
							getOverride: (e) => e.textColor,
							hasOverride: (e) => !!e.textColor
						}),
						"text-halo-color": new Z(U.paint_symbol["text-halo-color"]),
						"text-halo-width": new Z(U.paint_symbol["text-halo-width"]),
						"text-halo-blur": new Z(U.paint_symbol["text-halo-blur"]),
						"text-translate": new Y(U.paint_symbol["text-translate"]),
						"text-translate-anchor": new Y(U.paint_symbol["text-translate-anchor"])
					});
				},
				get layout() {
					return hd ||= new Za({
						"symbol-placement": new Y(U.layout_symbol["symbol-placement"]),
						"symbol-spacing": new Y(U.layout_symbol["symbol-spacing"]),
						"symbol-avoid-edges": new Y(U.layout_symbol["symbol-avoid-edges"]),
						"symbol-sort-key": new Z(U.layout_symbol["symbol-sort-key"]),
						"symbol-z-order": new Y(U.layout_symbol["symbol-z-order"]),
						"icon-allow-overlap": new Y(U.layout_symbol["icon-allow-overlap"]),
						"icon-overlap": new Y(U.layout_symbol["icon-overlap"]),
						"icon-ignore-placement": new Y(U.layout_symbol["icon-ignore-placement"]),
						"icon-optional": new Y(U.layout_symbol["icon-optional"]),
						"icon-rotation-alignment": new Y(U.layout_symbol["icon-rotation-alignment"]),
						"icon-size": new Z(U.layout_symbol["icon-size"]),
						"icon-text-fit": new Y(U.layout_symbol["icon-text-fit"]),
						"icon-text-fit-padding": new Y(U.layout_symbol["icon-text-fit-padding"]),
						"icon-image": new Z(U.layout_symbol["icon-image"]),
						"icon-rotate": new Z(U.layout_symbol["icon-rotate"]),
						"icon-padding": new Z(U.layout_symbol["icon-padding"]),
						"icon-keep-upright": new Y(U.layout_symbol["icon-keep-upright"]),
						"icon-offset": new Z(U.layout_symbol["icon-offset"]),
						"icon-anchor": new Z(U.layout_symbol["icon-anchor"]),
						"icon-pitch-alignment": new Y(U.layout_symbol["icon-pitch-alignment"]),
						"text-pitch-alignment": new Y(U.layout_symbol["text-pitch-alignment"]),
						"text-rotation-alignment": new Y(U.layout_symbol["text-rotation-alignment"]),
						"text-field": new Z(U.layout_symbol["text-field"]),
						"text-font": new Z(U.layout_symbol["text-font"]),
						"text-size": new Z(U.layout_symbol["text-size"]),
						"text-max-width": new Z(U.layout_symbol["text-max-width"]),
						"text-line-height": new Y(U.layout_symbol["text-line-height"]),
						"text-letter-spacing": new Z(U.layout_symbol["text-letter-spacing"]),
						"text-justify": new Z(U.layout_symbol["text-justify"]),
						"text-radial-offset": new Z(U.layout_symbol["text-radial-offset"]),
						"text-variable-anchor": new Y(U.layout_symbol["text-variable-anchor"]),
						"text-variable-anchor-offset": new Z(U.layout_symbol["text-variable-anchor-offset"]),
						"text-anchor": new Z(U.layout_symbol["text-anchor"]),
						"text-max-angle": new Y(U.layout_symbol["text-max-angle"]),
						"text-writing-mode": new Y(U.layout_symbol["text-writing-mode"]),
						"text-rotate": new Z(U.layout_symbol["text-rotate"]),
						"text-padding": new Y(U.layout_symbol["text-padding"]),
						"text-keep-upright": new Y(U.layout_symbol["text-keep-upright"]),
						"text-transform": new Z(U.layout_symbol["text-transform"]),
						"text-offset": new Z(U.layout_symbol["text-offset"]),
						"text-allow-overlap": new Y(U.layout_symbol["text-allow-overlap"]),
						"text-overlap": new Y(U.layout_symbol["text-overlap"]),
						"text-ignore-placement": new Y(U.layout_symbol["text-ignore-placement"]),
						"text-optional": new Y(U.layout_symbol["text-optional"])
					});
				}
			};
			class vd {
				constructor(e) {
					if (e.property.overrides === void 0) throw Error("overrides must be provided to instantiate FormatSectionOverride class");
					this.type = e.property.overrides ? e.property.overrides.runtimeType : Je, this.defaultValue = e;
				}
				evaluate(e) {
					if (e.formattedSection) {
						let t = this.defaultValue.property.overrides;
						if (t && t.hasOverride(e.formattedSection)) return t.getOverride(e.formattedSection);
					}
					return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
				}
				eachChild(e) {
					this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
				}
				outputDefined() {
					return !1;
				}
				serialize() {
					return null;
				}
			}
			J("FormatSectionOverride", vd, { omit: ["defaultValue"] });
			class yd extends $a {
				constructor(e, t) {
					super(e, _d, t);
				}
				recalculate(e, t) {
					if (super.recalculate(e, t), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") === "point" ? "viewport" : "map"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") === "point" ? "viewport" : "map"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
						let e = this.layout.get("text-writing-mode");
						if (e) {
							let t = [];
							for (let n of e) t.indexOf(n) < 0 && t.push(n);
							this.layout._values["text-writing-mode"] = t;
						} else this.layout._values["text-writing-mode"] = ["horizontal"];
					}
					this._setPaintOverrides();
				}
				getValueAndResolveTokens(e, t, n, i) {
					let a = this.layout.get(e).evaluate(t, {}, n, i), o = this._unevaluatedLayout._values[e];
					return o.isDataDriven() || pi(o.value) || !a ? a : function(e, t) {
						return t.replace(/{([^{}]+)}/g, ((t, n) => e && n in e ? String(e[n]) : ""));
					}(t.properties, a);
				}
				createBucket(e) {
					return new md(e);
				}
				queryRadius() {
					return 0;
				}
				queryIntersectsFeature() {
					throw Error("Should take a different path in FeatureIndex");
				}
				_setPaintOverrides() {
					for (let e of _d.paint.overridableProperties) {
						if (!yd.hasPaintOverride(this.layout, e)) continue;
						let t = this.paint.get(e), n = new vd(t), i = new fi(n, t.property.specification), a = null;
						a = t.value.kind === "constant" || t.value.kind === "source" ? new hi("source", i) : new gi("composite", i, t.value.zoomStops), this.paint._values[e] = new Ka(t.property, a, t.parameters);
					}
				}
				_handleOverridablePaintPropertyUpdate(e, t, n) {
					return !(!this.layout || t.isDataDriven() || n.isDataDriven()) && yd.hasPaintOverride(this.layout, e);
				}
				static hasPaintOverride(e, t) {
					let n = e.get("text-field"), i = _d.paint.properties[t], a = !1, o = (e) => {
						for (let t of e) if (i.overrides && i.overrides.hasOverride(t)) return void (a = !0);
					};
					if (n.value.kind === "constant" && n.value.value instanceof Ht) o(n.value.value.sections);
					else if (n.value.kind === "source" || n.value.kind === "composite") {
						let e = (t) => {
							a || (t instanceof en && K(t.value) === nt ? o(t.value.sections) : t instanceof Bn ? o(t.sections) : t.eachChild(e));
						}, t = n.value;
						t._styleExpression && e(t._styleExpression.expression);
					}
					return a;
				}
			}
			let bd;
			var xd = { get paint() {
				return bd ||= new Za({
					"background-color": new Y(U.paint_background["background-color"]),
					"background-pattern": new Ya(U.paint_background["background-pattern"]),
					"background-opacity": new Y(U.paint_background["background-opacity"])
				});
			} };
			class Sd extends $a {
				constructor(e, t) {
					super(e, xd, t);
				}
			}
			class Cd extends $a {
				constructor(e, t) {
					super(e, {}, t), this.onAdd = (e) => {
						this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl);
					}, this.onRemove = (e) => {
						this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl);
					}, this.implementation = e;
				}
				is3D() {
					return this.implementation.renderingMode === "3d";
				}
				hasOffscreenPass() {
					return this.implementation.prerender !== void 0;
				}
				recalculate() {}
				updateTransitions() {}
				hasTransition() {
					return !1;
				}
				serialize() {
					throw Error("Custom layers cannot be serialized");
				}
			}
			class wd {
				constructor(e) {
					this._methodToThrottle = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
						this._triggered = !1, this._methodToThrottle();
					});
				}
				trigger() {
					this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => {
						this._triggered = !1, this._methodToThrottle();
					}), 0));
				}
				remove() {
					delete this._channel, this._methodToThrottle = () => {};
				}
			}
			let Td = { once: !0 }, Ed = 6371008.8;
			class Dd {
				constructor(e, t) {
					if (isNaN(e) || isNaN(t)) throw Error(`Invalid LngLat object: (${e}, ${t})`);
					if (this.lng = +e, this.lat = +t, this.lat > 90 || this.lat < -90) throw Error("Invalid LngLat latitude value: must be between -90 and 90");
				}
				wrap() {
					return new Dd(R(this.lng, -180, 180), this.lat);
				}
				toArray() {
					return [this.lng, this.lat];
				}
				toString() {
					return `LngLat(${this.lng}, ${this.lat})`;
				}
				distanceTo(e) {
					let t = Math.PI / 180, n = this.lat * t, i = e.lat * t, a = Math.sin(n) * Math.sin(i) + Math.cos(n) * Math.cos(i) * Math.cos((e.lng - this.lng) * t);
					return Ed * Math.acos(Math.min(a, 1));
				}
				static convert(e) {
					if (e instanceof Dd) return e;
					if (Array.isArray(e) && (e.length === 2 || e.length === 3)) return new Dd(Number(e[0]), Number(e[1]));
					if (!Array.isArray(e) && typeof e == "object" && e) return new Dd(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
					throw Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
				}
			}
			let Od = 2 * Math.PI * Ed;
			function kd(e) {
				return Od * Math.cos(e * Math.PI / 180);
			}
			function Ad(e) {
				return (180 + e) / 360;
			}
			function jd(e) {
				return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + e * Math.PI / 360))) / 360;
			}
			function Md(e, t) {
				return e / kd(t);
			}
			function Nd(e) {
				return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * e) * Math.PI / 180)) - 90;
			}
			function Pd(e, t) {
				return e * kd(Nd(t));
			}
			class Fd {
				constructor(e, t, n = 0) {
					this.x = +e, this.y = +t, this.z = +n;
				}
				static fromLngLat(e, t = 0) {
					let n = Dd.convert(e);
					return new Fd(Ad(n.lng), jd(n.lat), Md(t, n.lat));
				}
				toLngLat() {
					return new Dd(360 * this.x - 180, Nd(this.y));
				}
				toAltitude() {
					return Pd(this.z, this.y);
				}
				meterInMercatorCoordinateUnits() {
					return 1 / Od * (e = Nd(this.y), 1 / Math.cos(e * Math.PI / 180));
					var e;
				}
			}
			function Id(e, t, n) {
				var i = 2 * Math.PI * 6378137 / 256 / 2 ** n;
				return [e * i - 2 * Math.PI * 6378137 / 2, t * i - 2 * Math.PI * 6378137 / 2];
			}
			class Ld {
				constructor(e, t, n) {
					if (!function(e, t, n) {
						return !(e < 0 || e > 25 || n < 0 || n >= 2 ** e || t < 0 || t >= 2 ** e);
					}(e, t, n)) throw Error(`x=${t}, y=${n}, z=${e} outside of bounds. 0<=x<${2 ** e}, 0<=y<${2 ** e} 0<=z<=25 `);
					this.z = e, this.x = t, this.y = n, this.key = Bd(0, e, e, t, n);
				}
				equals(e) {
					return this.z === e.z && this.x === e.x && this.y === e.y;
				}
				url(e, t, n) {
					let i = (o = this.y, s = this.z, c = Id(256 * (a = this.x), 256 * (o = 2 ** s - o - 1), s), l = Id(256 * (a + 1), 256 * (o + 1), s), c[0] + "," + c[1] + "," + l[0] + "," + l[1]);
					var a, o, s, c, l;
					let u = function(e, t, n) {
						let i, a = "";
						for (let o = e; o > 0; o--) i = 1 << o - 1, a += (t & i ? 1 : 0) + (n & i ? 2 : 0);
						return a;
					}(this.z, this.x, this.y);
					return e[(this.x + this.y) % e.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n === "tms" ? 2 ** this.z - this.y - 1 : this.y)).replace(/{ratio}/g, t > 1 ? "@2x" : "").replace(/{quadkey}/g, u).replace(/{bbox-epsg-3857}/g, i);
				}
				isChildOf(e) {
					let t = this.z - e.z;
					return t > 0 && e.x === this.x >> t && e.y === this.y >> t;
				}
				getTilePoint(e) {
					let t = 2 ** this.z;
					return new n((e.x * t - this.x) * j, (e.y * t - this.y) * j);
				}
				toString() {
					return `${this.z}/${this.x}/${this.y}`;
				}
			}
			class Rd {
				constructor(e, t) {
					this.wrap = e, this.canonical = t, this.key = Bd(e, t.z, t.z, t.x, t.y);
				}
			}
			class zd {
				constructor(e, t, n, i, a) {
					if (this.terrainRttPosMatrix32f = null, e < n) throw Error(`overscaledZ should be >= z; overscaledZ = ${e}; z = ${n}`);
					this.overscaledZ = e, this.wrap = t, this.canonical = new Ld(n, +i, +a), this.key = Bd(t, e, n, i, a);
				}
				clone() {
					return new zd(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				equals(e) {
					return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
				}
				scaledTo(e) {
					if (e > this.overscaledZ) throw Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
					let t = this.canonical.z - e;
					return e > this.canonical.z ? new zd(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new zd(e, this.wrap, e, this.canonical.x >> t, this.canonical.y >> t);
				}
				isOverscaled() {
					return this.overscaledZ > this.canonical.z;
				}
				calculateScaledKey(e, t) {
					if (e > this.overscaledZ) throw Error(`targetZ > this.overscaledZ; targetZ = ${e}; overscaledZ = ${this.overscaledZ}`);
					let n = this.canonical.z - e;
					return e > this.canonical.z ? Bd(this.wrap * +t, e, this.canonical.z, this.canonical.x, this.canonical.y) : Bd(this.wrap * +t, e, e, this.canonical.x >> n, this.canonical.y >> n);
				}
				isChildOf(e) {
					if (e.wrap !== this.wrap || this.overscaledZ - e.overscaledZ <= 0) return !1;
					if (e.overscaledZ === 0) return this.overscaledZ > 0;
					let t = this.canonical.z - e.canonical.z;
					return !(t < 0) && e.canonical.x === this.canonical.x >> t && e.canonical.y === this.canonical.y >> t;
				}
				children(e) {
					if (this.overscaledZ >= e) return [new zd(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
					let t = this.canonical.z + 1, n = 2 * this.canonical.x, i = 2 * this.canonical.y;
					return [
						new zd(t, this.wrap, t, n, i),
						new zd(t, this.wrap, t, n + 1, i),
						new zd(t, this.wrap, t, n, i + 1),
						new zd(t, this.wrap, t, n + 1, i + 1)
					];
				}
				isLessThan(e) {
					return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
				}
				wrapped() {
					return new zd(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				unwrapTo(e) {
					return new zd(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
				}
				overscaleFactor() {
					return 2 ** (this.overscaledZ - this.canonical.z);
				}
				toUnwrapped() {
					return new Rd(this.wrap, this.canonical);
				}
				toString() {
					return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
				}
				getTilePoint(e) {
					return this.canonical.getTilePoint(new Fd(e.x - this.wrap, e.y));
				}
			}
			function Bd(e, t, n, i, a) {
				(e *= 2) < 0 && (e = -1 * e - 1);
				let o = 1 << n;
				return (o * o * e + o * a + i).toString(36) + n.toString(36) + t.toString(36);
			}
			function Vd(e, t) {
				return t ? e.properties[t] : e.id;
			}
			J("CanonicalTileID", Ld), J("OverscaledTileID", zd, { omit: ["terrainRttPosMatrix32f"] });
			class Hd {
				constructor() {
					this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity;
				}
				extend(e) {
					return this.minX = Math.min(this.minX, e.x), this.minY = Math.min(this.minY, e.y), this.maxX = Math.max(this.maxX, e.x), this.maxY = Math.max(this.maxY, e.y), this;
				}
				expandBy(e) {
					return this.minX -= e, this.minY -= e, this.maxX += e, this.maxY += e, (this.minX > this.maxX || this.minY > this.maxY) && (this.minX = Infinity, this.maxX = -Infinity, this.minY = Infinity, this.maxY = -Infinity), this;
				}
				shrinkBy(e) {
					return this.expandBy(-e);
				}
				map(e) {
					let t = new Hd();
					return t.extend(e(new n(this.minX, this.minY))), t.extend(e(new n(this.maxX, this.minY))), t.extend(e(new n(this.minX, this.maxY))), t.extend(e(new n(this.maxX, this.maxY))), t;
				}
				static fromPoints(e) {
					let t = new Hd();
					for (let n of e) t.extend(n);
					return t;
				}
				contains(e) {
					return e.x >= this.minX && e.x <= this.maxX && e.y >= this.minY && e.y <= this.maxY;
				}
				empty() {
					return this.minX > this.maxX;
				}
				width() {
					return this.maxX - this.minX;
				}
				height() {
					return this.maxY - this.minY;
				}
				covers(e) {
					return !this.empty() && !e.empty() && e.minX >= this.minX && e.maxX <= this.maxX && e.minY >= this.minY && e.maxY <= this.maxY;
				}
				intersects(e) {
					return !this.empty() && !e.empty() && e.minX <= this.maxX && e.maxX >= this.minX && e.minY <= this.maxY && e.maxY >= this.minY;
				}
			}
			class Ud {
				constructor(e) {
					this._stringToNumber = {}, this._numberToString = [];
					for (let t = 0; t < e.length; t++) {
						let n = e[t];
						this._stringToNumber[n] = t, this._numberToString[t] = n;
					}
				}
				encode(e) {
					return this._stringToNumber[e];
				}
				decode(e) {
					if (e >= this._numberToString.length) throw Error(`Out of bounds. Index requested n=${e} can't be >= this._numberToString.length ${this._numberToString.length}`);
					return this._numberToString[e];
				}
			}
			class Wd {
				constructor(e, t, n, i, a) {
					this.type = "Feature", this._vectorTileFeature = e, e._z = t, e._x = n, e._y = i, this.properties = e.properties, this.id = a;
				}
				get geometry() {
					return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
				}
				set geometry(e) {
					this._geometry = e;
				}
				toJSON() {
					let e = { geometry: this.geometry };
					for (let t in this) t !== "_geometry" && t !== "_vectorTileFeature" && (e[t] = this[t]);
					return e;
				}
			}
			class Gd {
				constructor(e, t) {
					this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new ga(j, 16, 0), this.grid3D = new ga(j, 16, 0), this.featureIndexArray = new Wo(), this.promoteId = t;
				}
				insert(e, t, n, i, a, o) {
					let s = this.featureIndexArray.length;
					this.featureIndexArray.emplaceBack(n, i, a);
					let c = o ? this.grid3D : this.grid;
					for (let e = 0; e < t.length; e++) {
						let n = t[e], i = [
							Infinity,
							Infinity,
							-Infinity,
							-Infinity
						];
						for (let e = 0; e < n.length; e++) {
							let t = n[e];
							i[0] = Math.min(i[0], t.x), i[1] = Math.min(i[1], t.y), i[2] = Math.max(i[2], t.x), i[3] = Math.max(i[3], t.y);
						}
						i[0] < j && i[1] < j && i[2] >= 0 && i[3] >= 0 && c.insert(s, i[0], i[1], i[2], i[3]);
					}
				}
				loadVTLayers() {
					return this.vtLayers || (this.vtLayers = new Il(new vu(this.rawTileData)).layers, this.sourceLayerCoder = new Ud(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
				}
				query(e, t, i, a) {
					this.loadVTLayers();
					let o = e.params, s = j / e.tileSize / e.scale, c = wi(o.filter, o.globalState), l = e.queryGeometry, u = e.queryPadding * s, d = Hd.fromPoints(l), f = this.grid.query(d.minX - u, d.minY - u, d.maxX + u, d.maxY + u), p = Hd.fromPoints(e.cameraQueryGeometry).expandBy(u), m = this.grid3D.query(p.minX, p.minY, p.maxX, p.maxY, ((t, i, a, o) => function(e, t, i, a, o) {
						for (let n of e) if (t <= n.x && i <= n.y && a >= n.x && o >= n.y) return !0;
						let s = [
							new n(t, i),
							new n(t, o),
							new n(a, o),
							new n(a, i)
						];
						if (e.length > 2) {
							for (let t of s) if (ic(e, t)) return !0;
						}
						for (let t = 0; t < e.length - 1; t++) if (ac(e[t], e[t + 1], s)) return !0;
						return !1;
					}(e.cameraQueryGeometry, t - u, i - u, a + u, o + u)));
					for (let e of m) f.push(e);
					f.sort(qd);
					let h = {}, g;
					for (let n = 0; n < f.length; n++) {
						let u = f[n];
						if (u === g) continue;
						g = u;
						let d = this.featureIndexArray.get(u), p = null;
						this.loadMatchingFeature(h, d.bucketIndex, d.sourceLayerIndex, d.featureIndex, c, o.layers, o.availableImages, t, i, a, ((t, n, i) => (p ||= Ws(t), n.queryIntersectsFeature({
							queryGeometry: l,
							feature: t,
							featureState: i,
							geometry: p,
							zoom: this.z,
							transform: e.transform,
							pixelsToTileUnits: s,
							pixelPosMatrix: e.pixelPosMatrix,
							unwrappedTileID: this.tileID.toUnwrapped(),
							getElevation: e.getElevation
						}))));
					}
					return h;
				}
				loadMatchingFeature(e, t, n, i, a, o, s, c, l, u, d) {
					let f = this.bucketLayerIDs[t];
					if (o && !f.some(((e) => o.has(e)))) return;
					let p = this.sourceLayerCoder.decode(n), m = this.vtLayers[p].feature(i);
					if (a.needGeometry) {
						let e = Gs(m, !0);
						if (!a.filter(new Ra(this.tileID.overscaledZ), e, this.tileID.canonical)) return;
					} else if (!a.filter(new Ra(this.tileID.overscaledZ), m)) return;
					let h = this.getId(m, p);
					for (let t = 0; t < f.length; t++) {
						let n = f[t];
						if (o && !o.has(n)) continue;
						let a = c[n];
						if (!a) continue;
						let p = {};
						h && u && (p = u.getState(a.sourceLayer || "_geojsonTileLayer", h));
						let g = te({}, l[n]);
						g.paint = Kd(g.paint, a.paint, m, p, s), g.layout = Kd(g.layout, a.layout, m, p, s);
						let _ = !d || d(m, a, p);
						if (!_) continue;
						let v = new Wd(m, this.z, this.x, this.y, h);
						v.layer = g;
						let y = e[n];
						y === void 0 && (y = e[n] = []), y.push({
							featureIndex: i,
							feature: v,
							intersectionZ: _
						});
					}
				}
				lookupSymbolFeatures(e, t, n, i, a, o, s, c) {
					let l = {};
					this.loadVTLayers();
					let u = wi(a.filterSpec, a.globalState);
					for (let a of e) this.loadMatchingFeature(l, n, i, a, u, o, s, c, t);
					return l;
				}
				hasLayer(e) {
					for (let t of this.bucketLayerIDs) for (let n of t) if (e === n) return !0;
					return !1;
				}
				getId(e, t) {
					var n;
					let i = e.id;
					return this.promoteId && (i = e.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[t]], typeof i == "boolean" && (i = Number(i)), i === void 0 && (n = e.properties) != null && n.cluster && this.promoteId && (i = Number(e.properties.cluster_id))), i;
				}
			}
			function Kd(e, t, n, i, a) {
				return ie(e, ((e, o) => {
					let s = t instanceof qa ? t.get(o) : null;
					return s && s.evaluate ? s.evaluate(n, i, a) : s;
				}));
			}
			function qd(e, t) {
				return t - e;
			}
			function Jd(e, t, i, a, o) {
				let s = [];
				for (let c = 0; c < e.length; c++) {
					let l = e[c], u;
					for (let e = 0; e < l.length - 1; e++) {
						let c = l[e], d = l[e + 1];
						c.x < t && d.x < t || (c.x < t ? c = new n(t, c.y + (t - c.x) / (d.x - c.x) * (d.y - c.y))._round() : d.x < t && (d = new n(t, c.y + (t - c.x) / (d.x - c.x) * (d.y - c.y))._round()), c.y < i && d.y < i || (c.y < i ? c = new n(c.x + (i - c.y) / (d.y - c.y) * (d.x - c.x), i)._round() : d.y < i && (d = new n(c.x + (i - c.y) / (d.y - c.y) * (d.x - c.x), i)._round()), c.x >= a && d.x >= a || (c.x >= a ? c = new n(a, c.y + (a - c.x) / (d.x - c.x) * (d.y - c.y))._round() : d.x >= a && (d = new n(a, c.y + (a - c.x) / (d.x - c.x) * (d.y - c.y))._round()), c.y >= o && d.y >= o || (c.y >= o ? c = new n(c.x + (o - c.y) / (d.y - c.y) * (d.x - c.x), o)._round() : d.y >= o && (d = new n(c.x + (o - c.y) / (d.y - c.y) * (d.x - c.x), o)._round()), u && c.equals(u[u.length - 1]) || (u = [c], s.push(u)), u.push(d)))));
					}
				}
				return s;
			}
			J("FeatureIndex", Gd, { omit: ["rawTileData", "sourceLayerCoder"] });
			class Yd extends n {
				constructor(e, t, n, i) {
					super(e, t), this.angle = n, i !== void 0 && (this.segment = i);
				}
				clone() {
					return new Yd(this.x, this.y, this.angle, this.segment);
				}
			}
			function Xd(e, t, n, i, a) {
				if (t.segment === void 0 || n === 0) return !0;
				let o = t, s = t.segment + 1, c = 0;
				for (; c > -n / 2;) {
					if (s--, s < 0) return !1;
					c -= e[s].dist(o), o = e[s];
				}
				c += e[s].dist(e[s + 1]), s++;
				let l = [], u = 0;
				for (; c < n / 2;) {
					let t = e[s], n = e[s + 1];
					if (!n) return !1;
					let o = e[s - 1].angleTo(t) - t.angleTo(n);
					for (o = Math.abs((o + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
						distance: c,
						angleDelta: o
					}), u += o; c - l[0].distance > i;) u -= l.shift().angleDelta;
					if (u > a) return !1;
					s++, c += t.dist(n);
				}
				return !0;
			}
			function Zd(e) {
				let t = 0;
				for (let n = 0; n < e.length - 1; n++) t += e[n].dist(e[n + 1]);
				return t;
			}
			function Qd(e, t, n) {
				return e ? .6 * t * n : 0;
			}
			function $d(e, t) {
				return Math.max(e ? e.right - e.left : 0, t ? t.right - t.left : 0);
			}
			function ef(e, t, n, i, a, o) {
				let s = Qd(n, a, o), c = $d(n, i) * o, l = 0, u = Zd(e) / 2;
				for (let n = 0; n < e.length - 1; n++) {
					let i = e[n], a = e[n + 1], o = i.dist(a);
					if (l + o > u) {
						let d = (u - l) / o, f = Dn.number(i.x, a.x, d), p = Dn.number(i.y, a.y, d), m = new Yd(f, p, a.angleTo(i), n);
						return m._round(), !s || Xd(e, m, c, s, t) ? m : void 0;
					}
					l += o;
				}
			}
			function tf(e, t, n, i, a, o, s, c, l) {
				let u = Qd(i, o, s), d = $d(i, a), f = d * s, p = e[0].x === 0 || e[0].x === l || e[0].y === 0 || e[0].y === l;
				return t - f < t / 4 && (t = f + t / 4), nf(e, p ? t / 2 * c % t : (d / 2 + 2 * o) * s * c % t, t, u, n, f, p, !1, l);
			}
			function nf(e, t, n, i, a, o, s, c, l) {
				let u = o / 2, d = Zd(e), f = 0, p = t - n, m = [];
				for (let t = 0; t < e.length - 1; t++) {
					let s = e[t], c = e[t + 1], h = s.dist(c), g = c.angleTo(s);
					for (; p + n < f + h;) {
						p += n;
						let _ = (p - f) / h, v = Dn.number(s.x, c.x, _), y = Dn.number(s.y, c.y, _);
						if (v >= 0 && v < l && y >= 0 && y < l && p - u >= 0 && p + u <= d) {
							let n = new Yd(v, y, g, t);
							n._round(), i && !Xd(e, n, o, i, a) || m.push(n);
						}
					}
					f += h;
				}
				return c || m.length || s || (m = nf(e, f / 2, n, i, a, o, s, !0, l)), m;
			}
			function rf(e, t, i, a) {
				let o = [], s = e.image, c = s.pixelRatio, l = s.paddedRect.w - 2, u = s.paddedRect.h - 2, d = {
					x1: e.left,
					y1: e.top,
					x2: e.right,
					y2: e.bottom
				}, f = s.stretchX || [[0, l]], p = s.stretchY || [[0, u]], m = (e, t) => e + t[1] - t[0], h = f.reduce(m, 0), g = p.reduce(m, 0), _ = l - h, v = u - g, y = 0, b = h, x = 0, S = g, C = 0, w = _, T = 0, E = v;
				if (s.content && a) {
					let t = s.content, n = t[2] - t[0], i = t[3] - t[1];
					(s.textFitWidth || s.textFitHeight) && (d = rd(e)), y = af(f, 0, t[0]), x = af(p, 0, t[1]), b = af(f, t[0], t[2]), S = af(p, t[1], t[3]), C = t[0] - y, T = t[1] - x, w = n - b, E = i - S;
				}
				let O = d.x1, k = d.y1, A = d.x2 - O, j = d.y2 - k, M = (e, a, o, l) => {
					let u = cf(e.stretch - y, b, A, O), d = lf(e.fixed - C, w, e.stretch, h), f = cf(a.stretch - x, S, j, k), p = lf(a.fixed - T, E, a.stretch, g), m = cf(o.stretch - y, b, A, O), _ = lf(o.fixed - C, w, o.stretch, h), v = cf(l.stretch - x, S, j, k), M = lf(l.fixed - T, E, l.stretch, g), N = new n(u, f), P = new n(m, f), F = new n(m, v), I = new n(u, v), ee = new n(d / c, p / c), L = new n(_ / c, M / c), R = t * Math.PI / 180;
					if (R) {
						let e = Math.sin(R), t = Math.cos(R), n = [
							t,
							-e,
							e,
							t
						];
						N._matMult(n), P._matMult(n), I._matMult(n), F._matMult(n);
					}
					let te = e.stretch + e.fixed, ne = a.stretch + a.fixed;
					return {
						tl: N,
						tr: P,
						bl: I,
						br: F,
						tex: {
							x: s.paddedRect.x + 1 + te,
							y: s.paddedRect.y + 1 + ne,
							w: o.stretch + o.fixed - te,
							h: l.stretch + l.fixed - ne
						},
						writingMode: void 0,
						glyphOffset: [0, 0],
						sectionIndex: 0,
						pixelOffsetTL: ee,
						pixelOffsetBR: L,
						minFontScaleX: w / c / A,
						minFontScaleY: E / c / j,
						isSDF: i
					};
				};
				if (a && (s.stretchX || s.stretchY)) {
					let e = sf(f, _, h), t = sf(p, v, g);
					for (let n = 0; n < e.length - 1; n++) {
						let i = e[n], a = e[n + 1];
						for (let e = 0; e < t.length - 1; e++) o.push(M(i, t[e], a, t[e + 1]));
					}
				} else o.push(M({
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: -1
				}, {
					fixed: 0,
					stretch: l + 1
				}, {
					fixed: 0,
					stretch: u + 1
				}));
				return o;
			}
			function af(e, t, n) {
				let i = 0;
				for (let a of e) i += Math.max(t, Math.min(n, a[1])) - Math.max(t, Math.min(n, a[0]));
				return i;
			}
			function sf(e, t, n) {
				let i = [{
					fixed: -1,
					stretch: 0
				}];
				for (let [t, n] of e) {
					let e = i[i.length - 1];
					i.push({
						fixed: t - e.stretch,
						stretch: e.stretch
					}), i.push({
						fixed: t - e.stretch,
						stretch: e.stretch + (n - t)
					});
				}
				return i.push({
					fixed: t + 1,
					stretch: n
				}), i;
			}
			function cf(e, t, n, i) {
				return e / t * n + i;
			}
			function lf(e, t, n, i) {
				return e - t * n / i;
			}
			J("Anchor", Yd);
			class uf {
				constructor(e, t, i, a, o, s, c, l, u, d) {
					if (this.boxStartIndex = e.length, u) {
						let e = s.top, t = s.bottom, n = s.collisionPadding;
						n && (e -= n[1], t += n[3]);
						let i = t - e;
						i > 0 && (i = Math.max(10, i), this.circleDiameter = i);
					} else {
						let u = s.image?.content && (s.image.textFitWidth || s.image.textFitHeight) ? rd(s) : {
							x1: s.left,
							y1: s.top,
							x2: s.right,
							y2: s.bottom
						};
						u.y1 = u.y1 * c - l[0], u.y2 = u.y2 * c + l[2], u.x1 = u.x1 * c - l[3], u.x2 = u.x2 * c + l[1];
						let f = s.collisionPadding;
						if (f && (u.x1 -= f[0] * c, u.y1 -= f[1] * c, u.x2 += f[2] * c, u.y2 += f[3] * c), d) {
							let e = new n(u.x1, u.y1), t = new n(u.x2, u.y1), i = new n(u.x1, u.y2), a = new n(u.x2, u.y2), o = d * Math.PI / 180;
							e._rotate(o), t._rotate(o), i._rotate(o), a._rotate(o), u.x1 = Math.min(e.x, t.x, i.x, a.x), u.x2 = Math.max(e.x, t.x, i.x, a.x), u.y1 = Math.min(e.y, t.y, i.y, a.y), u.y2 = Math.max(e.y, t.y, i.y, a.y);
						}
						e.emplaceBack(t.x, t.y, u.x1, u.y1, u.x2, u.y2, i, a, o);
					}
					this.boxEndIndex = e.length;
				}
			}
			class df {
				constructor(e = [], t = (e, t) => e < t ? -1 : e > t ? 1 : 0) {
					if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let e = (this.length >> 1) - 1; e >= 0; e--) this._down(e);
				}
				push(e) {
					this.data.push(e), this._up(this.length++);
				}
				pop() {
					if (this.length === 0) return;
					let e = this.data[0], t = this.data.pop();
					return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
				}
				peek() {
					return this.data[0];
				}
				_up(e) {
					let { data: t, compare: n } = this, i = t[e];
					for (; e > 0;) {
						let a = e - 1 >> 1, o = t[a];
						if (n(i, o) >= 0) break;
						t[e] = o, e = a;
					}
					t[e] = i;
				}
				_down(e) {
					let { data: t, compare: n } = this, i = this.length >> 1, a = t[e];
					for (; e < i;) {
						let i = 1 + (e << 1), o = i + 1;
						if (o < this.length && n(t[o], t[i]) < 0 && (i = o), n(t[i], a) >= 0) break;
						t[e] = t[i], e = i;
					}
					t[e] = a;
				}
			}
			function ff(e, t = 1, i = !1) {
				let a = Hd.fromPoints(e[0]), o = Math.min(a.width(), a.height()), s = o / 2, c = new df([], pf), { minX: l, minY: u, maxX: d, maxY: f } = a;
				if (o === 0) return new n(l, u);
				for (let t = l; t < d; t += o) for (let n = u; n < f; n += o) c.push(new mf(t + s, n + s, s, e));
				let p = function(e) {
					let t = 0, n = 0, i = 0, a = e[0];
					for (let e = 0, o = a.length, s = o - 1; e < o; s = e++) {
						let o = a[e], c = a[s], l = o.x * c.y - c.x * o.y;
						n += (o.x + c.x) * l, i += (o.y + c.y) * l, t += 3 * l;
					}
					return new mf(n / t, i / t, 0, e);
				}(e), m = c.length;
				for (; c.length;) {
					let n = c.pop();
					(n.d > p.d || !p.d) && (p = n, i && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, m)), n.max - p.d <= t || (s = n.h / 2, c.push(new mf(n.p.x - s, n.p.y - s, s, e)), c.push(new mf(n.p.x + s, n.p.y - s, s, e)), c.push(new mf(n.p.x - s, n.p.y + s, s, e)), c.push(new mf(n.p.x + s, n.p.y + s, s, e)), m += 4);
				}
				return i && (console.log(`num probes: ${m}`), console.log(`best distance: ${p.d}`)), p.p;
			}
			function pf(e, t) {
				return t.max - e.max;
			}
			function mf(e, t, i, a) {
				this.p = new n(e, t), this.h = i, this.d = function(e, t) {
					let n = !1, i = Infinity;
					for (let a = 0; a < t.length; a++) {
						let o = t[a];
						for (let t = 0, a = o.length, s = a - 1; t < a; s = t++) {
							let a = o[t], c = o[s];
							a.y > e.y != c.y > e.y && e.x < (c.x - a.x) * (e.y - a.y) / (c.y - a.y) + a.x && (n = !n), i = Math.min(i, nc(e, a, c));
						}
					}
					return (n ? 1 : -1) * Math.sqrt(i);
				}(this.p, a), this.max = this.d + this.h * Math.SQRT2;
			}
			var hf;
			e.aE = void 0, (hf = e.aE ||= {})[hf.center = 1] = "center", hf[hf.left = 2] = "left", hf[hf.right = 3] = "right", hf[hf.top = 4] = "top", hf[hf.bottom = 5] = "bottom", hf[hf["top-left"] = 6] = "top-left", hf[hf["top-right"] = 7] = "top-right", hf[hf["bottom-left"] = 8] = "bottom-left", hf[hf["bottom-right"] = 9] = "bottom-right";
			let gf = Infinity;
			function _f(e, t) {
				return t[1] === gf ? function(e, t) {
					let n = 0, i = 0;
					t < 0 && (t = 0);
					let a = t / Math.SQRT2;
					switch (e) {
						case "top-right":
						case "top-left":
							i = a - 7;
							break;
						case "bottom-right":
						case "bottom-left":
							i = 7 - a;
							break;
						case "bottom":
							i = 7 - t;
							break;
						case "top": i = t - 7;
					}
					switch (e) {
						case "top-right":
						case "bottom-right":
							n = -a;
							break;
						case "top-left":
						case "bottom-left":
							n = a;
							break;
						case "left":
							n = t;
							break;
						case "right": n = -t;
					}
					return [n, i];
				}(e, t[0]) : function(e, t, n) {
					let i = 0, a = 0;
					switch (t = Math.abs(t), n = Math.abs(n), e) {
						case "top-right":
						case "top-left":
						case "top":
							a = n - 7;
							break;
						case "bottom-right":
						case "bottom-left":
						case "bottom": a = 7 - n;
					}
					switch (e) {
						case "top-right":
						case "bottom-right":
						case "right":
							i = -t;
							break;
						case "top-left":
						case "bottom-left":
						case "left": i = t;
					}
					return [i, a];
				}(e, t[0], t[1]);
			}
			function vf(e, t, n) {
				let i = e.layout, a = i.get("text-variable-anchor-offset")?.evaluate(t, {}, n);
				if (a) {
					let e = a.values, t = [];
					for (let n = 0; n < e.length; n += 2) {
						let i = t[n] = e[n], a = e[n + 1].map(((e) => e * mu));
						i.startsWith("top") ? a[1] -= 7 : i.startsWith("bottom") && (a[1] += 7), t[n + 1] = a;
					}
					return new Jt(t);
				}
				let o = i.get("text-variable-anchor");
				if (o) {
					let a;
					a = e._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? i.get("text-offset").evaluate(t, {}, n).map(((e) => e * mu)) : [i.get("text-radial-offset").evaluate(t, {}, n) * mu, gf];
					let s = [];
					for (let e of o) s.push(e, _f(e, a));
					return new Jt(s);
				}
				return null;
			}
			function yf(e) {
				switch (e) {
					case "right":
					case "top-right":
					case "bottom-right": return "right";
					case "left":
					case "top-left":
					case "bottom-left": return "left";
				}
				return "center";
			}
			function bf(t, n, i, a, o, s, c, l, u, d, f, p) {
				let m = s.textMaxSize.evaluate(n, {});
				m === void 0 && (m = c);
				let h = t.layers[0].layout, g = h.get("icon-offset").evaluate(n, {}, f), _ = Sf(i.horizontal), v = c / 24, y = t.tilePixelRatio * v, b = t.tilePixelRatio * m / 24, x = t.tilePixelRatio * l, S = t.tilePixelRatio * h.get("symbol-spacing"), C = h.get("text-padding") * t.tilePixelRatio, w = function(e, t, n, i = 1) {
					let a = e.get("icon-padding").evaluate(t, {}, n), o = a && a.values;
					return [
						o[0] * i,
						o[1] * i,
						o[2] * i,
						o[3] * i
					];
				}(h, n, f, t.tilePixelRatio), T = h.get("text-max-angle") / 180 * Math.PI, E = h.get("text-rotation-alignment") !== "viewport" && h.get("symbol-placement") !== "point", O = h.get("icon-rotation-alignment") === "map" && h.get("symbol-placement") !== "point", k = h.get("symbol-placement"), A = S / 2, M = h.get("icon-text-fit"), N;
				a && M !== "none" && (t.allowVerticalPlacement && i.vertical && (N = id(a, i.vertical, M, h.get("icon-text-fit-padding"), g, v)), _ && (a = id(a, _, M, h.get("icon-text-fit-padding"), g, v)));
				let P = f ? p.line.getGranularityForZoomLevel(f.z) : 1, F = (l, p) => {
					p.x < 0 || p.x >= j || p.y < 0 || p.y >= j || function(t, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _, v, y, b, x, S, C, w, T, E) {
						let O = t.addToLineVertexArray(n, i), k, A, j, M, N = 0, P = 0, F = 0, I = 0, ee = -1, L = -1, R = {}, te = bs("");
						if (t.allowVerticalPlacement && a.vertical) {
							let e = l.layout.get("text-rotate").evaluate(S, {}, T) + 90;
							j = new uf(u, n, d, f, p, a.vertical, m, h, g, e), c && (M = new uf(u, n, d, f, p, c, v, y, g, e));
						}
						if (o) {
							let i = l.layout.get("icon-rotate").evaluate(S, {}), a = l.layout.get("icon-text-fit") !== "none", s = rf(o, i, w, a), m = c ? rf(c, i, w, a) : void 0;
							A = new uf(u, n, d, f, p, o, v, y, !1, i), N = 4 * s.length;
							let h = t.iconSizeData, g = null;
							h.kind === "source" ? (g = [128 * l.layout.get("icon-size").evaluate(S, {})], g[0] > ad && se(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : h.kind === "composite" && (g = [128 * C.compositeIconSizes[0].evaluate(S, {}, T), 128 * C.compositeIconSizes[1].evaluate(S, {}, T)], (g[0] > ad || g[1] > ad) && se(`${t.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t.addSymbols(t.icon, s, g, x, b, S, e.ao.none, n, O.lineStartIndex, O.lineLength, -1, T), ee = t.icon.placedSymbolArray.length - 1, m && (P = 4 * m.length, t.addSymbols(t.icon, m, g, x, b, S, e.ao.vertical, n, O.lineStartIndex, O.lineLength, -1, T), L = t.icon.placedSymbolArray.length - 1);
						}
						let ne = Object.keys(a.horizontal);
						for (let i of ne) {
							let o = a.horizontal[i];
							if (!k) {
								te = bs(o.text);
								let e = l.layout.get("text-rotate").evaluate(S, {}, T);
								k = new uf(u, n, d, f, p, o, m, h, g, e);
							}
							let c = o.positionedLines.length === 1;
							if (F += xf(t, n, o, s, l, g, S, _, O, a.vertical ? e.ao.horizontal : e.ao.horizontalOnly, c ? ne : [i], R, ee, C, T), c) break;
						}
						a.vertical && (I += xf(t, n, a.vertical, s, l, g, S, _, O, e.ao.vertical, ["vertical"], R, L, C, T));
						let ie = k ? k.boxStartIndex : t.collisionBoxArray.length, ae = k ? k.boxEndIndex : t.collisionBoxArray.length, oe = j ? j.boxStartIndex : t.collisionBoxArray.length, z = j ? j.boxEndIndex : t.collisionBoxArray.length, ce = A ? A.boxStartIndex : t.collisionBoxArray.length, le = A ? A.boxEndIndex : t.collisionBoxArray.length, ue = M ? M.boxStartIndex : t.collisionBoxArray.length, de = M ? M.boxEndIndex : t.collisionBoxArray.length, fe = -1, pe = (e, t) => e && e.circleDiameter ? Math.max(e.circleDiameter, t) : t;
						fe = pe(k, fe), fe = pe(j, fe), fe = pe(A, fe), fe = pe(M, fe);
						let V = fe > -1 ? 1 : 0;
						V && (fe *= E / mu), t.glyphOffsetArray.length >= md.MAX_GLYPHS && se("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), S.sortKey !== void 0 && t.addToSortKeyRanges(t.symbolInstances.length, S.sortKey);
						let me = vf(l, S, T), [he, ge] = function(t, n) {
							let i = t.length, a = n?.values;
							if (a?.length > 0) for (let n = 0; n < a.length; n += 2) {
								let i = a[n + 1];
								t.emplaceBack(e.aE[a[n]], i[0], i[1]);
							}
							return [i, t.length];
						}(t.textAnchorOffsets, me);
						t.symbolInstances.emplaceBack(n.x, n.y, R.right >= 0 ? R.right : -1, R.center >= 0 ? R.center : -1, R.left >= 0 ? R.left : -1, R.vertical || -1, ee, L, te, ie, ae, oe, z, ce, le, ue, de, d, F, I, N, P, V, 0, m, fe, he, ge);
					}(t, p, l, i, a, o, N, t.layers[0], t.collisionBoxArray, n.index, n.sourceLayerIndex, t.index, y, [
						C,
						C,
						C,
						C
					], E, u, x, w, O, g, n, s, d, f, c);
				};
				if (k === "line") for (let e of Jd(n.geometry, 0, 0, j, j)) {
					let n = yl(e, P), o = tf(n, S, T, i.vertical || _, a, 24, b, t.overscaling, j);
					for (let e of o) _ && Cf(t, _.text, A, e) || F(n, e);
				}
				else if (k === "line-center") {
					for (let e of n.geometry) if (e.length > 1) {
						let t = yl(e, P), n = ef(t, T, i.vertical || _, a, 24, b);
						n && F(t, n);
					}
				} else if (n.type === "Polygon") for (let e of fr(n.geometry, 0)) {
					let t = ff(e, 16);
					F(yl(e[0], P, !0), new Yd(t.x, t.y, 0));
				}
				else if (n.type === "LineString") for (let e of n.geometry) {
					let t = yl(e, P);
					F(t, new Yd(t[0].x, t[0].y, 0));
				}
				else if (n.type === "Point") for (let e of n.geometry) for (let t of e) F([t], new Yd(t.x, t.y, 0));
			}
			function xf(e, t, i, a, o, s, c, l, u, d, f, p, m, h, g) {
				let _ = function(e, t, i, a, o, s, c, l) {
					let u = a.layout.get("text-rotate").evaluate(s, {}) * Math.PI / 180, d = [];
					for (let e of t.positionedLines) for (let a of e.positionedGlyphs) {
						if (!a.rect) continue;
						let s = a.rect || {}, f = 4, p = !0, m = 1, h = 0, g = (o || l) && a.vertical, _ = a.metrics.advance * a.scale / 2;
						if (l && t.verticalizable && (h = e.lineOffset / 2 - (a.imageName ? -(mu - a.metrics.width * a.scale) / 2 : (a.scale - 1) * mu)), a.imageName) {
							let e = c[a.imageName];
							p = e.sdf, m = e.pixelRatio, f = 1 / m;
						}
						let v = o ? [a.x + _, a.y] : [0, 0], y = o ? [0, 0] : [a.x + _ + i[0], a.y + i[1] - h], b = [0, 0];
						g && (b = y, y = [0, 0]);
						let x = a.metrics.isDoubleResolution ? 2 : 1, S = (a.metrics.left - f) * a.scale - _ + y[0], C = (-a.metrics.top - f) * a.scale + y[1], w = S + s.w / x * a.scale / m, T = C + s.h / x * a.scale / m, E = new n(S, C), O = new n(w, C), k = new n(S, T), A = new n(w, T);
						if (g) {
							let e = new n(-_, _ - -17), t = -Math.PI / 2, i = 12 - _, o = new n(22 - i, -(a.imageName ? i : 0)), s = new n(...b);
							E._rotateAround(t, e)._add(o)._add(s), O._rotateAround(t, e)._add(o)._add(s), k._rotateAround(t, e)._add(o)._add(s), A._rotateAround(t, e)._add(o)._add(s);
						}
						if (u) {
							let e = Math.sin(u), t = Math.cos(u), n = [
								t,
								-e,
								e,
								t
							];
							E._matMult(n), O._matMult(n), k._matMult(n), A._matMult(n);
						}
						let j = new n(0, 0), M = new n(0, 0);
						d.push({
							tl: E,
							tr: O,
							bl: k,
							br: A,
							tex: s,
							writingMode: t.writingMode,
							glyphOffset: v,
							sectionIndex: a.sectionIndex,
							isSDF: p,
							pixelOffsetTL: j,
							pixelOffsetBR: M,
							minFontScaleX: 0,
							minFontScaleY: 0
						});
					}
					return d;
				}(0, i, l, o, s, c, a, e.allowVerticalPlacement), v = e.textSizeData, y = null;
				v.kind === "source" ? (y = [128 * o.layout.get("text-size").evaluate(c, {})], y[0] > ad && se(`${e.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : v.kind === "composite" && (y = [128 * h.compositeTextSizes[0].evaluate(c, {}, g), 128 * h.compositeTextSizes[1].evaluate(c, {}, g)], (y[0] > ad || y[1] > ad) && se(`${e.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), e.addSymbols(e.text, _, y, l, s, c, d, t, u.lineStartIndex, u.lineLength, m, g);
				for (let t of f) p[t] = e.text.placedSymbolArray.length - 1;
				return 4 * _.length;
			}
			function Sf(e) {
				for (let t in e) return e[t];
				return null;
			}
			function Cf(e, t, n, i) {
				let a = e.compareText;
				if (t in a) {
					let e = a[t];
					for (let t = e.length - 1; t >= 0; t--) if (i.dist(e[t]) < n) return !0;
				} else a[t] = [];
				return a[t].push(i), !1;
			}
			let wf = [
				Int8Array,
				Uint8Array,
				Uint8ClampedArray,
				Int16Array,
				Uint16Array,
				Int32Array,
				Uint32Array,
				Float32Array,
				Float64Array
			];
			class Tf {
				static from(e) {
					if (!(e instanceof ArrayBuffer)) throw Error("Data must be an instance of ArrayBuffer.");
					let [t, n] = new Uint8Array(e, 0, 2);
					if (t !== 219) throw Error("Data does not appear to be in a KDBush format.");
					let i = n >> 4;
					if (i !== 1) throw Error(`Got v${i} data when expected v1.`);
					let a = wf[15 & n];
					if (!a) throw Error("Unrecognized array type.");
					let [o] = new Uint16Array(e, 2, 1), [s] = new Uint32Array(e, 4, 1);
					return new Tf(s, o, a, e);
				}
				constructor(e, t = 64, n = Float64Array, i) {
					if (isNaN(e) || e < 0) throw Error(`Unpexpected numItems value: ${e}.`);
					this.numItems = +e, this.nodeSize = Math.min(Math.max(+t, 2), 65535), this.ArrayType = n, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
					let a = wf.indexOf(this.ArrayType), o = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, s = e * this.IndexArrayType.BYTES_PER_ELEMENT, c = (8 - s % 8) % 8;
					if (a < 0) throw Error(`Unexpected typed array class: ${n}.`);
					i && i instanceof ArrayBuffer ? (this.data = i, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + s + c, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + o + s + c), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + s + c, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + a]), new Uint16Array(this.data, 2, 1)[0] = t, new Uint32Array(this.data, 4, 1)[0] = e);
				}
				add(e, t) {
					let n = this._pos >> 1;
					return this.ids[n] = n, this.coords[this._pos++] = e, this.coords[this._pos++] = t, n;
				}
				finish() {
					let e = this._pos >> 1;
					if (e !== this.numItems) throw Error(`Added ${e} items when expected ${this.numItems}.`);
					return Ef(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
				}
				range(e, t, n, i) {
					if (!this._finished) throw Error("Data not yet indexed - call index.finish().");
					let { ids: a, coords: o, nodeSize: s } = this, c = [
						0,
						a.length - 1,
						0
					], l = [];
					for (; c.length;) {
						let u = c.pop() || 0, d = c.pop() || 0, f = c.pop() || 0;
						if (d - f <= s) {
							for (let s = f; s <= d; s++) {
								let c = o[2 * s], u = o[2 * s + 1];
								c >= e && c <= n && u >= t && u <= i && l.push(a[s]);
							}
							continue;
						}
						let p = f + d >> 1, m = o[2 * p], h = o[2 * p + 1];
						m >= e && m <= n && h >= t && h <= i && l.push(a[p]), (u === 0 ? e <= m : t <= h) && (c.push(f), c.push(p - 1), c.push(1 - u)), (u === 0 ? n >= m : i >= h) && (c.push(p + 1), c.push(d), c.push(1 - u));
					}
					return l;
				}
				within(e, t, n) {
					if (!this._finished) throw Error("Data not yet indexed - call index.finish().");
					let { ids: i, coords: a, nodeSize: o } = this, s = [
						0,
						i.length - 1,
						0
					], c = [], l = n * n;
					for (; s.length;) {
						let u = s.pop() || 0, d = s.pop() || 0, f = s.pop() || 0;
						if (d - f <= o) {
							for (let n = f; n <= d; n++) Af(a[2 * n], a[2 * n + 1], e, t) <= l && c.push(i[n]);
							continue;
						}
						let p = f + d >> 1, m = a[2 * p], h = a[2 * p + 1];
						Af(m, h, e, t) <= l && c.push(i[p]), (u === 0 ? e - n <= m : t - n <= h) && (s.push(f), s.push(p - 1), s.push(1 - u)), (u === 0 ? e + n >= m : t + n >= h) && (s.push(p + 1), s.push(d), s.push(1 - u));
					}
					return c;
				}
			}
			function Ef(e, t, n, i, a, o) {
				if (a - i <= n) return;
				let s = i + a >> 1;
				Df(e, t, s, i, a, o), Ef(e, t, n, i, s - 1, 1 - o), Ef(e, t, n, s + 1, a, 1 - o);
			}
			function Df(e, t, n, i, a, o) {
				for (; a > i;) {
					if (a - i > 600) {
						let s = a - i + 1, c = n - i + 1, l = Math.log(s), u = .5 * Math.exp(2 * l / 3), d = .5 * Math.sqrt(l * u * (s - u) / s) * (c - s / 2 < 0 ? -1 : 1);
						Df(e, t, n, Math.max(i, Math.floor(n - c * u / s + d)), Math.min(a, Math.floor(n + (s - c) * u / s + d)), o);
					}
					let s = t[2 * n + o], c = i, l = a;
					for (Of(e, t, i, n), t[2 * a + o] > s && Of(e, t, i, a); c < l;) {
						for (Of(e, t, c, l), c++, l--; t[2 * c + o] < s;) c++;
						for (; t[2 * l + o] > s;) l--;
					}
					t[2 * i + o] === s ? Of(e, t, i, l) : (l++, Of(e, t, l, a)), l <= n && (i = l + 1), n <= l && (a = l - 1);
				}
			}
			function Of(e, t, n, i) {
				kf(e, n, i), kf(t, 2 * n, 2 * i), kf(t, 2 * n + 1, 2 * i + 1);
			}
			function kf(e, t, n) {
				let i = e[t];
				e[t] = e[n], e[n] = i;
			}
			function Af(e, t, n, i) {
				let a = e - n, o = t - i;
				return a * a + o * o;
			}
			var jf;
			e.cx = void 0, (jf = e.cx ||= {}).create = "create", jf.load = "load", jf.fullLoad = "fullLoad";
			let Mf = null, Nf = [], Pf = 1e3 / 60, Ff = "loadTime", If = "fullLoadTime";
			e.$ = j, e.A = m, e.B = function([e, t, n]) {
				return t += 90, t *= Math.PI / 180, n *= Math.PI / 180, {
					x: e * Math.cos(t) * Math.sin(n),
					y: e * Math.sin(t) * Math.sin(n),
					z: e * Math.cos(n)
				};
			}, e.C = Dn, e.D = Y, e.E = Ne, e.F = Ra, e.G = fa, e.H = de, e.I = Pu, e.J = class {
				constructor(e, t) {
					this.target = e, this.mapId = t, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new wd((() => this.process())), this.subscription = ge(this.target, "message", ((e) => this.receive(e)), !1), this.globalScope = le(self) ? e : window;
				}
				registerMessageHandler(e, t) {
					this.messageHandlers[e] = t;
				}
				sendAsync(e, t) {
					return new Promise(((n, i) => {
						let a = Math.round(0xde0b6b3a7640000 * Math.random()).toString(36).substring(0, 10), o = t ? ge(t.signal, "abort", (() => {
							o?.unsubscribe(), delete this.resolveRejects[a];
							let t = {
								id: a,
								type: "<cancel>",
								origin: location.origin,
								targetMapId: e.targetMapId,
								sourceMapId: this.mapId
							};
							this.target.postMessage(t);
						}), Td) : null;
						this.resolveRejects[a] = {
							resolve: (e) => {
								o?.unsubscribe(), n(e);
							},
							reject: (e) => {
								o?.unsubscribe(), i(e);
							}
						};
						let s = [], c = Object.assign(Object.assign({}, e), {
							id: a,
							sourceMapId: this.mapId,
							origin: location.origin,
							data: xa(e.data, s)
						});
						this.target.postMessage(c, { transfer: s });
					}));
				}
				receive(e) {
					let t = e.data, n = t.id;
					if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
						if (t.type === "<cancel>") {
							delete this.tasks[n];
							let e = this.abortControllers[n];
							delete this.abortControllers[n], e && e.abort();
							return;
						}
						if (le(self) || t.mustQueue) return this.tasks[n] = t, this.taskQueue.push(n), void this.invoker.trigger();
						this.processTask(n, t);
					}
				}
				process() {
					if (this.taskQueue.length === 0) return;
					let e = this.taskQueue.shift(), t = this.tasks[e];
					delete this.tasks[e], this.taskQueue.length > 0 && this.invoker.trigger(), t && this.processTask(e, t);
				}
				processTask(e, n) {
					return t(this, void 0, void 0, (function* () {
						if (n.type === "<response>") {
							let t = this.resolveRejects[e];
							if (delete this.resolveRejects[e], !t) return;
							n.error ? t.reject(Sa(n.error)) : t.resolve(Sa(n.data));
							return;
						}
						if (!this.messageHandlers[n.type]) return void this.completeTask(e, /* @__PURE__ */ Error(`Could not find a registered handler for ${n.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
						let t = Sa(n.data), i = new AbortController();
						this.abortControllers[e] = i;
						try {
							let a = yield this.messageHandlers[n.type](n.sourceMapId, t, i);
							this.completeTask(e, null, a);
						} catch (t) {
							this.completeTask(e, t);
						}
					}));
				}
				completeTask(e, t, n) {
					let i = [];
					delete this.abortControllers[e];
					let a = {
						id: e,
						type: "<response>",
						sourceMapId: this.mapId,
						origin: location.origin,
						error: t ? xa(t) : null,
						data: xa(n, i)
					};
					this.target.postMessage(a, { transfer: i });
				}
				remove() {
					this.invoker.remove(), this.subscription.unsubscribe();
				}
			}, e.K = we, e.L = function() {
				var e = new m(16);
				return m != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0), e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e;
			}, e.M = function(e, t, n) {
				var i, a, o, s, c, l, u, d, f, p, m, h, g = n[0], _ = n[1], v = n[2];
				return t === e ? (e[12] = t[0] * g + t[4] * _ + t[8] * v + t[12], e[13] = t[1] * g + t[5] * _ + t[9] * v + t[13], e[14] = t[2] * g + t[6] * _ + t[10] * v + t[14], e[15] = t[3] * g + t[7] * _ + t[11] * v + t[15]) : (a = t[1], o = t[2], s = t[3], c = t[4], l = t[5], u = t[6], d = t[7], f = t[8], p = t[9], m = t[10], h = t[11], e[0] = i = t[0], e[1] = a, e[2] = o, e[3] = s, e[4] = c, e[5] = l, e[6] = u, e[7] = d, e[8] = f, e[9] = p, e[10] = m, e[11] = h, e[12] = i * g + c * _ + f * v + t[12], e[13] = a * g + l * _ + p * v + t[13], e[14] = o * g + u * _ + m * v + t[14], e[15] = s * g + d * _ + h * v + t[15]), e;
			}, e.N = function(e, t, n) {
				var i = n[0], a = n[1], o = n[2];
				return e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i, e[3] = t[3] * i, e[4] = t[4] * a, e[5] = t[5] * a, e[6] = t[6] * a, e[7] = t[7] * a, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = t[11] * o, e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
			}, e.O = function(e, t, n) {
				var i = t[0], a = t[1], o = t[2], s = t[3], c = t[4], l = t[5], u = t[6], d = t[7], f = t[8], p = t[9], m = t[10], h = t[11], g = t[12], _ = t[13], v = t[14], y = t[15], b = n[0], x = n[1], S = n[2], C = n[3];
				return e[0] = b * i + x * c + S * f + C * g, e[1] = b * a + x * l + S * p + C * _, e[2] = b * o + x * u + S * m + C * v, e[3] = b * s + x * d + S * h + C * y, e[4] = (b = n[4]) * i + (x = n[5]) * c + (S = n[6]) * f + (C = n[7]) * g, e[5] = b * a + x * l + S * p + C * _, e[6] = b * o + x * u + S * m + C * v, e[7] = b * s + x * d + S * h + C * y, e[8] = (b = n[8]) * i + (x = n[9]) * c + (S = n[10]) * f + (C = n[11]) * g, e[9] = b * a + x * l + S * p + C * _, e[10] = b * o + x * u + S * m + C * v, e[11] = b * s + x * d + S * h + C * y, e[12] = (b = n[12]) * i + (x = n[13]) * c + (S = n[14]) * f + (C = n[15]) * g, e[13] = b * a + x * l + S * p + C * _, e[14] = b * o + x * u + S * m + C * v, e[15] = b * s + x * d + S * h + C * y, e;
			}, e.P = n, e.Q = function(e, t) {
				let n = {};
				for (let i = 0; i < t.length; i++) {
					let a = t[i];
					a in e && (n[a] = e[a]);
				}
				return n;
			}, e.R = Ec, e.S = Dd, e.T = Fc, e.U = jd, e.V = Ad, e.W = d, e.X = f, e.Y = V, e.Z = zd, e._ = t, e.a = Se, e.a$ = w, e.a0 = function(e, t) {
				if (!e) return t ?? {};
				if (!t) return e;
				let n = Object.assign({}, e);
				if (t.removeAll && (n = { removeAll: !0 }), t.remove) {
					let i = new Set(t.remove);
					n.add &&= n.add.filter(((e) => !i.has(e.id))), n.update &&= n.update.filter(((e) => !i.has(e.id)));
					let a = new Set((e.add ?? []).map(((e) => e.id)));
					t.remove = t.remove.filter(((e) => !a.has(e)));
				}
				if (t.remove) {
					let e = new Set(n.remove ? n.remove.concat(t.remove) : t.remove);
					n.remove = Array.from(e.values());
				}
				if (t.add) {
					let e = n.add ? n.add.concat(t.add) : t.add, i = new Map(e.map(((e) => [e.id, e])));
					n.add = Array.from(i.values());
				}
				if (t.update) {
					let e = new Map(n.update?.map(((e) => [e.id, e])));
					for (let n of t.update) {
						let t = e.get(n.id) ?? { id: n.id };
						n.newGeometry && (t.newGeometry = n.newGeometry), n.addOrUpdateProperties && (t.addOrUpdateProperties = (t.addOrUpdateProperties ?? []).concat(n.addOrUpdateProperties)), n.removeProperties && (t.removeProperties = (t.removeProperties ?? []).concat(n.removeProperties)), n.removeAllProperties && (t.removeAllProperties = !0), e.set(n.id, t);
					}
					n.update = Array.from(e.values());
				}
				return n.remove && n.add && (n.remove = n.remove.filter(((e) => n.add.findIndex(((t) => t.id === e)) === -1))), n;
			}, e.a1 = Fd, e.a2 = Hd, e.a3 = 25, e.a4 = Ld, e.a5 = (e) => {
				let t = window.document.createElement("video");
				return t.muted = !0, new Promise(((n) => {
					t.onloadstart = () => {
						n(t);
					};
					for (let n of e) {
						let e = window.document.createElement("source");
						Oe(n) || (t.crossOrigin = "Anonymous"), e.src = n, t.appendChild(e);
					}
				}));
			}, e.a6 = W, e.a7 = function() {
				return ne++;
			}, e.a8 = Po, e.a9 = md, e.aA = function(e) {
				let t = Infinity, n = Infinity, i = -Infinity, a = -Infinity;
				for (let o of e) t = Math.min(t, o.x), n = Math.min(n, o.y), i = Math.max(i, o.x), a = Math.max(a, o.y);
				return [
					t,
					n,
					i,
					a
				];
			}, e.aB = mu, e.aC = M, e.aD = function(e, t, n, i, a = !1) {
				if (!n[0] && !n[1]) return [0, 0];
				let o = a ? i === "map" ? -e.bearingInRadians : 0 : i === "viewport" ? e.bearingInRadians : 0;
				if (o) {
					let e = Math.sin(o), t = Math.cos(o);
					n = [n[0] * t - n[1] * e, n[0] * e + n[1] * t];
				}
				return [a ? n[0] : M(t, n[0], e.zoom), a ? n[1] : M(t, n[1], e.zoom)];
			}, e.aF = sd, e.aG = yf, e.aH = Yu, e.aI = Tf, e.aJ = oo, e.aK = ml, e.aL = Go, e.aM = ls, e.aN = os, e.aO = R, e.aP = H, e.aQ = Pd, e.aR = x, e.aS = b, e.aT = function(e) {
				var t = new m(3);
				return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;
			}, e.aU = function(e, t, n) {
				return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e[2] = t[2] - n[2], e;
			}, e.aV = function(e, t) {
				var n = t[0], i = t[1], a = t[2], o = n * n + i * i + a * a;
				return o > 0 && (o = 1 / Math.sqrt(o)), e[0] = t[0] * o, e[1] = t[1] * o, e[2] = t[2] * o, e;
			}, e.aW = S, e.aX = function(e, t) {
				return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
			}, e.aY = function(e, t, n) {
				return e[0] = t[0] * n[0], e[1] = t[1] * n[1], e[2] = t[2] * n[2], e[3] = t[3] * n[3], e;
			}, e.aZ = v, e.a_ = function(e, t, n) {
				let i = t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
				return i === 0 ? null : (-(e[0] * n[0] + e[1] * n[1] + e[2] * n[2]) - n[3]) / i;
			}, e.aa = wi, e.ab = Gs, e.ac = Wd, e.ad = function(e) {
				let t = {};
				if (e.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((e, n, i, a) => {
					let o = i || a;
					return t[n] = !o || o.toLowerCase(), "";
				})), t["max-age"]) {
					let e = parseInt(t["max-age"], 10);
					isNaN(e) ? delete t["max-age"] : t["max-age"] = e;
				}
				return t;
			}, e.ae = L, e.af = 85.051129, e.ag = _e, e.ah = function(e) {
				return 2 ** e;
			}, e.ai = g, e.aj = Md, e.ak = function(e) {
				return Math.log(e) / Math.LN2;
			}, e.al = function(e) {
				var t = e[0], n = e[1];
				return t * t + n * n;
			}, e.am = function(e) {
				if (!e.length) return /* @__PURE__ */ new Set();
				let t = Math.max(...e.map(((e) => e.canonical.z))), n = Infinity, i = -Infinity, a = Infinity, o = -Infinity, s = [];
				for (let c of e) {
					let { x: e, y: l, z: u } = c.canonical, d = 2 ** (t - u), f = e * d, p = l * d;
					s.push({
						id: c,
						x: f,
						y: p
					}), f < n && (n = f), f > i && (i = f), p < a && (a = p), p > o && (o = p);
				}
				let c = /* @__PURE__ */ new Set();
				for (let e of s) e.x !== n && e.x !== i && e.y !== a && e.y !== o || c.add(e.id);
				return c;
			}, e.an = function(e, t) {
				let n = 0, i = 0;
				if (e.kind === "constant") i = e.layoutSize;
				else if (e.kind !== "source") {
					let { interpolationType: a, minZoom: o, maxZoom: s } = e, c = a ? L(Tn.interpolationFactor(a, t, o, s), 0, 1) : 0;
					e.kind === "camera" ? i = Dn.number(e.minSize, e.maxSize, c) : n = c;
				}
				return {
					uSizeT: n,
					uSize: i
				};
			}, e.ap = function(e, { uSize: t, uSizeT: n }, { lowerSize: i, upperSize: a }) {
				return e.kind === "source" ? i / 128 : e.kind === "composite" ? Dn.number(i / 128, a / 128, n) : t;
			}, e.aq = function(e, t) {
				var n = t[0], i = t[1], a = t[2], o = t[3], s = t[4], c = t[5], l = t[6], u = t[7], d = t[8], f = t[9], p = t[10], m = t[11], h = t[12], g = t[13], _ = t[14], v = t[15], y = n * c - i * s, b = n * l - a * s, x = n * u - o * s, S = i * l - a * c, C = i * u - o * c, w = a * u - o * l, T = d * g - f * h, E = d * _ - p * h, O = d * v - m * h, k = f * _ - p * g, A = f * v - m * g, j = p * v - m * _, M = y * j - b * A + x * k + S * O - C * E + w * T;
				return M ? (e[0] = (c * j - l * A + u * k) * (M = 1 / M), e[1] = (a * A - i * j - o * k) * M, e[2] = (g * w - _ * C + v * S) * M, e[3] = (p * C - f * w - m * S) * M, e[4] = (l * O - s * j - u * E) * M, e[5] = (n * j - a * O + o * E) * M, e[6] = (_ * x - h * w - v * b) * M, e[7] = (d * w - p * x + m * b) * M, e[8] = (s * A - c * O + u * T) * M, e[9] = (i * O - n * A - o * T) * M, e[10] = (h * C - g * x + v * y) * M, e[11] = (f * x - d * C - m * y) * M, e[12] = (c * E - s * k - l * T) * M, e[13] = (n * k - i * E + a * T) * M, e[14] = (g * b - h * S - _ * y) * M, e[15] = (d * S - f * b + p * y) * M, e) : null;
			}, e.ar = k, e.as = function(e) {
				var t = e[0], n = e[1];
				return Math.sqrt(t * t + n * n);
			}, e.at = function(e) {
				return e[0] = 0, e[1] = 0, e;
			}, e.au = function(e, t, n) {
				return e[0] = t[0] * n, e[1] = t[1] * n, e;
			}, e.av = ud, e.aw = T, e.ax = function(e, t, i, a) {
				let o = t.y - e.y, s = t.x - e.x, c = a.y - i.y, l = a.x - i.x, u = c * s - l * o;
				if (u === 0) return null;
				let d = (l * (e.y - i.y) - c * (e.x - i.x)) / u;
				return new n(e.x + d * s, e.y + d * o);
			}, e.ay = Jd, e.az = Ys, e.b = fe, e.b$ = class extends Ts {
				constructor(e, t) {
					super(e, t), this.current = [];
				}
				set(e) {
					if (e != this.current) {
						this.current = e;
						let t = new Float32Array(e);
						this.gl.uniform1fv(this.location, t);
					}
				}
			}, e.b0 = function(e, t, n) {
				return e[0] = t[0] * n, e[1] = t[1] * n, e[2] = t[2] * n, e[3] = t[3] * n, e;
			}, e.b1 = function(e, t) {
				return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3];
			}, e.b2 = Rd, e.b3 = Bd, e.b4 = function(e, t, n, i, a) {
				var o = 1 / Math.tan(t / 2);
				if (e[0] = o / n, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = o, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[11] = -1, e[12] = 0, e[13] = 0, e[15] = 0, a != null && a !== Infinity) {
					var s = 1 / (i - a);
					e[10] = (a + i) * s, e[14] = 2 * a * i * s;
				} else e[10] = -1, e[14] = -2 * i;
				return e;
			}, e.b5 = function(e) {
				var t = new m(16);
				return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
			}, e.b6 = function(e, t, n) {
				var i = Math.sin(n), a = Math.cos(n), o = t[0], s = t[1], c = t[2], l = t[3], u = t[4], d = t[5], f = t[6], p = t[7];
				return t !== e && (e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * a + u * i, e[1] = s * a + d * i, e[2] = c * a + f * i, e[3] = l * a + p * i, e[4] = u * a - o * i, e[5] = d * a - s * i, e[6] = f * a - c * i, e[7] = p * a - l * i, e;
			}, e.b7 = function(e, t, n) {
				var i = Math.sin(n), a = Math.cos(n), o = t[4], s = t[5], c = t[6], l = t[7], u = t[8], d = t[9], f = t[10], p = t[11];
				return t !== e && (e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[4] = o * a + u * i, e[5] = s * a + d * i, e[6] = c * a + f * i, e[7] = l * a + p * i, e[8] = u * a - o * i, e[9] = d * a - s * i, e[10] = f * a - c * i, e[11] = p * a - l * i, e;
			}, e.b8 = function() {
				let e = new Float32Array(16);
				return g(e), e;
			}, e.b9 = function() {
				let e = new Float64Array(16);
				return g(e), e;
			}, e.bA = function(e, t) {
				let n = N(e, 360), i = N(t, 360), a = i - n, o = i > n ? a - 360 : a + 360;
				return Math.abs(a) < Math.abs(o) ? a : o;
			}, e.bB = function(e) {
				return e[0] = 0, e[1] = 0, e[2] = 0, e;
			}, e.bC = function(e, t, n, i) {
				let a = Math.sqrt(e * e + t * t), o = Math.sqrt(n * n + i * i);
				e /= a, t /= a, n /= o, i /= o;
				let s = Math.acos(e * n + t * i);
				return -t * n + e * i > 0 ? s : -s;
			}, e.bD = function(e, t) {
				let n = N(e, 2 * Math.PI), i = N(t, 2 * Math.PI);
				return Math.min(Math.abs(n - i), Math.abs(n - i + 2 * Math.PI), Math.abs(n - i - 2 * Math.PI));
			}, e.bE = function() {
				let e = {}, t = U.$version;
				for (let n in U.$root) {
					let i = U.$root[n];
					if (i.required) {
						let a = null;
						a = n === "version" ? t : i.type === "array" ? [] : {}, a != null && (e[n] = a);
					}
				}
				return e;
			}, e.bF = Ca, e.bG = Ee, e.bH = function e(t, n) {
				if (Array.isArray(t)) {
					if (!Array.isArray(n) || t.length !== n.length) return !1;
					for (let i = 0; i < t.length; i++) if (!e(t[i], n[i])) return !1;
					return !0;
				}
				if (typeof t == "object" && t && n !== null) {
					if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length) return !1;
					for (let i in t) if (!e(t[i], n[i])) return !1;
					return !0;
				}
				return t === n;
			}, e.bI = function(e) {
				e = e.slice();
				let t = Object.create(null);
				for (let n = 0; n < e.length; n++) t[e[n].id] = e[n];
				for (let n = 0; n < e.length; n++) "ref" in e[n] && (e[n] = Fe(e[n], t[e[n].ref]));
				return e;
			}, e.bJ = function(e, t) {
				if (e.type === "custom") return new Cd(e, t);
				switch (e.type) {
					case "background": return new Sd(e, t);
					case "circle": return new vc(e, t);
					case "color-relief": return new Rc(e, t);
					case "fill": return new Dl(e, t);
					case "fill-extrusion": return new Kl(e, t);
					case "heatmap": return new kc(e, t);
					case "hillshade": return new Mc(e, t);
					case "line": return new au(e, t);
					case "raster": return new no(e, t);
					case "symbol": return new yd(e, t);
				}
			}, e.bK = (e) => e.type === "raster", e.bL = oe, e.bM = function(e, t) {
				if (!e) return [{
					command: "setStyle",
					args: [t]
				}];
				let n = [];
				try {
					if (!Ie(e.version, t.version)) return [{
						command: "setStyle",
						args: [t]
					}];
					Ie(e.center, t.center) || n.push({
						command: "setCenter",
						args: [t.center]
					}), Ie(e.state, t.state) || n.push({
						command: "setGlobalState",
						args: [t.state]
					}), Ie(e.centerAltitude, t.centerAltitude) || n.push({
						command: "setCenterAltitude",
						args: [t.centerAltitude]
					}), Ie(e.zoom, t.zoom) || n.push({
						command: "setZoom",
						args: [t.zoom]
					}), Ie(e.bearing, t.bearing) || n.push({
						command: "setBearing",
						args: [t.bearing]
					}), Ie(e.pitch, t.pitch) || n.push({
						command: "setPitch",
						args: [t.pitch]
					}), Ie(e.roll, t.roll) || n.push({
						command: "setRoll",
						args: [t.roll]
					}), Ie(e.sprite, t.sprite) || n.push({
						command: "setSprite",
						args: [t.sprite]
					}), Ie(e.glyphs, t.glyphs) || n.push({
						command: "setGlyphs",
						args: [t.glyphs]
					}), Ie(e.transition, t.transition) || n.push({
						command: "setTransition",
						args: [t.transition]
					}), Ie(e.light, t.light) || n.push({
						command: "setLight",
						args: [t.light]
					}), Ie(e.terrain, t.terrain) || n.push({
						command: "setTerrain",
						args: [t.terrain]
					}), Ie(e.sky, t.sky) || n.push({
						command: "setSky",
						args: [t.sky]
					}), Ie(e.projection, t.projection) || n.push({
						command: "setProjection",
						args: [t.projection]
					});
					let i = {}, a = [];
					(function(e, t, n, i) {
						let a;
						for (a in t ||= {}, e ||= {}) Object.prototype.hasOwnProperty.call(e, a) && (Object.prototype.hasOwnProperty.call(t, a) || ze(a, n, i));
						for (a in t) Object.prototype.hasOwnProperty.call(t, a) && (Object.prototype.hasOwnProperty.call(e, a) ? Ie(e[a], t[a]) || (e[a].type === "geojson" && t[a].type === "geojson" && Ve(e, t, a) ? Le(n, {
							command: "setGeoJSONSourceData",
							args: [a, t[a].data]
						}) : Be(a, t, n, i)) : Re(a, t, n));
					})(e.sources, t.sources, a, i);
					let o = [];
					e.layers && e.layers.forEach(((e) => {
						"source" in e && i[e.source] ? n.push({
							command: "removeLayer",
							args: [e.id]
						}) : o.push(e);
					})), n = n.concat(a), function(e, t, n) {
						t ||= [];
						let i = (e ||= []).map(Ue), a = t.map(Ue), o = e.reduce(We, {}), s = t.reduce(We, {}), c = i.slice(), l = Object.create(null), u, d, f, p, m;
						for (let e = 0, t = 0; e < i.length; e++) u = i[e], Object.prototype.hasOwnProperty.call(s, u) ? t++ : (Le(n, {
							command: "removeLayer",
							args: [u]
						}), c.splice(c.indexOf(u, t), 1));
						for (let e = 0, t = 0; e < a.length; e++) u = a[a.length - 1 - e], c[c.length - 1 - e] !== u && (Object.prototype.hasOwnProperty.call(o, u) ? (Le(n, {
							command: "removeLayer",
							args: [u]
						}), c.splice(c.lastIndexOf(u, c.length - t), 1)) : t++, p = c[c.length - e], Le(n, {
							command: "addLayer",
							args: [s[u], p]
						}), c.splice(c.length - e, 0, u), l[u] = !0);
						for (let e = 0; e < a.length; e++) if (u = a[e], d = o[u], f = s[u], !l[u] && !Ie(d, f)) if (Ie(d.source, f.source) && Ie(d["source-layer"], f["source-layer"]) && Ie(d.type, f.type)) {
							for (m in He(d.layout, f.layout, n, u, null, "setLayoutProperty"), He(d.paint, f.paint, n, u, null, "setPaintProperty"), Ie(d.filter, f.filter) || Le(n, {
								command: "setFilter",
								args: [u, f.filter]
							}), Ie(d.minzoom, f.minzoom) && Ie(d.maxzoom, f.maxzoom) || Le(n, {
								command: "setLayerZoomRange",
								args: [
									u,
									f.minzoom,
									f.maxzoom
								]
							}), d) Object.prototype.hasOwnProperty.call(d, m) && m !== "layout" && m !== "paint" && m !== "filter" && m !== "metadata" && m !== "minzoom" && m !== "maxzoom" && (m.indexOf("paint.") === 0 ? He(d[m], f[m], n, u, m.slice(6), "setPaintProperty") : Ie(d[m], f[m]) || Le(n, {
								command: "setLayerProperty",
								args: [
									u,
									m,
									f[m]
								]
							}));
							for (m in f) Object.prototype.hasOwnProperty.call(f, m) && !Object.prototype.hasOwnProperty.call(d, m) && m !== "layout" && m !== "paint" && m !== "filter" && m !== "metadata" && m !== "minzoom" && m !== "maxzoom" && (m.indexOf("paint.") === 0 ? He(d[m], f[m], n, u, m.slice(6), "setPaintProperty") : Ie(d[m], f[m]) || Le(n, {
								command: "setLayerProperty",
								args: [
									u,
									m,
									f[m]
								]
							}));
						} else Le(n, {
							command: "removeLayer",
							args: [u]
						}), p = c[c.lastIndexOf(u) + 1], Le(n, {
							command: "addLayer",
							args: [f, p]
						});
					}(o, t.layers, n);
				} catch (e) {
					console.warn("Unable to compute style diff:", e), n = [{
						command: "setStyle",
						args: [t]
					}];
				}
				return n;
			}, e.bN = function(e) {
				let t = [], n = e.id;
				return n === void 0 && t.push({ message: `layers.${n}: missing required property "id"` }), e.render === void 0 && t.push({ message: `layers.${n}: missing required method "render"` }), e.renderingMode && e.renderingMode !== "2d" && e.renderingMode !== "3d" && t.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), t;
			}, e.bO = ie, e.bP = ae, e.bQ = class extends Ts {
				constructor(e, t) {
					super(e, t), this.current = 0;
				}
				set(e) {
					this.current !== e && (this.current = e, this.gl.uniform1i(this.location, e));
				}
			}, e.bR = Os, e.bS = class extends Ts {
				constructor(e, t) {
					super(e, t), this.current = ks;
				}
				set(e) {
					if (e[12] !== this.current[12] || e[0] !== this.current[0]) return this.current = e, void this.gl.uniformMatrix4fv(this.location, !1, e);
					for (let t = 1; t < 16; t++) if (e[t] !== this.current[t]) {
						this.current = e, this.gl.uniformMatrix4fv(this.location, !1, e);
						break;
					}
				}
			}, e.bT = Ds, e.bU = class extends Ts {
				constructor(e, t) {
					super(e, t), this.current = [
						0,
						0,
						0
					];
				}
				set(e) {
					e[0] === this.current[0] && e[1] === this.current[1] && e[2] === this.current[2] || (this.current = e, this.gl.uniform3f(this.location, e[0], e[1], e[2]));
				}
			}, e.bV = class extends Ts {
				constructor(e, t) {
					super(e, t), this.current = [0, 0];
				}
				set(e) {
					e[0] === this.current[0] && e[1] === this.current[1] || (this.current = e, this.gl.uniform2f(this.location, e[0], e[1]));
				}
			}, e.bW = h, e.bX = function(e, t) {
				var n = Math.sin(t), i = Math.cos(t);
				return e[0] = i, e[1] = n, e[2] = 0, e[3] = -n, e[4] = i, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
			}, e.bY = function(e, t, n) {
				var i = t[0], a = t[1], o = t[2];
				return e[0] = i * n[0] + a * n[3] + o * n[6], e[1] = i * n[1] + a * n[4] + o * n[7], e[2] = i * n[2] + a * n[5] + o * n[8], e;
			}, e.bZ = function(e, t, n, i, a, o, s) {
				var c = 1 / (t - n), l = 1 / (i - a), u = 1 / (o - s);
				return e[0] = -2 * c, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + n) * c, e[13] = (a + i) * l, e[14] = (s + o) * u, e[15] = 1, e;
			}, e.b_ = class extends Ts {
				constructor(e, t) {
					super(e, t), this.current = [];
				}
				set(e) {
					if (e != this.current) {
						this.current = e;
						let t = new Float32Array(4 * e.length);
						for (let n = 0; n < e.length; n++) t[4 * n] = e[n].r, t[4 * n + 1] = e[n].g, t[4 * n + 2] = e[n].b, t[4 * n + 3] = e[n].a;
						this.gl.uniform4fv(this.location, t);
					}
				}
			}, e.ba = function() {
				return new Float64Array(16);
			}, e.bb = function(e, t, n) {
				let i = new Float64Array(4);
				return O(i, e, t - 90, n), i;
			}, e.bc = function(e, t, n, i) {
				var a, o, s, c, l, u = t[0], d = t[1], f = t[2], m = t[3], h = n[0], g = n[1], _ = n[2], v = n[3];
				return (o = u * h + d * g + f * _ + m * v) < 0 && (o = -o, h = -h, g = -g, _ = -_, v = -v), 1 - o > p ? (a = Math.acos(o), s = Math.sin(a), c = Math.sin((1 - i) * a) / s, l = Math.sin(i * a) / s) : (c = 1 - i, l = i), e[0] = c * u + l * h, e[1] = c * d + l * g, e[2] = c * f + l * _, e[3] = c * m + l * v, e;
			}, e.bd = function(e) {
				let t = new Float64Array(9);
				var n, i, a, o, s, c, l, u, d, f = (a = (i = e)[0]) * (l = a + a), p = (o = i[1]) * l, m, h = (s = i[2]) * l, g = s * (u = o + o), _, v = (c = i[3]) * l, y = c * u, b = c * (d = s + s);
				(n = t)[0] = 1 - (m = o * u) - (_ = s * d), n[3] = p - b, n[6] = h + y, n[1] = p + b, n[4] = 1 - f - _, n[7] = g - v, n[2] = h - y, n[5] = g + v, n[8] = 1 - f - m;
				let x = H(-Math.asin(L(t[2], -1, 1))), S, C;
				return Math.hypot(t[5], t[8]) < .001 ? (S = 0, C = -H(Math.atan2(t[3], t[4]))) : (S = H(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])), C = H(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))), {
					roll: S,
					pitch: x + 90,
					bearing: C
				};
			}, e.be = function(e, t) {
				return e.roll == t.roll && e.pitch == t.pitch && e.bearing == t.bearing;
			}, e.bf = Rt, e.bg = Es, e.bh = hl, e.bi = gl, e.bj = pl, e.bk = P, e.bl = F, e.bm = Xt, e.bn = function(e, t, n, i, a) {
				return P(i, a, L((e - t) / (n - t), 0, 1));
			}, e.bo = N, e.bp = function() {
				return new Float64Array(3);
			}, e.bq = function(e, t, n, i) {
				return e[0] = t[0] + n[0] * i, e[1] = t[1] + n[1] * i, e[2] = t[2] + n[2] * i, e;
			}, e.br = O, e.bs = function(e, t, n) {
				var i = n[0], a = n[1], o = n[2], s = n[3], c = t[0], l = t[1], u = t[2], d = a * u - o * l, f = o * c - i * u, p = i * l - a * c;
				return e[0] = c + s * (d += d) + a * (p += p) - o * (f += f), e[1] = l + s * f + o * d - i * p, e[2] = u + s * p + i * f - a * d, e;
			}, e.bt = function(e, t, n) {
				let i = (a = [
					e[0],
					e[1],
					e[2],
					t[0],
					t[1],
					t[2],
					n[0],
					n[1],
					n[2]
				])[0] * ((d = a[8]) * (s = a[4]) - (c = a[5]) * (u = a[7])) + a[1] * (-d * (o = a[3]) + c * (l = a[6])) + a[2] * (u * o - s * l);
				var a, o, s, c, l, u, d;
				if (i === 0) return null;
				let f = S([], [
					t[0],
					t[1],
					t[2]
				], [
					n[0],
					n[1],
					n[2]
				]), p = S([], [
					n[0],
					n[1],
					n[2]
				], [
					e[0],
					e[1],
					e[2]
				]), m = S([], [
					e[0],
					e[1],
					e[2]
				], [
					t[0],
					t[1],
					t[2]
				]), h = x([], f, -e[3]);
				return b(h, h, x([], p, -t[3])), b(h, h, x([], m, -n[3])), x(h, h, 1 / i), h;
			}, e.bu = Ed, e.bv = function() {
				return new Float64Array(4);
			}, e.bw = function(e, t, n, i) {
				var a = [], o = [];
				return a[0] = t[0] - n[0], a[1] = t[1] - n[1], a[2] = t[2] - n[2], o[0] = a[0] * Math.cos(i) - a[1] * Math.sin(i), o[1] = a[0] * Math.sin(i) + a[1] * Math.cos(i), o[2] = a[2], e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e;
			}, e.bx = function(e, t, n, i) {
				var a = [], o = [];
				return a[0] = t[0] - n[0], a[1] = t[1] - n[1], a[2] = t[2] - n[2], o[0] = a[0], o[1] = a[1] * Math.cos(i) - a[2] * Math.sin(i), o[2] = a[1] * Math.sin(i) + a[2] * Math.cos(i), e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e;
			}, e.by = function(e, t, n, i) {
				var a = [], o = [];
				return a[0] = t[0] - n[0], a[1] = t[1] - n[1], a[2] = t[2] - n[2], o[0] = a[2] * Math.sin(i) + a[0] * Math.cos(i), o[1] = a[1], o[2] = a[2] * Math.cos(i) - a[0] * Math.sin(i), e[0] = o[0] + n[0], e[1] = o[1] + n[1], e[2] = o[2] + n[2], e;
			}, e.bz = function(e, t, n) {
				var i = Math.sin(n), a = Math.cos(n), o = t[0], s = t[1], c = t[2], l = t[3], u = t[8], d = t[9], f = t[10], p = t[11];
				return t !== e && (e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15]), e[0] = o * a - u * i, e[1] = s * a - d * i, e[2] = c * a - f * i, e[3] = l * a - p * i, e[8] = o * i + u * a, e[9] = s * i + d * a, e[10] = c * i + f * a, e[11] = l * i + p * a, e;
			}, e.c = xe, e.c0 = class extends So {}, e.c1 = du, e.c2 = class extends wo {}, e.c3 = Oc, e.c4 = function(e) {
				return e <= 1 ? 1 : 2 ** Math.ceil(Math.log(e) / Math.LN2);
			}, e.c5 = Dc, e.c6 = function(e, t, n) {
				var i = t[0], a = t[1], o = t[2], s = n[3] * i + n[7] * a + n[11] * o + n[15];
				return e[0] = (n[0] * i + n[4] * a + n[8] * o + n[12]) / (s ||= 1), e[1] = (n[1] * i + n[5] * a + n[9] * o + n[13]) / s, e[2] = (n[2] * i + n[6] * a + n[10] * o + n[14]) / s, e;
			}, e.c7 = class extends uo {}, e.c8 = class extends jo {}, e.c9 = function(e, t) {
				return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];
			}, e.cA = function(e, t) {
				Se.REGISTERED_PROTOCOLS[e] = t;
			}, e.cB = function(e) {
				delete Se.REGISTERED_PROTOCOLS[e];
			}, e.cC = function(e, t) {
				let n = {};
				for (let i = 0; i < e.length; i++) {
					let a = t && t[e[i].id] || Ni(e[i]);
					t && (t[e[i].id] = a);
					let o = n[a];
					o ||= n[a] = [], o.push(e[i]);
				}
				let i = [];
				for (let e in n) i.push(n[e]);
				return i;
			}, e.cD = J, e.cE = Ud, e.cF = Gd, e.cG = Fu, e.cH = function(t) {
				t.bucket.createArrays(), t.bucket.tilePixelRatio = j / (512 * t.bucket.overscaling), t.bucket.compareText = {}, t.bucket.iconsNeedLinear = !1;
				let n = t.bucket.layers[0], i = n.layout, a = n._unevaluatedLayout._values, o = {
					layoutIconSize: a["icon-size"].possiblyEvaluate(new Ra(t.bucket.zoom + 1), t.canonical),
					layoutTextSize: a["text-size"].possiblyEvaluate(new Ra(t.bucket.zoom + 1), t.canonical),
					textMaxSize: a["text-size"].possiblyEvaluate(new Ra(18))
				};
				if (t.bucket.textSizeData.kind === "composite") {
					let { minZoom: e, maxZoom: n } = t.bucket.textSizeData;
					o.compositeTextSizes = [a["text-size"].possiblyEvaluate(new Ra(e), t.canonical), a["text-size"].possiblyEvaluate(new Ra(n), t.canonical)];
				}
				if (t.bucket.iconSizeData.kind === "composite") {
					let { minZoom: e, maxZoom: n } = t.bucket.iconSizeData;
					o.compositeIconSizes = [a["icon-size"].possiblyEvaluate(new Ra(e), t.canonical), a["icon-size"].possiblyEvaluate(new Ra(n), t.canonical)];
				}
				let s = i.get("text-line-height") * mu, c = i.get("text-rotation-alignment") !== "viewport" && i.get("symbol-placement") !== "point", l = i.get("text-keep-upright"), u = i.get("text-size");
				for (let a of t.bucket.features) {
					let d = i.get("text-font").evaluate(a, {}, t.canonical).join(","), f = u.evaluate(a, {}, t.canonical), p = o.layoutTextSize.evaluate(a, {}, t.canonical), m = o.layoutIconSize.evaluate(a, {}, t.canonical), h = {
						horizontal: {},
						vertical: void 0
					}, g = a.text, _, v = [0, 0];
					if (g) {
						let o = g.toString(), u = i.get("text-letter-spacing").evaluate(a, {}, t.canonical) * mu, m = Ea(o) ? u : 0, _ = i.get("text-anchor").evaluate(a, {}, t.canonical), y = vf(n, a, t.canonical);
						if (!y) {
							let e = i.get("text-radial-offset").evaluate(a, {}, t.canonical);
							v = e ? _f(_, [e * mu, gf]) : i.get("text-offset").evaluate(a, {}, t.canonical).map(((e) => e * mu));
						}
						let b = c ? "center" : i.get("text-justify").evaluate(a, {}, t.canonical), x = i.get("symbol-placement") === "point" ? i.get("text-max-width").evaluate(a, {}, t.canonical) * mu : Infinity, S = () => {
							t.bucket.allowVerticalPlacement && Ta(o) && (h.vertical = zu(g, t.glyphMap, t.glyphPositions, t.imagePositions, d, x, s, _, "left", m, v, e.ao.vertical, !0, p, f));
						};
						if (!c && y) {
							let n = /* @__PURE__ */ new Set();
							if (b === "auto") for (let e = 0; e < y.values.length; e += 2) n.add(yf(y.values[e]));
							else n.add(b);
							let i = !1;
							for (let a of n) if (!h.horizontal[a]) if (i) h.horizontal[a] = h.horizontal[0];
							else {
								let n = zu(g, t.glyphMap, t.glyphPositions, t.imagePositions, d, x, s, "center", a, m, v, e.ao.horizontal, !1, p, f);
								n && (h.horizontal[a] = n, i = n.positionedLines.length === 1);
							}
							S();
						} else {
							b === "auto" && (b = yf(_));
							let n = zu(g, t.glyphMap, t.glyphPositions, t.imagePositions, d, x, s, _, b, m, v, e.ao.horizontal, !1, p, f);
							n && (h.horizontal[b] = n), S(), Ta(o) && c && l && (h.vertical = zu(g, t.glyphMap, t.glyphPositions, t.imagePositions, d, x, s, _, b, m, v, e.ao.vertical, !1, p, f));
						}
					}
					let y = !1;
					if (a.icon && a.icon.name) {
						let e = t.imageMap[a.icon.name];
						e && (_ = nd(t.imagePositions[a.icon.name], i.get("icon-offset").evaluate(a, {}, t.canonical), i.get("icon-anchor").evaluate(a, {}, t.canonical)), y = !!e.sdf, t.bucket.sdfIcons === void 0 ? t.bucket.sdfIcons = y : t.bucket.sdfIcons !== y && se("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e.pixelRatio !== t.bucket.pixelRatio || i.get("icon-rotate").constantOr(1) !== 0) && (t.bucket.iconsNeedLinear = !0));
					}
					let b = Sf(h.horizontal) || h.vertical;
					t.bucket.iconsInText = !!b && b.iconsInText, (b || _) && bf(t.bucket, a, h, _, t.imageMap, o, p, m, v, y, t.canonical, t.subdivisionGranularity);
				}
				t.showCollisionBoxes && t.bucket.generateCollisionDebugBuffers();
			}, e.cI = Cl, e.cJ = Bl, e.cK = $l, e.cL = Il, e.cM = vu, e.cN = class {
				constructor(e) {
					this._marks = {
						start: [e.url, "start"].join("#"),
						end: [e.url, "end"].join("#"),
						measure: e.url.toString()
					}, performance.mark(this._marks.start);
				}
				finish() {
					performance.mark(this._marks.end);
					let e = performance.getEntriesByName(this._marks.measure);
					return e.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), e = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), e;
				}
			}, e.cO = function(e, n, i, a, o) {
				return t(this, void 0, void 0, (function* () {
					if (f()) try {
						return yield V(e, n, i, a, o);
					} catch {}
					return function(e, t, n, i, a) {
						let o = e.width, s = e.height;
						me && he || (me = new OffscreenCanvas(o, s), he = me.getContext("2d", { willReadFrequently: !0 })), me.width = o, me.height = s, he.drawImage(e, 0, 0, o, s);
						let c = he.getImageData(t, n, i, a);
						return he.clearRect(0, 0, o, s), c.data;
					}(e, n, i, a, o);
				}));
			}, e.cP = Ic, e.cQ = i, e.cR = Pl, e.cS = jl, e.cT = mi, e.cU = function(e, t) {
				let n = /* @__PURE__ */ new Map();
				if (e != null) if (e.type === "Feature") n.set(Vd(e, t), e);
				else for (let i of e.features) n.set(Vd(i, t), i);
				return n;
			}, e.cV = function(e, t) {
				if (e == null) return !0;
				if (e.type === "Feature") return Vd(e, t) != null;
				if (e.type === "FeatureCollection") {
					let n = /* @__PURE__ */ new Set();
					for (let i of e.features) {
						let e = Vd(i, t);
						if (e == null || n.has(e)) return !1;
						n.add(e);
					}
					return !0;
				}
				return !1;
			}, e.cW = function(e, t, n) {
				if (t.removeAll && e.clear(), t.remove) for (let n of t.remove) e.delete(n);
				if (t.add) for (let i of t.add) {
					let t = Vd(i, n);
					t != null && e.set(t, i);
				}
				if (t.update) for (let n of t.update) {
					let t = e.get(n.id);
					if (t == null) continue;
					let i = !n.removeAllProperties && (n.removeProperties?.length > 0 || n.addOrUpdateProperties?.length > 0);
					if ((n.newGeometry || n.removeAllProperties || i) && (t = Object.assign({}, t), e.set(n.id, t), i && (t.properties = Object.assign({}, t.properties))), n.newGeometry && (t.geometry = n.newGeometry), n.removeAllProperties) t.properties = {};
					else if (n.removeProperties?.length > 0) for (let e of n.removeProperties) Object.prototype.hasOwnProperty.call(t.properties, e) && delete t.properties[e];
					if (n.addOrUpdateProperties?.length > 0) for (let { key: e, value: i } of n.addOrUpdateProperties) t.properties[e] = i;
				}
			}, e.cX = La, e.ca = function(e, t) {
				var n = e[0], i = e[1], a = e[2], o = e[3], s = e[4], c = e[5], l = e[6], u = e[7], d = e[8], f = e[9], m = e[10], h = e[11], g = e[12], _ = e[13], v = e[14], y = e[15], b = t[0], x = t[1], S = t[2], C = t[3], w = t[4], T = t[5], E = t[6], O = t[7], k = t[8], A = t[9], j = t[10], M = t[11], N = t[12], P = t[13], F = t[14], I = t[15];
				return Math.abs(n - b) <= p * Math.max(1, Math.abs(n), Math.abs(b)) && Math.abs(i - x) <= p * Math.max(1, Math.abs(i), Math.abs(x)) && Math.abs(a - S) <= p * Math.max(1, Math.abs(a), Math.abs(S)) && Math.abs(o - C) <= p * Math.max(1, Math.abs(o), Math.abs(C)) && Math.abs(s - w) <= p * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(c - T) <= p * Math.max(1, Math.abs(c), Math.abs(T)) && Math.abs(l - E) <= p * Math.max(1, Math.abs(l), Math.abs(E)) && Math.abs(u - O) <= p * Math.max(1, Math.abs(u), Math.abs(O)) && Math.abs(d - k) <= p * Math.max(1, Math.abs(d), Math.abs(k)) && Math.abs(f - A) <= p * Math.max(1, Math.abs(f), Math.abs(A)) && Math.abs(m - j) <= p * Math.max(1, Math.abs(m), Math.abs(j)) && Math.abs(h - M) <= p * Math.max(1, Math.abs(h), Math.abs(M)) && Math.abs(g - N) <= p * Math.max(1, Math.abs(g), Math.abs(N)) && Math.abs(_ - P) <= p * Math.max(1, Math.abs(_), Math.abs(P)) && Math.abs(v - F) <= p * Math.max(1, Math.abs(v), Math.abs(F)) && Math.abs(y - I) <= p * Math.max(1, Math.abs(y), Math.abs(I));
			}, e.cb = function(e, t) {
				return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
			}, e.cc = (e) => e.type === "symbol", e.cd = (e) => e.type === "circle", e.ce = (e) => e.type === "heatmap", e.cf = (e) => e.type === "line", e.cg = (e) => e.type === "fill", e.ch = (e) => e.type === "fill-extrusion", e.ci = (e) => e.type === "hillshade", e.cj = (e) => e.type === "color-relief", e.ck = (e) => e.type === "background", e.cl = (e) => e.type === "custom", e.cm = I, e.cn = function(e, t, n) {
				let i = A(t.x - n.x, t.y - n.y), a = A(e.x - n.x, e.y - n.y);
				var o, s;
				return H(Math.atan2(i[0] * a[1] - i[1] * a[0], (o = i)[0] * (s = a)[0] + o[1] * s[1]));
			}, e.co = ee, e.cp = function(e, t) {
				return ye[t] && (e instanceof MouseEvent || e instanceof WheelEvent);
			}, e.cq = function(e, t) {
				return ve[t] && "touches" in e;
			}, e.cr = function(e) {
				return ve[e] || ye[e];
			}, e.cs = function(e, t, n) {
				var i = t[0], a = t[1];
				return e[0] = n[0] * i + n[4] * a + n[12], e[1] = n[1] * i + n[5] * a + n[13], e;
			}, e.ct = function(e, t) {
				let { x: n, y: i } = Fd.fromLngLat(t);
				return !(e < 0 || e > 25 || i < 0 || i >= 1 || n < 0 || n >= 1);
			}, e.cu = function(e, t) {
				return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
			}, e.cv = class extends lo {}, e.cw = {
				mark(e) {
					performance.mark(e);
				},
				frame(e) {
					let t = e;
					Mf != null && Nf.push(t - Mf), Mf = t;
				},
				clearMetrics() {
					for (let t in Mf = null, Nf = [], performance.clearMeasures(Ff), performance.clearMeasures(If), e.cx) performance.clearMarks(e.cx[t]);
				},
				getPerformanceMetrics() {
					performance.measure(Ff, e.cx.create, e.cx.load), performance.measure(If, e.cx.create, e.cx.fullLoad);
					let t = performance.getEntriesByName(Ff)[0].duration, n = performance.getEntriesByName(If)[0].duration, i = Nf.length, a = 1 / (Nf.reduce(((e, t) => e + t), 0) / i / 1e3), o = Nf.filter(((e) => e > Pf)).reduce(((e, t) => e + (t - Pf) / Pf), 0);
					return {
						loadTime: t,
						fullLoadTime: n,
						fps: a,
						percentDroppedFrames: o / (i + o) * 100,
						totalFrames: i
					};
				}
			}, e.cy = function(e) {
				return e.message === be;
			}, e.cz = Te, e.d = Oe, e.e = te, e.f = (e) => t(void 0, void 0, void 0, (function* () {
				if (e.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
				let t = new Blob([new Uint8Array(e)], { type: "image/png" });
				try {
					return createImageBitmap(t);
				} catch (e) {
					throw Error(`Could not load image because of ${e.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
				}
			})), e.g = Ce, e.h = (e) => new Promise(((t, n) => {
				let i = new Image();
				i.onload = () => {
					t(i), URL.revokeObjectURL(i.src), i.onload = null, window.requestAnimationFrame((() => {
						i.src = pe;
					}));
				}, i.onerror = () => n(/* @__PURE__ */ Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
				let a = new Blob([new Uint8Array(e)], { type: "image/png" });
				i.src = e.byteLength ? URL.createObjectURL(a) : pe;
			})), e.i = le, e.j = (e, t) => De(te(e, { type: "json" }), t), e.k = Me, e.l = je, e.m = De, e.n = (e, t) => De(te(e, { type: "arrayBuffer" }), t), e.o = function(e) {
				return new vu(e).readFields(Au, []);
			}, e.p = Nu, e.q = Tc, e.r = Za, e.s = ge, e.t = Ha, e.u = wa, e.v = U, e.w = se, e.x = da, e.y = ha, e.z = ua;
		})), n("worker", ["./shared"], (function(e) {
			class t {
				constructor(e, t) {
					this.keyCache = {}, e && this.replace(e, t);
				}
				replace(e, t) {
					this._layerConfigs = {}, this._layers = {}, this.update(e, [], t);
				}
				update(t, n, i) {
					for (let n of t) {
						this._layerConfigs[n.id] = n;
						let t = this._layers[n.id] = e.bJ(n, i);
						t._featureFilter = e.aa(t.filter, i), this.keyCache[n.id] && delete this.keyCache[n.id];
					}
					for (let e of n) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];
					this.familiesBySource = {};
					let a = e.cC(Object.values(this._layerConfigs), this.keyCache);
					for (let e of a) {
						let t = e.map(((e) => this._layers[e.id])), n = t[0];
						if (n.visibility === "none") continue;
						let i = n.source || "", a = this.familiesBySource[i];
						a ||= this.familiesBySource[i] = {};
						let o = n.sourceLayer || "_geojsonTileLayer", s = a[o];
						s ||= a[o] = [], s.push(t);
					}
				}
			}
			class n {
				constructor(t) {
					let n = {}, i = [];
					for (let e in t) {
						let a = t[e], o = n[e] = {};
						for (let e in a) {
							let t = a[+e];
							if (!t || t.bitmap.width === 0 || t.bitmap.height === 0) continue;
							let n = {
								x: 0,
								y: 0,
								w: t.bitmap.width + 2,
								h: t.bitmap.height + 2
							};
							i.push(n), o[e] = {
								rect: n,
								metrics: t.metrics
							};
						}
					}
					let { w: a, h: o } = e.p(i), s = new e.q({
						width: a || 1,
						height: o || 1
					});
					for (let i in t) {
						let a = t[i];
						for (let t in a) {
							let o = a[+t];
							if (!o || o.bitmap.width === 0 || o.bitmap.height === 0) continue;
							let c = n[i][t].rect;
							e.q.copy(o.bitmap, s, {
								x: 0,
								y: 0
							}, {
								x: c.x + 1,
								y: c.y + 1
							}, o.bitmap);
						}
					}
					this.image = s, this.positions = n;
				}
			}
			e.cD("GlyphAtlas", n);
			class i {
				constructor(t) {
					this.tileID = new e.Z(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId, this.inFlightDependencies = [];
				}
				parse(t, i, o, s, c) {
					return e._(this, void 0, void 0, (function* () {
						this.status = "parsing", this.data = t, this.collisionBoxArray = new e.a8();
						let l = new e.cE(Object.keys(t.layers).sort()), u = new e.cF(this.tileID, this.promoteId);
						u.bucketLayerIDs = [];
						let d = {}, f = {
							featureIndex: u,
							iconDependencies: {},
							patternDependencies: {},
							glyphDependencies: {},
							dashDependencies: {},
							availableImages: o,
							subdivisionGranularity: c
						}, p = i.familiesBySource[this.source];
						for (let n in p) {
							let i = t.layers[n];
							if (!i) continue;
							i.version === 1 && e.w(`Vector tile source "${this.source}" layer "${n}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
							let s = l.encode(n), c = [];
							for (let e = 0; e < i.length; e++) {
								let t = i.feature(e), a = u.getId(t, n);
								c.push({
									feature: t,
									id: a,
									index: e,
									sourceLayerIndex: s
								});
							}
							for (let t of p[n]) {
								let n = t[0];
								n.source !== this.source && e.w(`layer.source = ${n.source} does not equal this.source = ${this.source}`), n.isHidden(this.zoom, !0) || (a(t, this.zoom, o), (d[n.id] = n.createBucket({
									index: u.bucketLayerIDs.length,
									layers: t,
									zoom: this.zoom,
									pixelRatio: this.pixelRatio,
									overscaling: this.overscaling,
									collisionBoxArray: this.collisionBoxArray,
									sourceLayerIndex: s,
									sourceID: this.source
								})).populate(c, f, this.tileID.canonical), u.bucketLayerIDs.push(t.map(((e) => e.id))));
							}
						}
						let m = e.bO(f.glyphDependencies, ((e) => Object.keys(e).map(Number)));
						this.inFlightDependencies.forEach(((e) => e?.abort())), this.inFlightDependencies = [];
						let h = Promise.resolve({});
						if (Object.keys(m).length) {
							let e = new AbortController();
							this.inFlightDependencies.push(e), h = s.sendAsync({
								type: "GG",
								data: {
									stacks: m,
									source: this.source,
									tileID: this.tileID,
									type: "glyphs"
								}
							}, e);
						}
						let g = Object.keys(f.iconDependencies), _ = Promise.resolve({});
						if (g.length) {
							let e = new AbortController();
							this.inFlightDependencies.push(e), _ = s.sendAsync({
								type: "GI",
								data: {
									icons: g,
									source: this.source,
									tileID: this.tileID,
									type: "icons"
								}
							}, e);
						}
						let v = Object.keys(f.patternDependencies), y = Promise.resolve({});
						if (v.length) {
							let e = new AbortController();
							this.inFlightDependencies.push(e), y = s.sendAsync({
								type: "GI",
								data: {
									icons: v,
									source: this.source,
									tileID: this.tileID,
									type: "patterns"
								}
							}, e);
						}
						let b = f.dashDependencies, x = Promise.resolve({});
						if (Object.keys(b).length) {
							let e = new AbortController();
							this.inFlightDependencies.push(e), x = s.sendAsync({
								type: "GDA",
								data: { dashes: b }
							}, e);
						}
						let [S, C, w, T] = yield Promise.all([
							h,
							_,
							y,
							x
						]), E = new n(S), O = new e.cG(C, w);
						for (let t in d) {
							let n = d[t];
							n instanceof e.a9 ? (a(n.layers, this.zoom, o), e.cH({
								bucket: n,
								glyphMap: S,
								glyphPositions: E.positions,
								imageMap: C,
								imagePositions: O.iconPositions,
								showCollisionBoxes: this.showCollisionBoxes,
								canonical: this.tileID.canonical,
								subdivisionGranularity: f.subdivisionGranularity
							})) : n.hasDependencies && (n instanceof e.cI || n instanceof e.cJ || n instanceof e.cK) && (a(n.layers, this.zoom, o), n.addFeatures(f, this.tileID.canonical, O.patternPositions, T));
						}
						return this.status = "done", {
							buckets: Object.values(d).filter(((e) => !e.isEmpty())),
							featureIndex: u,
							collisionBoxArray: this.collisionBoxArray,
							glyphAtlasImage: E.image,
							imageAtlas: O,
							dashPositions: T,
							glyphMap: this.returnDependencies ? S : null,
							iconMap: this.returnDependencies ? C : null,
							glyphPositions: this.returnDependencies ? E.positions : null
						};
					}));
				}
			}
			function a(t, n, i) {
				let a = new e.F(n);
				for (let e of t) e.recalculate(a, i);
			}
			class o {
				constructor(e, t, n) {
					this.actor = e, this.layerIndex = t, this.availableImages = n, this.fetching = {}, this.loading = {}, this.loaded = {};
				}
				loadVectorTile(t, n) {
					return e._(this, void 0, void 0, (function* () {
						let i = yield e.n(t.request, n);
						try {
							return {
								vectorTile: new e.cL(new e.cM(i.data)),
								rawData: i.data,
								cacheControl: i.cacheControl,
								expires: i.expires
							};
						} catch (e) {
							let n = new Uint8Array(i.data), a = `Unable to parse the tile at ${t.request.url}, `;
							throw a += n[0] === 31 && n[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e.message}`, Error(a);
						}
					}));
				}
				loadTile(t) {
					return e._(this, void 0, void 0, (function* () {
						let n = t.uid, a = !!(t && t.request && t.request.collectResourceTiming) && new e.cN(t.request), o = new i(t);
						this.loading[n] = o;
						let s = new AbortController();
						o.abort = s;
						try {
							let i = yield this.loadVectorTile(t, s);
							if (delete this.loading[n], !i) return null;
							let c = i.rawData, l = {};
							i.expires && (l.expires = i.expires), i.cacheControl && (l.cacheControl = i.cacheControl);
							let u = {};
							if (a) {
								let e = a.finish();
								e && (u.resourceTiming = JSON.parse(JSON.stringify(e)));
							}
							o.vectorTile = i.vectorTile;
							let d = o.parse(i.vectorTile, this.layerIndex, this.availableImages, this.actor, t.subdivisionGranularity);
							this.loaded[n] = o, this.fetching[n] = {
								rawTileData: c,
								cacheControl: l,
								resourceTiming: u
							};
							try {
								let t = yield d;
								return e.e({ rawTileData: c.slice(0) }, t, l, u);
							} finally {
								delete this.fetching[n];
							}
						} catch (e) {
							throw delete this.loading[n], o.status = "done", this.loaded[n] = o, e;
						}
					}));
				}
				reloadTile(t) {
					return e._(this, void 0, void 0, (function* () {
						let n = t.uid;
						if (!this.loaded || !this.loaded[n]) throw Error("Should not be trying to reload a tile that was never loaded or has been removed");
						let i = this.loaded[n];
						if (i.showCollisionBoxes = t.showCollisionBoxes, i.status === "parsing") {
							let a = yield i.parse(i.vectorTile, this.layerIndex, this.availableImages, this.actor, t.subdivisionGranularity), o;
							if (this.fetching[n]) {
								let { rawTileData: t, cacheControl: i, resourceTiming: s } = this.fetching[n];
								delete this.fetching[n], o = e.e({ rawTileData: t.slice(0) }, a, i, s);
							} else o = a;
							return o;
						}
						if (i.status === "done" && i.vectorTile) return i.parse(i.vectorTile, this.layerIndex, this.availableImages, this.actor, t.subdivisionGranularity);
					}));
				}
				abortTile(t) {
					return e._(this, void 0, void 0, (function* () {
						let e = this.loading, n = t.uid;
						e && e[n] && e[n].abort && (e[n].abort.abort(), delete e[n]);
					}));
				}
				removeTile(t) {
					return e._(this, void 0, void 0, (function* () {
						this.loaded && this.loaded[t.uid] && delete this.loaded[t.uid];
					}));
				}
			}
			class s {
				constructor() {
					this.loaded = {};
				}
				loadTile(t) {
					return e._(this, void 0, void 0, (function* () {
						let { uid: n, encoding: i, rawImageData: a, redFactor: o, greenFactor: s, blueFactor: c, baseShift: l } = t, u = a.width + 2, d = a.height + 2, f = e.b(a) ? new e.R({
							width: u,
							height: d
						}, yield e.cO(a, -1, -1, u, d)) : a, p = new e.cP(n, f, i, o, s, c, l);
						return this.loaded = this.loaded || {}, this.loaded[n] = p, p;
					}));
				}
				removeTile(e) {
					let t = this.loaded, n = e.uid;
					t && t[n] && delete t[n];
				}
			}
			var c, l, u = function() {
				if (l) return c;
				function e(e, n) {
					if (e.length !== 0) {
						t(e[0], n);
						for (var i = 1; i < e.length; i++) t(e[i], !n);
					}
				}
				function t(e, t) {
					for (var n = 0, i = 0, a = 0, o = e.length, s = o - 1; a < o; s = a++) {
						var c = (e[a][0] - e[s][0]) * (e[s][1] + e[a][1]), l = n + c;
						i += Math.abs(n) >= Math.abs(c) ? n - l + c : c - l + n, n = l;
					}
					n + i >= 0 != !!t && e.reverse();
				}
				return l = 1, c = function t(n, i) {
					var a, o = n && n.type;
					if (o === "FeatureCollection") for (a = 0; a < n.features.length; a++) t(n.features[a], i);
					else if (o === "GeometryCollection") for (a = 0; a < n.geometries.length; a++) t(n.geometries[a], i);
					else if (o === "Feature") t(n.geometry, i);
					else if (o === "Polygon") e(n.coordinates, i);
					else if (o === "MultiPolygon") for (a = 0; a < n.coordinates.length; a++) e(n.coordinates[a], i);
					return n;
				};
			}(), d = e.cQ(u);
			class f extends e.cS {
				constructor(t, n) {
					super(new e.cM(), 0, n, [], []), this.feature = t, this.type = t.type, this.properties = t.tags ? t.tags : {}, "id" in t && (typeof t.id == "string" ? this.id = parseInt(t.id, 10) : typeof t.id != "number" || isNaN(t.id) || (this.id = t.id));
				}
				loadGeometry() {
					let t = [], n = this.feature.type === 1 ? [this.feature.geometry] : this.feature.geometry;
					for (let i of n) {
						let n = [];
						for (let t of i) n.push(new e.P(t[0], t[1]));
						t.push(n);
					}
					return t;
				}
			}
			class p extends e.cR {
				constructor(t, n) {
					super(new e.cM()), this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.version = n ? n.version : 1, this.extent = n ? n.extent : 4096, this.length = t.length, this.features = t;
				}
				feature(e) {
					return new f(this.features[e], this.extent);
				}
			}
			function m(e, t) {
				t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096);
				let n = {
					keys: [],
					values: [],
					keycache: {},
					valuecache: {}
				};
				for (let i = 0; i < e.length; i++) n.feature = e.feature(i), t.writeMessage(2, h, n);
				let i = n.keys;
				for (let e of i) t.writeStringField(3, e);
				let a = n.values;
				for (let e of a) t.writeMessage(4, b, e);
			}
			function h(e, t) {
				if (!e.feature) return;
				let n = e.feature;
				n.id !== void 0 && t.writeVarintField(1, n.id), t.writeMessage(2, g, e), t.writeVarintField(3, n.type), t.writeMessage(4, y, n);
			}
			function g(e, t) {
				for (let n in e.feature?.properties) {
					let i = e.feature.properties[n], a = e.keycache[n];
					if (i === null) continue;
					a === void 0 && (e.keys.push(n), a = e.keys.length - 1, e.keycache[n] = a), t.writeVarint(a), typeof i != "string" && typeof i != "boolean" && typeof i != "number" && (i = JSON.stringify(i));
					let o = typeof i + ":" + i, s = e.valuecache[o];
					s === void 0 && (e.values.push(i), s = e.values.length - 1, e.valuecache[o] = s), t.writeVarint(s);
				}
			}
			function _(e, t) {
				return (t << 3) + (7 & e);
			}
			function v(e) {
				return e << 1 ^ e >> 31;
			}
			function y(e, t) {
				let n = e.loadGeometry(), i = e.type, a = 0, o = 0;
				for (let s of n) {
					let n = 1;
					i === 1 && (n = s.length), t.writeVarint(_(1, n));
					let c = i === 3 ? s.length - 1 : s.length;
					for (let e = 0; e < c; e++) {
						e === 1 && i !== 1 && t.writeVarint(_(2, c - 1));
						let n = s[e].x - a, l = s[e].y - o;
						t.writeVarint(v(n)), t.writeVarint(v(l)), a += n, o += l;
					}
					e.type === 3 && t.writeVarint(_(7, 1));
				}
			}
			function b(e, t) {
				let n = typeof e;
				n === "string" ? t.writeStringField(1, e) : n === "boolean" ? t.writeBooleanField(7, e) : n === "number" && (e % 1 == 0 ? e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e) : t.writeDoubleField(3, e));
			}
			let x = {
				minZoom: 0,
				maxZoom: 16,
				minPoints: 2,
				radius: 40,
				extent: 512,
				nodeSize: 64,
				log: !1,
				generateId: !1,
				reduce: null,
				map: (e) => e
			}, S = Math.fround || (C = new Float32Array(1), (e) => (C[0] = +e, C[0]));
			var C;
			class w {
				constructor(e) {
					this.options = Object.assign(Object.create(x), e), this.trees = Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
				}
				load(e) {
					let { log: t, minZoom: n, maxZoom: i } = this.options;
					t && console.time("total time");
					let a = `prepare ${e.length} points`;
					t && console.time(a), this.points = e;
					let o = [];
					for (let t = 0; t < e.length; t++) {
						let n = e[t];
						if (!n.geometry) continue;
						let [i, a] = n.geometry.coordinates, s = S(O(i)), c = S(k(a));
						o.push(s, c, Infinity, t, -1, 1), this.options.reduce && o.push(0);
					}
					let s = this.trees[i + 1] = this._createTree(o);
					t && console.timeEnd(a);
					for (let e = i; e >= n; e--) {
						let n = +Date.now();
						s = this.trees[e] = this._createTree(this._cluster(s, e)), t && console.log("z%d: %d clusters in %dms", e, s.numItems, +Date.now() - n);
					}
					return t && console.timeEnd("total time"), this;
				}
				getClusters(e, t) {
					let n = ((e[0] + 180) % 360 + 360) % 360 - 180, i = Math.max(-90, Math.min(90, e[1])), a = e[2] === 180 ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, e[3]));
					if (e[2] - e[0] >= 360) n = -180, a = 180;
					else if (n > a) {
						let e = this.getClusters([
							n,
							i,
							180,
							o
						], t), s = this.getClusters([
							-180,
							i,
							a,
							o
						], t);
						return e.concat(s);
					}
					let s = this.trees[this._limitZoom(t)], c = s.range(O(n), k(o), O(a), k(i)), l = s.data, u = [];
					for (let e of c) {
						let t = this.stride * e;
						u.push(l[t + 5] > 1 ? T(l, t, this.clusterProps) : this.points[l[t + 3]]);
					}
					return u;
				}
				getChildren(e) {
					let t = this._getOriginId(e), n = this._getOriginZoom(e), i = "No cluster with the specified id.", a = this.trees[n];
					if (!a) throw Error(i);
					let o = a.data;
					if (t * this.stride >= o.length) throw Error(i);
					let s = this.options.radius / (this.options.extent * 2 ** (n - 1)), c = a.within(o[t * this.stride], o[t * this.stride + 1], s), l = [];
					for (let t of c) {
						let n = t * this.stride;
						o[n + 4] === e && l.push(o[n + 5] > 1 ? T(o, n, this.clusterProps) : this.points[o[n + 3]]);
					}
					if (l.length === 0) throw Error(i);
					return l;
				}
				getLeaves(e, t, n) {
					let i = [];
					return this._appendLeaves(i, e, t ||= 10, n ||= 0, 0), i;
				}
				getTile(e, t, n) {
					let i = this.trees[this._limitZoom(e)], a = 2 ** e, { extent: o, radius: s } = this.options, c = s / o, l = (n - c) / a, u = (n + 1 + c) / a, d = { features: [] };
					return this._addTileFeatures(i.range((t - c) / a, l, (t + 1 + c) / a, u), i.data, t, n, a, d), t === 0 && this._addTileFeatures(i.range(1 - c / a, l, 1, u), i.data, a, n, a, d), t === a - 1 && this._addTileFeatures(i.range(0, l, c / a, u), i.data, -1, n, a, d), d.features.length ? d : null;
				}
				getClusterExpansionZoom(e) {
					let t = this._getOriginZoom(e) - 1;
					for (; t <= this.options.maxZoom;) {
						let n = this.getChildren(e);
						if (t++, n.length !== 1) break;
						e = n[0].properties.cluster_id;
					}
					return t;
				}
				_appendLeaves(e, t, n, i, a) {
					let o = this.getChildren(t);
					for (let t of o) {
						let o = t.properties;
						if (o && o.cluster ? a + o.point_count <= i ? a += o.point_count : a = this._appendLeaves(e, o.cluster_id, n, i, a) : a < i ? a++ : e.push(t), e.length === n) break;
					}
					return a;
				}
				_createTree(t) {
					let n = new e.aI(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
					for (let e = 0; e < t.length; e += this.stride) n.add(t[e], t[e + 1]);
					return n.finish(), n.data = t, n;
				}
				_addTileFeatures(e, t, n, i, a, o) {
					for (let s of e) {
						let e = s * this.stride, c = t[e + 5] > 1, l, u, d;
						if (c) l = E(t, e, this.clusterProps), u = t[e], d = t[e + 1];
						else {
							let n = this.points[t[e + 3]];
							l = n.properties;
							let [i, a] = n.geometry.coordinates;
							u = O(i), d = k(a);
						}
						let f = {
							type: 1,
							geometry: [[Math.round(this.options.extent * (u * a - n)), Math.round(this.options.extent * (d * a - i))]],
							tags: l
						}, p;
						p = c || this.options.generateId ? t[e + 3] : this.points[t[e + 3]].id, p !== void 0 && (f.id = p), o.features.push(f);
					}
				}
				_limitZoom(e) {
					return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
				}
				_cluster(e, t) {
					let { radius: n, extent: i, reduce: a, minPoints: o } = this.options, s = n / (i * 2 ** t), c = e.data, l = [], u = this.stride;
					for (let n = 0; n < c.length; n += u) {
						if (c[n + 2] <= t) continue;
						c[n + 2] = t;
						let i = c[n], d = c[n + 1], f = e.within(c[n], c[n + 1], s), p = c[n + 5], m = p;
						for (let e of f) {
							let n = e * u;
							c[n + 2] > t && (m += c[n + 5]);
						}
						if (m > p && m >= o) {
							let e, o = i * p, s = d * p, h = -1, g = (n / u << 5) + (t + 1) + this.points.length;
							for (let i of f) {
								let l = i * u;
								if (c[l + 2] <= t) continue;
								c[l + 2] = t;
								let d = c[l + 5];
								o += c[l] * d, s += c[l + 1] * d, c[l + 4] = g, a && (e || (e = this._map(c, n, !0), h = this.clusterProps.length, this.clusterProps.push(e)), a(e, this._map(c, l)));
							}
							c[n + 4] = g, l.push(o / m, s / m, Infinity, g, -1, m), a && l.push(h);
						} else {
							for (let e = 0; e < u; e++) l.push(c[n + e]);
							if (m > 1) for (let e of f) {
								let n = e * u;
								if (!(c[n + 2] <= t)) {
									c[n + 2] = t;
									for (let e = 0; e < u; e++) l.push(c[n + e]);
								}
							}
						}
					}
					return l;
				}
				_getOriginId(e) {
					return e - this.points.length >> 5;
				}
				_getOriginZoom(e) {
					return (e - this.points.length) % 32;
				}
				_map(e, t, n) {
					if (e[t + 5] > 1) {
						let i = this.clusterProps[e[t + 6]];
						return n ? Object.assign({}, i) : i;
					}
					let i = this.points[e[t + 3]].properties, a = this.options.map(i);
					return n && a === i ? Object.assign({}, a) : a;
				}
			}
			function T(e, t, n) {
				return {
					type: "Feature",
					id: e[t + 3],
					properties: E(e, t, n),
					geometry: {
						type: "Point",
						coordinates: [(i = e[t], 360 * (i - .5)), A(e[t + 1])]
					}
				};
				var i;
			}
			function E(e, t, n) {
				let i = e[t + 5], a = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? Math.round(i / 100) / 10 + "k" : i, o = e[t + 6], s = o === -1 ? {} : Object.assign({}, n[o]);
				return Object.assign(s, {
					cluster: !0,
					cluster_id: e[t + 3],
					point_count: i,
					point_count_abbreviated: a
				});
			}
			function O(e) {
				return e / 360 + .5;
			}
			function k(e) {
				let t = Math.sin(e * Math.PI / 180), n = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
				return n < 0 ? 0 : n > 1 ? 1 : n;
			}
			function A(e) {
				let t = (180 - 360 * e) * Math.PI / 180;
				return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
			}
			function j(e, t, n, i) {
				let a = i, o = t + (n - t >> 1), s, c = n - t, l = e[t], u = e[t + 1], d = e[n], f = e[n + 1];
				for (let i = t + 3; i < n; i += 3) {
					let t = M(e[i], e[i + 1], l, u, d, f);
					if (t > a) s = i, a = t;
					else if (t === a) {
						let e = Math.abs(i - o);
						e < c && (s = i, c = e);
					}
				}
				a > i && (s - t > 3 && j(e, t, s, i), e[s + 2] = a, n - s > 3 && j(e, s, n, i));
			}
			function M(e, t, n, i, a, o) {
				let s = a - n, c = o - i;
				if (s !== 0 || c !== 0) {
					let l = ((e - n) * s + (t - i) * c) / (s * s + c * c);
					l > 1 ? (n = a, i = o) : l > 0 && (n += s * l, i += c * l);
				}
				return s = e - n, c = t - i, s * s + c * c;
			}
			function N(e, t, n, i) {
				let a = {
					id: e ?? null,
					type: t,
					geometry: n,
					tags: i,
					minX: Infinity,
					minY: Infinity,
					maxX: -Infinity,
					maxY: -Infinity
				};
				if (t === "Point" || t === "MultiPoint" || t === "LineString") P(a, n);
				else if (t === "Polygon") P(a, n[0]);
				else if (t === "MultiLineString") for (let e of n) P(a, e);
				else if (t === "MultiPolygon") for (let e of n) P(a, e[0]);
				return a;
			}
			function P(e, t) {
				for (let n = 0; n < t.length; n += 3) e.minX = Math.min(e.minX, t[n]), e.minY = Math.min(e.minY, t[n + 1]), e.maxX = Math.max(e.maxX, t[n]), e.maxY = Math.max(e.maxY, t[n + 1]);
			}
			function F(e, t, n, i) {
				if (!t.geometry) return;
				let a = t.geometry.coordinates;
				if (a && a.length === 0) return;
				let o = t.geometry.type, s = (n.tolerance / ((1 << n.maxZoom) * n.extent)) ** 2, c = [], l = t.id;
				if (n.promoteId ? l = t.properties[n.promoteId] : n.generateId && (l = i || 0), o === "Point") I(a, c);
				else if (o === "MultiPoint") for (let e of a) I(e, c);
				else if (o === "LineString") ee(a, c, s, !1);
				else if (o === "MultiLineString") {
					if (n.lineMetrics) {
						for (let n of a) c = [], ee(n, c, s, !1), e.push(N(l, "LineString", c, t.properties));
						return;
					}
					L(a, c, s, !1);
				} else if (o === "Polygon") L(a, c, s, !0);
				else {
					if (o !== "MultiPolygon") {
						if (o === "GeometryCollection") {
							for (let a of t.geometry.geometries) F(e, {
								id: l,
								geometry: a,
								properties: t.properties
							}, n, i);
							return;
						}
						throw Error("Input data is not a valid GeoJSON object.");
					}
					for (let e of a) {
						let t = [];
						L(e, t, s, !0), c.push(t);
					}
				}
				e.push(N(l, o, c, t.properties));
			}
			function I(e, t) {
				t.push(R(e[0]), te(e[1]), 0);
			}
			function ee(e, t, n, i) {
				let a, o, s = 0;
				for (let n = 0; n < e.length; n++) {
					let c = R(e[n][0]), l = te(e[n][1]);
					t.push(c, l, 0), n > 0 && (s += i ? (a * l - c * o) / 2 : Math.sqrt((c - a) ** 2 + (l - o) ** 2)), a = c, o = l;
				}
				let c = t.length - 3;
				t[2] = 1, j(t, 0, c, n), t[c + 2] = 1, t.size = Math.abs(s), t.start = 0, t.end = t.size;
			}
			function L(e, t, n, i) {
				for (let a = 0; a < e.length; a++) {
					let o = [];
					ee(e[a], o, n, i), t.push(o);
				}
			}
			function R(e) {
				return e / 360 + .5;
			}
			function te(e) {
				let t = Math.sin(e * Math.PI / 180), n = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;
				return n < 0 ? 0 : n > 1 ? 1 : n;
			}
			function ne(e, t, n, i, a, o, s, c) {
				if (i /= t, o >= (n /= t) && s < i) return e;
				if (s < n || o >= i) return null;
				let l = [];
				for (let t of e) {
					let e = t.geometry, o = t.type, s = a === 0 ? t.minX : t.minY, u = a === 0 ? t.maxX : t.maxY;
					if (s >= n && u < i) {
						l.push(t);
						continue;
					}
					if (u < n || s >= i) continue;
					let d = [];
					if (o === "Point" || o === "MultiPoint") ie(e, d, n, i, a);
					else if (o === "LineString") ae(e, d, n, i, a, !1, c.lineMetrics);
					else if (o === "MultiLineString") z(e, d, n, i, a, !1);
					else if (o === "Polygon") z(e, d, n, i, a, !0);
					else if (o === "MultiPolygon") for (let t of e) {
						let e = [];
						z(t, e, n, i, a, !0), e.length && d.push(e);
					}
					if (d.length) {
						if (c.lineMetrics && o === "LineString") {
							for (let e of d) l.push(N(t.id, o, e, t.tags));
							continue;
						}
						o !== "LineString" && o !== "MultiLineString" || (d.length === 1 ? (o = "LineString", d = d[0]) : o = "MultiLineString"), o !== "Point" && o !== "MultiPoint" || (o = d.length === 3 ? "Point" : "MultiPoint"), l.push(N(t.id, o, d, t.tags));
					}
				}
				return l.length ? l : null;
			}
			function ie(e, t, n, i, a) {
				for (let o = 0; o < e.length; o += 3) {
					let s = e[o + a];
					s >= n && s <= i && se(t, e[o], e[o + 1], e[o + 2]);
				}
			}
			function ae(e, t, n, i, a, o, s) {
				let c = oe(e), l = a === 0 ? ce : le, u, d, f = e.start;
				for (let p = 0; p < e.length - 3; p += 3) {
					let m = e[p], h = e[p + 1], g = e[p + 2], _ = e[p + 3], v = e[p + 4], y = a === 0 ? m : h, b = a === 0 ? _ : v, x = !1;
					s && (u = Math.sqrt((m - _) ** 2 + (h - v) ** 2)), y < n ? b > n && (d = l(c, m, h, _, v, n), s && (c.start = f + u * d)) : y > i ? b < i && (d = l(c, m, h, _, v, i), s && (c.start = f + u * d)) : se(c, m, h, g), b < n && y >= n && (d = l(c, m, h, _, v, n), x = !0), b > i && y <= i && (d = l(c, m, h, _, v, i), x = !0), !o && x && (s && (c.end = f + u * d), t.push(c), c = oe(e)), s && (f += u);
				}
				let p = e.length - 3, m = e[p], h = e[p + 1], g = a === 0 ? m : h;
				g >= n && g <= i && se(c, m, h, e[p + 2]), p = c.length - 3, o && p >= 3 && (c[p] !== c[0] || c[p + 1] !== c[1]) && se(c, c[0], c[1], c[2]), c.length && t.push(c);
			}
			function oe(e) {
				let t = [];
				return t.size = e.size, t.start = e.start, t.end = e.end, t;
			}
			function z(e, t, n, i, a, o) {
				for (let s of e) ae(s, t, n, i, a, o, !1);
			}
			function se(e, t, n, i) {
				e.push(t, n, i);
			}
			function ce(e, t, n, i, a, o) {
				let s = (o - t) / (i - t);
				return se(e, o, n + (a - n) * s, 1), s;
			}
			function le(e, t, n, i, a, o) {
				let s = (o - n) / (a - n);
				return se(e, t + (i - t) * s, o, 1), s;
			}
			function ue(e, t) {
				let n = [];
				for (let i = 0; i < e.length; i++) {
					let a = e[i], o = a.type, s;
					if (o === "Point" || o === "MultiPoint" || o === "LineString") s = de(a.geometry, t);
					else if (o === "MultiLineString" || o === "Polygon") {
						s = [];
						for (let e of a.geometry) s.push(de(e, t));
					} else if (o === "MultiPolygon") {
						s = [];
						for (let e of a.geometry) {
							let n = [];
							for (let i of e) n.push(de(i, t));
							s.push(n);
						}
					}
					n.push(N(a.id, o, s, a.tags));
				}
				return n;
			}
			function de(e, t) {
				let n = [];
				n.size = e.size, e.start !== void 0 && (n.start = e.start, n.end = e.end);
				for (let i = 0; i < e.length; i += 3) n.push(e[i] + t, e[i + 1], e[i + 2]);
				return n;
			}
			function fe(e, t) {
				if (e.transformed) return e;
				let n = 1 << e.z, i = e.x, a = e.y;
				for (let o of e.features) {
					let e = o.geometry, s = o.type;
					if (o.geometry = [], s === 1) for (let s = 0; s < e.length; s += 2) o.geometry.push(pe(e[s], e[s + 1], t, n, i, a));
					else for (let s = 0; s < e.length; s++) {
						let c = [];
						for (let o = 0; o < e[s].length; o += 2) c.push(pe(e[s][o], e[s][o + 1], t, n, i, a));
						o.geometry.push(c);
					}
				}
				return e.transformed = !0, e;
			}
			function pe(e, t, n, i, a, o) {
				return [Math.round(n * (e * i - a)), Math.round(n * (t * i - o))];
			}
			function V(e, t, n, i, a) {
				let o = t === a.maxZoom ? 0 : a.tolerance / ((1 << t) * a.extent), s = {
					features: [],
					numPoints: 0,
					numSimplified: 0,
					numFeatures: e.length,
					source: null,
					x: n,
					y: i,
					z: t,
					transformed: !1,
					minX: 2,
					minY: 1,
					maxX: -1,
					maxY: 0
				};
				for (let t of e) me(s, t, o, a);
				return s;
			}
			function me(e, t, n, i) {
				let a = t.geometry, o = t.type, s = [];
				if (e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), o === "Point" || o === "MultiPoint") for (let t = 0; t < a.length; t += 3) s.push(a[t], a[t + 1]), e.numPoints++, e.numSimplified++;
				else if (o === "LineString") he(s, a, e, n, !1, !1);
				else if (o === "MultiLineString" || o === "Polygon") for (let t = 0; t < a.length; t++) he(s, a[t], e, n, o === "Polygon", t === 0);
				else if (o === "MultiPolygon") for (let t = 0; t < a.length; t++) {
					let i = a[t];
					for (let t = 0; t < i.length; t++) he(s, i[t], e, n, !0, t === 0);
				}
				if (s.length) {
					let n = t.tags || null;
					if (o === "LineString" && i.lineMetrics) {
						for (let e in n = {}, t.tags) n[e] = t.tags[e];
						n.mapbox_clip_start = a.start / a.size, n.mapbox_clip_end = a.end / a.size;
					}
					let c = {
						geometry: s,
						type: o === "Polygon" || o === "MultiPolygon" ? 3 : o === "LineString" || o === "MultiLineString" ? 2 : 1,
						tags: n
					};
					t.id !== null && (c.id = t.id), e.features.push(c);
				}
			}
			function he(e, t, n, i, a, o) {
				let s = i * i;
				if (i > 0 && t.size < (a ? s : i)) return void (n.numPoints += t.length / 3);
				let c = [];
				for (let e = 0; e < t.length; e += 3) (i === 0 || t[e + 2] > s) && (n.numSimplified++, c.push(t[e], t[e + 1])), n.numPoints++;
				a && function(e, t) {
					let n = 0;
					for (let t = 0, i = e.length, a = i - 2; t < i; a = t, t += 2) n += (e[t] - e[a]) * (e[t + 1] + e[a + 1]);
					if (n > 0 === t) for (let t = 0, n = e.length; t < n / 2; t += 2) {
						let i = e[t], a = e[t + 1];
						e[t] = e[n - 2 - t], e[t + 1] = e[n - 1 - t], e[n - 2 - t] = i, e[n - 1 - t] = a;
					}
				}(c, o), e.push(c);
			}
			let ge = {
				maxZoom: 14,
				indexMaxZoom: 5,
				indexMaxPoints: 1e5,
				tolerance: 3,
				extent: 4096,
				buffer: 64,
				lineMetrics: !1,
				promoteId: null,
				generateId: !1,
				debug: 0
			};
			class _e {
				constructor(e, t) {
					let n = (t = this.options = function(e, t) {
						for (let n in t) e[n] = t[n];
						return e;
					}(Object.create(ge), t)).debug;
					if (n && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw Error("maxZoom should be in the 0-24 range");
					if (t.promoteId && t.generateId) throw Error("promoteId and generateId cannot be used together.");
					let i = function(e, t) {
						let n = [];
						if (e.type === "FeatureCollection") for (let i = 0; i < e.features.length; i++) F(n, e.features[i], t, i);
						else F(n, e.type === "Feature" ? e : { geometry: e }, t);
						return n;
					}(e, t);
					this.tiles = {}, this.tileCoords = [], n && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i = function(e, t) {
						let n = t.buffer / t.extent, i = e, a = ne(e, 1, -1 - n, n, 0, -1, 2, t), o = ne(e, 1, 1 - n, 2 + n, 0, -1, 2, t);
						return (a || o) && (i = ne(e, 1, -n, 1 + n, 0, -1, 2, t) || [], a && (i = ue(a, 1).concat(i)), o && (i = i.concat(ue(o, -1)))), i;
					}(i, t), i.length && this.splitTile(i, 0, 0, 0), n && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
				}
				splitTile(e, t, n, i, a, o, s) {
					let c = [
						e,
						t,
						n,
						i
					], l = this.options, u = l.debug;
					for (; c.length;) {
						i = c.pop(), n = c.pop(), t = c.pop(), e = c.pop();
						let d = 1 << t, f = H(t, n, i), p = this.tiles[f];
						if (!p && (u > 1 && console.time("creation"), p = this.tiles[f] = V(e, t, n, i, l), this.tileCoords.push({
							z: t,
							x: n,
							y: i
						}), u)) {
							u > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, n, i, p.numFeatures, p.numPoints, p.numSimplified), console.timeEnd("creation"));
							let e = `z${t}`;
							this.stats[e] = (this.stats[e] || 0) + 1, this.total++;
						}
						if (p.source = e, a == null) {
							if (t === l.indexMaxZoom || p.numPoints <= l.indexMaxPoints) continue;
						} else {
							if (t === l.maxZoom || t === a) continue;
							if (a != null) {
								let e = a - t;
								if (n !== o >> e || i !== s >> e) continue;
							}
						}
						if (p.source = null, e.length === 0) continue;
						u > 1 && console.time("clipping");
						let m = .5 * l.buffer / l.extent, h = .5 - m, g = .5 + m, _ = 1 + m, v = null, y = null, b = null, x = null, S = ne(e, d, n - m, n + g, 0, p.minX, p.maxX, l), C = ne(e, d, n + h, n + _, 0, p.minX, p.maxX, l);
						e = null, S &&= (v = ne(S, d, i - m, i + g, 1, p.minY, p.maxY, l), y = ne(S, d, i + h, i + _, 1, p.minY, p.maxY, l), null), C &&= (b = ne(C, d, i - m, i + g, 1, p.minY, p.maxY, l), x = ne(C, d, i + h, i + _, 1, p.minY, p.maxY, l), null), u > 1 && console.timeEnd("clipping"), c.push(v || [], t + 1, 2 * n, 2 * i), c.push(y || [], t + 1, 2 * n, 2 * i + 1), c.push(b || [], t + 1, 2 * n + 1, 2 * i), c.push(x || [], t + 1, 2 * n + 1, 2 * i + 1);
					}
				}
				getTile(e, t, n) {
					e = +e, t = +t, n = +n;
					let { extent: i, debug: a } = this.options;
					if (e < 0 || e > 24) return null;
					let o = 1 << e, s = H(e, t = t + o & o - 1, n);
					if (this.tiles[s]) return fe(this.tiles[s], i);
					a > 1 && console.log("drilling down to z%d-%d-%d", e, t, n);
					let c, l = e, u = t, d = n;
					for (; !c && l > 0;) l--, u >>= 1, d >>= 1, c = this.tiles[H(l, u, d)];
					return c && c.source ? (a > 1 && (console.log("found parent tile z%d-%d-%d", l, u, d), console.time("drilling down")), this.splitTile(c.source, l, u, d, e, t, n), a > 1 && console.timeEnd("drilling down"), this.tiles[s] ? fe(this.tiles[s], i) : null) : null;
				}
			}
			function H(e, t, n) {
				return 32 * ((1 << e) * n + t) + e;
			}
			class ve extends o {
				constructor(e, t, n, i = ye) {
					super(e, t, n), this._dataUpdateable = /* @__PURE__ */ new Map(), this._createGeoJSONIndex = i;
				}
				loadVectorTile(t, n) {
					return e._(this, void 0, void 0, (function* () {
						let n = t.tileID.canonical;
						if (!this._geoJSONIndex) throw Error("Unable to parse the data into a cluster or geojson");
						let i = this._geoJSONIndex.getTile(n.z, n.x, n.y);
						if (!i) return null;
						let a = new p(i.features, {
							version: 2,
							extent: e.$
						}), o = function(t) {
							let n = new e.cM();
							return function(e, t) {
								for (let n in e.layers) t.writeMessage(3, m, e.layers[n]);
							}(t, n), n.finish();
						}(a);
						return o.byteOffset === 0 && o.byteLength === o.buffer.byteLength || (o = new Uint8Array(o)), {
							vectorTile: a,
							rawData: o.buffer
						};
					}));
				}
				loadData(t) {
					return e._(this, void 0, void 0, (function* () {
						var n;
						(n = this._pendingRequest) == null || n.abort();
						let i = !!(t && t.request && t.request.collectResourceTiming) && new e.cN(t.request);
						this._pendingRequest = new AbortController();
						try {
							(!this._pendingData || t.request || t.data || t.dataDiff) && (this._pendingData = this.loadAndProcessGeoJSON(t, this._pendingRequest));
							let e = yield this._pendingData;
							this._geoJSONIndex = this._createGeoJSONIndex(e, t), this.loaded = {};
							let n = { data: e };
							if (i) {
								let e = i.finish();
								e && (n.resourceTiming = {}, n.resourceTiming[t.source] = JSON.parse(JSON.stringify(e)));
							}
							return n;
						} catch (t) {
							if (delete this._pendingRequest, e.cy(t)) return { abandoned: !0 };
							throw t;
						}
					}));
				}
				getData() {
					return e._(this, void 0, void 0, (function* () {
						return this._pendingData;
					}));
				}
				reloadTile(e) {
					let t = this.loaded;
					return t && t[e.uid] ? super.reloadTile(e) : this.loadTile(e);
				}
				loadAndProcessGeoJSON(t, n) {
					return e._(this, void 0, void 0, (function* () {
						let i = yield this.loadGeoJSON(t, n);
						if (delete this._pendingRequest, typeof i != "object") throw Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`);
						if (d(i, !0), t.filter) {
							let n = e.cT(t.filter, {
								type: "boolean",
								"property-type": "data-driven",
								overridable: !1,
								transition: !1
							});
							if (n.result === "error") throw Error(n.value.map(((e) => `${e.key}: ${e.message}`)).join(", "));
							i = {
								type: "FeatureCollection",
								features: i.features.filter(((e) => n.value.evaluate({ zoom: 0 }, e)))
							};
						}
						return i;
					}));
				}
				loadGeoJSON(t, n) {
					return e._(this, void 0, void 0, (function* () {
						let { promoteId: i } = t;
						if (t.request) {
							let a = yield e.j(t.request, n);
							return this._dataUpdateable = e.cV(a.data, i) ? e.cU(a.data, i) : void 0, a.data;
						}
						if (typeof t.data == "string") try {
							let n = JSON.parse(t.data);
							return this._dataUpdateable = e.cV(n, i) ? e.cU(n, i) : void 0, n;
						} catch {
							throw Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`);
						}
						if (!t.dataDiff) throw Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`);
						if (!this._dataUpdateable) throw Error(`Cannot update existing geojson data in ${t.source}`);
						return e.cW(this._dataUpdateable, t.dataDiff, i), {
							type: "FeatureCollection",
							features: Array.from(this._dataUpdateable.values())
						};
					}));
				}
				removeSource(t) {
					return e._(this, void 0, void 0, (function* () {
						this._pendingRequest && this._pendingRequest.abort();
					}));
				}
				getClusterExpansionZoom(e) {
					return this._geoJSONIndex.getClusterExpansionZoom(e.clusterId);
				}
				getClusterChildren(e) {
					return this._geoJSONIndex.getChildren(e.clusterId);
				}
				getClusterLeaves(e) {
					return this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset);
				}
			}
			function ye(t, n) {
				return n.cluster ? new w(function({ superclusterOptions: t, clusterProperties: n }) {
					if (!n || !t) return t;
					let i = {}, a = {}, o = {
						accumulated: null,
						zoom: 0
					}, s = { properties: null }, c = Object.keys(n);
					for (let t of c) {
						let [o, s] = n[t], c = e.cT(s), l = e.cT(typeof o == "string" ? [
							o,
							["accumulated"],
							["get", t]
						] : o);
						i[t] = c.value, a[t] = l.value;
					}
					return t.map = (e) => {
						s.properties = e;
						let t = {};
						for (let e of c) t[e] = i[e].evaluate(o, s);
						return t;
					}, t.reduce = (e, t) => {
						s.properties = t;
						for (let t of c) o.accumulated = e[t], e[t] = a[t].evaluate(o, s);
					}, t;
				}(n)).load(t.features) : function(e, t) {
					return new _e(e, t);
				}(t, n.geojsonVtOptions);
			}
			class be {
				constructor(t) {
					this.self = t, this.actor = new e.J(t), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.globalStates = /* @__PURE__ */ new Map(), this.self.registerWorkerSource = (e, t) => {
						if (this.externalWorkerSourceTypes[e]) throw Error(`Worker source with name "${e}" already registered.`);
						this.externalWorkerSourceTypes[e] = t;
					}, this.self.addProtocol = e.cA, this.self.removeProtocol = e.cB, this.self.registerRTLTextPlugin = (t) => {
						e.cX.setMethods(t);
					}, this.actor.registerMessageHandler("LDT", ((e, t) => this._getDEMWorkerSource(e, t.source).loadTile(t))), this.actor.registerMessageHandler("RDT", ((t, n) => e._(this, void 0, void 0, (function* () {
						this._getDEMWorkerSource(t, n.source).removeTile(n);
					})))), this.actor.registerMessageHandler("GCEZ", ((t, n) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t, n.type, n.source).getClusterExpansionZoom(n);
					})))), this.actor.registerMessageHandler("GCC", ((t, n) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t, n.type, n.source).getClusterChildren(n);
					})))), this.actor.registerMessageHandler("GCL", ((t, n) => e._(this, void 0, void 0, (function* () {
						return this._getWorkerSource(t, n.type, n.source).getClusterLeaves(n);
					})))), this.actor.registerMessageHandler("LD", ((e, t) => this._getWorkerSource(e, t.type, t.source).loadData(t))), this.actor.registerMessageHandler("GD", ((e, t) => this._getWorkerSource(e, t.type, t.source).getData())), this.actor.registerMessageHandler("LT", ((e, t) => this._getWorkerSource(e, t.type, t.source).loadTile(t))), this.actor.registerMessageHandler("RT", ((e, t) => this._getWorkerSource(e, t.type, t.source).reloadTile(t))), this.actor.registerMessageHandler("AT", ((e, t) => this._getWorkerSource(e, t.type, t.source).abortTile(t))), this.actor.registerMessageHandler("RMT", ((e, t) => this._getWorkerSource(e, t.type, t.source).removeTile(t))), this.actor.registerMessageHandler("RS", ((t, n) => e._(this, void 0, void 0, (function* () {
						if (!this.workerSources[t] || !this.workerSources[t][n.type] || !this.workerSources[t][n.type][n.source]) return;
						let e = this.workerSources[t][n.type][n.source];
						delete this.workerSources[t][n.type][n.source], e.removeSource !== void 0 && e.removeSource(n);
					})))), this.actor.registerMessageHandler("RM", ((t) => e._(this, void 0, void 0, (function* () {
						delete this.layerIndexes[t], delete this.availableImages[t], delete this.workerSources[t], delete this.demWorkerSources[t], this.globalStates.delete(t);
					})))), this.actor.registerMessageHandler("SR", ((t, n) => e._(this, void 0, void 0, (function* () {
						this.referrer = n;
					})))), this.actor.registerMessageHandler("SRPS", ((e, t) => this._syncRTLPluginState(e, t))), this.actor.registerMessageHandler("IS", ((t, n) => e._(this, void 0, void 0, (function* () {
						this.self.importScripts(n);
					})))), this.actor.registerMessageHandler("SI", ((e, t) => this._setImages(e, t))), this.actor.registerMessageHandler("UL", ((t, n) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t).update(n.layers, n.removedIds, this._getGlobalState(t));
					})))), this.actor.registerMessageHandler("UGS", ((t, n) => e._(this, void 0, void 0, (function* () {
						let e = this._getGlobalState(t);
						for (let t in n) e[t] = n[t];
					})))), this.actor.registerMessageHandler("SL", ((t, n) => e._(this, void 0, void 0, (function* () {
						this._getLayerIndex(t).replace(n, this._getGlobalState(t));
					}))));
				}
				_getGlobalState(e) {
					let t = this.globalStates.get(e);
					return t || (t = {}, this.globalStates.set(e, t)), t;
				}
				_setImages(t, n) {
					return e._(this, void 0, void 0, (function* () {
						for (let e in this.availableImages[t] = n, this.workerSources[t]) {
							let i = this.workerSources[t][e];
							for (let e in i) i[e].availableImages = n;
						}
					}));
				}
				_syncRTLPluginState(t, n) {
					return e._(this, void 0, void 0, (function* () {
						return yield e.cX.syncState(n, this.self.importScripts);
					}));
				}
				_getAvailableImages(e) {
					let t = this.availableImages[e];
					return t ||= [], t;
				}
				_getLayerIndex(e) {
					let n = this.layerIndexes[e];
					return n ||= this.layerIndexes[e] = new t(), n;
				}
				_getWorkerSource(e, t, n) {
					if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), !this.workerSources[e][t][n]) {
						let i = { sendAsync: (t, n) => (t.targetMapId = e, this.actor.sendAsync(t, n)) };
						switch (t) {
							case "vector":
								this.workerSources[e][t][n] = new o(i, this._getLayerIndex(e), this._getAvailableImages(e));
								break;
							case "geojson":
								this.workerSources[e][t][n] = new ve(i, this._getLayerIndex(e), this._getAvailableImages(e));
								break;
							default: this.workerSources[e][t][n] = new this.externalWorkerSourceTypes[t](i, this._getLayerIndex(e), this._getAvailableImages(e));
						}
					}
					return this.workerSources[e][t][n];
				}
				_getDEMWorkerSource(e, t) {
					return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new s()), this.demWorkerSources[e][t];
				}
			}
			return e.i(self) && (self.worker = new be(self)), be;
		})), n("index", ["exports", "./shared"], (function(e, t) {
			var n = "5.10.0";
			function i() {
				var e = new t.A(4);
				return t.A != Float32Array && (e[1] = 0, e[2] = 0), e[0] = 1, e[3] = 1, e;
			}
			let a, o, s = {
				frame(e, n, i) {
					let a = requestAnimationFrame(((e) => {
						o(), n(e);
					})), { unsubscribe: o } = t.s(e.signal, "abort", (() => {
						o(), cancelAnimationFrame(a), i(t.c());
					}), !1);
				},
				frameAsync(e) {
					return new Promise(((t, n) => {
						this.frame(e, t, n);
					}));
				},
				getImageData(e, t = 0) {
					return this.getImageCanvasContext(e).getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);
				},
				getImageCanvasContext(e) {
					let t = window.document.createElement("canvas"), n = t.getContext("2d", { willReadFrequently: !0 });
					if (!n) throw Error("failed to create canvas 2d context");
					return t.width = e.width, t.height = e.height, n.drawImage(e, 0, 0, e.width, e.height), n;
				},
				resolveURL: (e) => (a ||= document.createElement("a"), a.href = e, a.href),
				hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
				get prefersReducedMotion() {
					return !!matchMedia && (o ??= matchMedia("(prefers-reduced-motion: reduce)"), o.matches);
				}
			}, c = new class {
				constructor() {
					this._realTime = typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), this._frozenAt = null;
				}
				getCurrentTime() {
					return this._frozenAt === null ? this._realTime() : this._frozenAt;
				}
				setNow(e) {
					this._frozenAt = e;
				}
				restoreNow() {
					this._frozenAt = null;
				}
				isFrozen() {
					return this._frozenAt !== null;
				}
			}();
			function l() {
				return c.getCurrentTime();
			}
			class u {
				static testProp(e) {
					if (!u.docStyle) return e[0];
					for (let t = 0; t < e.length; t++) if (e[t] in u.docStyle) return e[t];
					return e[0];
				}
				static create(e, t, n) {
					let i = window.document.createElement(e);
					return t !== void 0 && (i.className = t), n && n.appendChild(i), i;
				}
				static createNS(e, t) {
					return window.document.createElementNS(e, t);
				}
				static disableDrag() {
					u.docStyle && u.selectProp && (u.userSelect = u.docStyle[u.selectProp], u.docStyle[u.selectProp] = "none");
				}
				static enableDrag() {
					u.docStyle && u.selectProp && (u.docStyle[u.selectProp] = u.userSelect);
				}
				static setTransform(e, t) {
					e.style[u.transformProp] = t;
				}
				static addEventListener(e, t, n, i = {}) {
					e.addEventListener(t, n, "passive" in i ? i : i.capture);
				}
				static removeEventListener(e, t, n, i = {}) {
					e.removeEventListener(t, n, "passive" in i ? i : i.capture);
				}
				static suppressClickInternal(e) {
					e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", u.suppressClickInternal, !0);
				}
				static suppressClick() {
					window.addEventListener("click", u.suppressClickInternal, !0), window.setTimeout((() => {
						window.removeEventListener("click", u.suppressClickInternal, !0);
					}), 0);
				}
				static getScale(e) {
					let t = e.getBoundingClientRect();
					return {
						x: t.width / e.offsetWidth || 1,
						y: t.height / e.offsetHeight || 1,
						boundingClientRect: t
					};
				}
				static getPoint(e, n, i) {
					let a = n.boundingClientRect;
					return new t.P((i.clientX - a.left) / n.x - e.clientLeft, (i.clientY - a.top) / n.y - e.clientTop);
				}
				static mousePos(e, t) {
					let n = u.getScale(e);
					return u.getPoint(e, n, t);
				}
				static touchPos(e, t) {
					let n = [], i = u.getScale(e);
					for (let a = 0; a < t.length; a++) n.push(u.getPoint(e, i, t[a]));
					return n;
				}
				static mouseButton(e) {
					return e.button;
				}
				static remove(e) {
					e.parentNode && e.parentNode.removeChild(e);
				}
				static sanitize(e) {
					let t = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body"), n = t.querySelectorAll("script");
					for (let e of n) e.remove();
					return u.clean(t), t.innerHTML;
				}
				static isPossiblyDangerous(e, t) {
					let n = t.replace(/\s+/g, "").toLowerCase();
					return !(![
						"src",
						"href",
						"xlink:href"
					].includes(e) || !n.includes("javascript:") && !n.includes("data:")) || !!e.startsWith("on") || void 0;
				}
				static clean(e) {
					let t = e.children;
					for (let e of t) u.removeAttributes(e), u.clean(e);
				}
				static removeAttributes(e) {
					for (let { name: t, value: n } of e.attributes) u.isPossiblyDangerous(t, n) && e.removeAttribute(t);
				}
			}
			u.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, u.selectProp = u.testProp([
				"userSelect",
				"MozUserSelect",
				"WebkitUserSelect",
				"msUserSelect"
			]), u.transformProp = u.testProp(["transform", "WebkitTransform"]);
			let d = {
				supported: !1,
				testSupport: function(e) {
					!m && p && (h ? g(e) : f = e);
				}
			}, f, p, m = !1, h = !1;
			function g(e) {
				let t = e.createTexture();
				e.bindTexture(e.TEXTURE_2D, t);
				try {
					if (e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, p), e.isContextLost()) return;
					d.supported = !0;
				} catch {}
				e.deleteTexture(t), m = !0;
			}
			var _;
			typeof document < "u" && (p = document.createElement("img"), p.onload = () => {
				f && g(f), f = null, h = !0;
			}, p.onerror = () => {
				m = !0, f = null;
			}, p.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e) {
				let n, i, a, o;
				e.resetRequestQueue = () => {
					n = [], i = 0, a = 0, o = {};
				}, e.addThrottleControl = (e) => {
					let t = a++;
					return o[t] = e, t;
				}, e.removeThrottleControl = (e) => {
					delete o[e], c();
				}, e.getImage = (e, i, a = !0) => new Promise(((o, s) => {
					d.supported && (e.headers ||= {}, e.headers.accept = "image/webp,*/*"), t.e(e, { type: "image" }), n.push({
						abortController: i,
						requestParameters: e,
						supportImageRefresh: a,
						state: "queued",
						onError: (e) => {
							s(e);
						},
						onSuccess: (e) => {
							o(e);
						}
					}), c();
				}));
				let s = (e) => t._(this, void 0, void 0, (function* () {
					e.state = "running";
					let { requestParameters: n, supportImageRefresh: a, onError: o, onSuccess: s, abortController: u } = e, d = !1 === a && !t.i(self) && !t.g(n.url) && (!n.headers || Object.keys(n.headers).reduce(((e, t) => e && t === "accept"), !0));
					i++;
					let f = d ? l(n, u) : t.m(n, u);
					try {
						let n = yield f;
						delete e.abortController, e.state = "completed", n.data instanceof HTMLImageElement || t.b(n.data) ? s(n) : n.data && s({
							data: yield (p = n.data, typeof createImageBitmap == "function" ? t.f(p) : t.h(p)),
							cacheControl: n.cacheControl,
							expires: n.expires
						});
					} catch (t) {
						delete e.abortController, o(t);
					} finally {
						i--, c();
					}
					var p;
				})), c = () => {
					let e = (() => {
						for (let e of Object.keys(o)) if (o[e]()) return !0;
						return !1;
					})() ? t.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.a.MAX_PARALLEL_IMAGE_REQUESTS;
					for (let t = i; t < e && n.length > 0; t++) {
						let e = n.shift();
						e.abortController.signal.aborted ? t-- : s(e);
					}
				}, l = (e, n) => new Promise(((i, a) => {
					let o = new Image(), s = e.url, c = e.credentials;
					c && c === "include" ? o.crossOrigin = "use-credentials" : (c && c === "same-origin" || !t.d(s)) && (o.crossOrigin = "anonymous"), n.signal.addEventListener("abort", (() => {
						o.src = "", a(t.c());
					})), o.fetchPriority = "high", o.onload = () => {
						o.onerror = o.onload = null, i({ data: o });
					}, o.onerror = () => {
						o.onerror = o.onload = null, n.signal.aborted || a(/* @__PURE__ */ Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
					}, o.src = s;
				}));
			}(_ ||= {}), _.resetRequestQueue();
			class v {
				constructor(e) {
					this._transformRequestFn = e ?? null;
				}
				transformRequest(e, t) {
					return this._transformRequestFn && this._transformRequestFn(e, t) || { url: e };
				}
				setTransformRequest(e) {
					this._transformRequestFn = e;
				}
			}
			function y(e) {
				let t = [];
				if (typeof e == "string") t.push({
					id: "default",
					url: e
				});
				else if (e && e.length > 0) {
					let n = [];
					for (let { id: i, url: a } of e) {
						let e = `${i}${a}`;
						n.indexOf(e) === -1 && (n.push(e), t.push({
							id: i,
							url: a
						}));
					}
				}
				return t;
			}
			function b(e, t, n) {
				try {
					let i = new URL(e);
					return i.pathname += `${t}${n}`, i.toString();
				} catch {
					throw Error(`Invalid sprite URL "${e}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
				}
			}
			function x(e) {
				let { userImage: t } = e;
				return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);
			}
			class S extends t.E {
				constructor() {
					super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({
						width: 1,
						height: 1
					}), this.dirty = !0;
				}
				isLoaded() {
					return this.loaded;
				}
				setLoaded(e) {
					if (this.loaded !== e && (this.loaded = e, e)) {
						for (let { ids: e, promiseResolve: t } of this.requestors) t(this._getImagesForIds(e));
						this.requestors = [];
					}
				}
				getImage(e) {
					let n = this.images[e];
					if (n && !n.data && n.spriteData) {
						let e = n.spriteData;
						n.data = new t.R({
							width: e.width,
							height: e.height
						}, e.context.getImageData(e.x, e.y, e.width, e.height).data), n.spriteData = null;
					}
					return n;
				}
				addImage(e, t) {
					if (this.images[e]) throw Error(`Image id ${e} already exist, use updateImage instead`);
					this._validate(e, t) && (this.images[e] = t);
				}
				_validate(e, n) {
					let i = !0, a = n.data || n.spriteData;
					return this._validateStretch(n.stretchX, a && a.width) || (this.fire(new t.k(/* @__PURE__ */ Error(`Image "${e}" has invalid "stretchX" value`))), i = !1), this._validateStretch(n.stretchY, a && a.height) || (this.fire(new t.k(/* @__PURE__ */ Error(`Image "${e}" has invalid "stretchY" value`))), i = !1), this._validateContent(n.content, n) || (this.fire(new t.k(/* @__PURE__ */ Error(`Image "${e}" has invalid "content" value`))), i = !1), i;
				}
				_validateStretch(e, t) {
					if (!e) return !0;
					let n = 0;
					for (let i of e) {
						if (i[0] < n || i[1] < i[0] || t < i[1]) return !1;
						n = i[1];
					}
					return !0;
				}
				_validateContent(e, t) {
					if (!e) return !0;
					if (e.length !== 4) return !1;
					let n = t.spriteData, i = n && n.width || t.data.width, a = n && n.height || t.data.height;
					return !(e[0] < 0 || i < e[0] || e[1] < 0 || a < e[1] || e[2] < 0 || i < e[2] || e[3] < 0 || a < e[3] || e[2] < e[0] || e[3] < e[1]);
				}
				updateImage(e, t, n = !0) {
					let i = this.getImage(e);
					if (n && (i.data.width !== t.data.width || i.data.height !== t.data.height)) throw Error(`size mismatch between old image (${i.data.width}x${i.data.height}) and new image (${t.data.width}x${t.data.height}).`);
					t.version = i.version + 1, this.images[e] = t, this.updatedImages[e] = !0;
				}
				removeImage(e) {
					let t = this.images[e];
					delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove();
				}
				listImages() {
					return Object.keys(this.images);
				}
				getImages(e) {
					return new Promise(((t, n) => {
						let i = !0;
						if (!this.isLoaded()) for (let t of e) this.images[t] || (i = !1);
						this.isLoaded() || i ? t(this._getImagesForIds(e)) : this.requestors.push({
							ids: e,
							promiseResolve: t
						});
					}));
				}
				_getImagesForIds(e) {
					let n = {};
					for (let i of e) {
						let e = this.getImage(i);
						e ||= (this.fire(new t.l("styleimagemissing", { id: i })), this.getImage(i)), e ? n[i] = {
							data: e.data.clone(),
							pixelRatio: e.pixelRatio,
							sdf: e.sdf,
							version: e.version,
							stretchX: e.stretchX,
							stretchY: e.stretchY,
							content: e.content,
							textFitWidth: e.textFitWidth,
							textFitHeight: e.textFitHeight,
							hasRenderCallback: !!(e.userImage && e.userImage.render)
						} : t.w(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
					}
					return n;
				}
				getPixelSize() {
					let { width: e, height: t } = this.atlasImage;
					return {
						width: e,
						height: t
					};
				}
				getPattern(e) {
					let n = this.patterns[e], i = this.getImage(e);
					if (!i) return null;
					if (n && n.position.version === i.version) return n.position;
					if (n) n.position.version = i.version;
					else {
						let n = {
							w: i.data.width + 2,
							h: i.data.height + 2,
							x: 0,
							y: 0
						}, a = new t.I(n, i);
						this.patterns[e] = {
							bin: n,
							position: a
						};
					}
					return this._updatePatternAtlas(), this.patterns[e].position;
				}
				bind(e) {
					let n = e.gl;
					this.atlasTexture ? this.dirty &&= (this.atlasTexture.update(this.atlasImage), !1) : this.atlasTexture = new t.T(e, this.atlasImage, n.RGBA), this.atlasTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
				}
				_updatePatternAtlas() {
					let e = [];
					for (let t in this.patterns) e.push(this.patterns[t].bin);
					let { w: n, h: i } = t.p(e), a = this.atlasImage;
					for (let e in a.resize({
						width: n || 1,
						height: i || 1
					}), this.patterns) {
						let { bin: n } = this.patterns[e], i = n.x + 1, o = n.y + 1, s = this.getImage(e).data, c = s.width, l = s.height;
						t.R.copy(s, a, {
							x: 0,
							y: 0
						}, {
							x: i,
							y: o
						}, {
							width: c,
							height: l
						}), t.R.copy(s, a, {
							x: 0,
							y: l - 1
						}, {
							x: i,
							y: o - 1
						}, {
							width: c,
							height: 1
						}), t.R.copy(s, a, {
							x: 0,
							y: 0
						}, {
							x: i,
							y: o + l
						}, {
							width: c,
							height: 1
						}), t.R.copy(s, a, {
							x: c - 1,
							y: 0
						}, {
							x: i - 1,
							y: o
						}, {
							width: 1,
							height: l
						}), t.R.copy(s, a, {
							x: 0,
							y: 0
						}, {
							x: i + c,
							y: o
						}, {
							width: 1,
							height: l
						});
					}
					this.dirty = !0;
				}
				beginFrame() {
					this.callbackDispatchedThisFrame = {};
				}
				dispatchRenderCallbacks(e) {
					for (let n of e) {
						if (this.callbackDispatchedThisFrame[n]) continue;
						this.callbackDispatchedThisFrame[n] = !0;
						let e = this.getImage(n);
						e || t.w(`Image with ID: "${n}" was not found`), x(e) && this.updateImage(n, e);
					}
				}
			}
			let C = 0x56bc75e2d63100000;
			function w(e, t, n, i, a, o, s, c, l) {
				for (let u = t; u < t + i; u++) T(e, n * o + u, o, a, s, c, l);
				for (let u = n; u < n + a; u++) T(e, u * o + t, 1, i, s, c, l);
			}
			function T(e, t, n, i, a, o, s) {
				o[0] = 0, s[0] = -C, s[1] = C, a[0] = e[t];
				for (let c = 1, l = 0, u = 0; c < i; c++) {
					a[c] = e[t + c * n];
					let i = c * c;
					do {
						let e = o[l];
						u = (a[c] - a[e] + i - e * e) / (c - e) / 2;
					} while (u <= s[l] && --l > -1);
					l++, o[l] = c, s[l] = u, s[l + 1] = C;
				}
				for (let c = 0, l = 0; c < i; c++) {
					for (; s[l + 1] < c;) l++;
					let i = o[l], u = c - i;
					e[t + c * n] = a[i] + u * u;
				}
			}
			class E {
				constructor(e, t, n) {
					this.requestManager = e, this.localIdeographFontFamily = t, this.entries = {}, this.lang = n;
				}
				setURL(e) {
					this.url = e;
				}
				getGlyphs(e) {
					return t._(this, void 0, void 0, (function* () {
						let t = [];
						for (let n in e) for (let i of e[n]) t.push(this._getAndCacheGlyphsPromise(n, i));
						let n = yield Promise.all(t), i = {};
						for (let { stack: e, id: t, glyph: a } of n) i[e] || (i[e] = {}), i[e][t] = a && {
							id: a.id,
							bitmap: a.bitmap.clone(),
							metrics: a.metrics
						};
						return i;
					}));
				}
				_getAndCacheGlyphsPromise(e, n) {
					return t._(this, void 0, void 0, (function* () {
						let t = this.entries[e];
						t ||= this.entries[e] = {
							glyphs: {},
							requests: {},
							ranges: {}
						};
						let i = t.glyphs[n];
						if (i !== void 0) return {
							stack: e,
							id: n,
							glyph: i
						};
						if (i = this._tinySDF(t, e, n), i) return t.glyphs[n] = i, {
							stack: e,
							id: n,
							glyph: i
						};
						let a = Math.floor(n / 256);
						if (256 * a > 65535) throw Error("glyphs > 65535 not supported");
						if (t.ranges[a]) return {
							stack: e,
							id: n,
							glyph: i
						};
						if (!this.url) throw Error("glyphsUrl is not set");
						if (!t.requests[a]) {
							let n = E.loadGlyphRange(e, a, this.url, this.requestManager);
							t.requests[a] = n;
						}
						let o = yield t.requests[a];
						for (let e in o) this._doesCharSupportLocalGlyph(+e) || (t.glyphs[+e] = o[+e]);
						return t.ranges[a] = !0, {
							stack: e,
							id: n,
							glyph: o[n] || null
						};
					}));
				}
				_doesCharSupportLocalGlyph(e) {
					return !!this.localIdeographFontFamily && (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e)) || t.u["CJK Unified Ideographs"](e) || t.u["Hangul Syllables"](e) || t.u.Hiragana(e) || t.u.Katakana(e) || t.u["CJK Symbols and Punctuation"](e) || t.u["Halfwidth and Fullwidth Forms"](e));
				}
				_tinySDF(e, n, i) {
					let a = this.localIdeographFontFamily;
					if (!a || !this._doesCharSupportLocalGlyph(i)) return;
					let o = e.tinySDF;
					if (!o) {
						let t = "400";
						/bold/i.test(n) ? t = "900" : /medium/i.test(n) ? t = "500" : /light/i.test(n) && (t = "200"), o = e.tinySDF = new E.TinySDF({
							fontSize: 48,
							buffer: 6,
							radius: 16,
							cutoff: .25,
							lang: this.lang,
							fontFamily: a,
							fontWeight: t
						});
					}
					let s = o.draw(String.fromCharCode(i));
					return {
						id: i,
						bitmap: new t.q({
							width: s.width || 60,
							height: s.height || 60
						}, s.data),
						metrics: {
							width: s.glyphWidth / 2 || 24,
							height: s.glyphHeight / 2 || 24,
							left: s.glyphLeft / 2 + .5 || 0,
							top: s.glyphTop / 2 - 27.5 || -8,
							advance: s.glyphAdvance / 2 || 24,
							isDoubleResolution: !0
						}
					};
				}
			}
			E.loadGlyphRange = function(e, n, i, a) {
				return t._(this, void 0, void 0, (function* () {
					let o = 256 * n, s = o + 255, c = a.transformRequest(i.replace("{fontstack}", e).replace("{range}", `${o}-${s}`), "Glyphs"), l = yield t.n(c, new AbortController());
					if (!l || !l.data) throw Error(`Could not load glyph range. range: ${n}, ${o}-${s}`);
					let u = {};
					for (let e of t.o(l.data)) u[e.id] = e;
					return u;
				}));
			}, E.TinySDF = class {
				constructor({ fontSize: e = 24, buffer: t = 3, radius: n = 8, cutoff: i = .25, fontFamily: a = "sans-serif", fontWeight: o = "normal", fontStyle: s = "normal", lang: c = null } = {}) {
					this.buffer = t, this.cutoff = i, this.radius = n, this.lang = c;
					let l = this.size = e + 4 * t, u = this.ctx = this._createCanvas(l).getContext("2d", { willReadFrequently: !0 });
					u.font = `${s} ${o} ${e}px ${a}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(l * l), this.gridInner = new Float64Array(l * l), this.f = new Float64Array(l), this.z = new Float64Array(l + 1), this.v = new Uint16Array(l);
				}
				_createCanvas(e) {
					let t = document.createElement("canvas");
					return t.width = t.height = e, t;
				}
				draw(e) {
					let { width: t, actualBoundingBoxAscent: n, actualBoundingBoxDescent: i, actualBoundingBoxLeft: a, actualBoundingBoxRight: o } = this.ctx.measureText(e), s = Math.ceil(n), c = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - a))), l = Math.min(this.size - this.buffer, s + Math.ceil(i)), u = c + 2 * this.buffer, d = l + 2 * this.buffer, f = Math.max(u * d, 0), p = new Uint8ClampedArray(f), m = {
						data: p,
						width: u,
						height: d,
						glyphWidth: c,
						glyphHeight: l,
						glyphTop: s,
						glyphLeft: 0,
						glyphAdvance: t
					};
					if (c === 0 || l === 0) return m;
					let { ctx: h, buffer: g, gridInner: _, gridOuter: v } = this;
					this.lang && (h.lang = this.lang), h.clearRect(g, g, c, l), h.fillText(e, g, g + s);
					let y = h.getImageData(g, g, c, l);
					v.fill(C, 0, f), _.fill(0, 0, f);
					for (let e = 0; e < l; e++) for (let t = 0; t < c; t++) {
						let n = y.data[4 * (e * c + t) + 3] / 255;
						if (n === 0) continue;
						let i = (e + g) * u + t + g;
						if (n === 1) v[i] = 0, _[i] = C;
						else {
							let e = .5 - n;
							v[i] = e > 0 ? e * e : 0, _[i] = e < 0 ? e * e : 0;
						}
					}
					w(v, 0, 0, u, d, u, this.f, this.v, this.z), w(_, g, g, c, l, u, this.f, this.v, this.z);
					for (let e = 0; e < f; e++) {
						let t = Math.sqrt(v[e]) - Math.sqrt(_[e]);
						p[e] = Math.round(255 - 255 * (t / this.radius + this.cutoff));
					}
					return m;
				}
			};
			class O {
				constructor() {
					this.specification = t.v.light.position;
				}
				possiblyEvaluate(e, n) {
					return t.B(e.expression.evaluate(n));
				}
				interpolate(e, n, i) {
					return {
						x: t.C.number(e.x, n.x, i),
						y: t.C.number(e.y, n.y, i),
						z: t.C.number(e.z, n.z, i)
					};
				}
			}
			let k;
			class A extends t.E {
				constructor(e) {
					super(), k ||= new t.r({
						anchor: new t.D(t.v.light.anchor),
						position: new O(),
						color: new t.D(t.v.light.color),
						intensity: new t.D(t.v.light.intensity)
					}), this._transitionable = new t.t(k, void 0), this.setLight(e), this._transitioning = this._transitionable.untransitioned();
				}
				getLight() {
					return this._transitionable.serialize();
				}
				setLight(e, n = {}) {
					if (!this._validate(t.x, e, n)) for (let t in e) {
						let n = e[t];
						t.endsWith("-transition") ? this._transitionable.setTransition(t.slice(0, -11), n) : this._transitionable.setValue(t, n);
					}
				}
				updateTransitions(e) {
					this._transitioning = this._transitionable.transitioned(e, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e) {
					this.properties = this._transitioning.possiblyEvaluate(e);
				}
				_validate(e, n, i) {
					return (!i || !1 !== i.validate) && t.y(this, e.call(t.z, {
						value: n,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.v
					}));
				}
			}
			let j = new t.r({
				"sky-color": new t.D(t.v.sky["sky-color"]),
				"horizon-color": new t.D(t.v.sky["horizon-color"]),
				"fog-color": new t.D(t.v.sky["fog-color"]),
				"fog-ground-blend": new t.D(t.v.sky["fog-ground-blend"]),
				"horizon-fog-blend": new t.D(t.v.sky["horizon-fog-blend"]),
				"sky-horizon-blend": new t.D(t.v.sky["sky-horizon-blend"]),
				"atmosphere-blend": new t.D(t.v.sky["atmosphere-blend"])
			});
			class M extends t.E {
				constructor(e) {
					super(), this._transitionable = new t.t(j, void 0), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.F(0));
				}
				setSky(e, n = {}) {
					if (!this._validate(t.G, e, n)) for (let t in e ||= {
						"sky-color": "transparent",
						"horizon-color": "transparent",
						"fog-color": "transparent",
						"fog-ground-blend": 1,
						"atmosphere-blend": 0
					}, e) {
						let n = e[t];
						t.endsWith("-transition") ? this._transitionable.setTransition(t.slice(0, -11), n) : this._transitionable.setValue(t, n);
					}
				}
				getSky() {
					return this._transitionable.serialize();
				}
				updateTransitions(e) {
					this._transitioning = this._transitionable.transitioned(e, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition();
				}
				recalculate(e) {
					this.properties = this._transitioning.possiblyEvaluate(e);
				}
				_validate(e, n, i = {}) {
					return !1 !== i?.validate && t.y(this, e.call(t.z, t.e({
						value: n,
						style: {
							glyphs: !0,
							sprite: !0
						},
						styleSpec: t.v
					})));
				}
				calculateFogBlendOpacity(e) {
					return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1;
				}
			}
			class N {
				constructor(e, t) {
					this.width = e, this.height = t, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
				}
				getDash(e, t) {
					let n = e.join(",") + String(t);
					return this.dashEntry[n] || (this.dashEntry[n] = this.addDash(e, t)), this.dashEntry[n];
				}
				getDashRanges(e, t, n) {
					let i = [], a = e.length % 2 == 1 ? -e[e.length - 1] * n : 0, o = e[0] * n, s = !0;
					i.push({
						left: a,
						right: o,
						isDash: s,
						zeroLength: e[0] === 0
					});
					let c = e[0];
					for (let t = 1; t < e.length; t++) {
						s = !s;
						let l = e[t];
						a = c * n, c += l, o = c * n, i.push({
							left: a,
							right: o,
							isDash: s,
							zeroLength: l === 0
						});
					}
					return i;
				}
				addRoundDash(e, t, n) {
					let i = t / 2;
					for (let t = -n; t <= n; t++) {
						let a = this.width * (this.nextRow + n + t), o = 0, s = e[o];
						for (let c = 0; c < this.width; c++) {
							c / s.right > 1 && (s = e[++o]);
							let l = Math.abs(c - s.left), u = Math.abs(c - s.right), d = Math.min(l, u), f, p = t / n * (i + 1);
							if (s.isDash) {
								let e = i - Math.abs(p);
								f = Math.sqrt(d * d + e * e);
							} else f = i - Math.sqrt(d * d + p * p);
							this.data[a + c] = Math.max(0, Math.min(255, f + 128));
						}
					}
				}
				addRegularDash(e) {
					for (let t = e.length - 1; t >= 0; --t) {
						let n = e[t], i = e[t + 1];
						n.zeroLength ? e.splice(t, 1) : i && i.isDash === n.isDash && (i.left = n.left, e.splice(t, 1));
					}
					let t = e[0], n = e[e.length - 1];
					t.isDash === n.isDash && (t.left = n.left - this.width, n.right = t.right + this.width);
					let i = this.width * this.nextRow, a = 0, o = e[a];
					for (let t = 0; t < this.width; t++) {
						t / o.right > 1 && (o = e[++a]);
						let n = Math.abs(t - o.left), s = Math.abs(t - o.right), c = Math.min(n, s);
						this.data[i + t] = Math.max(0, Math.min(255, (o.isDash ? c : -c) + 128));
					}
				}
				addDash(e, n) {
					let i = n ? 7 : 0, a = 2 * i + 1;
					if (this.nextRow + a > this.height) return t.w("LineAtlas out of space"), null;
					let o = 0;
					for (let t = 0; t < e.length; t++) o += e[t];
					if (o !== 0) {
						let t = this.width / o, a = this.getDashRanges(e, this.width, t);
						n ? this.addRoundDash(a, t, i) : this.addRegularDash(a);
					}
					let s = {
						y: this.nextRow + i,
						height: 2 * i,
						width: o
					};
					return this.nextRow += a, this.dirty = !0, s;
				}
				bind(e) {
					let t = e.gl;
					this.texture ? (t.bindTexture(t.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, this.width, this.height, t.ALPHA, t.UNSIGNED_BYTE, this.data))) : (this.texture = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texImage2D(t.TEXTURE_2D, 0, t.ALPHA, this.width, this.height, 0, t.ALPHA, t.UNSIGNED_BYTE, this.data));
				}
			}
			let P = "maplibre_preloaded_worker_pool";
			class F {
				constructor() {
					this.active = {};
				}
				acquire(e) {
					if (!this.workers) for (this.workers = []; this.workers.length < F.workerCount;) this.workers.push(new Worker(t.a.WORKER_URL));
					return this.active[e] = !0, this.workers.slice();
				}
				release(e) {
					delete this.active[e], this.numActive() === 0 && (this.workers.forEach(((e) => {
						e.terminate();
					})), this.workers = null);
				}
				isPreloaded() {
					return !!this.active[P];
				}
				numActive() {
					return Object.keys(this.active).length;
				}
			}
			let I = Math.floor(s.hardwareConcurrency / 2), ee, L;
			function R() {
				return ee ||= new F(), ee;
			}
			F.workerCount = t.H(globalThis) ? Math.max(Math.min(I, 3), 1) : 1;
			class te {
				constructor(e, n) {
					this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = n;
					let i = this.workerPool.acquire(n);
					for (let e = 0; e < i.length; e++) {
						let a = new t.J(i[e], n);
						a.name = `Worker ${e}`, this.actors.push(a);
					}
					if (!this.actors.length) throw Error("No actors found");
				}
				broadcast(e, t) {
					let n = [];
					for (let i of this.actors) n.push(i.sendAsync({
						type: e,
						data: t
					}));
					return Promise.all(n);
				}
				getActor() {
					return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
				}
				remove(e = !0) {
					this.actors.forEach(((e) => {
						e.remove();
					})), this.actors = [], e && this.workerPool.release(this.id);
				}
				registerMessageHandler(e, t) {
					for (let n of this.actors) n.registerMessageHandler(e, t);
				}
			}
			function ne() {
				return L || (L = new te(R(), t.K), L.registerMessageHandler("GR", ((e, n, i) => t.m(n, i)))), L;
			}
			function ie(e, n) {
				let i = t.L();
				return t.M(i, i, [
					1,
					1,
					0
				]), t.N(i, i, [
					.5 * e.width,
					.5 * e.height,
					1
				]), e.calculatePosMatrix ? t.O(i, i, e.calculatePosMatrix(n.toUnwrapped())) : i;
			}
			function ae(e, t, n, i, a, o, s) {
				let c = function(e, t, n) {
					if (e) for (let i of e) {
						let e = t[i];
						if (e && e.source === n && e.type === "fill-extrusion") return !0;
					}
					else for (let e in t) {
						let i = t[e];
						if (i.source === n && i.type === "fill-extrusion") return !0;
					}
					return !1;
				}(a?.layers ?? null, t, e.id), l = o.maxPitchScaleFactor(), u = e.tilesIn(i, l, c);
				u.sort(oe);
				let d = [];
				for (let i of u) d.push({
					wrappedTileID: i.tileID.wrapped().key,
					queryResults: i.tile.queryRenderedFeatures(t, n, e._state, i.queryGeometry, i.cameraQueryGeometry, i.scale, a, o, l, ie(e.transform, i.tileID), s ? (e, t) => s(i.tileID, e, t) : void 0)
				});
				return function(e, t) {
					for (let n in e) for (let i of e[n]) z(i, t);
					return e;
				}(function(e) {
					let t = {}, n = {};
					for (let i of e) {
						let e = i.queryResults, a = i.wrappedTileID, o = n[a] = n[a] || {};
						for (let n in e) {
							let i = e[n], a = o[n] = o[n] || {}, s = t[n] = t[n] || [];
							for (let e of i) a[e.featureIndex] || (a[e.featureIndex] = !0, s.push(e));
						}
					}
					return t;
				}(d), e);
			}
			function oe(e, t) {
				let n = e.tileID, i = t.tileID;
				return n.overscaledZ - i.overscaledZ || n.canonical.y - i.canonical.y || n.wrap - i.wrap || n.canonical.x - i.canonical.x;
			}
			function z(e, t) {
				let n = e.feature, i = t.getFeatureState(n.layer["source-layer"], n.id);
				n.source = n.layer.source, n.layer["source-layer"] && (n.sourceLayer = n.layer["source-layer"]), n.state = i;
			}
			function se(e, n, i) {
				return t._(this, void 0, void 0, (function* () {
					let a = e;
					if (e.url ? a = (yield t.j(n.transformRequest(e.url, "Source"), i)).data : yield s.frameAsync(i), !a) return null;
					let o = t.Q(t.e(a, e), [
						"tiles",
						"minzoom",
						"maxzoom",
						"attribution",
						"bounds",
						"scheme",
						"tileSize",
						"encoding"
					]);
					return "vector_layers" in a && a.vector_layers && (o.vectorLayerIds = a.vector_layers.map(((e) => e.id))), o;
				}));
			}
			class ce {
				constructor(e, t) {
					e && (t ? this.setSouthWest(e).setNorthEast(t) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])));
				}
				setNorthEast(e) {
					return this._ne = e instanceof t.S ? new t.S(e.lng, e.lat) : t.S.convert(e), this;
				}
				setSouthWest(e) {
					return this._sw = e instanceof t.S ? new t.S(e.lng, e.lat) : t.S.convert(e), this;
				}
				extend(e) {
					let n = this._sw, i = this._ne, a, o;
					if (e instanceof t.S) a = e, o = e;
					else {
						if (!(e instanceof ce)) return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(ce.convert(e)) : this.extend(t.S.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(t.S.convert(e)) : this;
						if (a = e._sw, o = e._ne, !a || !o) return this;
					}
					return n || i ? (n.lng = Math.min(a.lng, n.lng), n.lat = Math.min(a.lat, n.lat), i.lng = Math.max(o.lng, i.lng), i.lat = Math.max(o.lat, i.lat)) : (this._sw = new t.S(a.lng, a.lat), this._ne = new t.S(o.lng, o.lat)), this;
				}
				getCenter() {
					return new t.S((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
				}
				getSouthWest() {
					return this._sw;
				}
				getNorthEast() {
					return this._ne;
				}
				getNorthWest() {
					return new t.S(this.getWest(), this.getNorth());
				}
				getSouthEast() {
					return new t.S(this.getEast(), this.getSouth());
				}
				getWest() {
					return this._sw.lng;
				}
				getSouth() {
					return this._sw.lat;
				}
				getEast() {
					return this._ne.lng;
				}
				getNorth() {
					return this._ne.lat;
				}
				toArray() {
					return [this._sw.toArray(), this._ne.toArray()];
				}
				toString() {
					return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
				}
				isEmpty() {
					return !(this._sw && this._ne);
				}
				contains(e) {
					let { lng: n, lat: i } = t.S.convert(e), a = this._sw.lng <= n && n <= this._ne.lng;
					return this._sw.lng > this._ne.lng && (a = this._sw.lng >= n && n >= this._ne.lng), this._sw.lat <= i && i <= this._ne.lat && a;
				}
				static convert(e) {
					return e instanceof ce ? e : e && new ce(e);
				}
				static fromLngLat(e, n = 0) {
					let i = 360 * n / 40075017, a = i / Math.cos(Math.PI / 180 * e.lat);
					return new ce(new t.S(e.lng - a, e.lat - i), new t.S(e.lng + a, e.lat + i));
				}
				adjustAntiMeridian() {
					let e = new t.S(this._sw.lng, this._sw.lat), n = new t.S(this._ne.lng, this._ne.lat);
					return new ce(e, e.lng > n.lng ? new t.S(n.lng + 360, n.lat) : n);
				}
			}
			class le {
				constructor(e, t, n) {
					this.bounds = ce.convert(this.validateBounds(e)), this.minzoom = t || 0, this.maxzoom = n || 24;
				}
				validateBounds(e) {
					return Array.isArray(e) && e.length === 4 ? [
						Math.max(-180, e[0]),
						Math.max(-90, e[1]),
						Math.min(180, e[2]),
						Math.min(90, e[3])
					] : [
						-180,
						-90,
						180,
						90
					];
				}
				contains(e) {
					let n = 2 ** e.z, i = Math.floor(t.V(this.bounds.getWest()) * n), a = Math.floor(t.U(this.bounds.getNorth()) * n), o = Math.ceil(t.V(this.bounds.getEast()) * n), s = Math.ceil(t.U(this.bounds.getSouth()) * n);
					return e.x >= i && e.x < o && e.y >= a && e.y < s;
				}
			}
			class ue extends t.E {
				constructor(e, n, i, a) {
					if (super(), this.id = e, this.dispatcher = i, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.e(this, t.Q(n, [
						"url",
						"scheme",
						"tileSize",
						"promoteId"
					])), this._options = t.e({ type: "vector" }, n), this._collectResourceTiming = n.collectResourceTiming, this.tileSize !== 512) throw Error("vector tile sources must have a tileSize of 512");
					this.setEventedParent(a);
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							let e = yield se(this._options, this.map._requestManager, this._tileJSONRequest);
							this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (t.e(this, e), e.bounds && (this.tileBounds = new le(e.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content"
							})));
						} catch (e) {
							this._tileJSONRequest = null, this._loaded = !0, this.fire(new t.k(e));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				hasTile(e) {
					return !this.tileBounds || this.tileBounds.contains(e.canonical);
				}
				onAdd(e) {
					this.map = e, this.load();
				}
				setSourceProperty(e) {
					this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load();
				}
				setTiles(e) {
					return this.setSourceProperty((() => {
						this._options.tiles = e;
					})), this;
				}
				setUrl(e) {
					return this.setSourceProperty((() => {
						this.url = e, this._options.url = e;
					})), this;
				}
				onRemove() {
					this._tileJSONRequest &&= (this._tileJSONRequest.abort(), null);
				}
				serialize() {
					return t.e({}, this._options);
				}
				loadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						let t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), n = {
							request: this.map._requestManager.transformRequest(t, "Tile"),
							uid: e.uid,
							tileID: e.tileID,
							zoom: e.tileID.overscaledZ,
							tileSize: this.tileSize * e.tileID.overscaleFactor(),
							type: this.type,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity
						};
						n.request.collectResourceTiming = this._collectResourceTiming;
						let i = "RT";
						if (e.actor && e.state !== "expired") {
							if (e.state === "loading") return new Promise(((t, n) => {
								e.reloadPromise = {
									resolve: t,
									reject: n
								};
							}));
						} else e.actor = this.dispatcher.getActor(), i = "LT";
						e.abortController = new AbortController();
						try {
							let t = yield e.actor.sendAsync({
								type: i,
								data: n
							}, e.abortController);
							if (delete e.abortController, e.aborted) return;
							this._afterTileLoadWorkerResponse(e, t);
						} catch (t) {
							if (delete e.abortController, e.aborted) return;
							if (t && t.status !== 404) throw t;
							this._afterTileLoadWorkerResponse(e, null);
						}
					}));
				}
				_afterTileLoadWorkerResponse(e, t) {
					if (t && t.resourceTiming && (e.resourceTiming = t.resourceTiming), t && this.map._refreshExpiredTiles && e.setExpiryData(t), e.loadVectorData(t, this.map.painter), e.reloadPromise) {
						let t = e.reloadPromise;
						e.reloadPromise = null, this.loadTile(e).then(t.resolve).catch(t.reject);
					}
				}
				abortTile(e) {
					return t._(this, void 0, void 0, (function* () {
						e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({
							type: "AT",
							data: {
								uid: e.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				unloadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e.uid,
								type: this.type,
								source: this.id
							}
						}));
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class de extends t.E {
				constructor(e, n, i, a) {
					super(), this.id = e, this.dispatcher = i, this.setEventedParent(a), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.e({ type: "raster" }, n), t.e(this, t.Q(n, [
						"url",
						"scheme",
						"tileSize"
					]));
				}
				load() {
					return t._(this, arguments, void 0, (function* (e = !1) {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
						try {
							let n = yield se(this._options, this.map._requestManager, this._tileJSONRequest);
							this._tileJSONRequest = null, this._loaded = !0, n && (t.e(this, n), n.bounds && (this.tileBounds = new le(n.bounds, this.minzoom, this.maxzoom)), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "metadata"
							})), this.fire(new t.l("data", {
								dataType: "source",
								sourceDataType: "content",
								sourceDataChanged: e
							})));
						} catch (e) {
							this._tileJSONRequest = null, this._loaded = !0, this.fire(new t.k(e));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				onAdd(e) {
					this.map = e, this.load();
				}
				onRemove() {
					this._tileJSONRequest &&= (this._tileJSONRequest.abort(), null);
				}
				setSourceProperty(e) {
					this._tileJSONRequest &&= (this._tileJSONRequest.abort(), null), e(), this.load(!0);
				}
				setTiles(e) {
					return this.setSourceProperty((() => {
						this._options.tiles = e;
					})), this;
				}
				setUrl(e) {
					return this.setSourceProperty((() => {
						this.url = e, this._options.url = e;
					})), this;
				}
				serialize() {
					return t.e({}, this._options);
				}
				hasTile(e) {
					return !this.tileBounds || this.tileBounds.contains(e.canonical);
				}
				loadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						let n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
						e.abortController = new AbortController();
						try {
							let i = yield _.getImage(this.map._requestManager.transformRequest(n, "Tile"), e.abortController, this.map._refreshExpiredTiles);
							if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
							if (i && i.data) {
								this.map._refreshExpiredTiles && (i.cacheControl || i.expires) && e.setExpiryData({
									cacheControl: i.cacheControl,
									expires: i.expires
								});
								let n = this.map.painter.context, a = n.gl, o = i.data;
								e.texture = this.map.painter.getTileTexture(o.width), e.texture ? e.texture.update(o, { useMipmap: !0 }) : (e.texture = new t.T(n, o, a.RGBA, { useMipmap: !0 }), e.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST)), e.state = "loaded";
							}
						} catch (t) {
							if (delete e.abortController, e.aborted) e.state = "unloaded";
							else if (t) throw e.state = "errored", t;
						}
					}));
				}
				abortTile(e) {
					return t._(this, void 0, void 0, (function* () {
						e.abortController && (e.abortController.abort(), delete e.abortController);
					}));
				}
				unloadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						e.texture && this.map.painter.saveTileTexture(e.texture);
					}));
				}
				hasTransition() {
					return !1;
				}
			}
			class fe extends de {
				constructor(e, n, i, a) {
					super(e, n, i, a), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, n), this.encoding = n.encoding || "mapbox", this.redFactor = n.redFactor, this.greenFactor = n.greenFactor, this.blueFactor = n.blueFactor, this.baseShift = n.baseShift;
				}
				loadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						let n = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = this.map._requestManager.transformRequest(n, "Tile");
						e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController();
						try {
							let n = yield _.getImage(i, e.abortController, this.map._refreshExpiredTiles);
							if (delete e.abortController, e.aborted) return void (e.state = "unloaded");
							if (n && n.data) {
								let i = n.data;
								this.map._refreshExpiredTiles && (n.cacheControl || n.expires) && e.setExpiryData({
									cacheControl: n.cacheControl,
									expires: n.expires
								});
								let a = t.b(i) && t.W() ? i : yield this.readImageNow(i), o = {
									type: this.type,
									uid: e.uid,
									source: this.id,
									rawImageData: a,
									encoding: this.encoding,
									redFactor: this.redFactor,
									greenFactor: this.greenFactor,
									blueFactor: this.blueFactor,
									baseShift: this.baseShift
								};
								(!e.actor || e.state === "expired") && (e.actor = this.dispatcher.getActor(), e.dem = yield e.actor.sendAsync({
									type: "LDT",
									data: o
								}), e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded");
							}
						} catch (t) {
							if (delete e.abortController, e.aborted) e.state = "unloaded";
							else if (t) throw e.state = "errored", t;
						}
					}));
				}
				readImageNow(e) {
					return t._(this, void 0, void 0, (function* () {
						if (typeof VideoFrame < "u" && t.X()) {
							let n = e.width + 2, i = e.height + 2;
							try {
								return new t.R({
									width: n,
									height: i
								}, yield t.Y(e, -1, -1, n, i));
							} catch {}
						}
						return s.getImageData(e, 1);
					}));
				}
				_getNeighboringTiles(e) {
					let n = e.canonical, i = 2 ** n.z, a = (n.x - 1 + i) % i, o = n.x === 0 ? e.wrap - 1 : e.wrap, s = (n.x + 1 + i) % i, c = n.x + 1 === i ? e.wrap + 1 : e.wrap, l = {};
					return l[new t.Z(e.overscaledZ, o, n.z, a, n.y).key] = { backfilled: !1 }, l[new t.Z(e.overscaledZ, c, n.z, s, n.y).key] = { backfilled: !1 }, n.y > 0 && (l[new t.Z(e.overscaledZ, o, n.z, a, n.y - 1).key] = { backfilled: !1 }, l[new t.Z(e.overscaledZ, e.wrap, n.z, n.x, n.y - 1).key] = { backfilled: !1 }, l[new t.Z(e.overscaledZ, c, n.z, s, n.y - 1).key] = { backfilled: !1 }), n.y + 1 < i && (l[new t.Z(e.overscaledZ, o, n.z, a, n.y + 1).key] = { backfilled: !1 }, l[new t.Z(e.overscaledZ, e.wrap, n.z, n.x, n.y + 1).key] = { backfilled: !1 }, l[new t.Z(e.overscaledZ, c, n.z, s, n.y + 1).key] = { backfilled: !1 }), l;
				}
				unloadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({
							type: "RDT",
							data: {
								type: this.type,
								uid: e.uid,
								source: this.id
							}
						}));
					}));
				}
			}
			class pe extends t.E {
				constructor(e, n, i, a) {
					super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._isUpdatingWorker = !1, this._pendingWorkerUpdate = { data: n.data }, this.actor = i.getActor(), this.setEventedParent(a), this._data = n.data, this._options = t.e({}, n), this._collectResourceTiming = n.collectResourceTiming, n.maxzoom !== void 0 && (this.maxzoom = n.maxzoom), n.type && (this.type = n.type), n.attribution && (this.attribution = n.attribution), this.promoteId = n.promoteId, n.clusterMaxZoom !== void 0 && this.maxzoom <= n.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${n.clusterMaxZoom}".`), this.workerOptions = t.e({
						source: this.id,
						cluster: n.cluster || !1,
						geojsonVtOptions: {
							buffer: this._pixelsToTileUnits(n.buffer === void 0 ? 128 : n.buffer),
							tolerance: this._pixelsToTileUnits(n.tolerance === void 0 ? .375 : n.tolerance),
							extent: t.$,
							maxZoom: this.maxzoom,
							lineMetrics: n.lineMetrics || !1,
							generateId: n.generateId || !1
						},
						superclusterOptions: {
							maxZoom: this._getClusterMaxZoom(n.clusterMaxZoom),
							minPoints: Math.max(2, n.clusterMinPoints || 2),
							extent: t.$,
							radius: this._pixelsToTileUnits(n.clusterRadius || 50),
							log: !1,
							generateId: n.generateId || !1
						},
						clusterProperties: n.clusterProperties,
						filter: n.filter
					}, n.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
				}
				_hasPendingWorkerUpdate() {
					return this._pendingWorkerUpdate.data !== void 0 || this._pendingWorkerUpdate.diff !== void 0 || this._pendingWorkerUpdate.optionsChanged;
				}
				_pixelsToTileUnits(e) {
					return e * (t.$ / this.tileSize);
				}
				_getClusterMaxZoom(e) {
					let n = e ? Math.round(e) : this.maxzoom - 1;
					return Number.isInteger(e) || e === void 0 || t.w(`Integer expected for option 'clusterMaxZoom': provided value "${e}" rounded to "${n}"`), n;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						yield this._updateWorkerData();
					}));
				}
				onAdd(e) {
					this.map = e, this.load();
				}
				setData(e) {
					return this._data = e, this._pendingWorkerUpdate = { data: e }, this._updateWorkerData(), this;
				}
				updateData(e) {
					return this._pendingWorkerUpdate.diff = t.a0(this._pendingWorkerUpdate.diff, e), this._updateWorkerData(), this;
				}
				getData() {
					return t._(this, void 0, void 0, (function* () {
						let e = t.e({ type: this.type }, this.workerOptions);
						return this.actor.sendAsync({
							type: "GD",
							data: e
						});
					}));
				}
				getCoordinatesFromGeometry(e) {
					return e.type === "GeometryCollection" ? e.geometries.map(((e) => e.coordinates)).flat(Infinity) : e.coordinates.flat(Infinity);
				}
				getBounds() {
					return t._(this, void 0, void 0, (function* () {
						let e = new ce(), t = yield this.getData(), n;
						switch (t.type) {
							case "FeatureCollection":
								n = t.features.map(((e) => this.getCoordinatesFromGeometry(e.geometry))).flat(Infinity);
								break;
							case "Feature":
								n = this.getCoordinatesFromGeometry(t.geometry);
								break;
							default: n = this.getCoordinatesFromGeometry(t);
						}
						if (n.length == 0) return e;
						for (let t = 0; t < n.length - 1; t += 2) e.extend([n[t], n[t + 1]]);
						return e;
					}));
				}
				setClusterOptions(e) {
					return this.workerOptions.cluster = e.cluster, e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = this._getClusterMaxZoom(e.clusterMaxZoom)), this._pendingWorkerUpdate.optionsChanged = !0, this._updateWorkerData(), this;
				}
				getClusterExpansionZoom(e) {
					return this.actor.sendAsync({
						type: "GCEZ",
						data: {
							type: this.type,
							clusterId: e,
							source: this.id
						}
					});
				}
				getClusterChildren(e) {
					return this.actor.sendAsync({
						type: "GCC",
						data: {
							type: this.type,
							clusterId: e,
							source: this.id
						}
					});
				}
				getClusterLeaves(e, t, n) {
					return this.actor.sendAsync({
						type: "GCL",
						data: {
							type: this.type,
							source: this.id,
							clusterId: e,
							limit: t,
							offset: n
						}
					});
				}
				_updateWorkerData() {
					return t._(this, void 0, void 0, (function* () {
						if (this._isUpdatingWorker) return;
						if (!this._hasPendingWorkerUpdate()) return void t.w(`No pending worker updates for GeoJSONSource ${this.id}.`);
						let { data: e, diff: n } = this._pendingWorkerUpdate, i = t.e({ type: this.type }, this.workerOptions);
						e ? (typeof e == "string" ? (i.request = this.map._requestManager.transformRequest(s.resolveURL(e), "Source"), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(e), this._pendingWorkerUpdate.data = void 0) : n && (i.dataDiff = n, this._pendingWorkerUpdate.diff = void 0), this._pendingWorkerUpdate.optionsChanged = void 0, this._isUpdatingWorker = !0, this.fire(new t.l("dataloading", { dataType: "source" }));
						try {
							let e = yield this.actor.sendAsync({
								type: "LD",
								data: i
							});
							if (this._isUpdatingWorker = !1, this._removed || e.abandoned) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							this._data = e.data;
							let n = null;
							e.resourceTiming && e.resourceTiming[this.id] && (n = e.resourceTiming[this.id].slice(0));
							let a = { dataType: "source" };
							this._collectResourceTiming && n && n.length > 0 && t.e(a, { resourceTiming: n }), this.fire(new t.l("data", Object.assign(Object.assign({}, a), { sourceDataType: "metadata" }))), this.fire(new t.l("data", Object.assign(Object.assign({}, a), { sourceDataType: "content" })));
						} catch (e) {
							if (this._isUpdatingWorker = !1, this._removed) return void this.fire(new t.l("dataabort", { dataType: "source" }));
							this.fire(new t.k(e));
						} finally {
							this._hasPendingWorkerUpdate() && this._updateWorkerData();
						}
					}));
				}
				loaded() {
					return !this._isUpdatingWorker && !this._hasPendingWorkerUpdate();
				}
				loadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						let t = e.actor ? "RT" : "LT";
						e.actor = this.actor;
						let n = {
							type: this.type,
							uid: e.uid,
							tileID: e.tileID,
							zoom: e.tileID.overscaledZ,
							maxZoom: this.maxzoom,
							tileSize: this.tileSize,
							source: this.id,
							pixelRatio: this.map.getPixelRatio(),
							showCollisionBoxes: this.map.showCollisionBoxes,
							promoteId: this.promoteId,
							subdivisionGranularity: this.map.style.projection.subdivisionGranularity
						};
						e.abortController = new AbortController();
						let i = yield this.actor.sendAsync({
							type: t,
							data: n
						}, e.abortController);
						delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(i, this.map.painter, t === "RT");
					}));
				}
				abortTile(e) {
					return t._(this, void 0, void 0, (function* () {
						e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0;
					}));
				}
				unloadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						e.unloadVectorData(), yield this.actor.sendAsync({
							type: "RMT",
							data: {
								uid: e.uid,
								type: this.type,
								source: this.id
							}
						});
					}));
				}
				onRemove() {
					this._removed = !0, this.actor.sendAsync({
						type: "RS",
						data: {
							type: this.type,
							source: this.id
						}
					});
				}
				serialize() {
					return t.e({}, this._options, {
						type: this.type,
						data: this._data
					});
				}
				hasTransition() {
					return !1;
				}
			}
			class V extends t.E {
				constructor(e, t, n, i) {
					super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = n, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(i), this.options = t;
				}
				load(e) {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1, this.fire(new t.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
						try {
							let t = yield _.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
							this._request = null, this._loaded = !0, t && t.data && (this.image = t.data, e && (this.coordinates = e), this._finishLoading());
						} catch (e) {
							this._request = null, this._loaded = !0, this.fire(new t.k(e));
						}
					}));
				}
				loaded() {
					return this._loaded;
				}
				updateImage(e) {
					return e.url ? (this._request &&= (this._request.abort(), null), this.options.url = e.url, this.load(e.coordinates).finally((() => {
						this.texture = null;
					})), this) : this;
				}
				_finishLoading() {
					this.map && (this.setCoordinates(this.coordinates), this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "metadata"
					})));
				}
				onAdd(e) {
					this.map = e, this.load();
				}
				onRemove() {
					this._request &&= (this._request.abort(), null);
				}
				setCoordinates(e) {
					this.coordinates = e;
					let n = e.map(t.a1.fromLngLat);
					var i;
					return this.tileID = function(e) {
						let n = t.a2.fromPoints(e), i = n.width(), a = n.height(), o = Math.max(i, a), s = Math.max(0, Math.floor(-Math.log(o) / Math.LN2)), c = 2 ** s;
						return new t.a4(s, Math.floor((n.minX + n.maxX) / 2 * c), Math.floor((n.minY + n.maxY) / 2 * c));
					}(n), this.terrainTileRanges = this._getOverlappingTileRanges(n), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = n.map(((e) => this.tileID.getTilePoint(e)._round())), this.flippedWindingOrder = ((i = this.tileCoords)[1].x - i[0].x) * (i[2].y - i[0].y) - (i[1].y - i[0].y) * (i[2].x - i[0].x) < 0, this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "content"
					})), this;
				}
				prepare() {
					if (Object.keys(this.tiles).length === 0 || !this.image) return;
					let e = this.map.painter.context, n = e.gl;
					this.texture || (this.texture = new t.T(e, this.image, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
					let i = !1;
					for (let e in this.tiles) {
						let t = this.tiles[e];
						t.state !== "loaded" && (t.state = "loaded", t.texture = this.texture, i = !0);
					}
					i && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				loadTile(e) {
					return t._(this, void 0, void 0, (function* () {
						this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored";
					}));
				}
				serialize() {
					return {
						type: "image",
						url: this.options.url,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return !1;
				}
				_getOverlappingTileRanges(e) {
					let { minX: n, minY: i, maxX: a, maxY: o } = t.a2.fromPoints(e), s = {};
					for (let e = 0; e <= t.a3; e++) {
						let t = 2 ** e, c = Math.floor(n * t), l = Math.floor(i * t), u = Math.floor(a * t), d = Math.floor(o * t);
						s[e] = {
							minTileX: c,
							minTileY: l,
							maxTileX: u,
							maxTileY: d
						};
					}
					return s;
				}
			}
			class me extends V {
				constructor(e, t, n, i) {
					super(e, t, n, i), this.roundZoom = !0, this.type = "video", this.options = t;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !1;
						let e = this.options;
						this.urls = [];
						for (let t of e.urls) this.urls.push(this.map._requestManager.transformRequest(t, "Source").url);
						try {
							let e = yield t.a5(this.urls);
							if (this._loaded = !0, !e) return;
							this.video = e, this.video.loop = !0, this.video.addEventListener("playing", (() => {
								this.map.triggerRepaint();
							})), this.map && this.video.play(), this._finishLoading();
						} catch (e) {
							this.fire(new t.k(e));
						}
					}));
				}
				pause() {
					this.video && this.video.pause();
				}
				play() {
					this.video && this.video.play();
				}
				seek(e) {
					if (this.video) {
						let n = this.video.seekable;
						e < n.start(0) || e > n.end(0) ? this.fire(new t.k(new t.a6(`sources.${this.id}`, null, `Playback for this video can be set only between the ${n.start(0)} and ${n.end(0)}-second mark.`))) : this.video.currentTime = e;
					}
				}
				getVideo() {
					return this.video;
				}
				onAdd(e) {
					this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
				}
				prepare() {
					if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
					let e = this.map.painter.context, n = e.gl;
					this.texture ? this.video.paused || (this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, n.RGBA, n.UNSIGNED_BYTE, this.video)) : (this.texture = new t.T(e, this.video, n.RGBA), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
					let i = !1;
					for (let e in this.tiles) {
						let t = this.tiles[e];
						t.state !== "loaded" && (t.state = "loaded", t.texture = this.texture, i = !0);
					}
					i && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "video",
						urls: this.urls,
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this.video && !this.video.paused;
				}
			}
			class he extends V {
				constructor(e, n, i, a) {
					super(e, n, i, a), n.coordinates ? Array.isArray(n.coordinates) && n.coordinates.length === 4 && !n.coordinates.some(((e) => !Array.isArray(e) || e.length !== 2 || e.some(((e) => typeof e != "number")))) || this.fire(new t.k(new t.a6(`sources.${e}`, null, "\"coordinates\" property must be an array of 4 longitude/latitude array pairs"))) : this.fire(new t.k(new t.a6(`sources.${e}`, null, "missing required property \"coordinates\""))), n.animate && typeof n.animate != "boolean" && this.fire(new t.k(new t.a6(`sources.${e}`, null, "optional \"animate\" property must be a boolean value"))), n.canvas ? typeof n.canvas == "string" || n.canvas instanceof HTMLCanvasElement || this.fire(new t.k(new t.a6(`sources.${e}`, null, "\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance"))) : this.fire(new t.k(new t.a6(`sources.${e}`, null, "missing required property \"canvas\""))), this.options = n, this.animate = n.animate === void 0 || n.animate;
				}
				load() {
					return t._(this, void 0, void 0, (function* () {
						this._loaded = !0, this.canvas ||= this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.k(/* @__PURE__ */ Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
							this._playing = !0, this.map.triggerRepaint();
						}, this.pause = function() {
							this._playing &&= (this.prepare(), !1);
						}, this._finishLoading());
					}));
				}
				getCanvas() {
					return this.canvas;
				}
				onAdd(e) {
					this.map = e, this.load(), this.canvas && this.animate && this.play();
				}
				onRemove() {
					this.pause();
				}
				prepare() {
					let e = !1;
					if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
					let n = this.map.painter.context, i = n.gl;
					this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new t.T(n, this.canvas, i.RGBA, { premultiply: !0 });
					let a = !1;
					for (let e in this.tiles) {
						let t = this.tiles[e];
						t.state !== "loaded" && (t.state = "loaded", t.texture = this.texture, a = !0);
					}
					a && this.fire(new t.l("data", {
						dataType: "source",
						sourceDataType: "idle",
						sourceId: this.id
					}));
				}
				serialize() {
					return {
						type: "canvas",
						coordinates: this.coordinates
					};
				}
				hasTransition() {
					return this._playing;
				}
				_hasInvalidDimensions() {
					for (let e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
					return !1;
				}
			}
			let ge = {}, _e = (e) => {
				switch (e) {
					case "geojson": return pe;
					case "image": return V;
					case "raster": return de;
					case "raster-dem": return fe;
					case "vector": return ue;
					case "video": return me;
					case "canvas": return he;
				}
				return ge[e];
			}, H = "RTLPluginLoaded";
			class ve extends t.E {
				constructor() {
					super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = ne();
				}
				_syncState(e) {
					return this.status = e, this.dispatcher.broadcast("SRPS", {
						pluginStatus: e,
						pluginURL: this.url
					}).catch(((e) => {
						throw this.status = "error", e;
					}));
				}
				getRTLTextPluginStatus() {
					return this.status;
				}
				clearRTLTextPlugin() {
					this.status = "unavailable", this.url = null;
				}
				setRTLTextPlugin(e) {
					return t._(this, arguments, void 0, (function* (e, t = !1) {
						if (this.url) throw Error("setRTLTextPlugin cannot be called multiple times.");
						if (this.url = s.resolveURL(e), !this.url) throw Error(`requested url ${e} is invalid`);
						if (this.status === "unavailable") {
							if (!t) return this._requestImport();
							this.status = "deferred", this._syncState(this.status);
						} else if (this.status === "requested") return this._requestImport();
					}));
				}
				_requestImport() {
					return t._(this, void 0, void 0, (function* () {
						yield this._syncState("loading"), this.status = "loaded", this.fire(new t.l(H));
					}));
				}
				lazyLoad() {
					this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
				}
			}
			let ye = null;
			function be() {
				return ye ||= new ve(), ye;
			}
			var xe, Se;
			(function(e) {
				e[e.Base = 0] = "Base", e[e.Parent = 1] = "Parent";
			})(xe ||= {}), function(e) {
				e[e.Departing = 0] = "Departing", e[e.Incoming = 1] = "Incoming";
			}(Se ||= {});
			class Ce {
				constructor(e, n) {
					this.timeAdded = 0, this.fadeEndTime = 0, this.fadeOpacity = 1, this.tileID = e, this.uid = t.a7(), this.uses = 0, this.tileSize = n, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
				}
				isRenderable(e) {
					return this.hasData() && (!this.fadeEndTime || this.fadeOpacity > 0) && (e || !this.holdingForSymbolFade());
				}
				setCrossFadeLogic({ fadingRole: e, fadingDirection: t, fadingParentID: n, fadeEndTime: i }) {
					this.resetFadeLogic(), this.fadingRole = e, this.fadingDirection = t, this.fadingParentID = n, this.fadeEndTime = i;
				}
				setSelfFadeLogic(e) {
					this.resetFadeLogic(), this.selfFading = !0, this.fadeEndTime = e;
				}
				resetFadeLogic() {
					this.fadingRole = null, this.fadingDirection = null, this.fadingParentID = null, this.selfFading = !1, this.timeAdded = l(), this.fadeEndTime = 0, this.fadeOpacity = 1;
				}
				wasRequested() {
					return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
				}
				clearTextures(e) {
					this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null;
				}
				loadVectorData(e, n, i) {
					if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) {
						for (let a in e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function(e, t) {
							let n = {};
							if (!t) return n;
							for (let i of e) {
								let e = i.layerIds.map(((e) => t.getLayer(e))).filter(Boolean);
								if (e.length !== 0) {
									i.layers = e, i.stateDependentLayerIds && (i.stateDependentLayers = i.stateDependentLayerIds.map(((t) => e.filter(((e) => e.id === t))[0])));
									for (let t of e) n[t.id] = i;
								}
							}
							return n;
						}(e.buckets, n?.style), this.hasSymbolBuckets = !1, this.buckets) {
							let e = this.buckets[a];
							if (e instanceof t.a9) {
								if (this.hasSymbolBuckets = !0, !i) break;
								e.justReloaded = !0;
							}
						}
						if (this.hasRTLText = !1, this.hasSymbolBuckets) for (let e in this.buckets) {
							let n = this.buckets[e];
							if (n instanceof t.a9 && n.hasRTLText) {
								this.hasRTLText = !0, be().lazyLoad();
								break;
							}
						}
						for (let e in this.queryPadding = 0, this.buckets) {
							let t = this.buckets[e];
							this.queryPadding = Math.max(this.queryPadding, n.style.getLayer(e).queryRadius(t));
						}
						e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage), this.dashPositions = e.dashPositions;
					} else this.collisionBoxArray = new t.a8();
				}
				unloadVectorData() {
					for (let e in this.buckets) this.buckets[e].destroy();
					this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas &&= null, this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.dashPositions &&= null, this.latestFeatureIndex = null, this.state = "unloaded";
				}
				getBucket(e) {
					return this.buckets[e.id];
				}
				upload(e) {
					for (let t in this.buckets) {
						let n = this.buckets[t];
						n.uploadPending() && n.upload(e);
					}
					let n = e.gl;
					this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new t.T(e, this.imageAtlas.image, n.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage &&= (this.glyphAtlasTexture = new t.T(e, this.glyphAtlasImage, n.ALPHA), null);
				}
				prepare(e) {
					this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture);
				}
				queryRenderedFeatures(e, t, n, i, a, o, s, c, l, u, d) {
					return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
						queryGeometry: i,
						cameraQueryGeometry: a,
						scale: o,
						tileSize: this.tileSize,
						pixelPosMatrix: u,
						transform: c,
						params: s,
						queryPadding: this.queryPadding * l,
						getElevation: d
					}, e, t, n) : {};
				}
				querySourceFeatures(e, n) {
					let i = this.latestFeatureIndex;
					if (!i || !i.rawTileData) return;
					let a = i.loadVTLayers(), o = n && n.sourceLayer ? n.sourceLayer : "", s = a._geojsonTileLayer || a[o];
					if (!s) return;
					let c = t.aa(n?.filter, n?.globalState), { z: l, x: u, y: d } = this.tileID.canonical, f = {
						z: l,
						x: u,
						y: d
					};
					for (let n = 0; n < s.length; n++) {
						let a = s.feature(n);
						if (c.needGeometry) {
							let e = t.ab(a, !0);
							if (!c.filter(new t.F(this.tileID.overscaledZ), e, this.tileID.canonical)) continue;
						} else if (!c.filter(new t.F(this.tileID.overscaledZ), a)) continue;
						let p = i.getId(a, o), m = new t.ac(a, l, u, d, p);
						m.tile = f, e.push(m);
					}
				}
				hasData() {
					return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
				}
				patternsLoaded() {
					return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
				}
				setExpiryData(e) {
					let n = this.expirationTime;
					if (e.cacheControl) {
						let n = t.ad(e.cacheControl);
						n["max-age"] && (this.expirationTime = Date.now() + 1e3 * n["max-age"]);
					} else e.expires && (this.expirationTime = new Date(e.expires).getTime());
					if (this.expirationTime) {
						let e = Date.now(), t = !1;
						if (this.expirationTime > e) t = !1;
						else if (n) if (this.expirationTime < n) t = !0;
						else {
							let i = this.expirationTime - n;
							i ? this.expirationTime = e + Math.max(i, 3e4) : t = !0;
						}
						else t = !0;
						t ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
					}
				}
				getExpiryTimeout() {
					if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), 2 ** 31 - 1);
				}
				setFeatureState(e, t) {
					if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0) return;
					let n = this.latestFeatureIndex.loadVTLayers();
					for (let i in this.buckets) {
						if (!t.style.hasLayer(i)) continue;
						let a = this.buckets[i], o = a.layers[0].sourceLayer || "_geojsonTileLayer", s = n[o], c = e[o];
						if (!s || !c || Object.keys(c).length === 0) continue;
						a.update(c, s, this.imageAtlas && this.imageAtlas.patternPositions || {}, this.dashPositions || {});
						let l = t && t.style && t.style.getLayer(i);
						l && (this.queryPadding = Math.max(this.queryPadding, l.queryRadius(a)));
					}
				}
				holdingForSymbolFade() {
					return this.symbolFadeHoldUntil !== void 0;
				}
				symbolFadeFinished() {
					return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < l();
				}
				clearSymbolFadeHold() {
					this.symbolFadeHoldUntil = void 0;
				}
				setSymbolHoldDuration(e) {
					this.symbolFadeHoldUntil = l() + e;
				}
				setDependencies(e, t) {
					let n = {};
					for (let e of t) n[e] = !0;
					this.dependencies[e] = n;
				}
				hasDependency(e, t) {
					for (let n of e) {
						let e = this.dependencies[n];
						if (e) {
							for (let n of t) if (e[n]) return !0;
						}
					}
					return !1;
				}
			}
			class we {
				constructor(e, t) {
					this.max = e, this.onRemove = t, this.reset();
				}
				reset() {
					for (let e in this.data) for (let t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);
					return this.data = {}, this.order = [], this;
				}
				add(e, t, n) {
					let i = e.wrapped().key;
					this.data[i] === void 0 && (this.data[i] = []);
					let a = {
						value: t,
						timeout: void 0
					};
					if (n !== void 0 && (a.timeout = setTimeout((() => {
						this.remove(e, a);
					}), n)), this.data[i].push(a), this.order.push(i), this.order.length > this.max) {
						let e = this._getAndRemoveByKey(this.order[0]);
						e && this.onRemove(e);
					}
					return this;
				}
				has(e) {
					return e.wrapped().key in this.data;
				}
				getAndRemove(e) {
					return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
				}
				_getAndRemoveByKey(e) {
					let t = this.data[e].shift();
					return t.timeout && clearTimeout(t.timeout), this.data[e].length === 0 && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value;
				}
				getByKey(e) {
					let t = this.data[e];
					return t ? t[0].value : null;
				}
				get(e) {
					return this.has(e) ? this.data[e.wrapped().key][0].value : null;
				}
				remove(e, t) {
					if (!this.has(e)) return this;
					let n = e.wrapped().key, i = t === void 0 ? 0 : this.data[n].indexOf(t), a = this.data[n][i];
					return this.data[n].splice(i, 1), a.timeout && clearTimeout(a.timeout), this.data[n].length === 0 && delete this.data[n], this.onRemove(a.value), this.order.splice(this.order.indexOf(n), 1), this;
				}
				setMaxSize(e) {
					for (this.max = e; this.order.length > this.max;) {
						let e = this._getAndRemoveByKey(this.order[0]);
						e && this.onRemove(e);
					}
					return this;
				}
				filter(e) {
					let t = [];
					for (let n in this.data) for (let i of this.data[n]) e(i.value) || t.push(i);
					for (let e of t) this.remove(e.value.tileID, e);
				}
			}
			class Te {
				constructor() {
					this.state = {}, this.stateChanges = {}, this.deletedStates = {};
				}
				updateState(e, n, i) {
					let a = String(n);
					if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][a] = this.stateChanges[e][a] || {}, t.e(this.stateChanges[e][a], i), this.deletedStates[e] === null) for (let t in this.deletedStates[e] = {}, this.state[e]) t !== a && (this.deletedStates[e][t] = null);
					else if (this.deletedStates[e] && this.deletedStates[e][a] === null) for (let t in this.deletedStates[e][a] = {}, this.state[e][a]) i[t] || (this.deletedStates[e][a][t] = null);
					else for (let t in i) this.deletedStates[e] && this.deletedStates[e][a] && this.deletedStates[e][a][t] === null && delete this.deletedStates[e][a][t];
				}
				removeFeatureState(e, t, n) {
					if (this.deletedStates[e] === null) return;
					let i = String(t);
					if (this.deletedStates[e] = this.deletedStates[e] || {}, n && t !== void 0) this.deletedStates[e][i] !== null && (this.deletedStates[e][i] = this.deletedStates[e][i] || {}, this.deletedStates[e][i][n] = null);
					else if (t !== void 0) if (this.stateChanges[e] && this.stateChanges[e][i]) for (n in this.deletedStates[e][i] = {}, this.stateChanges[e][i]) this.deletedStates[e][i][n] = null;
					else this.deletedStates[e][i] = null;
					else this.deletedStates[e] = null;
				}
				getState(e, n) {
					let i = String(n), a = t.e({}, (this.state[e] || {})[i], (this.stateChanges[e] || {})[i]);
					if (this.deletedStates[e] === null) return {};
					if (this.deletedStates[e]) {
						let t = this.deletedStates[e][n];
						if (t === null) return {};
						for (let e in t) delete a[e];
					}
					return a;
				}
				initializeTileState(e, t) {
					e.setFeatureState(this.state, t);
				}
				coalesceChanges(e, n) {
					let i = {};
					for (let e in this.stateChanges) {
						this.state[e] = this.state[e] || {};
						let n = {};
						for (let i in this.stateChanges[e]) this.state[e][i] || (this.state[e][i] = {}), t.e(this.state[e][i], this.stateChanges[e][i]), n[i] = this.state[e][i];
						i[e] = n;
					}
					for (let e in this.deletedStates) {
						this.state[e] = this.state[e] || {};
						let n = {};
						if (this.deletedStates[e] === null) for (let t in this.state[e]) n[t] = {}, this.state[e][t] = {};
						else for (let t in this.deletedStates[e]) {
							if (this.deletedStates[e][t] === null) this.state[e][t] = {};
							else for (let n of Object.keys(this.deletedStates[e][t])) delete this.state[e][t][n];
							n[t] = this.state[e][t];
						}
						i[e] = i[e] || {}, t.e(i[e], n);
					}
					if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(i).length !== 0) for (let t in e) e[t].setFeatureState(i, n);
				}
			}
			let Ee = 89.25;
			function De(e, n) {
				let i = t.ae(n.lat, -t.af, t.af);
				return new t.P(t.V(n.lng) * e, t.U(i) * e);
			}
			function Oe(e, n) {
				return new t.a1(n.x / e, n.y / e).toLngLat();
			}
			function ke(e) {
				return e.cameraToCenterDistance * Math.min(.85 * Math.tan(t.ag(90 - e.pitch)), Math.tan(t.ag(Ee - e.pitch)));
			}
			function Ae(e, n) {
				let i = e.canonical, a = n / t.ah(i.z), o = i.x + 2 ** i.z * e.wrap, s = t.ai(new Float64Array(16));
				return t.M(s, s, [
					o * a,
					i.y * a,
					0
				]), t.N(s, s, [
					a / t.$,
					a / t.$,
					1
				]), s;
			}
			function je(e, n, i, a, o) {
				let s = t.a1.fromLngLat(e, n), c = o * t.aj(1, e.lat), l = c * Math.cos(t.ag(i)), u = Math.sqrt(c * c - l * l), d = u * Math.sin(t.ag(-a)), f = u * Math.cos(t.ag(-a));
				return new t.a1(s.x + d, s.y + f, s.z + l);
			}
			function Me(e, t, n) {
				let i = t.intersectsFrustum(e);
				if (!n || i === 0) return i;
				let a = t.intersectsPlane(n);
				return a === 0 ? 0 : i === 2 && a === 2 ? 2 : 1;
			}
			function Ne(e, t, n) {
				let i = 0, a = (n - t) / 10;
				for (let o = 0; o < 10; o++) i += a * Math.cos(t + (o + .5) / 10 * (n - t)) ** +e;
				return i;
			}
			function U(e, n) {
				return function(i, a, o, s, c) {
					let l = 2 * ((e - 1) / t.ak(Math.cos(t.ag(Ee - c)) / Math.cos(t.ag(Ee))) - 1), u = Math.acos(o / s), d = 2 * Ne(l - 1, 0, t.ag(c / 2)), f = Math.min(t.ag(Ee), u + t.ag(c / 2)), p = Ne(l - 1, Math.min(f, u - t.ag(c / 2)), f), m = Math.atan(a / o), h = Math.hypot(a, o), g = i;
					return g += t.ak(s / h / Math.max(.5, Math.cos(t.ag(c / 2)))), g += l * t.ak(Math.cos(m)) / 2, g -= t.ak(Math.max(1, p / d / n)) / 2, g;
				};
			}
			let Pe = U(9.314, 3);
			function Fe(e, n) {
				let i = (n.roundZoom ? Math.round : Math.floor)(e.zoom + t.ak(e.tileSize / n.tileSize));
				return Math.max(0, i);
			}
			function Ie(e, n) {
				let i = e.getCameraFrustum(), a = e.getClippingPlane(), o = e.screenPointToMercatorCoordinate(e.getCameraPoint()), s = t.a1.fromLngLat(e.center, e.elevation);
				o.z = s.z + Math.cos(e.pitchInRadians) * e.cameraToCenterDistance / e.worldSize;
				let c = e.getCoveringTilesDetailsProvider(), l = c.allowVariableZoom(e, n), u = Fe(e, n), d = n.minzoom || 0, f = n.maxzoom === void 0 ? e.maxZoom : n.maxzoom, p = Math.min(Math.max(0, u), f), m = 2 ** p, h = [
					m * o.x,
					m * o.y,
					0
				], g = [
					m * s.x,
					m * s.y,
					0
				], _ = Math.hypot(s.x - o.x, s.y - o.y), v = Math.abs(s.z - o.z), y = Math.hypot(_, v), b = (e) => ({
					zoom: 0,
					x: 0,
					y: 0,
					wrap: e,
					fullyVisible: !1
				}), x = [], S = [];
				if (e.renderWorldCopies && c.allowWorldCopies()) for (let e = 1; e <= 3; e++) x.push(b(-e)), x.push(b(e));
				for (x.push(b(0)); x.length > 0;) {
					let m = x.pop(), _ = m.x, b = m.y, C = m.fullyVisible, w = {
						x: _,
						y: b,
						z: m.zoom
					}, T = c.getTileBoundingVolume(w, m.wrap, e.elevation, n);
					if (!C) {
						let e = Me(i, T, a);
						if (e === 0) continue;
						C = e === 2;
					}
					let E = c.distanceToTile2d(o.x, o.y, w, T), O = u;
					l && (O = (n.calculateTileZoom || Pe)(e.zoom + t.ak(e.tileSize / n.tileSize), E, v, y, e.fov)), O = (n.roundZoom ? Math.round : Math.floor)(O), O = Math.max(0, O);
					let k = Math.min(O, f);
					if (m.wrap = c.getWrap(s, w, m.wrap), m.zoom >= k) {
						if (m.zoom < d) continue;
						let e = p - m.zoom, i = h[0] - .5 - (_ << e), a = h[1] - .5 - (b << e), o = n.reparseOverscaled ? Math.max(m.zoom, O) : m.zoom;
						S.push({
							tileID: new t.Z(m.zoom === f ? o : m.zoom, m.wrap, m.zoom, _, b),
							distanceSq: t.al([g[0] - .5 - _, g[1] - .5 - b]),
							tileDistanceToCamera: Math.sqrt(i * i + a * a)
						});
					} else for (let e = 0; e < 4; e++) x.push({
						zoom: m.zoom + 1,
						x: (_ << 1) + e % 2,
						y: (b << 1) + (e >> 1),
						wrap: m.wrap,
						fullyVisible: C
					});
				}
				return S.sort(((e, t) => e.distanceSq - t.distanceSq)).map(((e) => e.tileID));
			}
			let Le = t.a2.fromPoints([new t.P(0, 0), new t.P(t.$, t.$)]);
			class Re extends t.E {
				constructor(e, t, n) {
					super(), this.id = e, this.dispatcher = n, this.on("data", ((e) => this._dataHandler(e))), this.on("dataloading", (() => {
						this._sourceErrored = !1;
					})), this.on("error", (() => {
						this._sourceErrored = this._source.loaded();
					})), this._source = ((e, t, n, i) => {
						let a = new (_e(t.type))(e, t, n, i);
						if (a.id !== e) throw Error(`Expected Source id to be ${e} instead of ${a.id}`);
						return a;
					})(e, t, n, this), this._tiles = {}, this._cache = new we(0, ((e) => this._unloadTile(e))), this._timers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._rasterFadeDuration = 0, this._maxFadingAncestorLevels = 5, this._state = new Te(), this._didEmitContent = !1, this._updated = !1;
				}
				onAdd(e) {
					this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e);
				}
				onRemove(e) {
					this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e);
				}
				loaded() {
					if (this._sourceErrored) return !0;
					if (!this._sourceLoaded || !this._source.loaded()) return !1;
					if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
					if (!this._updated) return !1;
					for (let e in this._tiles) {
						let t = this._tiles[e];
						if (t.state !== "loaded" && t.state !== "errored") return !1;
					}
					return !0;
				}
				getSource() {
					return this._source;
				}
				pause() {
					this._paused = !0;
				}
				resume() {
					if (!this._paused) return;
					let e = this._shouldReloadOnResume;
					this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain);
				}
				_loadTile(e, n, i) {
					return t._(this, void 0, void 0, (function* () {
						try {
							yield this._source.loadTile(e), this._tileLoaded(e, n, i);
						} catch (n) {
							e.state = "errored", n.status === 404 ? this.update(this.transform, this.terrain) : this._source.fire(new t.k(n, { tile: e }));
						}
					}));
				}
				_unloadTile(e) {
					this._source.unloadTile && this._source.unloadTile(e);
				}
				_abortTile(e) {
					this._source.abortTile && this._source.abortTile(e), this._source.fire(new t.l("dataabort", {
						tile: e,
						coord: e.tileID,
						dataType: "source"
					}));
				}
				serialize() {
					return this._source.serialize();
				}
				prepare(e) {
					for (let t in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
						let n = this._tiles[t];
						n.upload(e), n.prepare(this.map.style.imageManager);
					}
				}
				getIds() {
					return Object.values(this._tiles).map(((e) => e.tileID)).sort(ze).map(((e) => e.key));
				}
				getRenderableIds(e) {
					let n = [];
					for (let t in this._tiles) this._isIdRenderable(t, e) && n.push(this._tiles[t]);
					return e ? n.sort(((e, n) => {
						let i = e.tileID, a = n.tileID, o = new t.P(i.canonical.x, i.canonical.y)._rotate(-this.transform.bearingInRadians), s = new t.P(a.canonical.x, a.canonical.y)._rotate(-this.transform.bearingInRadians);
						return i.overscaledZ - a.overscaledZ || s.y - o.y || s.x - o.x;
					})).map(((e) => e.tileID.key)) : n.map(((e) => e.tileID)).sort(ze).map(((e) => e.key));
				}
				hasRenderableParent(e) {
					let t = e.overscaledZ - 1;
					if (t >= this._source.minzoom) {
						let n = this._getLoadedTile(e.scaledTo(t));
						if (n) return this._isIdRenderable(n.tileID.key);
					}
					return !1;
				}
				_isIdRenderable(e, t = !1) {
					return this._tiles[e]?.isRenderable(t);
				}
				reload(e) {
					if (this._paused) this._shouldReloadOnResume = !0;
					else for (let t in this._cache.reset(), this._tiles) e ? this._reloadTile(t, "expired") : this._tiles[t].state !== "errored" && this._reloadTile(t, "reloading");
				}
				_reloadTile(e, n) {
					return t._(this, void 0, void 0, (function* () {
						let t = this._tiles[e];
						t && (t.state !== "loading" && (t.state = n), yield this._loadTile(t, e, n));
					}));
				}
				_tileLoaded(e, n, i) {
					e.timeAdded = l(), i === "expired" && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(n, e), this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new t.l("data", {
						dataType: "source",
						tile: e,
						coord: e.tileID
					}));
				}
				_backfillDEM(e) {
					let t = this.getRenderableIds();
					for (let i = 0; i < t.length; i++) {
						let a = t[i];
						if (e.neighboringTiles && e.neighboringTiles[a]) {
							let t = this.getTileByID(a);
							n(e, t), n(t, e);
						}
					}
					function n(e, t) {
						e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0;
						let n = t.tileID.canonical.x - e.tileID.canonical.x, i = t.tileID.canonical.y - e.tileID.canonical.y, a = 2 ** e.tileID.canonical.z, o = t.tileID.key;
						n === 0 && i === 0 || Math.abs(i) > 1 || (Math.abs(n) > 1 && (Math.abs(n + a) === 1 ? n += a : Math.abs(n - a) === 1 && (n -= a)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, n, i), e.neighboringTiles && e.neighboringTiles[o] && (e.neighboringTiles[o].backfilled = !0)));
					}
				}
				getTile(e) {
					return this.getTileByID(e.key);
				}
				getTileByID(e) {
					return this._tiles[e];
				}
				_retainLoadedChildren(e, t) {
					let n = Object.values(e), i = this._getLoadedDescendents(n), a = {};
					for (let e of n) {
						let n = i[e.key];
						if (!n?.length) {
							a[e.key] = e;
							continue;
						}
						let o = e.overscaledZ + Re.maxUnderzooming, s = n.filter(((e) => e.tileID.overscaledZ <= o));
						if (!s.length) {
							a[e.key] = e;
							continue;
						}
						let c = Math.min(...s.map(((e) => e.tileID.overscaledZ))), l = s.filter(((e) => e.tileID.overscaledZ === c)).map(((e) => e.tileID));
						for (let e of l) t[e.key] = e;
						this._areDescendentsComplete(l, c, e.overscaledZ) || (a[e.key] = e);
					}
					return a;
				}
				_getLoadedDescendents(e) {
					var t;
					let n = {};
					for (let i in this._tiles) {
						let a = this._tiles[i];
						if (a.hasData()) for (let i of e) a.tileID.isChildOf(i) && (n[t = i.key] || (n[t] = [])).push(a);
					}
					return n;
				}
				_areDescendentsComplete(e, t, n) {
					return e.length === 1 && e[0].isOverscaled() ? e[0].overscaledZ === t : 4 ** (t - n) === e.length;
				}
				_getLoadedTile(e) {
					let t = this._tiles[e.key];
					return t?.hasData() ? t : null;
				}
				updateCacheSize(e) {
					let n = Math.ceil(e.width / this._source.tileSize) + 1, i = Math.ceil(e.height / this._source.tileSize) + 1, a = Math.floor(n * i * (this._maxTileCacheZoomLevels === null ? t.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, a) : a;
					this._cache.setMaxSize(o);
				}
				handleWrapJump(e) {
					let t = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
					if (this._prevLng = e, t) {
						let e = {};
						for (let n in this._tiles) {
							let i = this._tiles[n];
							i.tileID = i.tileID.unwrapTo(i.tileID.wrap + t), e[i.tileID.key] = i;
						}
						this._tiles = e, this._resetTileReloadTimers();
					}
				}
				update(e, n) {
					if (!this._sourceLoaded || this._paused) return;
					let i;
					this.transform = e, this.terrain = n, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this.used || this.usedForTerrain ? this._source.tileID ? i = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(((e) => new t.Z(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y))) : (i = Ie(e, {
						tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
						minzoom: this._source.minzoom,
						maxzoom: this._source.maxzoom,
						roundZoom: !this.usedForTerrain && this._source.roundZoom,
						reparseOverscaled: this._source.reparseOverscaled,
						terrain: n,
						calculateTileZoom: this._source.calculateTileZoom
					}), this._source.hasTile && (i = i.filter(((e) => this._source.hasTile(e))))) : i = [], this.usedForTerrain && (i = this._addTerrainIdealTiles(i));
					let a = i.length === 0 && !this._updated && this._didEmitContent;
					this._updated = !0, a && this.fire(new t.l("data", {
						sourceDataType: "idle",
						dataType: "source",
						sourceId: this.id
					}));
					let o = Fe(e, this._source), s = this._updateRetainedTiles(i, o), c = Be(this._source.type);
					c && this._rasterFadeDuration > 0 && !n && this._updateFadingTiles(i, s), c ? this._cleanUpRasterTiles(s) : this._cleanUpVectorTiles(s);
				}
				_cleanUpRasterTiles(e) {
					for (let t in this._tiles) e[t] || this._removeTile(t);
				}
				_cleanUpVectorTiles(e) {
					for (let t in this._tiles) {
						let n = this._tiles[t];
						e[t] ? n.clearSymbolFadeHold() : n.hasSymbolBuckets ? n.holdingForSymbolFade() ? n.symbolFadeFinished() && this._removeTile(t) : n.setSymbolHoldDuration(this.map._fadeDuration) : this._removeTile(t);
					}
				}
				_addTerrainIdealTiles(e) {
					let t = [];
					for (let n of e) if (n.canonical.z > this._source.minzoom) {
						let e = n.scaledTo(n.canonical.z - 1);
						t.push(e);
						let i = n.scaledTo(Math.max(this._source.minzoom, Math.min(n.canonical.z, 5)));
						t.push(i);
					}
					return e.concat(t);
				}
				releaseSymbolFadeTiles() {
					for (let e in this._tiles) this._tiles[e].holdingForSymbolFade() && this._removeTile(e);
				}
				_updateRetainedTiles(e, t) {
					let n = {}, i = {}, a = Math.max(t - Re.maxOverzooming, this._source.minzoom), o = {};
					for (let t of e) {
						let e = this._addTile(t);
						n[t.key] = t, e.hasData() || (o[t.key] = t);
					}
					for (let e in o = this._retainLoadedChildren(o, n), o) {
						let t = o[e], s = this._tiles[e], c = s?.wasRequested();
						for (let e = t.overscaledZ - 1; e >= a; --e) {
							let a = t.scaledTo(e);
							if (i[a.key]) break;
							if (i[a.key] = !0, s = this.getTile(a), !s && c && (s = this._addTile(a)), s) {
								let e = s.hasData();
								if ((e || !this.map?.cancelPendingTileRequestsWhileZooming || c) && (n[a.key] = a), c = s.wasRequested(), e) break;
							}
						}
					}
					return n;
				}
				_updateFadingTiles(e, n) {
					let i = l(), a = t.am(e);
					for (let t of e) {
						let e = this._tiles[t.key];
						e.fadingDirection !== Se.Departing && e.fadeOpacity !== 0 || e.resetFadeLogic(), this._updateFadingAncestor(e, n, i) || this._updateFadingDescendents(e, n, i) || this._updateFadingEdge(e, a, i) || e.resetFadeLogic();
					}
				}
				_updateFadingAncestor(e, t, n) {
					if (!e.hasData()) return !1;
					let { tileID: i, fadingRole: a, fadingDirection: o, fadingParentID: s } = e;
					if (a === xe.Base && o === Se.Incoming && s) return t[s.key] = s, !0;
					let c = Math.max(i.overscaledZ - this._maxFadingAncestorLevels, this._source.minzoom);
					for (let a = i.overscaledZ - 1; a >= c; a--) {
						let o = i.scaledTo(a), s = this._getLoadedTile(o);
						if (s) return e.setCrossFadeLogic({
							fadingRole: xe.Base,
							fadingDirection: Se.Incoming,
							fadingParentID: s.tileID,
							fadeEndTime: n + this._rasterFadeDuration
						}), s.setCrossFadeLogic({
							fadingRole: xe.Parent,
							fadingDirection: Se.Departing,
							fadeEndTime: n + this._rasterFadeDuration
						}), t[o.key] = o, !0;
					}
					return !1;
				}
				_updateFadingDescendents(e, t, n) {
					if (!e.hasData()) return !1;
					let i = e.tileID.children(this._source.maxzoom), a = this._updateFadingChildren(e, i, t, n);
					if (a) return !0;
					for (let o of i) {
						let i = o.children(this._source.maxzoom);
						this._updateFadingChildren(e, i, t, n) && (a = !0);
					}
					return a;
				}
				_updateFadingChildren(e, t, n, i) {
					if (t[0].overscaledZ >= this._source.maxzoom) return !1;
					let a = !1;
					for (let o of t) {
						let t = this._getLoadedTile(o);
						if (!t) continue;
						let { fadingRole: s, fadingDirection: c, fadingParentID: l } = t;
						s === xe.Base && c === Se.Departing && l || (t.setCrossFadeLogic({
							fadingRole: xe.Base,
							fadingDirection: Se.Departing,
							fadingParentID: e.tileID,
							fadeEndTime: i + this._rasterFadeDuration
						}), e.setCrossFadeLogic({
							fadingRole: xe.Parent,
							fadingDirection: Se.Incoming,
							fadeEndTime: i + this._rasterFadeDuration
						})), n[o.key] = o, a = !0;
					}
					return a;
				}
				_updateFadingEdge(e, t, n) {
					let i = e.tileID;
					return !!e.selfFading || !e.hasData() && !!t.has(i) && (e.setSelfFadeLogic(n + this._rasterFadeDuration), !0);
				}
				_addTile(e) {
					let n = this._tiles[e.key];
					if (n) return n;
					n = this._cache.getAndRemove(e), n && (n.resetFadeLogic(), this._setTileReloadTimer(e.key, n), n.tileID = e, this._state.initializeTileState(n, this.map ? this.map.painter : null));
					let i = n;
					return n || (n = new Ce(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(n, e.key, n.state)), n.uses++, this._tiles[e.key] = n, i || this._source.fire(new t.l("dataloading", {
						tile: n,
						coord: n.tileID,
						dataType: "source"
					})), n;
				}
				_setTileReloadTimer(e, t) {
					this._clearTileReloadTimer(e);
					let n = t.getExpiryTimeout();
					n && (this._timers[e] = setTimeout((() => {
						this._reloadTile(e, "expired"), delete this._timers[e];
					}), n));
				}
				_clearTileReloadTimer(e) {
					let t = this._timers[e];
					t && (clearTimeout(t), delete this._timers[e]);
				}
				_resetTileReloadTimers() {
					for (let e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];
					for (let e in this._tiles) this._setTileReloadTimer(e, this._tiles[e]);
				}
				refreshTiles(e) {
					for (let t in this._tiles) (this._isIdRenderable(t) || this._tiles[t].state == "errored") && e.some(((e) => e.equals(this._tiles[t].tileID.canonical))) && this._reloadTile(t, "expired");
				}
				_removeTile(e) {
					let t = this._tiles[e];
					t && (t.uses--, delete this._tiles[e], this._clearTileReloadTimer(e), t.uses > 0 || (t.hasData() && t.state !== "reloading" ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t))));
				}
				_dataHandler(e) {
					e.dataType === "source" && (e.sourceDataType === "metadata" ? this._sourceLoaded = !0 : e.sourceDataType === "content" && this._sourceLoaded && !this._paused && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0));
				}
				clearTiles() {
					for (let e in this._shouldReloadOnResume = !1, this._paused = !1, this._tiles) this._removeTile(e);
					this._cache.reset();
				}
				tilesIn(e, n, i) {
					let a = [], o = this.transform;
					if (!o) return a;
					let s = o.getCoveringTilesDetailsProvider().allowWorldCopies(), c = i ? o.getCameraQueryGeometry(e) : e, l = (e) => o.screenPointToMercatorCoordinate(e, this.terrain), u = this.transformBbox(e, l, !s), d = this.transformBbox(c, l, !s), f = this.getIds(), p = t.a2.fromPoints(d);
					for (let e = 0; e < f.length; e++) {
						let i = this._tiles[f[e]];
						if (i.holdingForSymbolFade()) continue;
						let c = s ? [i.tileID] : [i.tileID.unwrapTo(-1), i.tileID.unwrapTo(0)], l = 2 ** (o.zoom - i.tileID.overscaledZ), m = n * i.queryPadding * t.$ / i.tileSize / l;
						for (let e of c) {
							let n = p.map(((n) => e.getTilePoint(new t.a1(n.x, n.y))));
							if (n.expandBy(m), n.intersects(Le)) {
								let t = u.map(((t) => e.getTilePoint(t))), n = d.map(((t) => e.getTilePoint(t)));
								a.push({
									tile: i,
									tileID: s ? e : e.unwrapTo(0),
									queryGeometry: t,
									cameraQueryGeometry: n,
									scale: l
								});
							}
						}
					}
					return a;
				}
				transformBbox(e, n, i) {
					let a = e.map(n);
					if (i) {
						let i = t.a2.fromPoints(e);
						i.shrinkBy(.001 * Math.min(i.width(), i.height()));
						let o = i.map(n);
						t.a2.fromPoints(a).covers(o) || (a = a.map(((e) => e.x > .5 ? new t.a1(e.x - 1, e.y, e.z) : e)));
					}
					return a;
				}
				getVisibleCoordinates(e) {
					let t = this.getRenderableIds(e).map(((e) => this._tiles[e].tileID));
					return this.transform && this.transform.populateCache(t), t;
				}
				hasTransition() {
					if (this._source.hasTransition()) return !0;
					if (Be(this._source.type) && this._rasterFadeDuration > 0) {
						let e = l();
						for (let t in this._tiles) if (this._tiles[t].fadeEndTime >= e) return !0;
					}
					return !1;
				}
				setRasterFadeDuration(e) {
					this._rasterFadeDuration = e;
				}
				setFeatureState(e, t, n) {
					this._state.updateState(e ||= "_geojsonTileLayer", t, n);
				}
				removeFeatureState(e, t, n) {
					this._state.removeFeatureState(e ||= "_geojsonTileLayer", t, n);
				}
				getFeatureState(e, t) {
					return this._state.getState(e ||= "_geojsonTileLayer", t);
				}
				setDependencies(e, t, n) {
					let i = this._tiles[e];
					i && i.setDependencies(t, n);
				}
				reloadTilesForDependencies(e, t) {
					for (let n in this._tiles) this._tiles[n].hasDependency(e, t) && this._reloadTile(n, "reloading");
					this._cache.filter(((n) => !n.hasDependency(e, t)));
				}
			}
			function ze(e, t) {
				let n = Math.abs(2 * e.wrap) - +(e.wrap < 0), i = Math.abs(2 * t.wrap) - +(t.wrap < 0);
				return e.overscaledZ - t.overscaledZ || i - n || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x;
			}
			function Be(e) {
				return e === "raster" || e === "image" || e === "video";
			}
			Re.maxOverzooming = 10, Re.maxUnderzooming = 3;
			class Ve {
				constructor(e, t) {
					this.reset(e, t);
				}
				reset(e, t) {
					this.points = e || [], this._distances = [0];
					for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);
					this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
				}
				lerp(e) {
					if (this.points.length === 1) return this.points[0];
					e = t.ae(e, 0, 1);
					let n = 1, i = this._distances[n], a = e * this.paddedLength + this.padding;
					for (; i < a && n < this._distances.length;) i = this._distances[++n];
					let o = n - 1, s = this._distances[o], c = i - s, l = c > 0 ? (a - s) / c : 0;
					return this.points[o].mult(1 - l).add(this.points[n].mult(l));
				}
			}
			function He(e, t) {
				let n = !0;
				return e === "always" || e !== "never" && t !== "never" || (n = !1), n;
			}
			class Ue {
				constructor(e, t, n) {
					let i = this.boxCells = [], a = this.circleCells = [];
					this.xCellCount = Math.ceil(e / n), this.yCellCount = Math.ceil(t / n);
					for (let e = 0; e < this.xCellCount * this.yCellCount; e++) i.push([]), a.push([]);
					this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;
				}
				keysLength() {
					return this.boxKeys.length + this.circleKeys.length;
				}
				insert(e, t, n, i, a) {
					this._forEachCell(t, n, i, a, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(n), this.bboxes.push(i), this.bboxes.push(a);
				}
				insertCircle(e, t, n, i) {
					this._forEachCell(t - i, n - i, t + i, n + i, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(n), this.circles.push(i);
				}
				_insertBoxCell(e, t, n, i, a, o) {
					this.boxCells[a].push(o);
				}
				_insertCircleCell(e, t, n, i, a, o) {
					this.circleCells[a].push(o);
				}
				_query(e, t, n, i, a, o, s) {
					if (n < 0 || e > this.width || i < 0 || t > this.height) return [];
					let c = [];
					if (e <= 0 && t <= 0 && this.width <= n && this.height <= i) {
						if (a) return [{
							key: null,
							x1: e,
							y1: t,
							x2: n,
							y2: i
						}];
						for (let e = 0; e < this.boxKeys.length; e++) c.push({
							key: this.boxKeys[e],
							x1: this.bboxes[4 * e],
							y1: this.bboxes[4 * e + 1],
							x2: this.bboxes[4 * e + 2],
							y2: this.bboxes[4 * e + 3]
						});
						for (let e = 0; e < this.circleKeys.length; e++) {
							let t = this.circles[3 * e], n = this.circles[3 * e + 1], i = this.circles[3 * e + 2];
							c.push({
								key: this.circleKeys[e],
								x1: t - i,
								y1: n - i,
								x2: t + i,
								y2: n + i
							});
						}
					} else this._forEachCell(e, t, n, i, this._queryCell, c, {
						hitTest: a,
						overlapMode: o,
						seenUids: {
							box: {},
							circle: {}
						}
					}, s);
					return c;
				}
				query(e, t, n, i) {
					return this._query(e, t, n, i, !1, null);
				}
				hitTest(e, t, n, i, a, o) {
					return this._query(e, t, n, i, !0, a, o).length > 0;
				}
				hitTestCircle(e, t, n, i, a) {
					let o = e - n, s = e + n, c = t - n, l = t + n;
					if (s < 0 || o > this.width || l < 0 || c > this.height) return !1;
					let u = [];
					return this._forEachCell(o, c, s, l, this._queryCellCircle, u, {
						hitTest: !0,
						overlapMode: i,
						circle: {
							x: e,
							y: t,
							radius: n
						},
						seenUids: {
							box: {},
							circle: {}
						}
					}, a), u.length > 0;
				}
				_queryCell(e, t, n, i, a, o, s, c) {
					let { seenUids: l, hitTest: u, overlapMode: d } = s, f = this.boxCells[a];
					if (f !== null) {
						let a = this.bboxes;
						for (let s of f) if (!l.box[s]) {
							l.box[s] = !0;
							let f = 4 * s, p = this.boxKeys[s];
							if (e <= a[f + 2] && t <= a[f + 3] && n >= a[f + 0] && i >= a[f + 1] && (!c || c(p)) && (!u || !He(d, p.overlapMode)) && (o.push({
								key: p,
								x1: a[f],
								y1: a[f + 1],
								x2: a[f + 2],
								y2: a[f + 3]
							}), u)) return !0;
						}
					}
					let p = this.circleCells[a];
					if (p !== null) {
						let a = this.circles;
						for (let s of p) if (!l.circle[s]) {
							l.circle[s] = !0;
							let f = 3 * s, p = this.circleKeys[s];
							if (this._circleAndRectCollide(a[f], a[f + 1], a[f + 2], e, t, n, i) && (!c || c(p)) && (!u || !He(d, p.overlapMode))) {
								let e = a[f], t = a[f + 1], n = a[f + 2];
								if (o.push({
									key: p,
									x1: e - n,
									y1: t - n,
									x2: e + n,
									y2: t + n
								}), u) return !0;
							}
						}
					}
					return !1;
				}
				_queryCellCircle(e, t, n, i, a, o, s, c) {
					let { circle: l, seenUids: u, overlapMode: d } = s, f = this.boxCells[a];
					if (f !== null) {
						let e = this.bboxes;
						for (let t of f) if (!u.box[t]) {
							u.box[t] = !0;
							let n = 4 * t, i = this.boxKeys[t];
							if (this._circleAndRectCollide(l.x, l.y, l.radius, e[n + 0], e[n + 1], e[n + 2], e[n + 3]) && (!c || c(i)) && !He(d, i.overlapMode)) return o.push(!0), !0;
						}
					}
					let p = this.circleCells[a];
					if (p !== null) {
						let e = this.circles;
						for (let t of p) if (!u.circle[t]) {
							u.circle[t] = !0;
							let n = 3 * t, i = this.circleKeys[t];
							if (this._circlesCollide(e[n], e[n + 1], e[n + 2], l.x, l.y, l.radius) && (!c || c(i)) && !He(d, i.overlapMode)) return o.push(!0), !0;
						}
					}
				}
				_forEachCell(e, t, n, i, a, o, s, c) {
					let l = this._convertToXCellCoord(e), u = this._convertToYCellCoord(t), d = this._convertToXCellCoord(n), f = this._convertToYCellCoord(i);
					for (let p = l; p <= d; p++) for (let l = u; l <= f; l++) if (a.call(this, e, t, n, i, this.xCellCount * l + p, o, s, c)) return;
				}
				_convertToXCellCoord(e) {
					return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
				}
				_convertToYCellCoord(e) {
					return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
				}
				_circlesCollide(e, t, n, i, a, o) {
					let s = i - e, c = a - t, l = n + o;
					return l * l > s * s + c * c;
				}
				_circleAndRectCollide(e, t, n, i, a, o, s) {
					let c = (o - i) / 2, l = Math.abs(e - (i + c));
					if (l > c + n) return !1;
					let u = (s - a) / 2, d = Math.abs(t - (a + u));
					if (d > u + n) return !1;
					if (l <= c || d <= u) return !0;
					let f = l - c, p = d - u;
					return f * f + p * p <= n * n;
				}
			}
			function We(e, n, a) {
				let o = t.L();
				if (!e) {
					let { vecSouth: e, vecEast: t } = Ge(n), a = i();
					a[0] = t[0], a[1] = t[1], a[2] = e[0], a[3] = e[1], s = a, (p = (l = (c = a)[0]) * (f = c[3]) - (d = c[2]) * (u = c[1])) && (s[0] = f * (p = 1 / p), s[1] = -u * p, s[2] = -d * p, s[3] = l * p), o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3];
				}
				var s, c, l, u, d, f, p;
				return t.N(o, o, [
					1 / a,
					1 / a,
					1
				]), o;
			}
			function W(e, n, i, a) {
				if (e) {
					let e = t.L();
					if (!n) {
						let { vecSouth: t, vecEast: n } = Ge(i);
						e[0] = n[0], e[1] = n[1], e[4] = t[0], e[5] = t[1];
					}
					return t.N(e, e, [
						a,
						a,
						1
					]), e;
				}
				return i.pixelsToClipSpaceMatrix;
			}
			function Ge(e) {
				let n = Math.cos(e.rollInRadians), i = Math.sin(e.rollInRadians), a = Math.cos(e.pitchInRadians), o = Math.cos(e.bearingInRadians), s = Math.sin(e.bearingInRadians), c = t.ar();
				c[0] = -o * a * i - s * n, c[1] = -s * a * i + o * n;
				let l = t.as(c);
				l < 1e-9 ? t.at(c) : t.au(c, c, 1 / l);
				let u = t.ar();
				u[0] = o * a * n - s * i, u[1] = s * a * n + o * i;
				let d = t.as(u);
				return d < 1e-9 ? t.at(u) : t.au(u, u, 1 / d), {
					vecEast: u,
					vecSouth: c
				};
			}
			function Ke(e, n, i, a) {
				let o;
				a ? (o = [
					e,
					n,
					a(e, n),
					1
				], t.aw(o, o, i)) : (o = [
					e,
					n,
					0,
					1
				], ct(o, o, i));
				let s = o[3];
				return {
					point: new t.P(o[0] / s, o[1] / s),
					signedDistanceFromCamera: s,
					isOccluded: !1
				};
			}
			function qe(e, t) {
				return .5 + e / t * .5;
			}
			function Je(e, t) {
				return e.x >= -t[0] && e.x <= t[0] && e.y >= -t[1] && e.y <= t[1];
			}
			function G(e, n, i, a, o, s, c, l, u, d, f, p, m) {
				let h = i ? e.textSizeData : e.iconSizeData, g = t.an(h, n.transform.zoom), _ = [256 / n.width * 2 + 1, 256 / n.height * 2 + 1], v = i ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;
				v.clear();
				let y = e.lineVertexArray, b = i ? e.text.placedSymbolArray : e.icon.placedSymbolArray, x = n.transform.width / n.transform.height, S = !1;
				for (let i = 0; i < b.length; i++) {
					let C = b.get(i);
					if (C.hidden || C.writingMode === t.ao.vertical && !S) {
						st(C.numGlyphs, v);
						continue;
					}
					S = !1;
					let w = new t.P(C.anchorX, C.anchorY), T = {
						getElevation: m,
						pitchedLabelPlaneMatrix: a,
						lineVertexArray: y,
						pitchWithMap: s,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: n.transform,
						tileAnchorPoint: w,
						unwrappedTileID: u,
						width: d,
						height: f,
						translation: p
					}, E = nt(C.anchorX, C.anchorY, T);
					if (!Je(E.point, _)) {
						st(C.numGlyphs, v);
						continue;
					}
					let O = qe(n.transform.cameraToCenterDistance, E.signedDistanceFromCamera), k = t.ap(h, g, C), A = s ? k * n.transform.getPitchedTextCorrection(C.anchorX, C.anchorY, u) / O : k * O, j = Ze({
						projectionContext: T,
						pitchedLabelPlaneMatrixInverse: o,
						symbol: C,
						fontSize: A,
						flip: !1,
						keepUpright: c,
						glyphOffsetArray: e.glyphOffsetArray,
						dynamicLayoutVertexArray: v,
						aspectRatio: x,
						rotateToLine: l
					});
					S = j.useVertical, (j.notEnoughRoom || S || j.needsFlipping && Ze({
						projectionContext: T,
						pitchedLabelPlaneMatrixInverse: o,
						symbol: C,
						fontSize: A,
						flip: !0,
						keepUpright: c,
						glyphOffsetArray: e.glyphOffsetArray,
						dynamicLayoutVertexArray: v,
						aspectRatio: x,
						rotateToLine: l
					}).notEnoughRoom) && st(C.numGlyphs, v);
				}
				i ? e.text.dynamicLayoutVertexBuffer.updateData(v) : e.icon.dynamicLayoutVertexBuffer.updateData(v);
			}
			function Ye(e, t, n, i, a, o, s, c) {
				let l = o.glyphStartIndex + o.numGlyphs, u = o.lineStartIndex, d = o.lineStartIndex + o.lineLength, f = t.getoffsetX(o.glyphStartIndex), p = t.getoffsetX(l - 1), m = at(e * f, n, i, a, o.segment, u, d, c, s);
				if (!m) return null;
				let h = at(e * p, n, i, a, o.segment, u, d, c, s);
				return h ? c.projectionCache.anyProjectionOccluded ? null : {
					first: m,
					last: h
				} : null;
			}
			function Xe(e, n, i, a) {
				return e === t.ao.horizontal && Math.abs(i.y - n.y) > Math.abs(i.x - n.x) * a ? { useVertical: !0 } : (e === t.ao.vertical ? n.y < i.y : n.x > i.x) ? { needsFlipping: !0 } : null;
			}
			function Ze(e) {
				let { projectionContext: n, pitchedLabelPlaneMatrixInverse: i, symbol: a, fontSize: o, flip: s, keepUpright: c, glyphOffsetArray: l, dynamicLayoutVertexArray: u, aspectRatio: d, rotateToLine: f } = e, p = o / 24, m = a.lineOffsetX * p, h = a.lineOffsetY * p, g;
				if (a.numGlyphs > 1) {
					let e = a.glyphStartIndex + a.numGlyphs, t = a.lineStartIndex, o = a.lineStartIndex + a.lineLength, u = Ye(p, l, m, h, s, a, f, n);
					if (!u) return { notEnoughRoom: !0 };
					let _ = tt(u.first.point.x, u.first.point.y, n, i), v = tt(u.last.point.x, u.last.point.y, n, i);
					if (c && !s) {
						let e = Xe(a.writingMode, _, v, d);
						if (e) return e;
					}
					g = [u.first];
					for (let i = a.glyphStartIndex + 1; i < e - 1; i++) {
						let e = at(p * l.getoffsetX(i), m, h, s, a.segment, t, o, n, f);
						if (!e) return { notEnoughRoom: !0 };
						g.push(e);
					}
					g.push(u.last);
				} else {
					if (c && !s) {
						let e = et(n.tileAnchorPoint.x, n.tileAnchorPoint.y, n).point, o = a.lineStartIndex + a.segment + 1, s = new t.P(n.lineVertexArray.getx(o), n.lineVertexArray.gety(o)), c = et(s.x, s.y, n), l = c.signedDistanceFromCamera > 0 ? c.point : Qe(n.tileAnchorPoint, s, e, 1, n), u = tt(e.x, e.y, n, i), f = tt(l.x, l.y, n, i), p = Xe(a.writingMode, u, f, d);
						if (p) return p;
					}
					let e = at(p * l.getoffsetX(a.glyphStartIndex), m, h, s, a.segment, a.lineStartIndex, a.lineStartIndex + a.lineLength, n, f);
					if (!e || n.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
					g = [e];
				}
				for (let e of g) t.av(u, e.point, e.angle);
				return {};
			}
			function Qe(e, t, n, i, a) {
				let o = e.add(e.sub(t)._unit()), s = et(o.x, o.y, a).point, c = n.sub(s);
				return n.add(c._mult(i / c.mag()));
			}
			function $e(e, n, i) {
				let a = n.projectionCache;
				if (a.projections[e]) return a.projections[e];
				let o = new t.P(n.lineVertexArray.getx(e), n.lineVertexArray.gety(e)), s = et(o.x, o.y, n);
				if (s.signedDistanceFromCamera > 0) return a.projections[e] = s.point, a.anyProjectionOccluded = a.anyProjectionOccluded || s.isOccluded, s.point;
				let c = e - i.direction;
				return Qe(i.distanceFromAnchor === 0 ? n.tileAnchorPoint : new t.P(n.lineVertexArray.getx(c), n.lineVertexArray.gety(c)), o, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, n);
			}
			function et(e, t, n) {
				let i = e + n.translation[0], a = t + n.translation[1], o;
				return n.pitchWithMap ? (o = Ke(i, a, n.pitchedLabelPlaneMatrix, n.getElevation), o.isOccluded = !1) : (o = n.transform.projectTileCoordinates(i, a, n.unwrappedTileID, n.getElevation), o.point.x = (.5 * o.point.x + .5) * n.width, o.point.y = (.5 * -o.point.y + .5) * n.height), o;
			}
			function tt(e, n, i, a) {
				if (i.pitchWithMap) {
					let o = [
						e,
						n,
						0,
						1
					];
					return t.aw(o, o, a), i.transform.projectTileCoordinates(o[0] / o[3], o[1] / o[3], i.unwrappedTileID, i.getElevation).point;
				}
				return {
					x: e / i.width * 2 - 1,
					y: 1 - n / i.height * 2
				};
			}
			function nt(e, t, n) {
				return n.transform.projectTileCoordinates(e, t, n.unwrappedTileID, n.getElevation);
			}
			function rt(e, t, n) {
				return e._unit()._perp()._mult(t * n);
			}
			function it(e, n, i, a, o, s, c, l, u) {
				if (l.projectionCache.offsets[e]) return l.projectionCache.offsets[e];
				let d = i.add(n);
				if (e + u.direction < a || e + u.direction >= o) return l.projectionCache.offsets[e] = d, d;
				let f = $e(e + u.direction, l, u), p = rt(f.sub(i), c, u.direction), m = i.add(p), h = f.add(p);
				return l.projectionCache.offsets[e] = t.ax(s, d, m, h) || d, l.projectionCache.offsets[e];
			}
			function at(e, t, n, i, a, o, s, c, l) {
				let u = i ? e - t : e + t, d = u > 0 ? 1 : -1, f = 0;
				i && (d *= -1, f = Math.PI), d < 0 && (f += Math.PI);
				let p, m = d > 0 ? o + a : o + a + 1;
				c.projectionCache.cachedAnchorPoint ? p = c.projectionCache.cachedAnchorPoint : (p = et(c.tileAnchorPoint.x, c.tileAnchorPoint.y, c).point, c.projectionCache.cachedAnchorPoint = p);
				let h, g, _ = p, v = p, y = 0, b = 0, x = Math.abs(u), S = [], C;
				for (; y + b <= x;) {
					if (m += d, m < o || m >= s) return null;
					y += b, v = _, g = h;
					let e = {
						absOffsetX: x,
						direction: d,
						distanceFromAnchor: y,
						previousVertex: v
					};
					if (_ = $e(m, c, e), n === 0) S.push(v), C = _.sub(v);
					else {
						let t, i = _.sub(v);
						t = i.mag() === 0 ? rt($e(m + d, c, e).sub(_), n, d) : rt(i, n, d), g ||= v.add(t), h = it(m, t, _, o, s, g, n, c, e), S.push(g), C = h.sub(g);
					}
					b = C.mag();
				}
				let w = C._mult((x - y) / b)._add(g || v), T = f + Math.atan2(_.y - v.y, _.x - v.x);
				return S.push(w), {
					point: w,
					angle: l ? T : 0,
					path: S
				};
			}
			let ot = new Float32Array([
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0,
				-Infinity,
				-Infinity,
				0
			]);
			function st(e, t) {
				for (let n = 0; n < e; n++) {
					let e = t.length;
					t.resize(e + 4), t.float32.set(ot, 3 * e);
				}
			}
			function ct(e, t, n) {
				let i = t[0], a = t[1];
				return e[0] = n[0] * i + n[4] * a + n[12], e[1] = n[1] * i + n[5] * a + n[13], e[3] = n[3] * i + n[7] * a + n[15], e;
			}
			class lt {
				constructor(e, t = new Ue(e.width + 200, e.height + 200, 25), n = new Ue(e.width + 200, e.height + 200, 25)) {
					this.transform = e, this.grid = t, this.ignoredGrid = n, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + 100, this.screenBottomBoundary = e.height + 100, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6;
				}
				placeCollisionBox(e, t, n, i, a, o, s, c, l, u, d, f) {
					let p = this.projectAndGetPerspectiveRatio(e.anchorPointX + c[0], e.anchorPointY + c[1], a, u, f), m = n * p.perspectiveRatio, h;
					if (o || s) h = this._projectCollisionBox(e, m, i, a, o, s, c, p, u, d, f);
					else {
						let t = p.x + (d ? d.x * m : 0), n = p.y + (d ? d.y * m : 0);
						h = {
							allPointsOccluded: !1,
							box: [
								t + e.x1 * m,
								n + e.y1 * m,
								t + e.x2 * m,
								n + e.y2 * m
							]
						};
					}
					let [g, _, v, y] = h.box, b = o ? h.allPointsOccluded : p.isOccluded, x = b;
					return x ||= p.perspectiveRatio < this.perspectiveRatioCutoff, x ||= !this.isInsideGrid(g, _, v, y), x || t !== "always" && this.grid.hitTest(g, _, v, y, t, l) ? {
						box: [
							g,
							_,
							v,
							y
						],
						placeable: !1,
						offscreen: !1,
						occluded: b
					} : {
						box: [
							g,
							_,
							v,
							y
						],
						placeable: !0,
						offscreen: this.isOffscreen(g, _, v, y),
						occluded: b
					};
				}
				placeCollisionCircles(e, n, i, a, o, s, c, l, u, d, f, p, m, h) {
					let g = [], _ = new t.P(n.anchorX, n.anchorY), v = this.getPerspectiveRatio(_.x, _.y, s, h), y = (u ? o * this.transform.getPitchedTextCorrection(n.anchorX, n.anchorY, s) / v : o * v) / t.aB, b = {
						getElevation: h,
						pitchedLabelPlaneMatrix: c,
						lineVertexArray: i,
						pitchWithMap: u,
						projectionCache: {
							projections: {},
							offsets: {},
							cachedAnchorPoint: void 0,
							anyProjectionOccluded: !1
						},
						transform: this.transform,
						tileAnchorPoint: _,
						unwrappedTileID: s,
						width: this.transform.width,
						height: this.transform.height,
						translation: m
					}, x = Ye(y, a, n.lineOffsetX * y, n.lineOffsetY * y, !1, n, !1, b), S = !1, C = !1, w = !0;
					if (x) {
						let n = .5 * f * v + p, i = new t.P(-100, -100), a = new t.P(this.screenRightBoundary, this.screenBottomBoundary), o = new Ve(), s = x.first, c = x.last, m = [];
						for (let e = s.path.length - 1; e >= 1; e--) m.push(s.path[e]);
						for (let e = 1; e < c.path.length; e++) m.push(c.path[e]);
						let h = 2.5 * n;
						if (u) {
							let e = this.projectPathToScreenSpace(m, b);
							m = e.some(((e) => e.signedDistanceFromCamera <= 0)) ? [] : e.map(((e) => e.point));
						}
						let _ = [];
						if (m.length > 0) {
							let e = m[0].clone(), n = m[0].clone();
							for (let t = 1; t < m.length; t++) e.x = Math.min(e.x, m[t].x), e.y = Math.min(e.y, m[t].y), n.x = Math.max(n.x, m[t].x), n.y = Math.max(n.y, m[t].y);
							_ = e.x >= i.x && n.x <= a.x && e.y >= i.y && n.y <= a.y ? [m] : n.x < i.x || e.x > a.x || n.y < i.y || e.y > a.y ? [] : t.ay([m], i.x, i.y, a.x, a.y);
						}
						for (let t of _) {
							o.reset(t, .25 * n);
							let i = 0;
							i = o.length <= .5 * n ? 1 : Math.ceil(o.paddedLength / h) + 1;
							for (let t = 0; t < i; t++) {
								let a = t / Math.max(i - 1, 1), s = o.lerp(a), c = s.x + 100, u = s.y + 100;
								g.push(c, u, n, 0);
								let f = c - n, p = u - n, m = c + n, h = u + n;
								if (w &&= this.isOffscreen(f, p, m, h), C ||= this.isInsideGrid(f, p, m, h), e !== "always" && this.grid.hitTestCircle(c, u, n, e, d) && (S = !0, !l)) return {
									circles: [],
									offscreen: !1,
									collisionDetected: S
								};
							}
						}
					}
					return {
						circles: !l && S || !C || v < this.perspectiveRatioCutoff ? [] : g,
						offscreen: w,
						collisionDetected: S
					};
				}
				projectPathToScreenSpace(e, n) {
					return function(e) {
						let t = 0, n = 0, i = 0, a = 0;
						for (let o = 0; o < e.length; o++) e[o].isOccluded ? (i = o + 1, a = 0) : (a++, a > n && (n = a, t = i));
						return e.slice(t, t + n);
					}(function(e, n) {
						let i = t.L();
						return t.aq(i, n.pitchedLabelPlaneMatrix), e.map(((e) => {
							let t = Ke(e.x, e.y, i, n.getElevation), a = n.transform.projectTileCoordinates(t.point.x, t.point.y, n.unwrappedTileID, n.getElevation);
							return a.point.x = (.5 * a.point.x + .5) * n.width, a.point.y = (.5 * -a.point.y + .5) * n.height, a;
						}));
					}(e, n));
				}
				queryRenderedSymbols(e) {
					if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
					let n = [], i = new t.a2();
					for (let a of e) {
						let e = new t.P(a.x + 100, a.y + 100);
						i.extend(e), n.push(e);
					}
					let { minX: a, minY: o, maxX: s, maxY: c } = i, l = this.grid.query(a, o, s, c).concat(this.ignoredGrid.query(a, o, s, c)), u = {}, d = {};
					for (let e of l) {
						let i = e.key;
						if (u[i.bucketInstanceId] === void 0 && (u[i.bucketInstanceId] = {}), u[i.bucketInstanceId][i.featureIndex]) continue;
						let a = [
							new t.P(e.x1, e.y1),
							new t.P(e.x2, e.y1),
							new t.P(e.x2, e.y2),
							new t.P(e.x1, e.y2)
						];
						t.az(n, a) && (u[i.bucketInstanceId][i.featureIndex] = !0, d[i.bucketInstanceId] === void 0 && (d[i.bucketInstanceId] = []), d[i.bucketInstanceId].push(i.featureIndex));
					}
					return d;
				}
				insertCollisionBox(e, t, n, i, a, o) {
					(n ? this.ignoredGrid : this.grid).insert({
						bucketInstanceId: i,
						featureIndex: a,
						collisionGroupID: o,
						overlapMode: t
					}, e[0], e[1], e[2], e[3]);
				}
				insertCollisionCircles(e, t, n, i, a, o) {
					let s = n ? this.ignoredGrid : this.grid, c = {
						bucketInstanceId: i,
						featureIndex: a,
						collisionGroupID: o,
						overlapMode: t
					};
					for (let t = 0; t < e.length; t += 4) s.insertCircle(c, e[t], e[t + 1], e[t + 2]);
				}
				projectAndGetPerspectiveRatio(e, n, i, a, o) {
					if (o) {
						let i;
						a ? (i = [
							e,
							n,
							a(e, n),
							1
						], t.aw(i, i, o)) : (i = [
							e,
							n,
							0,
							1
						], ct(i, i, o));
						let s = i[3];
						return {
							x: (i[0] / s + 1) / 2 * this.transform.width + 100,
							y: (-i[1] / s + 1) / 2 * this.transform.height + 100,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / s * .5,
							isOccluded: !1,
							signedDistanceFromCamera: s
						};
					}
					{
						let t = this.transform.projectTileCoordinates(e, n, i, a);
						return {
							x: (t.point.x + 1) / 2 * this.transform.width + 100,
							y: (1 - t.point.y) / 2 * this.transform.height + 100,
							perspectiveRatio: .5 + this.transform.cameraToCenterDistance / t.signedDistanceFromCamera * .5,
							isOccluded: t.isOccluded,
							signedDistanceFromCamera: t.signedDistanceFromCamera
						};
					}
				}
				getPerspectiveRatio(e, t, n, i) {
					let a = this.transform.projectTileCoordinates(e, t, n, i);
					return .5 + this.transform.cameraToCenterDistance / a.signedDistanceFromCamera * .5;
				}
				isOffscreen(e, t, n, i) {
					return n < 100 || e >= this.screenRightBoundary || i < 100 || t > this.screenBottomBoundary;
				}
				isInsideGrid(e, t, n, i) {
					return n >= 0 && e < this.gridRightBoundary && i >= 0 && t < this.gridBottomBoundary;
				}
				getViewportMatrix() {
					let e = t.ai([]);
					return t.M(e, e, [
						-100,
						-100,
						0
					]), e;
				}
				_projectCollisionBox(e, n, i, a, o, s, c, l, u, d, f) {
					let p = 1, m = 0, h = 0, g = 1, _ = e.anchorPointX + c[0], v = e.anchorPointY + c[1];
					if (s && !o) {
						let e = this.projectAndGetPerspectiveRatio(_ + 1, v, a, u, f), t = e.x - l.x, n = Math.atan((e.y - l.y) / t) + (t < 0 ? Math.PI : 0), i = Math.sin(n), o = Math.cos(n);
						p = o, m = i, h = -i, g = o;
					} else if (!s && o) {
						let e = Ge(this.transform);
						p = e.vecEast[0], m = e.vecEast[1], h = e.vecSouth[0], g = e.vecSouth[1];
					}
					let y = l.x, b = l.y, x = n;
					o && (y = _, b = v, x = 2 ** -(this.transform.zoom - i.overscaledZ), x *= this.transform.getPitchedTextCorrection(_, v, a), d || (x *= t.ae(.5 + l.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), d && (y += p * d.x * x + h * d.y * x, b += m * d.x * x + g * d.y * x);
					let S = e.x1 * x, C = e.x2 * x, w = (S + C) / 2, T = e.y1 * x, E = e.y2 * x, O = (T + E) / 2, k = [
						{
							offsetX: S,
							offsetY: T
						},
						{
							offsetX: w,
							offsetY: T
						},
						{
							offsetX: C,
							offsetY: T
						},
						{
							offsetX: C,
							offsetY: O
						},
						{
							offsetX: C,
							offsetY: E
						},
						{
							offsetX: w,
							offsetY: E
						},
						{
							offsetX: S,
							offsetY: E
						},
						{
							offsetX: S,
							offsetY: O
						}
					], A = [];
					for (let { offsetX: e, offsetY: n } of k) A.push(new t.P(y + p * e + h * n, b + m * e + g * n));
					let j = !1;
					if (o) {
						let e = A.map(((e) => this.projectAndGetPerspectiveRatio(e.x, e.y, a, u, f)));
						j = e.some(((e) => !e.isOccluded)), A = e.map(((e) => new t.P(e.x, e.y)));
					} else j = !0;
					return {
						box: t.aA(A),
						allPointsOccluded: !j
					};
				}
			}
			class ut {
				constructor(e, t, n, i) {
					this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : i && n ? 1 : 0, this.placed = n;
				}
				isHidden() {
					return this.opacity === 0 && !this.placed;
				}
			}
			class dt {
				constructor(e, t, n, i, a) {
					this.text = new ut(e ? e.text : null, t, n, a), this.icon = new ut(e ? e.icon : null, t, i, a);
				}
				isHidden() {
					return this.text.isHidden() && this.icon.isHidden();
				}
			}
			class ft {
				constructor(e, t, n) {
					this.text = e, this.icon = t, this.skipFade = n;
				}
			}
			class pt {
				constructor(e, t, n, i, a) {
					this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = n, this.bucketIndex = i, this.tileID = a;
				}
			}
			class mt {
				constructor(e) {
					this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
				}
				get(e) {
					if (this.crossSourceCollisions) return {
						ID: 0,
						predicate: null
					};
					if (!this.collisionGroups[e]) {
						let t = ++this.maxGroupID;
						this.collisionGroups[e] = {
							ID: t,
							predicate: (e) => e.collisionGroupID === t
						};
					}
					return this.collisionGroups[e];
				}
			}
			function ht(e, n, i, a, o) {
				let { horizontalAlign: s, verticalAlign: c } = t.aH(e);
				return new t.P(-(s - .5) * n + a[0] * o, -(c - .5) * i + a[1] * o);
			}
			class gt {
				constructor(e, t, n, i, a) {
					this.transform = e.clone(), this.terrain = t, this.collisionIndex = new lt(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = n, this.retainedQueryData = {}, this.collisionGroups = new mt(i), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = a, a && (a.prevPlacement = void 0), this.placedOrientations = {};
				}
				_getTerrainElevationFunc(e) {
					let t = this.terrain;
					return t ? (n, i) => t.getElevation(e, n, i) : null;
				}
				getBucketParts(e, n, i, a) {
					let o = i.getBucket(n), s = i.latestFeatureIndex;
					if (!o || !s || n.id !== o.layerIds[0]) return;
					let c = i.collisionBoxArray, l = o.layers[0].layout, u = o.layers[0].paint, d = 2 ** (this.transform.zoom - i.tileID.overscaledZ), f = i.tileSize / t.$, p = i.tileID.toUnwrapped(), m = l.get("text-rotation-alignment") === "map", h = t.aC(i, 1, this.transform.zoom), g = t.aD(this.collisionIndex.transform, i, u.get("text-translate"), u.get("text-translate-anchor")), _ = t.aD(this.collisionIndex.transform, i, u.get("icon-translate"), u.get("icon-translate-anchor")), v = We(m, this.transform, h);
					this.retainedQueryData[o.bucketInstanceId] = new pt(o.bucketInstanceId, s, o.sourceLayerIndex, o.index, i.tileID);
					let y = {
						bucket: o,
						layout: l,
						translationText: g,
						translationIcon: _,
						unwrappedTileID: p,
						pitchedLabelPlaneMatrix: v,
						scale: d,
						textPixelRatio: f,
						holdingForFade: i.holdingForSymbolFade(),
						collisionBoxArray: c,
						partiallyEvaluatedTextSize: t.an(o.textSizeData, this.transform.zoom),
						collisionGroup: this.collisionGroups.get(o.sourceID)
					};
					if (a) for (let t of o.sortKeyRanges) {
						let { sortKey: n, symbolInstanceStart: i, symbolInstanceEnd: a } = t;
						e.push({
							sortKey: n,
							symbolInstanceStart: i,
							symbolInstanceEnd: a,
							parameters: y
						});
					}
					else e.push({
						symbolInstanceStart: 0,
						symbolInstanceEnd: o.symbolInstances.length,
						parameters: y
					});
				}
				attemptAnchorPlacement(e, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _, v, y, b, x) {
					let S = t.aE[e.textAnchor], C = [e.textOffset0, e.textOffset1], w = ht(S, i, a, C, o), T = this.collisionIndex.placeCollisionBox(n, p, l, u, d, c, s, _, f.predicate, b, w, x);
					if ((!y || this.collisionIndex.placeCollisionBox(y, p, l, u, d, c, s, v, f.predicate, b, w, x).placeable) && T.placeable) {
						let e;
						if (this.prevPlacement && this.prevPlacement.variableOffsets[m.crossTileID] && this.prevPlacement.placements[m.crossTileID] && this.prevPlacement.placements[m.crossTileID].text && (e = this.prevPlacement.variableOffsets[m.crossTileID].anchor), m.crossTileID === 0) throw Error("symbolInstance.crossTileID can't be 0");
						return this.variableOffsets[m.crossTileID] = {
							textOffset: C,
							width: i,
							height: a,
							anchor: S,
							textBoxScale: o,
							prevAnchor: e
						}, this.markUsedJustification(h, S, m, g), h.allowVerticalPlacement && (this.markUsedOrientation(h, g, m), this.placedOrientations[m.crossTileID] = g), {
							shift: w,
							placedGlyphBoxes: T
						};
					}
				}
				placeLayerBucketPart(e, n, i) {
					let { bucket: a, layout: o, translationText: s, translationIcon: c, unwrappedTileID: l, pitchedLabelPlaneMatrix: u, textPixelRatio: d, holdingForFade: f, collisionBoxArray: p, partiallyEvaluatedTextSize: m, collisionGroup: h } = e.parameters, g = o.get("text-optional"), _ = o.get("icon-optional"), v = t.aF(o, "text-overlap", "text-allow-overlap"), y = v === "always", b = t.aF(o, "icon-overlap", "icon-allow-overlap"), x = b === "always", S = o.get("text-rotation-alignment") === "map", C = o.get("text-pitch-alignment") === "map", w = o.get("icon-text-fit") !== "none", T = o.get("symbol-z-order") === "viewport-y", E = y && (x || !a.hasIconData() || _), O = x && (y || !a.hasTextData() || g);
					!a.collisionArrays && p && a.deserializeCollisionBoxes(p);
					let k = this.retainedQueryData[a.bucketInstanceId].tileID, A = this._getTerrainElevationFunc(k), j = this.transform.getFastPathSimpleProjectionMatrix(k), M = (e, p, x) => {
						if (n[e.crossTileID]) return;
						if (f) return void (this.placements[e.crossTileID] = new ft(!1, !1, !1));
						let T = !1, M = !1, N = !0, P = null, F = {
							box: null,
							placeable: !1,
							offscreen: null,
							occluded: !1
						}, I = { placeable: !1 }, ee = null, L = null, R = null, te = 0, ne = 0, ie = 0;
						p.textFeatureIndex ? te = p.textFeatureIndex : e.useRuntimeCollisionCircles && (te = e.featureIndex), p.verticalTextFeatureIndex && (ne = p.verticalTextFeatureIndex);
						let ae = p.textBox;
						if (ae) {
							let n = (n) => {
								let i = t.ao.horizontal;
								if (a.allowVerticalPlacement && !n && this.prevPlacement) {
									let t = this.prevPlacement.placedOrientations[e.crossTileID];
									t && (this.placedOrientations[e.crossTileID] = t, i = t, this.markUsedOrientation(a, i, e));
								}
								return i;
							}, o = (n, i) => {
								if (a.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && p.verticalTextBox) {
									for (let e of a.writingModes) if (e === t.ao.vertical ? (F = i(), I = F) : F = n(), F && F.placeable) break;
								} else F = n();
							}, u = e.textAnchorOffsetStartIndex, f = e.textAnchorOffsetEndIndex;
							if (f === u) {
								let i = (t, n) => {
									let i = this.collisionIndex.placeCollisionBox(t, v, d, k, l, C, S, s, h.predicate, A, void 0, j);
									return i && i.placeable && (this.markUsedOrientation(a, n, e), this.placedOrientations[e.crossTileID] = n), i;
								};
								o((() => i(ae, t.ao.horizontal)), (() => {
									let n = p.verticalTextBox;
									return a.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && n ? i(n, t.ao.vertical) : {
										box: null,
										offscreen: null
									};
								})), n(F && F.placeable);
							} else {
								let m = t.aE[this.prevPlacement?.variableOffsets[e.crossTileID]?.anchor], g = (t, n, o) => {
									let p = t.x2 - t.x1, g = t.y2 - t.y1, _ = e.textBoxScale, y = w && b === "never" ? n : null, x = null, E = v === "never" ? 1 : 2, O = "never";
									m && E++;
									for (let n = 0; n < E; n++) {
										for (let n = u; n < f; n++) {
											let i = a.textAnchorOffsets.get(n);
											if (m && i.textAnchor !== m) continue;
											let u = this.attemptAnchorPlacement(i, t, p, g, _, S, C, d, k, l, h, O, e, a, o, s, c, y, A);
											if (u && (x = u.placedGlyphBoxes, x && x.placeable)) return T = !0, P = u.shift, x;
										}
										m ? m = null : O = v;
									}
									return i && !x && (x = {
										box: this.collisionIndex.placeCollisionBox(ae, "always", d, k, l, C, S, s, h.predicate, A, void 0, j).box,
										offscreen: !1,
										placeable: !1,
										occluded: !1
									}), x;
								};
								o((() => g(ae, p.iconBox, t.ao.horizontal)), (() => {
									let n = p.verticalTextBox;
									return a.allowVerticalPlacement && (!F || !F.placeable) && e.numVerticalGlyphVertices > 0 && n ? g(n, p.verticalIconBox, t.ao.vertical) : {
										box: null,
										occluded: !0,
										offscreen: null
									};
								})), F && (T = F.placeable, N = F.offscreen);
								let _ = n(F && F.placeable);
								if (!T && this.prevPlacement) {
									let t = this.prevPlacement.variableOffsets[e.crossTileID];
									t && (this.variableOffsets[e.crossTileID] = t, this.markUsedJustification(a, t.anchor, e, _));
								}
							}
						}
						if (ee = F, T = ee && ee.placeable, N = ee && ee.offscreen, e.useRuntimeCollisionCircles && e.centerJustifiedTextSymbolIndex >= 0) {
							let n = a.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex), c = t.ap(a.textSizeData, m, n), d = o.get("text-padding");
							L = this.collisionIndex.placeCollisionCircles(v, n, a.lineVertexArray, a.glyphOffsetArray, c, l, u, i, C, h.predicate, e.collisionCircleDiameter, d, s, A), L.circles.length && L.collisionDetected && !i && t.w("Collisions detected, but collision boxes are not shown"), T = y || L.circles.length > 0 && !L.collisionDetected, N &&= L.offscreen;
						}
						if (p.iconFeatureIndex && (ie = p.iconFeatureIndex), p.iconBox) {
							let e = (e) => this.collisionIndex.placeCollisionBox(e, b, d, k, l, C, S, c, h.predicate, A, w && P ? P : void 0, j);
							I && I.placeable && p.verticalIconBox ? (R = e(p.verticalIconBox), M = R.placeable) : (R = e(p.iconBox), M = R.placeable), N &&= R.offscreen;
						}
						let oe = g || e.numHorizontalGlyphVertices === 0 && e.numVerticalGlyphVertices === 0, z = _ || e.numIconVertices === 0;
						oe || z ? z ? oe || (M &&= T) : T = M && T : M = T = M && T;
						let se = M && R.placeable;
						if (T && ee.placeable && this.collisionIndex.insertCollisionBox(ee.box, v, o.get("text-ignore-placement"), a.bucketInstanceId, I && I.placeable && ne ? ne : te, h.ID), se && this.collisionIndex.insertCollisionBox(R.box, b, o.get("icon-ignore-placement"), a.bucketInstanceId, ie, h.ID), L && T && this.collisionIndex.insertCollisionCircles(L.circles, v, o.get("text-ignore-placement"), a.bucketInstanceId, te, h.ID), i && this.storeCollisionData(a.bucketInstanceId, x, p, ee, R, L), e.crossTileID === 0) throw Error("symbolInstance.crossTileID can't be 0");
						if (a.bucketInstanceId === 0) throw Error("bucket.bucketInstanceId can't be 0");
						this.placements[e.crossTileID] = new ft((T || E) && !ee?.occluded, (M || O) && !R?.occluded, N || a.justReloaded), n[e.crossTileID] = !0;
					};
					if (T) {
						if (e.symbolInstanceStart !== 0) throw Error("bucket.bucketInstanceId should be 0");
						let t = a.getSortedSymbolIndexes(-this.transform.bearingInRadians);
						for (let e = t.length - 1; e >= 0; --e) {
							let n = t[e];
							M(a.symbolInstances.get(n), a.collisionArrays[n], n);
						}
					} else for (let t = e.symbolInstanceStart; t < e.symbolInstanceEnd; t++) M(a.symbolInstances.get(t), a.collisionArrays[t], t);
					a.justReloaded = !1;
				}
				storeCollisionData(e, t, n, i, a, o) {
					if (n.textBox || n.iconBox) {
						let o, s;
						this.collisionBoxArrays.has(e) ? o = this.collisionBoxArrays.get(e) : (o = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e, o)), o.has(t) ? s = o.get(t) : (s = {
							text: null,
							icon: null
						}, o.set(t, s)), n.textBox && (s.text = i.box), n.iconBox && (s.icon = a.box);
					}
					if (o) {
						let t = this.collisionCircleArrays[e];
						t === void 0 && (t = this.collisionCircleArrays[e] = []);
						for (let e = 0; e < o.circles.length; e += 4) t.push(o.circles[e + 0] - 100), t.push(o.circles[e + 1] - 100), t.push(o.circles[e + 2]), t.push(o.collisionDetected ? 1 : 0);
					}
				}
				markUsedJustification(e, n, i, a) {
					let o;
					o = a === t.ao.vertical ? i.verticalPlacedTextSymbolIndex : {
						left: i.leftJustifiedTextSymbolIndex,
						center: i.centerJustifiedTextSymbolIndex,
						right: i.rightJustifiedTextSymbolIndex
					}[t.aG(n)];
					let s = [
						i.leftJustifiedTextSymbolIndex,
						i.centerJustifiedTextSymbolIndex,
						i.rightJustifiedTextSymbolIndex,
						i.verticalPlacedTextSymbolIndex
					];
					for (let t of s) t >= 0 && (e.text.placedSymbolArray.get(t).crossTileID = o >= 0 && t !== o ? 0 : i.crossTileID);
				}
				markUsedOrientation(e, n, i) {
					let a = n === t.ao.horizontal || n === t.ao.horizontalOnly ? n : 0, o = n === t.ao.vertical ? n : 0, s = [
						i.leftJustifiedTextSymbolIndex,
						i.centerJustifiedTextSymbolIndex,
						i.rightJustifiedTextSymbolIndex
					];
					for (let t of s) e.text.placedSymbolArray.get(t).placedOrientation = a;
					i.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(i.verticalPlacedTextSymbolIndex).placedOrientation = o);
				}
				commit(e) {
					this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
					let t = this.prevPlacement, n = !1;
					this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;
					let i = t ? t.symbolFadeChange(e) : 1, a = t ? t.opacities : {}, o = t ? t.variableOffsets : {}, s = t ? t.placedOrientations : {};
					for (let e in this.placements) {
						let t = this.placements[e], o = a[e];
						o ? (this.opacities[e] = new dt(o, i, t.text, t.icon), n = n || t.text !== o.text.placed || t.icon !== o.icon.placed) : (this.opacities[e] = new dt(null, i, t.text, t.icon, t.skipFade), n = n || t.text || t.icon);
					}
					for (let e in a) {
						let t = a[e];
						if (!this.opacities[e]) {
							let a = new dt(t, i, !1, !1);
							a.isHidden() || (this.opacities[e] = a, n = n || t.text.placed || t.icon.placed);
						}
					}
					for (let e in o) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = o[e]);
					for (let e in s) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = s[e]);
					if (t && t.lastPlacementChangeTime === void 0) throw Error("Last placement time for previous placement is not defined");
					n ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);
				}
				updateLayerOpacities(e, t) {
					let n = {};
					for (let i of t) {
						let t = i.getBucket(e);
						t && i.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, i.tileID, n, i.collisionBoxArray);
					}
				}
				updateBucketOpacities(e, n, i, a) {
					e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
					let o = e.layers[0], s = o.layout, c = new dt(null, 0, !1, !1, !0), l = s.get("text-allow-overlap"), u = s.get("icon-allow-overlap"), d = o._unevaluatedLayout.hasValue("text-variable-anchor") || o._unevaluatedLayout.hasValue("text-variable-anchor-offset"), f = s.get("text-rotation-alignment") === "map", p = s.get("text-pitch-alignment") === "map", m = s.get("icon-text-fit") !== "none", h = new dt(null, 0, l && (u || !e.hasIconData() || s.get("icon-optional")), u && (l || !e.hasTextData() || s.get("text-optional")), !0);
					!e.collisionArrays && a && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(a);
					let g = (e, t, n) => {
						for (let i = 0; i < t / 4; i++) e.opacityVertexArray.emplaceBack(n);
						e.hasVisibleVertices = e.hasVisibleVertices || n !== Ct;
					}, _ = this.collisionBoxArrays.get(e.bucketInstanceId);
					for (let n = 0; n < e.symbolInstances.length; n++) {
						let a = e.symbolInstances.get(n), { numHorizontalGlyphVertices: o, numVerticalGlyphVertices: s, crossTileID: l } = a, u = this.opacities[l];
						i[l] ? u = c : u || (u = h, this.opacities[l] = u), i[l] = !0;
						let v = a.numIconVertices > 0, y = this.placedOrientations[a.crossTileID], b = y === t.ao.vertical, x = y === t.ao.horizontal || y === t.ao.horizontalOnly;
						if (o > 0 || s > 0) {
							let t = St(u.text);
							g(e.text, o, b ? Ct : t), g(e.text, s, x ? Ct : t);
							let n = u.text.isHidden();
							[
								a.rightJustifiedTextSymbolIndex,
								a.centerJustifiedTextSymbolIndex,
								a.leftJustifiedTextSymbolIndex
							].forEach(((t) => {
								t >= 0 && (e.text.placedSymbolArray.get(t).hidden = n || b ? 1 : 0);
							})), a.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(a.verticalPlacedTextSymbolIndex).hidden = n || x ? 1 : 0);
							let i = this.variableOffsets[a.crossTileID];
							i && this.markUsedJustification(e, i.anchor, a, y);
							let c = this.placedOrientations[a.crossTileID];
							c && (this.markUsedJustification(e, "left", a, c), this.markUsedOrientation(e, c, a));
						}
						if (v) {
							let t = St(u.icon), n = !(m && a.verticalPlacedIconSymbolIndex && b);
							a.placedIconSymbolIndex >= 0 && (g(e.icon, a.numIconVertices, n ? t : Ct), e.icon.placedSymbolArray.get(a.placedIconSymbolIndex).hidden = u.icon.isHidden()), a.verticalPlacedIconSymbolIndex >= 0 && (g(e.icon, a.numVerticalIconVertices, n ? Ct : t), e.icon.placedSymbolArray.get(a.verticalPlacedIconSymbolIndex).hidden = u.icon.isHidden());
						}
						let S = _ && _.has(n) ? _.get(n) : {
							text: null,
							icon: null
						};
						if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
							let i = e.collisionArrays[n];
							if (i) {
								let n = new t.P(0, 0);
								if (i.textBox || i.verticalTextBox) {
									let t = !0;
									if (d) {
										let e = this.variableOffsets[l];
										e ? (n = ht(e.anchor, e.width, e.height, e.textOffset, e.textBoxScale), f && n._rotate(p ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t = !1;
									}
									if (i.textBox || i.verticalTextBox) {
										let a;
										i.textBox && (a = b), i.verticalTextBox && (a = x), _t(e.textCollisionBox.collisionVertexArray, u.text.placed, !t || a, S.text, n.x, n.y);
									}
								}
								if (i.iconBox || i.verticalIconBox) {
									let t = !!(!x && i.verticalIconBox), a;
									i.iconBox && (a = t), i.verticalIconBox && (a = !t), _t(e.iconCollisionBox.collisionVertexArray, u.icon.placed, a, S.icon, m ? n.x : 0, m ? n.y : 0);
								}
							}
						}
					}
					if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
					if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
					e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]);
				}
				symbolFadeChange(e) {
					return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
				}
				zoomAdjustment(e) {
					return Math.max(0, (this.transform.zoom - e) / 1.5);
				}
				hasTransitions(e) {
					return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
				}
				stillRecent(e, t) {
					let n = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;
					return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * n > e;
				}
				setStale() {
					this.stale = !0;
				}
			}
			function _t(e, t, n, i, a, o) {
				i && i.length !== 0 || (i = [
					0,
					0,
					0,
					0
				]);
				let s = i[0] - 100, c = i[1] - 100, l = i[2] - 100, u = i[3] - 100;
				e.emplaceBack(t ? 1 : 0, n ? 1 : 0, a || 0, o || 0, s, c), e.emplaceBack(t ? 1 : 0, n ? 1 : 0, a || 0, o || 0, l, c), e.emplaceBack(t ? 1 : 0, n ? 1 : 0, a || 0, o || 0, l, u), e.emplaceBack(t ? 1 : 0, n ? 1 : 0, a || 0, o || 0, s, u);
			}
			let vt = 2 ** 25, yt = 2 ** 24, bt = 2 ** 17, xt = 2 ** 16;
			function St(e) {
				if (e.opacity === 0 && !e.placed) return 0;
				if (e.opacity === 1 && e.placed) return 4294967295;
				let t = e.placed ? 1 : 0, n = Math.floor(127 * e.opacity);
				return n * vt + t * yt + n * bt + t * xt + n * 512 + t * 256 + n * 2 + t;
			}
			let Ct = 0;
			class wt {
				constructor(e) {
					this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
				}
				continuePlacement(e, t, n, i, a) {
					let o = this._bucketParts;
					for (; this._currentTileIndex < e.length;) if (t.getBucketParts(o, i, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a()) return !0;
					for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, o.sort(((e, t) => e.sortKey - t.sortKey))); this._currentPartIndex < o.length;) if (t.placeLayerBucketPart(o[this._currentPartIndex], this._seenCrossTileIDs, n), this._currentPartIndex++, a()) return !0;
					return !1;
				}
			}
			class Tt {
				constructor(e, t, n, i, a, o, s, c) {
					this.placement = new gt(e, t, o, s, c), this._currentPlacementIndex = n.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = a, this._done = !1;
				}
				isDone() {
					return this._done;
				}
				continuePlacement(e, t, n) {
					let i = l(), a = () => !this._forceFullPlacement && l() - i > 2;
					for (; this._currentPlacementIndex >= 0;) {
						let i = t[e[this._currentPlacementIndex]], o = this.placement.collisionIndex.transform.zoom;
						if (i.type === "symbol" && (!i.minzoom || i.minzoom <= o) && (!i.maxzoom || i.maxzoom > o)) {
							if (this._inProgressLayer ||= new wt(i), this._inProgressLayer.continuePlacement(n[i.source], this.placement, this._showCollisionBoxes, i, a)) return;
							delete this._inProgressLayer;
						}
						this._currentPlacementIndex--;
					}
					this._done = !0;
				}
				commit(e) {
					return this.placement.commit(e), this.placement;
				}
			}
			let Et = 512 / t.$ / 2;
			class Dt {
				constructor(e, n, i) {
					this.tileID = e, this.bucketInstanceId = i, this._symbolsByKey = {};
					let a = /* @__PURE__ */ new Map();
					for (let e = 0; e < n.length; e++) {
						let t = n.get(e), i = t.key, o = a.get(i);
						o ? o.push(t) : a.set(i, [t]);
					}
					for (let [e, n] of a) {
						let i = {
							positions: n.map(((e) => ({
								x: Math.floor(e.anchorX * Et),
								y: Math.floor(e.anchorY * Et)
							}))),
							crossTileIDs: n.map(((e) => e.crossTileID))
						};
						if (i.positions.length > 128) {
							let e = new t.aI(i.positions.length, 16, Uint16Array);
							for (let { x: t, y: n } of i.positions) e.add(t, n);
							e.finish(), delete i.positions, i.index = e;
						}
						this._symbolsByKey[e] = i;
					}
				}
				getScaledCoordinates(e, n) {
					let { x: i, y: a, z: o } = this.tileID.canonical, { x: s, y: c, z: l } = n.canonical, u = Et / 2 ** (l - o), d = (c * t.$ + e.anchorY) * u, f = a * t.$ * Et;
					return {
						x: Math.floor((s * t.$ + e.anchorX) * u - i * t.$ * Et),
						y: Math.floor(d - f)
					};
				}
				findMatches(e, t, n) {
					let i = this.tileID.canonical.z < t.canonical.z ? 1 : 2 ** (this.tileID.canonical.z - t.canonical.z);
					for (let a = 0; a < e.length; a++) {
						let o = e.get(a);
						if (o.crossTileID) continue;
						let s = this._symbolsByKey[o.key];
						if (!s) continue;
						let c = this.getScaledCoordinates(o, t);
						if (s.index) {
							let e = s.index.range(c.x - i, c.y - i, c.x + i, c.y + i).sort();
							for (let t of e) {
								let e = s.crossTileIDs[t];
								if (!n[e]) {
									n[e] = !0, o.crossTileID = e;
									break;
								}
							}
						} else if (s.positions) for (let e = 0; e < s.positions.length; e++) {
							let t = s.positions[e], a = s.crossTileIDs[e];
							if (Math.abs(t.x - c.x) <= i && Math.abs(t.y - c.y) <= i && !n[a]) {
								n[a] = !0, o.crossTileID = a;
								break;
							}
						}
					}
				}
				getCrossTileIDsLists() {
					return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e));
				}
			}
			class Ot {
				constructor() {
					this.maxCrossTileID = 0;
				}
				generate() {
					return ++this.maxCrossTileID;
				}
			}
			class kt {
				constructor() {
					this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
				}
				handleWrapJump(e) {
					let t = Math.round((e - this.lng) / 360);
					if (t !== 0) for (let e in this.indexes) {
						let n = this.indexes[e], i = {};
						for (let e in n) {
							let a = n[e];
							a.tileID = a.tileID.unwrapTo(a.tileID.wrap + t), i[a.tileID.key] = a;
						}
						this.indexes[e] = i;
					}
					this.lng = e;
				}
				addBucket(e, t, n) {
					if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
						if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;
						this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
					}
					for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;
					this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
					let i = this.usedCrossTileIDs[e.overscaledZ];
					for (let n in this.indexes) {
						let a = this.indexes[n];
						if (Number(n) > e.overscaledZ) for (let n in a) {
							let o = a[n];
							o.tileID.isChildOf(e) && o.findMatches(t.symbolInstances, e, i);
						}
						else {
							let o = a[e.scaledTo(Number(n)).key];
							o && o.findMatches(t.symbolInstances, e, i);
						}
					}
					for (let e = 0; e < t.symbolInstances.length; e++) {
						let a = t.symbolInstances.get(e);
						a.crossTileID || (a.crossTileID = n.generate(), i[a.crossTileID] = !0);
					}
					return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Dt(e, t.symbolInstances, t.bucketInstanceId), !0;
				}
				removeBucketCrossTileIDs(e, t) {
					for (let n of t.getCrossTileIDsLists()) for (let t of n) delete this.usedCrossTileIDs[e][t];
				}
				removeStaleBuckets(e) {
					let t = !1;
					for (let n in this.indexes) {
						let i = this.indexes[n];
						for (let a in i) e[i[a].bucketInstanceId] || (this.removeBucketCrossTileIDs(n, i[a]), delete i[a], t = !0);
					}
					return t;
				}
			}
			class At {
				constructor() {
					this.layerIndexes = {}, this.crossTileIDs = new Ot(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
				}
				addLayer(e, t, n) {
					let i = this.layerIndexes[e.id];
					i === void 0 && (i = this.layerIndexes[e.id] = new kt());
					let a = !1, o = {};
					i.handleWrapJump(n);
					for (let n of t) {
						let t = n.getBucket(e);
						t && e.id === t.layerIds[0] && (t.bucketInstanceId ||= ++this.maxBucketInstanceId, i.addBucket(n.tileID, t, this.crossTileIDs) && (a = !0), o[t.bucketInstanceId] = !0);
					}
					return i.removeStaleBuckets(o) && (a = !0), a;
				}
				pruneUnusedLayers(e) {
					let t = {};
					for (let n in e.forEach(((e) => {
						t[e] = !0;
					})), this.layerIndexes) t[n] || delete this.layerIndexes[n];
				}
			}
			var jt = "void main() {fragColor=vec4(1.0);}";
			let Mt = {
				prelude: Nt("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"),
				projectionMercator: Nt("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
				projectionGlobe: Nt("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"),
				background: Nt("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				backgroundPattern: Nt("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
				circle: Nt("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"),
				clippingMask: Nt(jt, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
				heatmap: Nt("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"),
				heatmapTexture: Nt("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
				collisionBox: Nt("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
				collisionCircle: Nt("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
				colorRelief: Nt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;uniform vec4 u_unpack;uniform sampler2D u_elevation_stops;uniform sampler2D u_color_stops;uniform int u_color_ramp_size;uniform float u_opacity;in vec2 v_pos;float getElevation(vec2 coord) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}float getElevationStop(int stop) {float x=(float(stop)+0.5)/float(u_color_ramp_size);vec4 data=texture(u_elevation_stops,vec2(x,0))*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {float el=getElevation(v_pos);int r=(u_color_ramp_size-1);int l=0;float el_l=getElevationStop(l);float el_r=getElevationStop(r);while(r-l > 1){int m=(r+l)/2;float el_m=getElevationStop(m);if(el < el_m){r=m;el_r=el_m;}else\n{l=m;el_l=el_m;}}float x=(float(l)+(el-el_l)/(el_r-el_l)+0.5)/float(u_color_ramp_size);fragColor=u_opacity*texture(u_color_stops,vec2(x,0));\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_dimension;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_pos/8192.0)*scale+epsilon;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				debug: Nt("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
				depth: Nt(jt, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"),
				fill: Nt("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"),
				fillOutline: Nt("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillOutlinePattern: Nt("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"),
				fillPattern: Nt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"),
				fillExtrusion: Nt("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"),
				fillExtrusionPattern: Nt("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"),
				hillshadePrepare: Nt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack);}void main() {vec2 epsilon=1.0/u_dimension;float tileSize=u_dimension.x-2.0;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))*tileSize/pow(2.0,exaggeration+(28.2562-u_zoom));fragColor=clamp(vec4(deriv.x/8.0+0.5,deriv.y/8.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
				hillshade: Nt("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform float u_exaggeration;uniform vec4 u_accent;uniform int u_method;uniform float u_altitudes[NUM_ILLUMINATION_SOURCES];uniform float u_azimuths[NUM_ILLUMINATION_SOURCES];uniform vec4 u_shadows[NUM_ILLUMINATION_SOURCES];uniform vec4 u_highlights[NUM_ILLUMINATION_SOURCES];\n#define PI 3.141592653589793\n#define STANDARD 0\n#define COMBINED 1\n#define IGOR 2\n#define MULTIDIRECTIONAL 3\n#define BASIC 4\nfloat get_aspect(vec2 deriv){return deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);}void igor_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float aspect=get_aspect(deriv);float azimuth=u_azimuths[0]+PI;float slope_stength=atan(length(deriv))*2.0/PI;float aspect_strength=1.0-abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);float shadow_strength=slope_stength*aspect_strength;float highlight_strength=slope_stength*(1.0-aspect_strength);fragColor=u_shadows[0]*shadow_strength+u_highlights[0]*highlight_strength;}void standard_hillshade(vec2 deriv){float azimuth=u_azimuths[0]+PI;float slope=atan(0.625*length(deriv));float aspect=get_aspect(deriv);float intensity=u_exaggeration;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadows[0],u_highlights[0],shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;}void basic_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor=u_highlights[0]*(2.0*shade-1.0);}else\n{fragColor=u_shadows[0]*(1.0-2.0*shade);}}void multidirectional_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;fragColor=vec4(0,0,0,0);for(int i=0; i < NUM_ILLUMINATION_SOURCES; i++){float cos_alt=cos(u_altitudes[i]);float sin_alt=sin(u_altitudes[i]);float cos_az=-cos(u_azimuths[i]);float sin_az=-sin(u_azimuths[i]);float cang=(sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv));float shade=clamp(cang,0.0,1.0);if(shade > 0.5){fragColor+=u_highlights[i]*(2.0*shade-1.0)/float(NUM_ILLUMINATION_SOURCES);}else\n{fragColor+=u_shadows[i]*(1.0-2.0*shade)/float(NUM_ILLUMINATION_SOURCES);}}}void combined_hillshade(vec2 deriv){deriv=deriv*u_exaggeration*2.0;float azimuth=u_azimuths[0]+PI;float cos_az=cos(azimuth);float sin_az=sin(azimuth);float cos_alt=cos(u_altitudes[0]);float sin_alt=sin(u_altitudes[0]);float cang=acos((sin_alt-(deriv.y*cos_az*cos_alt-deriv.x*sin_az*cos_alt))/sqrt(1.0+dot(deriv,deriv)));cang=clamp(cang,0.0,PI/2.0);float shade=cang*atan(length(deriv))*4.0/PI/PI;float highlight=(PI/2.0-cang)*atan(length(deriv))*4.0/PI/PI;fragColor=u_shadows[0]*shade+u_highlights[0]*highlight;}void main() {vec4 pixel=texture(u_image,v_pos);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));vec2 deriv=((pixel.rg*8.0)-4.0)/scaleFactor;if (u_method==BASIC) {basic_hillshade(deriv);} else if (u_method==COMBINED) {combined_hillshade(deriv);} else if (u_method==IGOR) {igor_hillshade(deriv);} else if (u_method==MULTIDIRECTIONAL) {multidirectional_hillshade(deriv);} else if (u_method==STANDARD) {standard_hillshade(deriv);} else {standard_hillshade(deriv);}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
				line: Nt("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				lineGradient: Nt("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"),
				linePattern: Nt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"),
				lineSDF: Nt("uniform lowp float u_device_pixel_ratio;uniform lowp float u_lineatlas_width;uniform sampler2D u_image;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0/u_device_pixel_ratio)/min(dasharray_from.w,dasharray_to.w);alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"),
				lineGradientSDF: Nt("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform sampler2D u_image_dash;uniform float u_mix;uniform lowp float u_lineatlas_width;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);float sdfdist_a=texture(u_image_dash,v_tex_a).a;float sdfdist_b=texture(u_image_dash,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfgamma=(u_lineatlas_width/256.0)/min(dasharray_from.w,dasharray_to.w);float dash_alpha=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*dash_alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;uniform float u_tileratio;uniform float u_crossfade_from;uniform float u_crossfade_to;uniform float u_lineatlas_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;out vec2 v_tex_a;out vec2 v_tex_b;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define mediump vec4 dasharray_from\n#pragma mapbox: define mediump vec4 dasharray_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 dasharray_from\n#pragma mapbox: initialize mediump vec4 dasharray_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;float texel_height=1.0/u_image_height;float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nfloat u_patternscale_a_x=u_tileratio/dasharray_from.w/u_crossfade_from;float u_patternscale_a_y=-dasharray_from.z/2.0/u_lineatlas_height;float u_patternscale_b_x=u_tileratio/dasharray_to.w/u_crossfade_to;float u_patternscale_b_y=-dasharray_to.z/2.0/u_lineatlas_height;v_tex_a=vec2(a_linesofar*u_patternscale_a_x/floorwidth,normal.y*u_patternscale_a_y+(float(dasharray_from.y)+0.5)/u_lineatlas_height);v_tex_b=vec2(a_linesofar*u_patternscale_b_x/floorwidth,normal.y*u_patternscale_b_y+(float(dasharray_to.y)+0.5)/u_lineatlas_height);v_width2=vec2(outset,inset);}"),
				raster: Nt("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
				symbolIcon: Nt("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"),
				symbolSDF: Nt("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"),
				symbolTextAndIcon: Nt("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"),
				terrain: Nt("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
				terrainDepth: Nt("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
				terrainCoords: Nt("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
				projectionErrorMeasurement: Nt("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
				atmosphere: Nt("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
				sky: Nt("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
			};
			function Nt(e, t) {
				let n = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, i = t.match(/in ([\w]+) ([\w]+)/g), a = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s = o ? o.concat(a) : a, c = {};
				return {
					fragmentSource: e = e.replace(n, ((e, t, n, i, a) => (c[a] = !0, t === "define" ? `\n#ifndef HAS_UNIFORM_u_${a}\nin ${n} ${i} ${a};\n#else\nuniform ${n} ${i} u_${a};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${a}\n    ${n} ${i} ${a} = u_${a};\n#endif\n`))),
					vertexSource: t = t.replace(n, ((e, t, n, i, a) => {
						let o = i === "float" ? "vec2" : "vec4", s = a.match(/color/) ? "color" : o;
						return c[a] ? t === "define" ? `\n#ifndef HAS_UNIFORM_u_${a}\nuniform lowp float u_${a}_t;\nin ${n} ${o} a_${a};\nout ${n} ${i} ${a};\n#else\nuniform ${n} ${i} u_${a};\n#endif\n` : s === "vec4" ? `\n#ifndef HAS_UNIFORM_u_${a}\n    ${a} = a_${a};\n#else\n    ${n} ${i} ${a} = u_${a};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${a}\n    ${a} = unpack_mix_${s}(a_${a}, u_${a}_t);\n#else\n    ${n} ${i} ${a} = u_${a};\n#endif\n` : t === "define" ? `\n#ifndef HAS_UNIFORM_u_${a}\nuniform lowp float u_${a}_t;\nin ${n} ${o} a_${a};\n#else\nuniform ${n} ${i} u_${a};\n#endif\n` : s === "vec4" ? `\n#ifndef HAS_UNIFORM_u_${a}\n    ${n} ${i} ${a} = a_${a};\n#else\n    ${n} ${i} ${a} = u_${a};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${a}\n    ${n} ${i} ${a} = unpack_mix_${s}(a_${a}, u_${a}_t);\n#else\n    ${n} ${i} ${a} = u_${a};\n#endif\n`;
					})),
					staticAttributes: i,
					staticUniforms: s
				};
			}
			class Pt {
				constructor(e, t, n) {
					this.vertexBuffer = e, this.indexBuffer = t, this.segments = n;
				}
				destroy() {
					this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
				}
			}
			var Ft = t.aJ([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}]);
			let It = "#define PROJECTION_MERCATOR", Lt = "mercator";
			class Rt {
				constructor() {
					this._cachedMesh = null;
				}
				get name() {
					return "mercator";
				}
				get useSubdivision() {
					return !1;
				}
				get shaderVariantName() {
					return Lt;
				}
				get shaderDefine() {
					return It;
				}
				get shaderPreludeCode() {
					return Mt.projectionMercator;
				}
				get vertexShaderPreludeCode() {
					return Mt.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return t.aK.noSubdivision;
				}
				get useGlobeControls() {
					return !1;
				}
				get transitionState() {
					return 0;
				}
				get latitudeErrorCorrectionRadians() {
					return 0;
				}
				destroy() {}
				updateGPUdependent(e) {}
				getMeshFromTileID(e, n, i, a, o) {
					if (this._cachedMesh) return this._cachedMesh;
					let s = new t.aL();
					s.emplaceBack(0, 0), s.emplaceBack(t.$, 0), s.emplaceBack(0, t.$), s.emplaceBack(t.$, t.$);
					let c = e.createVertexBuffer(s, Ft.members), l = t.aM.simpleSegment(0, 0, 4, 2), u = new t.aN();
					u.emplaceBack(1, 0, 2), u.emplaceBack(1, 2, 3);
					let d = e.createIndexBuffer(u);
					return this._cachedMesh = new Pt(c, d, l), this._cachedMesh;
				}
				recalculate() {}
				hasTransition() {
					return !1;
				}
				setErrorQueryLatitudeDegrees(e) {}
			}
			class zt {
				constructor(e = 0, t = 0, n = 0, i = 0) {
					if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(n) || n < 0 || isNaN(i) || i < 0) throw Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
					this.top = e, this.bottom = t, this.left = n, this.right = i;
				}
				interpolate(e, n, i) {
					return n.top != null && e.top != null && (this.top = t.C.number(e.top, n.top, i)), n.bottom != null && e.bottom != null && (this.bottom = t.C.number(e.bottom, n.bottom, i)), n.left != null && e.left != null && (this.left = t.C.number(e.left, n.left, i)), n.right != null && e.right != null && (this.right = t.C.number(e.right, n.right, i)), this;
				}
				getCenter(e, n) {
					let i = t.ae((this.left + e - this.right) / 2, 0, e), a = t.ae((this.top + n - this.bottom) / 2, 0, n);
					return new t.P(i, a);
				}
				equals(e) {
					return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
				}
				clone() {
					return new zt(this.top, this.bottom, this.left, this.right);
				}
				toJSON() {
					return {
						top: this.top,
						bottom: this.bottom,
						left: this.left,
						right: this.right
					};
				}
			}
			function Bt(e, t) {
				if (!e.renderWorldCopies || e.lngRange) return;
				let n = t.lng - e.center.lng;
				t.lng += n > 180 ? -360 : n < -180 ? 360 : 0;
			}
			function Vt(e) {
				return Math.max(0, Math.floor(e));
			}
			class Ht {
				constructor(e, n) {
					this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = n?.renderWorldCopies === void 0 || !!n?.renderWorldCopies, this._minZoom = n?.minZoom || 0, this._maxZoom = n?.maxZoom || 22, this._minPitch = n?.minPitch == null ? 0 : n?.minPitch, this._maxPitch = n?.maxPitch == null ? 60 : n?.maxPitch, this._constrain = n?.constrain ?? this._callbacks.constrain, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.S(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Vt(this._zoom), this._scale = t.ah(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new zt(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
				}
				apply(e, n, i) {
					this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = Vt(this._zoom), this._scale = t.ah(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new zt(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !i && e.autoCalculateNearFarZ, n && this.constrainInternal(), this._calcMatrices();
				}
				get pixelsToClipSpaceMatrix() {
					return this._pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._clipSpaceToPixelsMatrix;
				}
				get minElevationForCurrentTile() {
					return this._minElevationForCurrentTile;
				}
				setMinElevationForCurrentTile(e) {
					this._minElevationForCurrentTile = e;
				}
				get tileSize() {
					return this._tileSize;
				}
				get tileZoom() {
					return this._tileZoom;
				}
				get scale() {
					return this._scale;
				}
				get width() {
					return this._width;
				}
				get height() {
					return this._height;
				}
				get bearingInRadians() {
					return this._bearingInRadians;
				}
				get lngRange() {
					return this._lngRange;
				}
				get latRange() {
					return this._latRange;
				}
				get pixelsToGLUnits() {
					return this._pixelsToGLUnits;
				}
				get minZoom() {
					return this._minZoom;
				}
				setMinZoom(e) {
					this._minZoom !== e && (this._minZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom));
				}
				get maxZoom() {
					return this._maxZoom;
				}
				setMaxZoom(e) {
					this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.constrain(this._center, this.zoom).zoom));
				}
				get minPitch() {
					return this._minPitch;
				}
				setMinPitch(e) {
					this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e)));
				}
				get maxPitch() {
					return this._maxPitch;
				}
				setMaxPitch(e) {
					this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e)));
				}
				get renderWorldCopies() {
					return this._renderWorldCopies;
				}
				setRenderWorldCopies(e) {
					e === void 0 ? e = !0 : e === null && (e = !1), this._renderWorldCopies = e;
				}
				get constrain() {
					return this._constrain;
				}
				setConstrain(e) {
					e ||= this._callbacks.constrain, this._constrain = e, this.constrainInternal(), this._calcMatrices();
				}
				get worldSize() {
					return this._tileSize * this._scale;
				}
				get centerOffset() {
					return this.centerPoint._sub(this.size._div(2));
				}
				get size() {
					return new t.P(this._width, this._height);
				}
				get bearing() {
					return this._bearingInRadians / Math.PI * 180;
				}
				setBearing(e) {
					let n = t.aO(e, -180, 180) * Math.PI / 180;
					var a, o, s, c, l, u, d, f, p;
					this._bearingInRadians !== n && (this._unmodified = !1, this._bearingInRadians = n, this._calcMatrices(), this._rotationMatrix = i(), a = this._rotationMatrix, s = -this._bearingInRadians, c = (o = this._rotationMatrix)[0], l = o[1], u = o[2], d = o[3], f = Math.sin(s), p = Math.cos(s), a[0] = c * p + u * f, a[1] = l * p + d * f, a[2] = c * -f + u * p, a[3] = l * -f + d * p);
				}
				get rotationMatrix() {
					return this._rotationMatrix;
				}
				get pitchInRadians() {
					return this._pitchInRadians;
				}
				get pitch() {
					return this._pitchInRadians / Math.PI * 180;
				}
				setPitch(e) {
					let n = t.ae(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
					this._pitchInRadians !== n && (this._unmodified = !1, this._pitchInRadians = n, this._calcMatrices());
				}
				get rollInRadians() {
					return this._rollInRadians;
				}
				get roll() {
					return this._rollInRadians / Math.PI * 180;
				}
				setRoll(e) {
					let t = e / 180 * Math.PI;
					this._rollInRadians !== t && (this._unmodified = !1, this._rollInRadians = t, this._calcMatrices());
				}
				get fovInRadians() {
					return this._fovInRadians;
				}
				get fov() {
					return t.aP(this._fovInRadians);
				}
				setFov(e) {
					e = t.ae(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = t.ag(e), this._calcMatrices());
				}
				get zoom() {
					return this._zoom;
				}
				setZoom(e) {
					let n = this.constrain(this._center, e).zoom;
					this._zoom !== n && (this._unmodified = !1, this._zoom = n, this._tileZoom = Math.max(0, Math.floor(n)), this._scale = t.ah(n), this.constrainInternal(), this._calcMatrices());
				}
				get center() {
					return this._center;
				}
				setCenter(e) {
					e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this.constrainInternal(), this._calcMatrices());
				}
				get elevation() {
					return this._elevation;
				}
				setElevation(e) {
					e !== this._elevation && (this._elevation = e, this.constrainInternal(), this._calcMatrices());
				}
				get padding() {
					return this._edgeInsets.toJSON();
				}
				setPadding(e) {
					this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
				}
				get centerPoint() {
					return this._edgeInsets.getCenter(this._width, this._height);
				}
				get pixelsPerMeter() {
					return this._pixelPerMeter;
				}
				get unmodified() {
					return this._unmodified;
				}
				get cameraToCenterDistance() {
					return this._cameraToCenterDistance;
				}
				get nearZ() {
					return this._nearZ;
				}
				get farZ() {
					return this._farZ;
				}
				get autoCalculateNearFarZ() {
					return this._autoCalculateNearFarZ;
				}
				overrideNearFarZ(e, t) {
					this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = t, this._calcMatrices();
				}
				clearNearFarZOverride() {
					this._autoCalculateNearFarZ = !0, this._calcMatrices();
				}
				isPaddingEqual(e) {
					return this._edgeInsets.equals(e);
				}
				interpolatePadding(e, t, n) {
					this._unmodified = !1, this._edgeInsets.interpolate(e, t, n), this.constrainInternal(), this._calcMatrices();
				}
				resize(e, t, n = !0) {
					this._width = e, this._height = t, n && this.constrainInternal(), this._calcMatrices();
				}
				getMaxBounds() {
					return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new ce([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
				}
				setMaxBounds(e) {
					e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this.constrainInternal()) : (this._lngRange = null, this._latRange = [-t.af, t.af]);
				}
				getCameraQueryGeometry(e, n) {
					if (n.length === 1) return [n[0], e];
					{
						let { minX: i, minY: a, maxX: o, maxY: s } = t.a2.fromPoints(n).extend(e);
						return [
							new t.P(i, a),
							new t.P(o, a),
							new t.P(o, s),
							new t.P(i, s),
							new t.P(i, a)
						];
					}
				}
				constrainInternal() {
					if (!this.center || !this._width || !this._height || this._constraining) return;
					this._constraining = !0;
					let e = this._unmodified, { center: t, zoom: n } = this.constrain(this.center, this.zoom);
					this.setCenter(t), this.setZoom(n), this._unmodified = e, this._constraining = !1;
				}
				_calcMatrices() {
					if (this._width && this._height) {
						this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
						let e = t.ai(new Float64Array(16));
						t.N(e, e, [
							this._width / 2,
							-this._height / 2,
							1
						]), t.M(e, e, [
							1,
							-1,
							0
						]), this._clipSpaceToPixelsMatrix = e, e = t.ai(new Float64Array(16)), t.N(e, e, [
							1,
							-1,
							1
						]), t.M(e, e, [
							-1,
							-1,
							0
						]), t.N(e, e, [
							2 / this._width,
							2 / this._height,
							1
						]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height;
					}
					this._callbacks.calcMatrices();
				}
				calculateCenterFromCameraLngLatAlt(e, n, i, a) {
					let o = i === void 0 ? this.bearing : i, s = a = a === void 0 ? this.pitch : a, c = t.a1.fromLngLat(e, n), l = -Math.cos(t.ag(s)), u = Math.sin(t.ag(s)), d = u * Math.sin(t.ag(o)), f = -u * Math.cos(t.ag(o)), p = this.elevation, m = n - p, h;
					l * m >= 0 || Math.abs(l) < .1 ? (h = 1e4, p = n + h * l) : h = -m / l;
					let g, _, v = t.aQ(1, c.y), y = 0;
					do {
						if (y += 1, y > 10) break;
						_ = h / v, g = new t.a1(c.x + d * _, c.y + f * _), v = 1 / g.meterInMercatorCoordinateUnits();
					} while (Math.abs(h - _ * v) > 1e-12);
					return {
						center: g.toLngLat(),
						elevation: p,
						zoom: t.ak(this.height / 2 / Math.tan(this.fovInRadians / 2) / _ / this.tileSize)
					};
				}
				recalculateZoomAndCenter(e) {
					if (this.elevation - e == 0) return;
					let n = t.aj(1, this.center.lat) * this.worldSize, i = this.cameraToCenterDistance / n, a = t.a1.fromLngLat(this.center, this.elevation), o = je(this.center, this.elevation, this.pitch, this.bearing, i);
					this._elevation = e;
					let s = this.calculateCenterFromCameraLngLatAlt(o.toLngLat(), t.aQ(o.z, a.y), this.bearing, this.pitch);
					this._elevation = s.elevation, this._center = s.center, this.setZoom(s.zoom);
				}
				getCameraPoint() {
					let e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
					return this.centerPoint.add(new t.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians)));
				}
				getCameraAltitude() {
					return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
				}
				getCameraLngLat() {
					let e = t.aj(1, this.center.lat) * this.worldSize;
					return je(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat();
				}
				getMercatorTileCoordinates(e) {
					if (!e) return [
						0,
						0,
						1,
						1
					];
					let n = e.canonical.z >= 0 ? 1 << e.canonical.z : 2 ** e.canonical.z;
					return [
						e.canonical.x / n,
						e.canonical.y / n,
						1 / n / t.$,
						1 / n / t.$
					];
				}
			}
			class Ut {
				constructor(e, n) {
					this.min = e, this.max = n, this.center = t.aR([], t.aS([], this.min, this.max), .5);
				}
				quadrant(e) {
					let n = [e % 2 == 0, e < 2], i = t.aT(this.min), a = t.aT(this.max);
					for (let e = 0; e < n.length; e++) i[e] = n[e] ? this.min[e] : this.center[e], a[e] = n[e] ? this.center[e] : this.max[e];
					return a[2] = this.max[2], new Ut(i, a);
				}
				distanceX(e) {
					return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
				}
				distanceY(e) {
					return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
				}
				intersectsFrustum(e) {
					let t = !0;
					for (let n = 0; n < e.planes.length; n++) {
						let i = this.intersectsPlane(e.planes[n]);
						if (i === 0) return 0;
						i === 1 && (t = !1);
					}
					return t ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1;
				}
				intersectsPlane(e) {
					let t = e[3], n = e[3];
					for (let i = 0; i < 3; i++) e[i] > 0 ? (t += e[i] * this.min[i], n += e[i] * this.max[i]) : (n += e[i] * this.min[i], t += e[i] * this.max[i]);
					return t >= 0 ? 2 : n < 0 ? 0 : 1;
				}
			}
			class Wt {
				distanceToTile2d(e, t, n, i) {
					let a = i.distanceX([e, t]), o = i.distanceY([e, t]);
					return Math.hypot(a, o);
				}
				getWrap(e, t, n) {
					return n;
				}
				getTileBoundingVolume(e, n, i, a) {
					let o = 0, s = 0;
					if (a?.terrain) {
						let c = new t.Z(e.z, n, e.z, e.x, e.y), l = a.terrain.getMinMaxElevation(c);
						o = l.minElevation ?? Math.min(0, i), s = l.maxElevation ?? Math.max(0, i);
					}
					let c = 1 << e.z;
					return new Ut([
						n + e.x / c,
						e.y / c,
						o
					], [
						n + (e.x + 1) / c,
						(e.y + 1) / c,
						s
					]);
				}
				allowVariableZoom(e, n) {
					let i = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, a = t.ae(78.5 - i / 2, 0, 60);
					return !!n.terrain || e.pitch > a;
				}
				allowWorldCopies() {
					return !0;
				}
				prepareNextFrame() {}
			}
			class Gt {
				constructor(e, t, n) {
					this.points = e, this.planes = t, this.aabb = n;
				}
				static fromInvProjectionMatrix(e, n = 1, i = 0, a, o) {
					let s = o ? [
						[
							6,
							5,
							4
						],
						[
							0,
							1,
							2
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					] : [
						[
							0,
							1,
							2
						],
						[
							6,
							5,
							4
						],
						[
							0,
							3,
							7
						],
						[
							2,
							1,
							5
						],
						[
							3,
							2,
							6
						],
						[
							0,
							4,
							5
						]
					], c = 2 ** i, l = [
						[
							-1,
							1,
							-1,
							1
						],
						[
							1,
							1,
							-1,
							1
						],
						[
							1,
							-1,
							-1,
							1
						],
						[
							-1,
							-1,
							-1,
							1
						],
						[
							-1,
							1,
							1,
							1
						],
						[
							1,
							1,
							1,
							1
						],
						[
							1,
							-1,
							1,
							1
						],
						[
							-1,
							-1,
							1,
							1
						]
					].map(((i) => function(e, n, i, a) {
						let o = t.aw([], e, n), s = 1 / o[3] / i * a;
						return t.aY(o, o, [
							s,
							s,
							1 / o[3],
							s
						]);
					}(i, e, n, c)));
					a && function(e, n, i, a) {
						let o = a ? 4 : 0, s = a ? 0 : 4, c = 0, l = [], u = [];
						for (let n = 0; n < 4; n++) {
							let i = t.aU([], e[n + s], e[n + o]), a = t.aZ(i);
							t.aR(i, i, 1 / a), l.push(a), u.push(i);
						}
						for (let n = 0; n < 4; n++) {
							let a = t.a_(e[n + o], u[n], i);
							c = a !== null && a >= 0 ? Math.max(c, a) : Math.max(c, l[n]);
						}
						let d = function(e, n) {
							let i = t.aU([], e[n[0]], e[n[1]]), a = t.aU([], e[n[2]], e[n[1]]), o = [
								0,
								0,
								0,
								0
							];
							return t.aV(o, t.aW([], i, a)), o[3] = -t.aX(o, e[n[0]]), o;
						}(e, n), f = function(e, n) {
							let i = t.a$(e), a = t.b0([], e, 1 / i), o = t.aU([], n, t.aR([], a, t.aX(n, a))), s = t.a$(o);
							if (s > 0) {
								let e = Math.sqrt(1 - a[3] * a[3]), i = t.aR([], a, -a[3]), c = t.aS([], i, t.aR([], o, e / s));
								return t.b1(n, c);
							}
							return null;
						}(i, d);
						if (f !== null) {
							let e = f / t.aX(u[0], d);
							c = Math.min(c, e);
						}
						for (let t = 0; t < 4; t++) {
							let n = Math.min(c, l[t]);
							e[t + s] = [
								e[t + o][0] + u[t][0] * n,
								e[t + o][1] + u[t][1] * n,
								e[t + o][2] + u[t][2] * n,
								1
							];
						}
					}(l, s[0], a, o);
					let u = s.map(((e) => {
						let n = t.aU([], l[e[0]], l[e[1]]), i = t.aU([], l[e[2]], l[e[1]]), a = t.aV([], t.aW([], n, i)), o = -t.aX(a, l[e[1]]);
						return a.concat(o);
					})), d = [
						Infinity,
						Infinity,
						Infinity
					], f = [
						-Infinity,
						-Infinity,
						-Infinity
					];
					for (let e of l) for (let t = 0; t < 3; t++) d[t] = Math.min(d[t], e[t]), f[t] = Math.max(f[t], e[t]);
					return new Gt(l, u, new Ut(d, f));
				}
			}
			class Kt {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e) {
					this._helper.setMinZoom(e);
				}
				setMaxZoom(e) {
					this._helper.setMaxZoom(e);
				}
				setMinPitch(e) {
					this._helper.setMinPitch(e);
				}
				setMaxPitch(e) {
					this._helper.setMaxPitch(e);
				}
				setRenderWorldCopies(e) {
					this._helper.setRenderWorldCopies(e);
				}
				setBearing(e) {
					this._helper.setBearing(e);
				}
				setPitch(e) {
					this._helper.setPitch(e);
				}
				setRoll(e) {
					this._helper.setRoll(e);
				}
				setFov(e) {
					this._helper.setFov(e);
				}
				setZoom(e) {
					this._helper.setZoom(e);
				}
				setCenter(e) {
					this._helper.setCenter(e);
				}
				setElevation(e) {
					this._helper.setElevation(e);
				}
				setMinElevationForCurrentTile(e) {
					this._helper.setMinElevationForCurrentTile(e);
				}
				setPadding(e) {
					this._helper.setPadding(e);
				}
				interpolatePadding(e, t, n) {
					return this._helper.interpolatePadding(e, t, n);
				}
				isPaddingEqual(e) {
					return this._helper.isPaddingEqual(e);
				}
				resize(e, t, n = !0) {
					this._helper.resize(e, t, n);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e) {
					this._helper.setMaxBounds(e);
				}
				setConstrain(e) {
					this._helper.setConstrain(e);
				}
				overrideNearFarZ(e, t) {
					this._helper.overrideNearFarZ(e, t);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get constrain() {
					return this._helper.constrain;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e, t) {}
				constructor(e) {
					this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this.defaultConstrain = (e, n) => {
						n = t.ae(+n, this.minZoom, this.maxZoom);
						let i = {
							center: new t.S(e.lng, e.lat),
							zoom: n
						}, a = this._helper._lngRange;
						if (!this._helper._renderWorldCopies && a === null) {
							let e = 179.9999999999;
							a = [-e, e];
						}
						let o = this.tileSize * t.ah(i.zoom), s = 0, c = o, l = 0, u = o, d = 0, f = 0, { x: p, y: m } = this.size;
						if (this._helper._latRange) {
							let e = this._helper._latRange;
							s = t.U(e[1]) * o, c = t.U(e[0]) * o, c - s < m && (d = m / (c - s));
						}
						a && (l = t.aO(t.V(a[0]) * o, 0, o), u = t.aO(t.V(a[1]) * o, 0, o), u < l && (u += o), u - l < p && (f = p / (u - l)));
						let { x: h, y: g } = De(o, e), _, v, y = Math.max(f || 0, d || 0);
						if (y) {
							let e = new t.P(f ? (u + l) / 2 : h, d ? (c + s) / 2 : g);
							return i.center = Oe(o, e).wrap(), i.zoom += t.ak(y), i;
						}
						if (this._helper._latRange) {
							let e = m / 2;
							g - e < s && (v = s + e), g + e > c && (v = c - e);
						}
						if (a) {
							let e = (l + u) / 2, n = h;
							this._helper._renderWorldCopies && (n = t.aO(h, e - o / 2, e + o / 2));
							let i = p / 2;
							n - i < l && (_ = l + i), n + i > u && (_ = u - i);
						}
						if (_ !== void 0 || v !== void 0) {
							let e = new t.P(_ ?? h, v ?? g);
							i.center = Oe(o, e).wrap();
						}
						return i;
					}, this._helper = new Ht({
						calcMatrices: () => {
							this._calcMatrices();
						},
						constrain: (e, t) => this.defaultConstrain(e, t)
					}, e), this._coveringTilesDetailsProvider = new Wt();
				}
				clone() {
					let e = new Kt();
					return e.apply(this), e;
				}
				apply(e, t, n) {
					this._helper.apply(e, t, n);
				}
				get cameraPosition() {
					return this._cameraPosition;
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._viewProjMatrix;
				}
				get inverseProjectionMatrix() {
					return this._invProjMatrix;
				}
				get mercatorMatrix() {
					return this._mercatorMatrix;
				}
				getVisibleUnwrappedCoordinates(e) {
					let n = [new t.b2(0, e)];
					if (this._helper._renderWorldCopies) {
						let i = this.screenPointToMercatorCoordinate(new t.P(0, 0)), a = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), o = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), s = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), c = Math.floor(Math.min(i.x, a.x, o.x, s.x)), l = Math.floor(Math.max(i.x, a.x, o.x, s.x));
						for (let i = c - 1; i <= l + 1; i++) i !== 0 && n.push(new t.b2(i, e));
					}
					return n;
				}
				getCameraFrustum() {
					return Gt.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
				}
				getClippingPlane() {
					return null;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e) {
					let t = this.screenPointToLocation(this.centerPoint, e), n = e ? e.getElevationForLngLatZoom(t, this._helper._tileZoom) : 0;
					this._helper.recalculateZoomAndCenter(n);
				}
				setLocationAtPoint(e, n) {
					let i = t.aj(this.elevation, this.center.lat), a = this.screenPointToMercatorCoordinateAtZ(n, i), o = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, i), s = t.a1.fromLngLat(e), c = new t.a1(s.x - (a.x - o.x), s.y - (a.y - o.y));
					this.setCenter(c?.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
				}
				locationToScreenPoint(e, n) {
					return n ? this.coordinatePoint(t.a1.fromLngLat(e), n.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t.a1.fromLngLat(e));
				}
				screenPointToLocation(e, t) {
					return this.screenPointToMercatorCoordinate(e, t)?.toLngLat();
				}
				screenPointToMercatorCoordinate(e, t) {
					if (t) {
						let n = t.pointCoordinate(e);
						if (n != null) return n;
					}
					return this.screenPointToMercatorCoordinateAtZ(e);
				}
				screenPointToMercatorCoordinateAtZ(e, n) {
					let i = n || 0, a = [
						e.x,
						e.y,
						0,
						1
					], o = [
						e.x,
						e.y,
						1,
						1
					];
					t.aw(a, a, this._pixelMatrixInverse), t.aw(o, o, this._pixelMatrixInverse);
					let s = a[3], c = o[3], l = a[1] / s, u = o[1] / c, d = a[2] / s, f = o[2] / c, p = d === f ? 0 : (i - d) / (f - d);
					return new t.a1(t.C.number(a[0] / s, o[0] / c, p) / this.worldSize, t.C.number(l, u, p) / this.worldSize, i);
				}
				coordinatePoint(e, n = 0, i = this._pixelMatrix) {
					let a = [
						e.x * this.worldSize,
						e.y * this.worldSize,
						n,
						1
					];
					return t.aw(a, a, i), new t.P(a[0] / a[3], a[1] / a[3]);
				}
				getBounds() {
					let e = Math.max(0, this._helper._height / 2 - ke(this));
					return new ce().extend(this.screenPointToLocation(new t.P(0, e))).extend(this.screenPointToLocation(new t.P(this._helper._width, e))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height)));
				}
				isPointOnMapSurface(e, t) {
					return t ? t.pointCoordinate(e) != null : e.y > this.height / 2 - ke(this);
				}
				calculatePosMatrix(e, n = !1, i) {
					let a = e.key ?? t.b3(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), o = n ? this._alignedPosMatrixCache : this._posMatrixCache;
					if (o.has(a)) {
						let e = o.get(a);
						return i ? e.f32 : e.f64;
					}
					let s = Ae(e, this.worldSize);
					t.O(s, n ? this._alignedProjMatrix : this._viewProjMatrix, s);
					let c = {
						f64: s,
						f32: new Float32Array(s)
					};
					return o.set(a, c), i ? c.f32 : c.f64;
				}
				calculateFogMatrix(e) {
					let n = e.key, i = this._fogMatrixCacheF32;
					if (i.has(n)) return i.get(n);
					let a = Ae(e, this.worldSize);
					return t.O(a, this._fogMatrix, a), i.set(n, new Float32Array(a)), i.get(n);
				}
				calculateCenterFromCameraLngLatAlt(e, t, n, i) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e, t, n, i);
				}
				_calculateNearFarZIfNeeded(e, n, i) {
					if (!this._helper.autoCalculateNearFarZ) return;
					let a = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), o = e - a * this._helper._pixelPerMeter / Math.cos(n), s = a < 0 ? o : e, c = Math.PI / 2 + this.pitchInRadians, l = t.ag(this.fov) * (Math.abs(Math.cos(t.ag(this.roll))) * this.height + Math.abs(Math.sin(t.ag(this.roll))) * this.width) / this.height * (.5 + i.y / this.height), u = Math.sin(l) * s / Math.sin(t.ae(Math.PI - c - l, .01, Math.PI - .01)), d = ke(this), f = Math.atan(d / this._helper.cameraToCenterDistance), p = t.ag(.75), m = f > p ? 2 * f * (.5 + i.y / (2 * d)) : p, h = Math.sin(m) * s / Math.sin(t.ae(Math.PI - c - m, .01, Math.PI - .01)), g = Math.min(u, h);
					this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - n) * g + s), this._helper._nearZ = this._helper._height / 50;
				}
				_calcMatrices() {
					if (!this._helper._height) return;
					let e = this.centerOffset, n = De(this.worldSize, this.center), i = n.x, a = n.y;
					this._helper._pixelPerMeter = t.aj(1, this.center.lat) * this.worldSize;
					let o = t.ag(Math.min(this.pitch, Ee)), s = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(o)), c;
					this._calculateNearFarZIfNeeded(s, o, e), c = new Float64Array(16), t.b4(c, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.aq(this._invProjMatrix, c), c[8] = 2 * -e.x / this._helper._width, c[9] = 2 * e.y / this._helper._height, this._projectionMatrix = t.b5(c), t.N(c, c, [
						1,
						-1,
						1
					]), t.M(c, c, [
						0,
						0,
						-this._helper.cameraToCenterDistance
					]), t.b6(c, c, -this.rollInRadians), t.b7(c, c, this.pitchInRadians), t.b6(c, c, -this.bearingInRadians), t.M(c, c, [
						-i,
						-a,
						0
					]), this._mercatorMatrix = t.N([], c, [
						this.worldSize,
						this.worldSize,
						this.worldSize
					]), t.N(c, c, [
						1,
						1,
						this._helper._pixelPerMeter
					]), this._pixelMatrix = t.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, c), t.M(c, c, [
						0,
						0,
						-this.elevation
					]), this._viewProjMatrix = c, this._invViewProjMatrix = t.aq([], c);
					let l = [
						0,
						0,
						-1,
						1
					];
					t.aw(l, l, this._invViewProjMatrix), this._cameraPosition = [
						l[0] / l[3],
						l[1] / l[3],
						l[2] / l[3]
					], this._fogMatrix = new Float64Array(16), t.b4(this._fogMatrix, this.fovInRadians, this.width / this.height, s, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, t.N(this._fogMatrix, this._fogMatrix, [
						1,
						-1,
						1
					]), t.M(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.b6(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.b7(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.b6(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.M(this._fogMatrix, this._fogMatrix, [
						-i,
						-a,
						0
					]), t.N(this._fogMatrix, this._fogMatrix, [
						1,
						1,
						this._helper._pixelPerMeter
					]), t.M(this._fogMatrix, this._fogMatrix, [
						0,
						0,
						-this.elevation
					]), this._pixelMatrix3D = t.O(new Float64Array(16), this.clipSpaceToPixelsMatrix, c);
					let u = this._helper._width % 2 / 2, d = this._helper._height % 2 / 2, f = Math.cos(this.bearingInRadians), p = Math.sin(-this.bearingInRadians), m = i - Math.round(i) + f * u + p * d, h = a - Math.round(a) + f * d + p * u, g = new Float64Array(c);
					if (t.M(g, g, [
						m > .5 ? m - 1 : m,
						h > .5 ? h - 1 : h,
						0
					]), this._alignedProjMatrix = g, c = t.aq(new Float64Array(16), this._pixelMatrix), !c) throw Error("failed to invert matrix");
					this._pixelMatrixInverse = c, this._clearMatrixCaches();
				}
				_clearMatrixCaches() {
					this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
				}
				maxPitchScaleFactor() {
					if (!this._pixelMatrixInverse) return 1;
					let e = this.screenPointToMercatorCoordinate(new t.P(0, 0)), n = [
						e.x * this.worldSize,
						e.y * this.worldSize,
						0,
						1
					];
					return t.aw(n, n, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					let e = t.aj(1, this.center.lat) * this.worldSize;
					return je(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat();
				}
				lngLatToCameraDepth(e, n) {
					let i = t.a1.fromLngLat(e), a = [
						i.x * this.worldSize,
						i.y * this.worldSize,
						n,
						1
					];
					return t.aw(a, a, this._viewProjMatrix), a[2] / a[3];
				}
				getProjectionData(e) {
					let { overscaledTileID: n, aligned: i, applyTerrainMatrix: a } = e, o = this._helper.getMercatorTileCoordinates(n), s = n ? this.calculatePosMatrix(n, i, !0) : null, c;
					return c = n && n.terrainRttPosMatrix32f && a ? n.terrainRttPosMatrix32f : s || t.b8(), {
						mainMatrix: c,
						tileMercatorCoords: o,
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: c
					};
				}
				isLocationOccluded(e) {
					return !1;
				}
				getPixelScale() {
					return 1;
				}
				getCircleRadiusCorrection() {
					return 1;
				}
				getPitchedTextCorrection(e, t, n) {
					return 1;
				}
				transformLightDirection(e) {
					return t.aT(e);
				}
				getRayDirectionFromPixel(e) {
					throw Error("Not implemented.");
				}
				projectTileCoordinates(e, n, i, a) {
					let o = this.calculatePosMatrix(i), s;
					a ? (s = [
						e,
						n,
						a(e, n),
						1
					], t.aw(s, s, o)) : (s = [
						e,
						n,
						0,
						1
					], ct(s, s, o));
					let c = s[3];
					return {
						point: new t.P(s[0] / c, s[1] / c),
						signedDistanceFromCamera: c,
						isOccluded: !1
					};
				}
				populateCache(e) {
					for (let t of e) this.calculatePosMatrix(t);
				}
				getMatrixForModel(e, n) {
					let i = t.a1.fromLngLat(e, n), a = i.meterInMercatorCoordinateUnits(), o = t.b9();
					return t.M(o, o, [
						i.x,
						i.y,
						i.z
					]), t.b6(o, o, Math.PI), t.b7(o, o, Math.PI / 2), t.N(o, o, [
						-a,
						a,
						a
					]), o;
				}
				getProjectionDataForCustomLayer(e = !0) {
					let n = new t.Z(0, 0, 0, 0, 0), i = this.getProjectionData({
						overscaledTileID: n,
						applyGlobeMatrix: e
					}), a = Ae(n, this.worldSize);
					t.O(a, this._viewProjMatrix, a), i.tileMercatorCoords = [
						0,
						0,
						1,
						1
					];
					let o = [
						t.$,
						t.$,
						this.worldSize / this._helper.pixelsPerMeter
					], s = t.ba();
					return t.N(s, a, o), i.fallbackMatrix = s, i.mainMatrix = s, i;
				}
				getFastPathSimpleProjectionMatrix(e) {
					return this.calculatePosMatrix(e);
				}
			}
			function qt() {
				t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
			}
			function Jt(e) {
				if (e.useSlerp) if (e.k < 1) {
					let n = t.bb(e.startEulerAngles.roll, e.startEulerAngles.pitch, e.startEulerAngles.bearing), i = t.bb(e.endEulerAngles.roll, e.endEulerAngles.pitch, e.endEulerAngles.bearing), a = new Float64Array(4);
					t.bc(a, n, i, e.k);
					let o = t.bd(a);
					e.tr.setRoll(o.roll), e.tr.setPitch(o.pitch), e.tr.setBearing(o.bearing);
				} else e.tr.setRoll(e.endEulerAngles.roll), e.tr.setPitch(e.endEulerAngles.pitch), e.tr.setBearing(e.endEulerAngles.bearing);
				else e.tr.setRoll(t.C.number(e.startEulerAngles.roll, e.endEulerAngles.roll, e.k)), e.tr.setPitch(t.C.number(e.startEulerAngles.pitch, e.endEulerAngles.pitch, e.k)), e.tr.setBearing(t.C.number(e.startEulerAngles.bearing, e.endEulerAngles.bearing, e.k));
			}
			function Yt(e, n, i, a, o) {
				let s = o.padding, c = De(o.worldSize, i.getNorthWest()), l = De(o.worldSize, i.getNorthEast()), u = De(o.worldSize, i.getSouthEast()), d = De(o.worldSize, i.getSouthWest()), f = t.ag(-a), p = c.rotate(f), m = l.rotate(f), h = u.rotate(f), g = d.rotate(f), _ = new t.P(Math.max(p.x, m.x, g.x, h.x), Math.max(p.y, m.y, g.y, h.y)), v = new t.P(Math.min(p.x, m.x, g.x, h.x), Math.min(p.y, m.y, g.y, h.y)), y = _.sub(v), b = (o.width - (s.left + s.right + n.left + n.right)) / y.x, x = (o.height - (s.top + s.bottom + n.top + n.bottom)) / y.y;
				if (x < 0 || b < 0) return void qt();
				let S = Math.min(t.ak(o.scale * Math.min(b, x)), e.maxZoom), C = t.P.convert(e.offset), w = new t.P((n.left - n.right) / 2, (n.top - n.bottom) / 2).rotate(t.ag(a)), T = C.add(w).mult(o.scale / t.ah(S));
				return {
					center: Oe(o.worldSize, c.add(u).div(2).sub(T)),
					zoom: S,
					bearing: a
				};
			}
			class Xt {
				get useGlobeControls() {
					return !1;
				}
				handlePanInertia(e, t) {
					let n = e.mag(), i = Math.abs(ke(t));
					return {
						easingOffset: e.mult(Math.min(.75 * i / n, 1)),
						easingCenter: t.center
					};
				}
				handleMapControlsRollPitchBearingZoom(e, t) {
					e.bearingDelta && t.setBearing(t.bearing + e.bearingDelta), e.pitchDelta && t.setPitch(t.pitch + e.pitchDelta), e.rollDelta && t.setRoll(t.roll + e.rollDelta), e.zoomDelta && t.setZoom(t.zoom + e.zoomDelta);
				}
				handleMapControlsPan(e, t, n) {
					e.around.distSqr(t.centerPoint) < .01 || t.setLocationAtPoint(n, e.around);
				}
				cameraForBoxAndBearing(e, t, n, i, a) {
					return Yt(e, t, n, i, a);
				}
				handleJumpToCenterZoom(e, n) {
					e.zoom !== (n.zoom === void 0 ? e.zoom : +n.zoom) && e.setZoom(+n.zoom), n.center !== void 0 && e.setCenter(t.S.convert(n.center));
				}
				handleEaseTo(e, n) {
					let i = e.zoom, a = e.padding, o = {
						roll: e.roll,
						pitch: e.pitch,
						bearing: e.bearing
					}, s = {
						roll: n.roll === void 0 ? e.roll : n.roll,
						pitch: n.pitch === void 0 ? e.pitch : n.pitch,
						bearing: n.bearing === void 0 ? e.bearing : n.bearing
					}, c = n.zoom !== void 0, l = !e.isPaddingEqual(n.padding), u = !1, d = c ? +n.zoom : e.zoom, f = e.centerPoint.add(n.offsetAsPoint), p = e.screenPointToLocation(f), { center: m, zoom: h } = e.constrain(t.S.convert(n.center || p), d ?? i);
					Bt(e, m);
					let g = De(e.worldSize, p), _ = De(e.worldSize, m).sub(g), v = t.ah(h - i);
					return u = h !== i, {
						easeFunc: (c) => {
							if (u && e.setZoom(t.C.number(i, h, c)), t.be(o, s) || Jt({
								startEulerAngles: o,
								endEulerAngles: s,
								tr: e,
								k: c,
								useSlerp: o.roll != s.roll
							}), l && (e.interpolatePadding(a, n.padding, c), f = e.centerPoint.add(n.offsetAsPoint)), n.around) e.setLocationAtPoint(n.around, n.aroundPoint);
							else {
								let n = t.ah(e.zoom - i), a = (h > i ? Math.min(2, v) : Math.max(.5, v)) ** (1 - c), o = Oe(e.worldSize, g.add(_.mult(c * a)).mult(n));
								e.setLocationAtPoint(e.renderWorldCopies ? o.wrap() : o, f);
							}
						},
						isZooming: u,
						elevationCenter: m
					};
				}
				handleFlyTo(e, n) {
					let i = n.zoom !== void 0, a = e.zoom, o = e.constrain(t.S.convert(n.center || n.locationAtOffset), i ? +n.zoom : a), s = o.center, c = o.zoom;
					Bt(e, s);
					let l = De(e.worldSize, n.locationAtOffset), u = De(e.worldSize, s).sub(l), d = u.mag(), f = t.ah(c - a), p;
					if (n.minZoom !== void 0) {
						let i = Math.min(+n.minZoom, a, c), o = e.constrain(s, i).zoom;
						p = t.ah(o - a);
					}
					return {
						easeFunc: (n, i, o, d) => {
							e.setZoom(n === 1 ? c : a + t.ak(i));
							let f = n === 1 ? s : Oe(e.worldSize, l.add(u.mult(o)).mult(i));
							e.setLocationAtPoint(e.renderWorldCopies ? f.wrap() : f, d);
						},
						scaleOfZoom: f,
						targetCenter: s,
						scaleOfMinZoom: p,
						pixelPathLength: d
					};
				}
			}
			class Zt {
				constructor(e, t, n) {
					this.blendFunction = e, this.blendColor = t, this.mask = n;
				}
			}
			Zt.Replace = [1, 0], Zt.disabled = new Zt(Zt.Replace, t.bf.transparent, [
				!1,
				!1,
				!1,
				!1
			]), Zt.unblended = new Zt(Zt.Replace, t.bf.transparent, [
				!0,
				!0,
				!0,
				!0
			]), Zt.alphaBlended = new Zt([1, 771], t.bf.transparent, [
				!0,
				!0,
				!0,
				!0
			]);
			let Qt = 2305;
			class K {
				constructor(e, t, n) {
					this.enable = e, this.mode = t, this.frontFace = n;
				}
			}
			K.disabled = new K(!1, 1029, Qt), K.backCCW = new K(!0, 1029, Qt), K.frontCCW = new K(!0, 1028, Qt);
			class $t {
				constructor(e, t, n) {
					this.func = e, this.mask = t, this.range = n;
				}
			}
			$t.ReadOnly = !1, $t.ReadWrite = !0, $t.disabled = new $t(519, $t.ReadOnly, [0, 1]);
			let en = 7680;
			class tn {
				constructor(e, t, n, i, a, o) {
					this.test = e, this.ref = t, this.mask = n, this.fail = i, this.depthFail = a, this.pass = o;
				}
			}
			tn.disabled = new tn({
				func: 519,
				mask: 0
			}, 0, 0, en, en, en);
			let nn = /* @__PURE__ */ new WeakMap();
			function rn(e) {
				if (nn.has(e)) return nn.get(e);
				{
					let t = e.getParameter(e.VERSION)?.startsWith("WebGL 2.0");
					return nn.set(e, t), t;
				}
			}
			class an {
				get awaitingQuery() {
					return !!this._readbackQueue;
				}
				constructor(e) {
					this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e;
					let n = e.context, i = n.gl;
					this._texFormat = i.RGBA, this._texType = i.UNSIGNED_BYTE;
					let a = new t.aL();
					a.emplaceBack(-1, -1), a.emplaceBack(2, -1), a.emplaceBack(-1, 2);
					let o = new t.aN();
					o.emplaceBack(0, 1, 2), this._fullscreenTriangle = new Pt(n.createVertexBuffer(a, Ft.members), n.createIndexBuffer(o), t.aM.simpleSegment(0, 0, a.length, o.length)), this._resultBuffer = new Uint8Array(4), n.activeTexture.set(i.TEXTURE1);
					let s = i.createTexture();
					i.bindTexture(i.TEXTURE_2D, s), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texImage2D(i.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = n.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(s), rn(i) && (this._pbo = i.createBuffer(), i.bindBuffer(i.PIXEL_PACK_BUFFER, this._pbo), i.bufferData(i.PIXEL_PACK_BUFFER, 4, i.STREAM_READ), i.bindBuffer(i.PIXEL_PACK_BUFFER, null));
				}
				destroy() {
					let e = this._cachedRenderContext.context.gl;
					this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
				}
				updateErrorLoop(e, t) {
					let n = this._updateCount;
					return this._readbackQueue ? n >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : n >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, t), this._updateCount++, this._measuredError;
				}
				_bindFramebuffer() {
					let e = this._cachedRenderContext.context, t = e.gl;
					e.activeTexture.set(t.TEXTURE1), t.bindTexture(t.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer);
				}
				_renderErrorTexture(e, n) {
					let i = this._cachedRenderContext.context, a = i.gl;
					if (this._bindFramebuffer(), i.viewport.set([
						0,
						0,
						this._texWidth,
						this._texHeight
					]), i.clear({ color: t.bf.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(i, a.TRIANGLES, $t.disabled, tn.disabled, Zt.unblended, K.disabled, ((e, t) => ({
						u_input: e,
						u_output_expected: t
					}))(e, n), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && rn(a)) {
						a.bindBuffer(a.PIXEL_PACK_BUFFER, this._pbo), a.readBuffer(a.COLOR_ATTACHMENT0), a.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), a.bindBuffer(a.PIXEL_PACK_BUFFER, null);
						let e = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
						a.flush(), this._readbackQueue = {
							frameNumberIssued: this._updateCount,
							sync: e
						};
					} else this._readbackQueue = {
						frameNumberIssued: this._updateCount,
						sync: null
					};
				}
				_tryReadback() {
					let e = this._cachedRenderContext.context.gl;
					if (this._pbo && this._readbackQueue && rn(e)) {
						let n = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
						if (n === e.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
						if (n === e.TIMEOUT_EXPIRED) return;
						e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null);
					} else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
					this._readbackQueue = null, this._measuredError = an._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
				}
				static _parseRGBA8float(e) {
					let t = 0;
					return t += e[0] / 256, t += e[1] / 65536, t += e[2] / 16777216, e[3] < 127 && (t = -t), t / 128;
				}
			}
			let on = t.$ / 128;
			function sn(e, n) {
				let i = e.granularity === void 0 ? 1 : Math.max(e.granularity, 1), a = i + (e.generateBorders ? 2 : 0), o = i + (e.extendToNorthPole || e.generateBorders ? 1 : 0) + (e.extendToSouthPole || e.generateBorders ? 1 : 0), s = a + 1, c = o + 1, l = e.generateBorders ? -1 : 0, u = e.generateBorders || e.extendToNorthPole ? -1 : 0, d = i + (e.generateBorders ? 1 : 0), f = i + (e.generateBorders || e.extendToSouthPole ? 1 : 0), p = s * c, m = a * o * 6, h = s * c > 65536;
				if (h && n === "16bit") throw Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
				let g = h || n === "32bit", _ = new Int16Array(2 * p), v = 0;
				for (let n = u; n <= f; n++) for (let a = l; a <= d; a++) {
					let o = a / i * t.$;
					a === -1 && (o = -on), a === i + 1 && (o = t.$ + on);
					let s = n / i * t.$;
					n === -1 && (s = e.extendToNorthPole ? t.bh : -on), n === i + 1 && (s = e.extendToSouthPole ? t.bi : t.$ + on), _[v++] = o, _[v++] = s;
				}
				let y = g ? new Uint32Array(m) : new Uint16Array(m), b = 0;
				for (let e = 0; e < o; e++) for (let t = 0; t < a; t++) {
					let n = t + 1 + e * s, i = t + (e + 1) * s, a = t + 1 + (e + 1) * s;
					y[b++] = t + e * s, y[b++] = i, y[b++] = n, y[b++] = n, y[b++] = i, y[b++] = a;
				}
				return {
					vertices: _.buffer.slice(0),
					indices: y.buffer.slice(0),
					uses32bitIndices: g
				};
			}
			let ln = new t.aK({
				fill: new t.bj(128, 2),
				line: new t.bj(512, 0),
				tile: new t.bj(128, 32),
				stencil: new t.bj(128, 1),
				circle: 3
			});
			class un {
				constructor() {
					this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
				}
				get name() {
					return "vertical-perspective";
				}
				get transitionState() {
					return 1;
				}
				get useSubdivision() {
					return !0;
				}
				get shaderVariantName() {
					return "globe";
				}
				get shaderDefine() {
					return "#define GLOBE";
				}
				get shaderPreludeCode() {
					return Mt.projectionGlobe;
				}
				get vertexShaderPreludeCode() {
					return Mt.projectionMercator.vertexSource;
				}
				get subdivisionGranularity() {
					return ln;
				}
				get useGlobeControls() {
					return !0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._errorCorrectionUsable;
				}
				destroy() {
					this._errorMeasurement && this._errorMeasurement.destroy();
				}
				updateGPUdependent(e) {
					this._errorMeasurement ||= new an(e);
					let n = t.U(this._errorQueryLatitudeDegrees), i = 2 * Math.atan(Math.exp(Math.PI - n * Math.PI * 2)) - .5 * Math.PI, a = this._errorMeasurement.updateErrorLoop(n, i), o = l();
					a !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = a, this._errorMeasurementLastChangeTime = o);
					let s = Math.min(Math.max((o - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
					this._errorCorrectionUsable = t.bk(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.bl(s));
				}
				_getMeshKey(e) {
					return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`;
				}
				getMeshFromTileID(e, t, n, i, a) {
					let o = (a === "stencil" ? ln.stencil : ln.tile).getGranularityForZoomLevel(t.z);
					return this._getMesh(e, {
						granularity: o,
						generateBorders: n,
						extendToNorthPole: t.y === 0 && i,
						extendToSouthPole: t.y === (1 << t.z) - 1 && i
					});
				}
				_getMesh(e, n) {
					let i = this._getMeshKey(n);
					if (i in this._tileMeshCache) return this._tileMeshCache[i];
					let a = function(e, n) {
						let i = sn(n, "16bit"), a = t.aL.deserialize({
							arrayBuffer: i.vertices,
							length: i.vertices.byteLength / 2 / 2
						}), o = t.aN.deserialize({
							arrayBuffer: i.indices,
							length: i.indices.byteLength / 2 / 3
						});
						return new Pt(e.createVertexBuffer(a, Ft.members), e.createIndexBuffer(o), t.aM.simpleSegment(0, 0, a.length, o.length));
					}(e, n);
					return this._tileMeshCache[i] = a, a;
				}
				recalculate(e) {}
				hasTransition() {
					let e = l(), t = !1;
					return t ||= (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, t ||= this._errorMeasurement && this._errorMeasurement.awaitingQuery, t;
				}
				setErrorQueryLatitudeDegrees(e) {
					this._errorQueryLatitudeDegrees = e;
				}
			}
			let dn = new t.r({ type: new t.D(t.v.projection.type) });
			class fn extends t.E {
				constructor(e) {
					super(), this._transitionable = new t.t(dn, void 0), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.F(0)), this._mercatorProjection = new Rt(), this._verticalPerspectiveProjection = new un();
				}
				get transitionState() {
					let e = this.properties.get("type");
					if (typeof e == "string" && e === "mercator") return 0;
					if (typeof e == "string" && e === "vertical-perspective") return 1;
					if (e instanceof t.bm) {
						if (e.from === "vertical-perspective" && e.to === "mercator") return 1 - e.transition;
						if (e.from === "mercator" && e.to === "vertical-perspective") return e.transition;
					}
					return 1;
				}
				get useGlobeRendering() {
					return this.transitionState > 0;
				}
				get latitudeErrorCorrectionRadians() {
					return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
				}
				get currentProjection() {
					return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
				}
				get name() {
					return "globe";
				}
				get useSubdivision() {
					return this.currentProjection.useSubdivision;
				}
				get shaderVariantName() {
					return this.currentProjection.shaderVariantName;
				}
				get shaderDefine() {
					return this.currentProjection.shaderDefine;
				}
				get shaderPreludeCode() {
					return this.currentProjection.shaderPreludeCode;
				}
				get vertexShaderPreludeCode() {
					return this.currentProjection.vertexShaderPreludeCode;
				}
				get subdivisionGranularity() {
					return this.currentProjection.subdivisionGranularity;
				}
				get useGlobeControls() {
					return this.transitionState > 0;
				}
				destroy() {
					this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
				}
				updateGPUdependent(e) {
					this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e);
				}
				getMeshFromTileID(e, t, n, i, a) {
					return this.currentProjection.getMeshFromTileID(e, t, n, i, a);
				}
				setProjection(e) {
					this._transitionable.setValue("type", e?.type || "mercator");
				}
				updateTransitions(e) {
					this._transitioning = this._transitionable.transitioned(e, this._transitioning);
				}
				hasTransition() {
					return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
				}
				recalculate(e) {
					this.properties = this._transitioning.possiblyEvaluate(e);
				}
				setErrorQueryLatitudeDegrees(e) {
					this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e);
				}
			}
			function pn(e) {
				let t = gn(e.worldSize, e.center.lat);
				return 2 * Math.PI * t;
			}
			function mn(e, n, i, a, o) {
				let s = 1 / (1 << o), c = n / t.$ * s + a * s, l = t.bo((e / t.$ * s + i * s) * Math.PI * 2 + Math.PI, 2 * Math.PI), u = 2 * Math.atan(Math.exp(Math.PI - c * Math.PI * 2)) - .5 * Math.PI, d = Math.cos(u), f = new Float64Array(3);
				return f[0] = Math.sin(l) * d, f[1] = Math.sin(u), f[2] = Math.cos(l) * d, f;
			}
			function hn(e) {
				return function(e, t) {
					let n = Math.cos(t), i = new Float64Array(3);
					return i[0] = Math.sin(e) * n, i[1] = Math.sin(t), i[2] = Math.cos(e) * n, i;
				}(e.lng * Math.PI / 180, e.lat * Math.PI / 180);
			}
			function gn(e, t) {
				return e / (2 * Math.PI) / Math.cos(t * Math.PI / 180);
			}
			function _n(e) {
				let n = Math.asin(e[1]) / Math.PI * 180, i = Math.sqrt(e[0] * e[0] + e[2] * e[2]);
				if (i > 1e-6) {
					let a = e[0] / i, o = Math.acos(e[2] / i), s = (a > 0 ? o : -o) / Math.PI * 180;
					return new t.S(t.aO(s, -180, 180), n);
				}
				return new t.S(0, n);
			}
			function vn(e) {
				return Math.cos(e * Math.PI / 180);
			}
			function yn(e, n) {
				let i = vn(e), a = vn(n);
				return t.ak(a / i);
			}
			function bn(e, n) {
				let i = e.rotate(n.bearingInRadians), a = n.zoom + yn(n.center.lat, 0), o = t.bk(1 / vn(n.center.lat), 1 / vn(Math.min(Math.abs(n.center.lat), 60)), t.bn(a, 7, 3, 0, 1)), s = 360 / pn({
					worldSize: n.worldSize,
					center: { lat: n.center.lat }
				});
				return new t.S(n.center.lng - i.x * s * o, t.ae(n.center.lat + i.y * s, -t.af, t.af));
			}
			function xn(e) {
				let t = .5 * e, n = Math.sin(t), i = Math.cos(t);
				return Math.log(n + i) - Math.log(i - n);
			}
			function Sn(e, n, i, a) {
				let o = e.lat + i * a;
				if (Math.abs(i) > 1) {
					let s = (Math.sign(e.lat + i) === Math.sign(e.lat) ? Math.abs(e.lat) : -Math.abs(e.lat)) * Math.PI / 180, c = Math.abs(e.lat + i) * Math.PI / 180, l = xn(s + a * (c - s)), u = xn(s), d = xn(c);
					return new t.S(e.lng + n * ((l - u) / (d - u)), o);
				}
				return new t.S(e.lng + n * a, o);
			}
			class Cn {
				constructor(e) {
					this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._boundingVolumeFactory = e;
				}
				swapBuffers() {
					if (!this._hadAnyChanges) return;
					let e = this._cachePrevious;
					this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1;
				}
				getTileBoundingVolume(e, t, n, i) {
					let a = `${e.z}_${e.x}_${e.y}_${i?.terrain ? "t" : ""}`, o = this._cache.get(a);
					if (o) return o;
					let s = this._cachePrevious.get(a);
					if (s) return this._cache.set(a, s), s;
					let c = this._boundingVolumeFactory(e, t, n, i);
					return this._cache.set(a, c), this._hadAnyChanges = !0, c;
				}
			}
			class wn {
				constructor(e, t, n, i) {
					this.min = n, this.max = i, this.points = e, this.planes = t;
				}
				static fromAabb(e, t) {
					let n = [];
					for (let i = 0; i < 8; i++) n.push([
						1 & ~i ? e[0] : t[0],
						(i >> 1 & 1) == 1 ? t[1] : e[1],
						(i >> 2 & 1) == 1 ? t[2] : e[2]
					]);
					return new wn(n, [
						[
							-1,
							0,
							0,
							t[0]
						],
						[
							1,
							0,
							0,
							-e[0]
						],
						[
							0,
							-1,
							0,
							t[1]
						],
						[
							0,
							1,
							0,
							-e[1]
						],
						[
							0,
							0,
							-1,
							t[2]
						],
						[
							0,
							0,
							1,
							-e[2]
						]
					], e, t);
				}
				static fromCenterSizeAngles(e, n, i) {
					let a = t.br([], i[0], i[1], i[2]), o = t.bs([], [
						n[0],
						0,
						0
					], a), s = t.bs([], [
						0,
						n[1],
						0
					], a), c = t.bs([], [
						0,
						0,
						n[2]
					], a), l = [...e], u = [...e];
					for (let t = 0; t < 8; t++) for (let n = 0; n < 3; n++) {
						let i = e[n] + o[n] * (1 & ~t ? -1 : 1) + s[n] * ((t >> 1 & 1) == 1 ? 1 : -1) + c[n] * ((t >> 2 & 1) == 1 ? 1 : -1);
						l[n] = Math.min(l[n], i), u[n] = Math.max(u[n], i);
					}
					let d = [];
					for (let n = 0; n < 8; n++) {
						let i = [...e];
						t.aS(i, i, t.aR([], o, 1 & ~n ? -1 : 1)), t.aS(i, i, t.aR([], s, (n >> 1 & 1) == 1 ? 1 : -1)), t.aS(i, i, t.aR([], c, (n >> 2 & 1) == 1 ? 1 : -1)), d.push(i);
					}
					return new wn(d, [
						[...o, -t.aX(o, d[0])],
						[...s, -t.aX(s, d[0])],
						[...c, -t.aX(c, d[0])],
						[
							-o[0],
							-o[1],
							-o[2],
							-t.aX(o, d[7])
						],
						[
							-s[0],
							-s[1],
							-s[2],
							-t.aX(s, d[7])
						],
						[
							-c[0],
							-c[1],
							-c[2],
							-t.aX(c, d[7])
						]
					], l, u);
				}
				intersectsFrustum(e) {
					let t = !0, n = this.points.length, i = this.planes.length, a = e.planes.length, o = e.points.length;
					for (let i = 0; i < a; i++) {
						let a = e.planes[i], o = 0;
						for (let e = 0; e < n; e++) {
							let t = this.points[e];
							a[0] * t[0] + a[1] * t[1] + a[2] * t[2] + a[3] >= 0 && o++;
						}
						if (o === 0) return 0;
						o < n && (t = !1);
					}
					if (t) return 2;
					for (let t = 0; t < i; t++) {
						let n = this.planes[t], i = 0;
						for (let t = 0; t < o; t++) {
							let a = e.points[t];
							n[0] * a[0] + n[1] * a[1] + n[2] * a[2] + n[3] >= 0 && i++;
						}
						if (i === 0) return 0;
					}
					return 1;
				}
				intersectsPlane(e) {
					let t = this.points.length, n = 0;
					for (let i = 0; i < t; i++) {
						let t = this.points[i];
						e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] >= 0 && n++;
					}
					return n === t ? 2 : n === 0 ? 0 : 1;
				}
			}
			function Tn(e, t, n) {
				let i = e - t;
				return i < 0 ? -i : Math.max(0, i - n);
			}
			function En(e, t, n, i, a) {
				let o = e - n, s;
				return s = o < 0 ? Math.min(-o, 1 + o - a) : o > 1 ? Math.min(Math.max(o - a, 0), 1 - o) : 0, Math.max(s, Tn(t, i, a));
			}
			class Dn {
				constructor() {
					this._boundingVolumeCache = new Cn(this._computeTileBoundingVolume);
				}
				prepareNextFrame() {
					this._boundingVolumeCache.swapBuffers();
				}
				distanceToTile2d(e, t, n, i) {
					let a = 1 << n.z, o = 1 / a, s = n.x / a, c = n.y / a, l = 2;
					return l = Math.min(l, En(e, t, s, c, o)), l = Math.min(l, En(e, t, s + .5, -c - o, o)), l = Math.min(l, En(e, t, s + .5, 2 - c - o, o)), l;
				}
				getWrap(e, t, n) {
					let i = 1 << t.z, a = 1 / i, o = t.x / i, s = Tn(e.x, o, a), c = Tn(e.x, o - 1, a), l = Tn(e.x, o + 1, a), u = Math.min(s, c, l);
					return u === l ? 1 : u === c ? -1 : 0;
				}
				allowVariableZoom(e, t) {
					return Fe(e, t) > 4;
				}
				allowWorldCopies() {
					return !1;
				}
				getTileBoundingVolume(e, t, n, i) {
					return this._boundingVolumeCache.getTileBoundingVolume(e, t, n, i);
				}
				_computeTileBoundingVolume(e, n, i, a) {
					let o = 0, s = 0;
					if (a?.terrain) {
						let c = new t.Z(e.z, n, e.z, e.x, e.y), l = a.terrain.getMinMaxElevation(c);
						o = l.minElevation ?? Math.min(0, i), s = l.maxElevation ?? Math.max(0, i);
					}
					if (o /= t.bu, s /= t.bu, o += 1, s += 1, e.z <= 0) return wn.fromAabb([
						-s,
						-s,
						-s
					], [
						s,
						s,
						s
					]);
					if (e.z === 1) return wn.fromAabb([
						e.x === 0 ? -s : 0,
						e.y === 0 ? 0 : -s,
						-s
					], [
						e.x === 0 ? 0 : s,
						e.y === 0 ? s : 0,
						s
					]);
					{
						let n = [
							mn(0, 0, e.x, e.y, e.z),
							mn(t.$, 0, e.x, e.y, e.z),
							mn(t.$, t.$, e.x, e.y, e.z),
							mn(0, t.$, e.x, e.y, e.z)
						], i = [];
						for (let e of n) i.push(t.aR([], e, s));
						if (s !== o) for (let e of n) i.push(t.aR([], e, o));
						e.y === 0 && i.push([
							0,
							1,
							0
						]), e.y === (1 << e.z) - 1 && i.push([
							0,
							-1,
							0
						]);
						let a = [
							1,
							1,
							1
						], c = [
							-1,
							-1,
							-1
						];
						for (let e of i) for (let t = 0; t < 3; t++) a[t] = Math.min(a[t], e[t]), c[t] = Math.max(c[t], e[t]);
						let l = mn(t.$ / 2, t.$ / 2, e.x, e.y, e.z), u = t.aW([], [
							0,
							1,
							0
						], l);
						t.aV(u, u);
						let d = t.aW([], l, u);
						t.aV(d, d);
						let f = t.aW([], n[2], n[1]);
						t.aV(f, f);
						let p = t.aW([], n[0], n[3]);
						t.aV(p, p), i.push(t.aR([], l, s)), e.y >= (1 << e.z) / 2 && i.push(t.aR([], mn(t.$ / 2, 0, e.x, e.y, e.z), s)), e.y < (1 << e.z) / 2 && i.push(t.aR([], mn(t.$ / 2, t.$, e.x, e.y, e.z), s));
						let m = On(l, i), h = On(d, i), g = [
							-l[0],
							-l[1],
							-l[2],
							m.max
						], _ = [
							l[0],
							l[1],
							l[2],
							-m.min
						], v = [
							-d[0],
							-d[1],
							-d[2],
							h.max
						], y = [
							d[0],
							d[1],
							d[2],
							-h.min
						], b = [...f, 0], x = [...p, 0], S = [];
						return e.y === 0 ? S.push(t.bt(x, b, g), t.bt(x, b, _)) : S.push(t.bt(v, b, g), t.bt(v, b, _), t.bt(v, x, g), t.bt(v, x, _)), e.y === (1 << e.z) - 1 ? S.push(t.bt(x, b, g), t.bt(x, b, _)) : S.push(t.bt(y, b, g), t.bt(y, b, _), t.bt(y, x, g), t.bt(y, x, _)), new wn(S, [
							g,
							_,
							v,
							y,
							b,
							x
						], a, c);
					}
				}
			}
			function On(e, n) {
				let i = Infinity, a = -Infinity;
				for (let o of n) {
					let n = t.aX(e, o);
					i = Math.min(i, n), a = Math.max(a, n);
				}
				return {
					min: i,
					max: a
				};
			}
			class kn {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e) {
					this._helper.setMinZoom(e);
				}
				setMaxZoom(e) {
					this._helper.setMaxZoom(e);
				}
				setMinPitch(e) {
					this._helper.setMinPitch(e);
				}
				setMaxPitch(e) {
					this._helper.setMaxPitch(e);
				}
				setRenderWorldCopies(e) {
					this._helper.setRenderWorldCopies(e);
				}
				setBearing(e) {
					this._helper.setBearing(e);
				}
				setPitch(e) {
					this._helper.setPitch(e);
				}
				setRoll(e) {
					this._helper.setRoll(e);
				}
				setFov(e) {
					this._helper.setFov(e);
				}
				setZoom(e) {
					this._helper.setZoom(e);
				}
				setCenter(e) {
					this._helper.setCenter(e);
				}
				setElevation(e) {
					this._helper.setElevation(e);
				}
				setMinElevationForCurrentTile(e) {
					this._helper.setMinElevationForCurrentTile(e);
				}
				setPadding(e) {
					this._helper.setPadding(e);
				}
				interpolatePadding(e, t, n) {
					return this._helper.interpolatePadding(e, t, n);
				}
				isPaddingEqual(e) {
					return this._helper.isPaddingEqual(e);
				}
				resize(e, t) {
					this._helper.resize(e, t);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e) {
					this._helper.setMaxBounds(e);
				}
				setConstrain(e) {
					this._helper.setConstrain(e);
				}
				overrideNearFarZ(e, t) {
					this._helper.overrideNearFarZ(e, t);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get constrain() {
					return this._helper.constrain;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				setTransitionState(e) {}
				constructor(e) {
					this._cachedClippingPlane = t.bv(), this._projectionMatrix = t.b9(), this._globeViewProjMatrix32f = t.b8(), this._globeViewProjMatrixNoCorrection = t.b9(), this._globeViewProjMatrixNoCorrectionInverted = t.b9(), this._globeProjMatrixInverted = t.b9(), this._cameraPosition = t.bp(), this._globeLatitudeErrorCorrectionRadians = 0, this.defaultConstrain = (e, n) => {
						let i = t.ae(e.lat, -t.af, t.af), a = t.ae(+n, this.minZoom + yn(0, i), this.maxZoom);
						return {
							center: new t.S(e.lng, i),
							zoom: a
						};
					}, this._helper = new Ht({
						calcMatrices: () => {
							this._calcMatrices();
						},
						constrain: (e, t) => this.defaultConstrain(e, t)
					}, e), this._coveringTilesDetailsProvider = new Dn();
				}
				clone() {
					let e = new kn();
					return e.apply(this), e;
				}
				apply(e, t) {
					this._globeLatitudeErrorCorrectionRadians = t || 0, this._helper.apply(e);
				}
				get projectionMatrix() {
					return this._projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this._globeViewProjMatrixNoCorrection;
				}
				get inverseProjectionMatrix() {
					return this._globeProjMatrixInverted;
				}
				get cameraPosition() {
					let e = t.bp();
					return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				getProjectionData(e) {
					let { overscaledTileID: t, applyGlobeMatrix: n } = e, i = this._helper.getMercatorTileCoordinates(t);
					return {
						mainMatrix: this._globeViewProjMatrix32f,
						tileMercatorCoords: i,
						clippingPlane: this._cachedClippingPlane,
						projectionTransition: n ? 1 : 0,
						fallbackMatrix: this._globeViewProjMatrix32f
					};
				}
				_computeClippingPlane(e) {
					let n = this.pitchInRadians, i = this.cameraToCenterDistance / e, a = Math.sin(n) * i, o = Math.cos(n) * i + 1, s = 1 / Math.sqrt(a * a + o * o) * 1, c = -a, l = o, u = Math.sqrt(c * c + l * l);
					c /= u, l /= u;
					let d = [
						0,
						c,
						l
					];
					t.bw(d, d, [
						0,
						0,
						0
					], -this.bearingInRadians), t.bx(d, d, [
						0,
						0,
						0
					], -1 * this.center.lat * Math.PI / 180), t.by(d, d, [
						0,
						0,
						0
					], this.center.lng * Math.PI / 180);
					let f = 1 / t.aZ(d);
					return t.aR(d, d, f), [...d, -s * f];
				}
				isLocationOccluded(e) {
					return !this.isSurfacePointVisible(hn(e));
				}
				transformLightDirection(e) {
					let n = this._helper._center.lng * Math.PI / 180, i = this._helper._center.lat * Math.PI / 180, a = Math.cos(i), o = [
						Math.sin(n) * a,
						Math.sin(i),
						Math.cos(n) * a
					], s = [
						o[2],
						0,
						-o[0]
					], c = [
						0,
						0,
						0
					];
					t.aW(c, s, o), t.aV(s, s), t.aV(c, c);
					let l = [
						0,
						0,
						0
					];
					return t.aV(l, [
						s[0] * e[0] + c[0] * e[1] + o[0] * e[2],
						s[1] * e[0] + c[1] * e[1] + o[1] * e[2],
						s[2] * e[0] + c[2] * e[1] + o[2] * e[2]
					]), l;
				}
				getPixelScale() {
					return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getCircleRadiusCorrection() {
					return Math.cos(this._helper._center.lat * Math.PI / 180);
				}
				getPitchedTextCorrection(e, n, i) {
					let a = function(e, n, i) {
						let a = 1 / (1 << i.z);
						return new t.a1(e / t.$ * a + i.x * a, n / t.$ * a + i.y * a);
					}(e, n, i.canonical), o = (s = a.y, [t.bo(a.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s * Math.PI * 2)) - .5 * Math.PI]);
					var s;
					return this.getCircleRadiusCorrection() / Math.cos(o[1]);
				}
				projectTileCoordinates(e, n, i, a) {
					let o = i.canonical, s = mn(e, n, o.x, o.y, o.z), c = 1 + (a ? a(e, n) : 0) / t.bu, l = [
						s[0] * c,
						s[1] * c,
						s[2] * c,
						1
					];
					t.aw(l, l, this._globeViewProjMatrixNoCorrection);
					let u = this._cachedClippingPlane, d = u[0] * s[0] + u[1] * s[1] + u[2] * s[2] + u[3] < 0;
					return {
						point: new t.P(l[0] / l[3], l[1] / l[3]),
						signedDistanceFromCamera: l[3],
						isOccluded: d
					};
				}
				_calcMatrices() {
					if (!this._helper._width || !this._helper._height) return;
					let e = gn(this.worldSize, this.center.lat), n = t.ba(), i = t.ba();
					this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), t.b4(n, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
					let a = this.centerOffset;
					n[8] = 2 * -a.x / this._helper._width, n[9] = 2 * a.y / this._helper._height, this._projectionMatrix = t.b5(n), this._globeProjMatrixInverted = t.ba(), t.aq(this._globeProjMatrixInverted, n), t.M(n, n, [
						0,
						0,
						-this.cameraToCenterDistance
					]), t.b6(n, n, this.rollInRadians), t.b7(n, n, -this.pitchInRadians), t.b6(n, n, this.bearingInRadians), t.M(n, n, [
						0,
						0,
						-e
					]);
					let o = t.bp();
					o[0] = e, o[1] = e, o[2] = e, t.b7(i, n, this.center.lat * Math.PI / 180), t.bz(i, i, -this.center.lng * Math.PI / 180), t.N(i, i, o), this._globeViewProjMatrixNoCorrection = i, t.b7(n, n, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bz(n, n, -this.center.lng * Math.PI / 180), t.N(n, n, o), this._globeViewProjMatrix32f = new Float32Array(n), this._globeViewProjMatrixNoCorrectionInverted = t.ba(), t.aq(this._globeViewProjMatrixNoCorrectionInverted, i);
					let s = t.bp();
					this._cameraPosition = t.bp(), this._cameraPosition[2] = this.cameraToCenterDistance / e, t.bw(this._cameraPosition, this._cameraPosition, s, -this.rollInRadians), t.bx(this._cameraPosition, this._cameraPosition, s, this.pitchInRadians), t.bw(this._cameraPosition, this._cameraPosition, s, -this.bearingInRadians), t.aS(this._cameraPosition, this._cameraPosition, [
						0,
						0,
						1
					]), t.bx(this._cameraPosition, this._cameraPosition, s, -this.center.lat * Math.PI / 180), t.by(this._cameraPosition, this._cameraPosition, s, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e);
					let c = t.b5(this._globeViewProjMatrixNoCorrectionInverted);
					t.N(c, c, [
						1,
						1,
						-1
					]), this._cachedFrustum = Gt.fromInvProjectionMatrix(c, 1, 0, this._cachedClippingPlane, !0);
				}
				calculateFogMatrix(e) {
					t.w("calculateFogMatrix is not supported on globe projection.");
					let n = t.ba();
					return t.ai(n), n;
				}
				getVisibleUnwrappedCoordinates(e) {
					return [new t.b2(0, e)];
				}
				getCameraFrustum() {
					return this._cachedFrustum;
				}
				getClippingPlane() {
					return this._cachedClippingPlane;
				}
				getCoveringTilesDetailsProvider() {
					return this._coveringTilesDetailsProvider;
				}
				recalculateZoomAndCenter(e) {
					e && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
				}
				maxPitchScaleFactor() {
					return 1;
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e, n) {
					if (!this._globeViewProjMatrixNoCorrection) return 1;
					let i = hn(e);
					t.aR(i, i, 1 + n / t.bu);
					let a = t.bv();
					return t.aw(a, [
						i[0],
						i[1],
						i[2],
						1
					], this._globeViewProjMatrixNoCorrection), a[2] / a[3];
				}
				populateCache(e) {}
				getBounds() {
					let e = .5 * this.width, n = .5 * this.height, i = [
						new t.P(0, 0),
						new t.P(e, 0),
						new t.P(this.width, 0),
						new t.P(this.width, n),
						new t.P(this.width, this.height),
						new t.P(e, this.height),
						new t.P(0, this.height),
						new t.P(0, n)
					], a = [];
					for (let e of i) a.push(this.unprojectScreenPoint(e));
					let o = 0, s = 0, c = 0, l = 0, u = this.center;
					for (let e of a) {
						let n = t.bA(u.lng, e.lng), i = t.bA(u.lat, e.lat);
						n < s && (s = n), n > o && (o = n), i < l && (l = i), i > c && (c = i);
					}
					let d = [
						u.lng + s,
						u.lat + l,
						u.lng + o,
						u.lat + c
					];
					return this.isSurfacePointOnScreen([
						0,
						1,
						0
					]) && (d[3] = 90, d[0] = -180, d[2] = 180), this.isSurfacePointOnScreen([
						0,
						-1,
						0
					]) && (d[1] = -90, d[0] = -180, d[2] = 180), new ce(d);
				}
				calculateCenterFromCameraLngLatAlt(e, t, n, i) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e, t, n, i);
				}
				setLocationAtPoint(e, n) {
					let i = hn(this.unprojectScreenPoint(n)), a = hn(e), o = t.bp();
					t.bB(o);
					let s = t.bp();
					t.by(s, i, o, -this.center.lng * Math.PI / 180), t.bx(s, s, o, this.center.lat * Math.PI / 180);
					let c = a[0] * a[0] + a[2] * a[2], l = s[0] * s[0];
					if (c < l) return;
					let u = Math.sqrt(c - l), d = -u, f = t.bC(a[0], a[2], s[0], u), p = t.bC(a[0], a[2], s[0], d), m = t.bp();
					t.by(m, a, o, -f);
					let h = t.bC(m[1], m[2], s[1], s[2]), g = t.bp();
					t.by(g, a, o, -p);
					let _ = t.bC(g[1], g[2], s[1], s[2]), v = .5 * Math.PI, y = h >= -v && h <= v, b = _ >= -v && _ <= v, x, S;
					if (y && b) {
						let e = this.center.lng * Math.PI / 180, n = this.center.lat * Math.PI / 180;
						t.bD(f, e) + t.bD(h, n) < t.bD(p, e) + t.bD(_, n) ? (x = f, S = h) : (x = p, S = _);
					} else if (y) x = f, S = h;
					else {
						if (!b) return;
						x = p, S = _;
					}
					let C = x / Math.PI * 180, w = S / Math.PI * 180, T = this.center.lat;
					this.setCenter(new t.S(C, t.ae(w, -90, 90))), this.setZoom(this.zoom + yn(T, this.center.lat));
				}
				locationToScreenPoint(e, n) {
					let i = hn(e);
					if (n) {
						let a = n.getElevationForLngLatZoom(e, this._helper._tileZoom);
						t.aR(i, i, 1 + a / t.bu);
					}
					return this._projectSurfacePointToScreen(i);
				}
				_projectSurfacePointToScreen(e) {
					let n = t.bv();
					return t.aw(n, [...e, 1], this._globeViewProjMatrixNoCorrection), n[0] /= n[3], n[1] /= n[3], new t.P((.5 * n[0] + .5) * this.width, (.5 * -n[1] + .5) * this.height);
				}
				screenPointToMercatorCoordinate(e, n) {
					if (n) {
						let t = n.pointCoordinate(e);
						if (t) return t;
					}
					return t.a1.fromLngLat(this.unprojectScreenPoint(e));
				}
				screenPointToLocation(e, t) {
					return this.screenPointToMercatorCoordinate(e, t)?.toLngLat();
				}
				isPointOnMapSurface(e, t) {
					let n = this._cameraPosition, i = this.getRayDirectionFromPixel(e);
					return !!this.rayPlanetIntersection(n, i);
				}
				getRayDirectionFromPixel(e) {
					let n = t.bv();
					n[0] = e.x / this.width * 2 - 1, n[1] = -1 * (e.y / this.height * 2 - 1), n[2] = 1, n[3] = 1, t.aw(n, n, this._globeViewProjMatrixNoCorrectionInverted), n[0] /= n[3], n[1] /= n[3], n[2] /= n[3];
					let i = t.bp();
					i[0] = n[0] - this._cameraPosition[0], i[1] = n[1] - this._cameraPosition[1], i[2] = n[2] - this._cameraPosition[2];
					let a = t.bp();
					return t.aV(a, i), a;
				}
				isSurfacePointVisible(e) {
					let t = this._cachedClippingPlane;
					return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] >= 0;
				}
				isSurfacePointOnScreen(e) {
					if (!this.isSurfacePointVisible(e)) return !1;
					let n = t.bv();
					return t.aw(n, [...e, 1], this._globeViewProjMatrixNoCorrection), n[0] /= n[3], n[1] /= n[3], n[2] /= n[3], n[0] > -1 && n[0] < 1 && n[1] > -1 && n[1] < 1 && n[2] > -1 && n[2] < 1;
				}
				rayPlanetIntersection(e, n) {
					let i = t.aX(e, n), a = t.bp(), o = t.bp();
					t.aR(o, n, i), t.aU(a, e, o);
					let s = 1 - t.aX(a, a);
					if (s < 0) return null;
					let c = t.aX(e, e) - 1, l = -i + (i < 0 ? 1 : -1) * Math.sqrt(s), u = c / l, d = l;
					return {
						tMin: Math.min(u, d),
						tMax: Math.max(u, d)
					};
				}
				unprojectScreenPoint(e) {
					let n = this._cameraPosition, i = this.getRayDirectionFromPixel(e), a = this.rayPlanetIntersection(n, i);
					if (a) {
						let e = t.bp();
						t.aS(e, n, [
							i[0] * a.tMin,
							i[1] * a.tMin,
							i[2] * a.tMin
						]);
						let o = t.bp();
						return t.aV(o, e), _n(o);
					}
					let o = this._cachedClippingPlane, s = o[0] * i[0] + o[1] * i[1] + o[2] * i[2], c = -t.b1(o, n) / s, l = t.bp();
					if (c > 0) t.aS(l, n, [
						i[0] * c,
						i[1] * c,
						i[2] * c
					]);
					else {
						let e = t.bp();
						t.aS(e, n, [
							2 * i[0],
							2 * i[1],
							2 * i[2]
						]);
						let a = t.b1(this._cachedClippingPlane, e);
						t.aU(l, e, [
							this._cachedClippingPlane[0] * a,
							this._cachedClippingPlane[1] * a,
							this._cachedClippingPlane[2] * a
						]);
					}
					let u = function(e) {
						let n = t.bp();
						return n[0] = e[0] * -e[3], n[1] = e[1] * -e[3], n[2] = e[2] * -e[3], {
							center: n,
							radius: Math.sqrt(1 - e[3] * e[3])
						};
					}(o);
					return _n(function(e, n, i) {
						let a = t.bp();
						t.aU(a, i, e);
						let o = t.bp();
						return t.bq(o, e, a, n / t.a$(a)), o;
					}(u.center, u.radius, l));
				}
				getMatrixForModel(e, n) {
					let i = t.S.convert(e), a = 1 / t.bu, o = t.b9();
					return t.bz(o, o, i.lng / 180 * Math.PI), t.b7(o, o, -i.lat / 180 * Math.PI), t.M(o, o, [
						0,
						0,
						1 + n / t.bu
					]), t.b7(o, o, .5 * Math.PI), t.N(o, o, [
						a,
						a,
						a
					]), o;
				}
				getProjectionDataForCustomLayer(e = !0) {
					let n = this.getProjectionData({
						overscaledTileID: new t.Z(0, 0, 0, 0, 0),
						applyGlobeMatrix: e
					});
					return n.tileMercatorCoords = [
						0,
						0,
						1,
						1
					], n;
				}
				getFastPathSimpleProjectionMatrix(e) {}
			}
			class An {
				get pixelsToClipSpaceMatrix() {
					return this._helper.pixelsToClipSpaceMatrix;
				}
				get clipSpaceToPixelsMatrix() {
					return this._helper.clipSpaceToPixelsMatrix;
				}
				get pixelsToGLUnits() {
					return this._helper.pixelsToGLUnits;
				}
				get centerOffset() {
					return this._helper.centerOffset;
				}
				get size() {
					return this._helper.size;
				}
				get rotationMatrix() {
					return this._helper.rotationMatrix;
				}
				get centerPoint() {
					return this._helper.centerPoint;
				}
				get pixelsPerMeter() {
					return this._helper.pixelsPerMeter;
				}
				setMinZoom(e) {
					this._helper.setMinZoom(e);
				}
				setMaxZoom(e) {
					this._helper.setMaxZoom(e);
				}
				setMinPitch(e) {
					this._helper.setMinPitch(e);
				}
				setMaxPitch(e) {
					this._helper.setMaxPitch(e);
				}
				setRenderWorldCopies(e) {
					this._helper.setRenderWorldCopies(e);
				}
				setBearing(e) {
					this._helper.setBearing(e);
				}
				setPitch(e) {
					this._helper.setPitch(e);
				}
				setRoll(e) {
					this._helper.setRoll(e);
				}
				setFov(e) {
					this._helper.setFov(e);
				}
				setZoom(e) {
					this._helper.setZoom(e);
				}
				setCenter(e) {
					this._helper.setCenter(e);
				}
				setElevation(e) {
					this._helper.setElevation(e);
				}
				setMinElevationForCurrentTile(e) {
					this._helper.setMinElevationForCurrentTile(e);
				}
				setPadding(e) {
					this._helper.setPadding(e);
				}
				interpolatePadding(e, t, n) {
					return this._helper.interpolatePadding(e, t, n);
				}
				isPaddingEqual(e) {
					return this._helper.isPaddingEqual(e);
				}
				resize(e, t, n = !0) {
					this._helper.resize(e, t, n);
				}
				getMaxBounds() {
					return this._helper.getMaxBounds();
				}
				setMaxBounds(e) {
					this._helper.setMaxBounds(e);
				}
				setConstrain(e) {
					this._helper.setConstrain(e);
				}
				overrideNearFarZ(e, t) {
					this._helper.overrideNearFarZ(e, t);
				}
				clearNearFarZOverride() {
					this._helper.clearNearFarZOverride();
				}
				getCameraQueryGeometry(e) {
					return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e);
				}
				get tileSize() {
					return this._helper.tileSize;
				}
				get tileZoom() {
					return this._helper.tileZoom;
				}
				get scale() {
					return this._helper.scale;
				}
				get worldSize() {
					return this._helper.worldSize;
				}
				get width() {
					return this._helper.width;
				}
				get height() {
					return this._helper.height;
				}
				get lngRange() {
					return this._helper.lngRange;
				}
				get latRange() {
					return this._helper.latRange;
				}
				get minZoom() {
					return this._helper.minZoom;
				}
				get maxZoom() {
					return this._helper.maxZoom;
				}
				get zoom() {
					return this._helper.zoom;
				}
				get center() {
					return this._helper.center;
				}
				get minPitch() {
					return this._helper.minPitch;
				}
				get maxPitch() {
					return this._helper.maxPitch;
				}
				get pitch() {
					return this._helper.pitch;
				}
				get pitchInRadians() {
					return this._helper.pitchInRadians;
				}
				get roll() {
					return this._helper.roll;
				}
				get rollInRadians() {
					return this._helper.rollInRadians;
				}
				get bearing() {
					return this._helper.bearing;
				}
				get bearingInRadians() {
					return this._helper.bearingInRadians;
				}
				get fov() {
					return this._helper.fov;
				}
				get fovInRadians() {
					return this._helper.fovInRadians;
				}
				get elevation() {
					return this._helper.elevation;
				}
				get minElevationForCurrentTile() {
					return this._helper.minElevationForCurrentTile;
				}
				get padding() {
					return this._helper.padding;
				}
				get unmodified() {
					return this._helper.unmodified;
				}
				get renderWorldCopies() {
					return this._helper.renderWorldCopies;
				}
				get cameraToCenterDistance() {
					return this._helper.cameraToCenterDistance;
				}
				get constrain() {
					return this._helper.constrain;
				}
				get nearZ() {
					return this._helper.nearZ;
				}
				get farZ() {
					return this._helper.farZ;
				}
				get autoCalculateNearFarZ() {
					return this._helper.autoCalculateNearFarZ;
				}
				get isGlobeRendering() {
					return this._globeness > 0;
				}
				setTransitionState(e, t) {
					this._globeness = e, this._globeLatitudeErrorCorrectionRadians = t, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().prepareNextFrame(), this._mercatorTransform.getCoveringTilesDetailsProvider().prepareNextFrame();
				}
				get currentTransform() {
					return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
				}
				constructor(e) {
					this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this.defaultConstrain = (e, t) => this.currentTransform.defaultConstrain(e, t), this._helper = new Ht({
						calcMatrices: () => {
							this._calcMatrices();
						},
						constrain: (e, t) => this.defaultConstrain(e, t)
					}, e), this._globeness = 1, this._mercatorTransform = new Kt(), this._verticalPerspectiveTransform = new kn();
				}
				clone() {
					let e = new An();
					return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e;
				}
				apply(e) {
					this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
				}
				get projectionMatrix() {
					return this.currentTransform.projectionMatrix;
				}
				get modelViewProjectionMatrix() {
					return this.currentTransform.modelViewProjectionMatrix;
				}
				get inverseProjectionMatrix() {
					return this.currentTransform.inverseProjectionMatrix;
				}
				get cameraPosition() {
					return this.currentTransform.cameraPosition;
				}
				getProjectionData(e) {
					let t = this._mercatorTransform.getProjectionData(e), n = this._verticalPerspectiveTransform.getProjectionData(e);
					return {
						mainMatrix: this.isGlobeRendering ? n.mainMatrix : t.mainMatrix,
						clippingPlane: n.clippingPlane,
						tileMercatorCoords: n.tileMercatorCoords,
						projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
						fallbackMatrix: t.fallbackMatrix
					};
				}
				isLocationOccluded(e) {
					return this.currentTransform.isLocationOccluded(e);
				}
				transformLightDirection(e) {
					return this.currentTransform.transformLightDirection(e);
				}
				getPixelScale() {
					return t.bk(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
				}
				getCircleRadiusCorrection() {
					return t.bk(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
				}
				getPitchedTextCorrection(e, n, i) {
					let a = this._mercatorTransform.getPitchedTextCorrection(e, n, i), o = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, n, i);
					return t.bk(a, o, this._globeness);
				}
				projectTileCoordinates(e, t, n, i) {
					return this.currentTransform.projectTileCoordinates(e, t, n, i);
				}
				_calcMatrices() {
					this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
				}
				calculateFogMatrix(e) {
					return this.currentTransform.calculateFogMatrix(e);
				}
				getVisibleUnwrappedCoordinates(e) {
					return this.currentTransform.getVisibleUnwrappedCoordinates(e);
				}
				getCameraFrustum() {
					return this.currentTransform.getCameraFrustum();
				}
				getClippingPlane() {
					return this.currentTransform.getClippingPlane();
				}
				getCoveringTilesDetailsProvider() {
					return this.currentTransform.getCoveringTilesDetailsProvider();
				}
				recalculateZoomAndCenter(e) {
					this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e);
				}
				maxPitchScaleFactor() {
					return this._mercatorTransform.maxPitchScaleFactor();
				}
				getCameraPoint() {
					return this._helper.getCameraPoint();
				}
				getCameraAltitude() {
					return this._helper.getCameraAltitude();
				}
				getCameraLngLat() {
					return this._helper.getCameraLngLat();
				}
				lngLatToCameraDepth(e, t) {
					return this.currentTransform.lngLatToCameraDepth(e, t);
				}
				populateCache(e) {
					this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e);
				}
				getBounds() {
					return this.currentTransform.getBounds();
				}
				calculateCenterFromCameraLngLatAlt(e, t, n, i) {
					return this._helper.calculateCenterFromCameraLngLatAlt(e, t, n, i);
				}
				setLocationAtPoint(e, t) {
					if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, t), void this.apply(this._mercatorTransform);
					this._verticalPerspectiveTransform.setLocationAtPoint(e, t), this.apply(this._verticalPerspectiveTransform);
				}
				locationToScreenPoint(e, t) {
					return this.currentTransform.locationToScreenPoint(e, t);
				}
				screenPointToMercatorCoordinate(e, t) {
					return this.currentTransform.screenPointToMercatorCoordinate(e, t);
				}
				screenPointToLocation(e, t) {
					return this.currentTransform.screenPointToLocation(e, t);
				}
				isPointOnMapSurface(e, t) {
					return this.currentTransform.isPointOnMapSurface(e, t);
				}
				getRayDirectionFromPixel(e) {
					return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e);
				}
				getMatrixForModel(e, t) {
					return this.currentTransform.getMatrixForModel(e, t);
				}
				getProjectionDataForCustomLayer(e = !0) {
					let t = this._mercatorTransform.getProjectionDataForCustomLayer(e);
					if (!this.isGlobeRendering) return t;
					let n = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
					return n.fallbackMatrix = t.mainMatrix, n;
				}
				getFastPathSimpleProjectionMatrix(e) {
					return this.currentTransform.getFastPathSimpleProjectionMatrix(e);
				}
			}
			class jn {
				get useGlobeControls() {
					return !0;
				}
				handlePanInertia(e, n) {
					let i = bn(e, n);
					return Math.abs(i.lng - n.center.lng) > 180 && (i.lng = n.center.lng + 179.5 * Math.sign(i.lng - n.center.lng)), {
						easingCenter: i,
						easingOffset: new t.P(0, 0)
					};
				}
				handleMapControlsRollPitchBearingZoom(e, n) {
					let i = e.around, a = n.screenPointToLocation(i);
					e.bearingDelta && n.setBearing(n.bearing + e.bearingDelta), e.pitchDelta && n.setPitch(n.pitch + e.pitchDelta), e.rollDelta && n.setRoll(n.roll + e.rollDelta);
					let o = n.zoom;
					e.zoomDelta && n.setZoom(n.zoom + e.zoomDelta);
					let s = n.zoom - o;
					if (s === 0) return;
					let c = t.bA(n.center.lng, a.lng), l = c / (Math.abs(c / 180) + 1), u = t.bA(n.center.lat, a.lat), d = n.getRayDirectionFromPixel(i), f = n.cameraPosition, p = -1 * t.aX(f, d), m = t.bp();
					t.aS(m, f, [
						d[0] * p,
						d[1] * p,
						d[2] * p
					]);
					let h = t.aZ(m) - 1, g = Math.exp(.5 * -Math.max(h - .3, 0)), _ = gn(n.worldSize, n.center.lat) / Math.min(n.width, n.height), v = t.bn(_, .9, .5, 1, .25), y = (1 - t.ah(-s)) * Math.min(g, v), b = n.center.lat, x = n.zoom, S = new t.S(n.center.lng + l * y, t.ae(n.center.lat + u * y, -t.af, t.af));
					n.setLocationAtPoint(a, i);
					let C = n.center, w = t.bn(Math.abs(c), 45, 85, 0, 1), T = t.bn(_, .75, .35, 0, 1), E = Math.max(w, T) ** .25, O = t.bA(C.lng, S.lng), k = t.bA(C.lat, S.lat);
					n.setCenter(new t.S(C.lng + O * E, C.lat + k * E).wrap()), n.setZoom(x + yn(b, n.center.lat));
				}
				handleMapControlsPan(e, t, n) {
					if (!e.panDelta) return;
					let i = t.center.lat, a = t.zoom;
					t.setCenter(bn(e.panDelta, t).wrap()), t.setZoom(a + yn(i, t.center.lat));
				}
				cameraForBoxAndBearing(e, n, i, a, o) {
					let s = Yt(e, n, i, a, o), c = n.left / o.width * 2 - 1, l = (o.width - n.right) / o.width * 2 - 1, u = n.top / o.height * -2 + 1, d = (o.height - n.bottom) / o.height * -2 + 1, f = t.bA(i.getWest(), i.getEast()) < 0, p = f ? i.getEast() : i.getWest(), m = f ? i.getWest() : i.getEast(), h = Math.max(i.getNorth(), i.getSouth()), g = Math.min(i.getNorth(), i.getSouth()), _ = p + .5 * t.bA(p, m), v = h + .5 * t.bA(h, g), y = o.clone();
					y.setCenter(s.center), y.setBearing(s.bearing), y.setPitch(0), y.setRoll(0), y.setZoom(s.zoom);
					let b = y.modelViewProjectionMatrix, x = [
						hn(i.getNorthWest()),
						hn(i.getNorthEast()),
						hn(i.getSouthWest()),
						hn(i.getSouthEast()),
						hn(new t.S(m, v)),
						hn(new t.S(p, v)),
						hn(new t.S(_, h)),
						hn(new t.S(_, g))
					], S = hn(s.center), C = Infinity;
					for (let e of x) c < 0 && (C = jn.getLesserNonNegativeNonNull(C, jn.solveVectorScale(e, S, b, "x", c))), l > 0 && (C = jn.getLesserNonNegativeNonNull(C, jn.solveVectorScale(e, S, b, "x", l))), u > 0 && (C = jn.getLesserNonNegativeNonNull(C, jn.solveVectorScale(e, S, b, "y", u))), d < 0 && (C = jn.getLesserNonNegativeNonNull(C, jn.solveVectorScale(e, S, b, "y", d)));
					if (Number.isFinite(C) && C !== 0) return s.zoom = y.zoom + t.ak(C), s;
					qt();
				}
				handleJumpToCenterZoom(e, n) {
					let i = e.center.lat, a = e.constrain(n.center ? t.S.convert(n.center) : e.center, e.zoom).center;
					e.setCenter(a.wrap());
					let o = n.zoom === void 0 ? e.zoom + yn(i, a.lat) : +n.zoom;
					e.zoom !== o && e.setZoom(o);
				}
				handleEaseTo(e, n) {
					let i = e.zoom, a = e.center, o = e.padding, s = {
						roll: e.roll,
						pitch: e.pitch,
						bearing: e.bearing
					}, c = {
						roll: n.roll === void 0 ? e.roll : n.roll,
						pitch: n.pitch === void 0 ? e.pitch : n.pitch,
						bearing: n.bearing === void 0 ? e.bearing : n.bearing
					}, l = n.zoom !== void 0, u = !e.isPaddingEqual(n.padding), d = !1, f = n.center ? t.S.convert(n.center) : a, p = e.constrain(f, i).center;
					Bt(e, p);
					let m = e.clone();
					m.setCenter(p), m.setZoom(l ? +n.zoom : i + yn(a.lat, f.lat)), m.setBearing(n.bearing);
					let h = new t.P(t.ae(e.centerPoint.x + n.offsetAsPoint.x, 0, e.width), t.ae(e.centerPoint.y + n.offsetAsPoint.y, 0, e.height));
					m.setLocationAtPoint(p, h);
					let g = (n.offset && n.offsetAsPoint.mag()) > 0 ? m.center : p, _ = l ? +n.zoom : i + yn(a.lat, g.lat), v = i + yn(a.lat, 0), y = _ + yn(g.lat, 0), b = t.bA(a.lng, g.lng), x = t.bA(a.lat, g.lat), S = t.ah(y - v);
					return d = _ !== i, {
						easeFunc: (i) => {
							if (t.be(s, c) || Jt({
								startEulerAngles: s,
								endEulerAngles: c,
								tr: e,
								k: i,
								useSlerp: s.roll != c.roll
							}), u && e.interpolatePadding(o, n.padding, i), n.around) t.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(n.around, n.aroundPoint);
							else {
								let t = (y > v ? Math.min(2, S) : Math.max(.5, S)) ** (1 - i), n = Sn(a, b, x, i * t);
								e.setCenter(n.wrap());
							}
							if (d) {
								let n = t.C.number(v, y, i) + yn(0, e.center.lat);
								e.setZoom(n);
							}
						},
						isZooming: d,
						elevationCenter: g
					};
				}
				handleFlyTo(e, n) {
					let i = n.zoom !== void 0, a = e.center, o = e.zoom, s = e.padding, c = !e.isPaddingEqual(n.padding), l = e.constrain(t.S.convert(n.center || n.locationAtOffset), o).center, u = i ? +n.zoom : e.zoom + yn(e.center.lat, l.lat), d = e.clone();
					d.setCenter(l), d.setZoom(u), d.setBearing(n.bearing);
					let f = new t.P(t.ae(e.centerPoint.x + n.offsetAsPoint.x, 0, e.width), t.ae(e.centerPoint.y + n.offsetAsPoint.y, 0, e.height));
					d.setLocationAtPoint(l, f);
					let p = d.center;
					Bt(e, p);
					let m = function(e, n, i) {
						let a = hn(n), o = hn(i), s = t.aX(a, o), c = Math.acos(s), l = pn(e);
						return c / (2 * Math.PI) * l;
					}(e, a, p), h = o + yn(a.lat, 0), g = u + yn(p.lat, 0), _ = t.ah(g - h), v;
					if (typeof n.minZoom == "number") {
						let i = +n.minZoom + yn(p.lat, 0), a = Math.min(i, h, g) + yn(0, p.lat), o = e.constrain(p, a).zoom + yn(p.lat, 0);
						v = t.ah(o - h);
					}
					let y = t.bA(a.lng, p.lng), b = t.bA(a.lat, p.lat);
					return {
						easeFunc: (i, o, l, d) => {
							let f = Sn(a, y, b, l);
							c && e.interpolatePadding(s, n.padding, i);
							let m = i === 1 ? p : f;
							e.setCenter(m.wrap());
							let g = h + t.ak(o);
							e.setZoom(i === 1 ? u : g + yn(0, m.lat));
						},
						scaleOfZoom: _,
						targetCenter: p,
						scaleOfMinZoom: v,
						pixelPathLength: m
					};
				}
				static solveVectorScale(e, t, n, i, a) {
					let o = i === "x" ? [
						n[0],
						n[4],
						n[8],
						n[12]
					] : [
						n[1],
						n[5],
						n[9],
						n[13]
					], s = [
						n[3],
						n[7],
						n[11],
						n[15]
					], c = e[0] * o[0] + e[1] * o[1] + e[2] * o[2], l = e[0] * s[0] + e[1] * s[1] + e[2] * s[2], u = t[0] * o[0] + t[1] * o[1] + t[2] * o[2], d = t[0] * s[0] + t[1] * s[1] + t[2] * s[2];
					return u + a * l === c + a * d || s[3] * (c - u) + o[3] * (d - l) + c * d == u * l ? null : (u + o[3] - a * d - a * s[3]) / (u - c - a * d + a * l);
				}
				static getLesserNonNegativeNonNull(e, t) {
					return t !== null && t >= 0 && t < e ? t : e;
				}
			}
			class Mn {
				constructor(e) {
					this._globe = e, this._mercatorCameraHelper = new Xt(), this._verticalPerspectiveCameraHelper = new jn();
				}
				get useGlobeControls() {
					return this._globe.useGlobeRendering;
				}
				get currentHelper() {
					return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
				}
				handlePanInertia(e, t) {
					return this.currentHelper.handlePanInertia(e, t);
				}
				handleMapControlsRollPitchBearingZoom(e, t) {
					return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, t);
				}
				handleMapControlsPan(e, t, n) {
					this.currentHelper.handleMapControlsPan(e, t, n);
				}
				cameraForBoxAndBearing(e, t, n, i, a) {
					return this.currentHelper.cameraForBoxAndBearing(e, t, n, i, a);
				}
				handleJumpToCenterZoom(e, t) {
					this.currentHelper.handleJumpToCenterZoom(e, t);
				}
				handleEaseTo(e, t) {
					return this.currentHelper.handleEaseTo(e, t);
				}
				handleFlyTo(e, t) {
					return this.currentHelper.handleFlyTo(e, t);
				}
			}
			let Nn = (e, n) => t.y(e, n && n.filter(((e) => e.identifier !== "source.canvas"))), Pn = t.bE();
			class Fn extends t.E {
				constructor(e, n = {}) {
					super(), this._rtlPluginLoaded = () => {
						for (let e in this.sourceCaches) {
							let t = this.sourceCaches[e].getSource().type;
							t !== "vector" && t !== "geojson" || this.sourceCaches[e].reload();
						}
					}, this.map = e, this.dispatcher = new te(R(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((e, t) => this.getGlyphs(e, t))), this.dispatcher.registerMessageHandler("GI", ((e, t) => this.getImages(e, t))), this.dispatcher.registerMessageHandler("GDA", ((e, t) => this.getDashes(e, t))), this.imageManager = new S(), this.imageManager.setEventedParent(this);
					let i = e._container?.lang || typeof document < "u" && document.documentElement?.lang || void 0;
					this.glyphManager = new E(e._requestManager, n.localIdeographFontFamily, i), this.lineAtlas = new N(256, 512), this.crossTileSymbolIndex = new At(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.bF(), this._loaded = !1, this._availableImages = [], this._globalState = {}, this._resetUpdates(), this.dispatcher.broadcast("SR", t.bG()), be().on(H, this._rtlPluginLoaded), this.on("data", ((e) => {
						if (e.dataType !== "source" || e.sourceDataType !== "metadata") return;
						let t = this.sourceCaches[e.sourceId];
						if (!t) return;
						let n = t.getSource();
						if (n && n.vectorLayerIds) for (let e in this._layers) {
							let t = this._layers[e];
							t.source === n.id && this._validateLayer(t);
						}
					}));
				}
				setGlobalStateProperty(e, n) {
					this._checkLoaded();
					let i = n === null ? this.stylesheet.state?.[e]?.default ?? null : n;
					if (t.bH(i, this._globalState[e])) return this;
					this._globalState[e] = i, this._applyGlobalStateChanges([e]);
				}
				getGlobalState() {
					return this._globalState;
				}
				setGlobalState(e) {
					this._checkLoaded();
					let n = [];
					for (let i in e) !t.bH(this._globalState[i], e[i].default) && (n.push(i), this._globalState[i] = e[i].default);
					this._applyGlobalStateChanges(n);
				}
				_applyGlobalStateChanges(e) {
					if (e.length === 0) return;
					let t = /* @__PURE__ */ new Set(), n = {};
					for (let i of e) for (let e in n[i] = this._globalState[i], this._layers) {
						let n = this._layers[e], a = n.getLayoutAffectingGlobalStateRefs(), o = n.getPaintAffectingGlobalStateRefs();
						if (a.has(i) && t.add(n.source), o.has(i)) for (let { name: e, value: t } of o.get(i)) this._updatePaintProperty(n, e, t);
					}
					for (let e in this.dispatcher.broadcast("UGS", n), this.sourceCaches) t.has(e) && (this._reloadSource(e), this._changed = !0);
				}
				loadURL(e, n = {}, i) {
					this.fire(new t.l("dataloading", { dataType: "style" })), n.validate = typeof n.validate != "boolean" || n.validate;
					let a = this.map._requestManager.transformRequest(e, "Style");
					this._loadStyleRequest = new AbortController();
					let o = this._loadStyleRequest;
					t.j(a, this._loadStyleRequest).then(((e) => {
						this._loadStyleRequest = null, this._load(e.data, n, i);
					})).catch(((e) => {
						this._loadStyleRequest = null, e && !o.signal.aborted && this.fire(new t.k(e));
					}));
				}
				loadJSON(e, n = {}, i) {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), s.frameAsync(this._frameRequest).then((() => {
						this._frameRequest = null, n.validate = !1 !== n.validate, this._load(e, n, i);
					})).catch((() => {}));
				}
				loadEmpty() {
					this.fire(new t.l("dataloading", { dataType: "style" })), this._load(Pn, { validate: !1 });
				}
				_load(e, n, i) {
					let a = n.transformStyle ? n.transformStyle(i, e) : e;
					if (!n.validate || !Nn(this, t.z(a))) {
						for (let e in a = Object.assign({}, a), this._loaded = !0, this.stylesheet = a, a.sources) this.addSource(e, a.sources[e], { validate: !1 });
						a.sprite ? this._loadSprite(a.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(a.glyphs), this._createLayers(), this.light = new A(this.stylesheet.light), this._setProjectionInternal(this.stylesheet.projection?.type || "mercator"), this.sky = new M(this.stylesheet.sky), this.map.setTerrain(this.stylesheet.terrain ?? null), this.fire(new t.l("data", { dataType: "style" })), this.fire(new t.l("style.load"));
					}
				}
				_createLayers() {
					let e = t.bI(this.stylesheet.layers);
					this.setGlobalState(this.stylesheet.state ?? null), this.dispatcher.broadcast("SL", e), this._order = e.map(((e) => e.id)), this._layers = {}, this._serializedLayers = null;
					for (let n of e) {
						let e = t.bJ(n, this._globalState);
						if (e.setEventedParent(this, { layer: { id: n.id } }), this._layers[n.id] = e, t.bK(e) && this.sourceCaches[e.source]) {
							let t = n.paint?.["raster-fade-duration"] ?? e.paint.get("raster-fade-duration");
							this.sourceCaches[e.source].setRasterFadeDuration(t);
						}
					}
				}
				_loadSprite(e, n = !1, i = void 0) {
					let a;
					this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(e, n, i, a) {
						return t._(this, void 0, void 0, (function* () {
							let o = y(e), c = i > 1 ? "@2x" : "", l = {}, u = {};
							for (let { id: e, url: i } of o) {
								let o = n.transformRequest(b(i, c, ".json"), "SpriteJSON");
								l[e] = t.j(o, a);
								let s = n.transformRequest(b(i, c, ".png"), "SpriteImage");
								u[e] = _.getImage(s, a);
							}
							return yield Promise.all([...Object.values(l), ...Object.values(u)]), function(e, n) {
								return t._(this, void 0, void 0, (function* () {
									let t = {};
									for (let i in e) {
										t[i] = {};
										let a = s.getImageCanvasContext((yield n[i]).data), o = (yield e[i]).data;
										for (let e in o) {
											let { width: n, height: s, x: c, y: l, sdf: u, pixelRatio: d, stretchX: f, stretchY: p, content: m, textFitWidth: h, textFitHeight: g } = o[e];
											t[i][e] = {
												data: null,
												pixelRatio: d,
												sdf: u,
												stretchX: f,
												stretchY: p,
												content: m,
												textFitWidth: h,
												textFitHeight: g,
												spriteData: {
													width: n,
													height: s,
													x: c,
													y: l,
													context: a
												}
											};
										}
									}
									return t;
								}));
							}(l, u);
						}));
					}(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(((e) => {
						if (this._spriteRequest = null, e) for (let t in e) {
							this._spritesImagesIds[t] = [];
							let i = this._spritesImagesIds[t] ? this._spritesImagesIds[t].filter(((t) => !(t in e))) : [];
							for (let e of i) this.imageManager.removeImage(e), this._changedImages[e] = !0;
							for (let i in e[t]) {
								let a = t === "default" ? i : `${t}:${i}`;
								this._spritesImagesIds[t].push(a), a in this.imageManager.images ? this.imageManager.updateImage(a, e[t][i], !1) : this.imageManager.addImage(a, e[t][i]), n && (this._changedImages[a] = !0);
							}
						}
					})).catch(((e) => {
						this._spriteRequest = null, a = e, this.fire(new t.k(a));
					})).finally((() => {
						this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), n && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" })), i && i(a);
					}));
				}
				_unloadSprite() {
					for (let e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0;
					this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				_validateLayer(e) {
					let n = this.sourceCaches[e.source];
					if (!n) return;
					let i = e.sourceLayer;
					if (!i) return;
					let a = n.getSource();
					(a.type === "geojson" || a.vectorLayerIds && a.vectorLayerIds.indexOf(i) === -1) && this.fire(new t.k(/* @__PURE__ */ Error(`Source layer "${i}" does not exist on source "${a.id}" as specified by style layer "${e.id}".`)));
				}
				loaded() {
					if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
					for (let e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1;
					return !!this.imageManager.isLoaded();
				}
				_serializeByIds(e, n = !1) {
					let i = this._serializedAllLayers();
					if (!e || e.length === 0) return Object.values(n ? t.bL(i) : i);
					let a = [];
					for (let o of e) if (i[o]) {
						let e = n ? t.bL(i[o]) : i[o];
						a.push(e);
					}
					return a;
				}
				_serializedAllLayers() {
					let e = this._serializedLayers;
					if (e) return e;
					e = this._serializedLayers = {};
					let t = Object.keys(this._layers);
					for (let n of t) {
						let t = this._layers[n];
						t.type !== "custom" && (e[n] = t.serialize());
					}
					return e;
				}
				hasTransitions() {
					if (this.light?.hasTransition() || this.sky?.hasTransition() || this.projection?.hasTransition()) return !0;
					for (let e in this.sourceCaches) if (this.sourceCaches[e].hasTransition()) return !0;
					for (let e in this._layers) if (this._layers[e].hasTransition()) return !0;
					return !1;
				}
				_checkLoaded() {
					if (!this._loaded) throw Error("Style is not done loading.");
				}
				update(e) {
					if (!this._loaded) return;
					let n = this._changed;
					if (n) {
						let t = Object.keys(this._updatedLayers), n = Object.keys(this._removedLayers);
						for (let e in (t.length || n.length) && this._updateWorkerLayers(t, n), this._updatedSources) {
							let t = this._updatedSources[e];
							if (t === "reload") this._reloadSource(e);
							else {
								if (t !== "clear") throw Error(`Invalid action ${t}`);
								this._clearSource(e);
							}
						}
						for (let t in this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs(), this._updatedPaintProps) this._layers[t].updateTransitions(e);
						this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates();
					}
					let i = {};
					for (let e in this.sourceCaches) {
						let t = this.sourceCaches[e];
						i[e] = t.used, t.used = !1;
					}
					for (let t of this._order) {
						let n = this._layers[t];
						n.recalculate(e, this._availableImages), !n.isHidden(e.zoom) && n.source && (this.sourceCaches[n.source].used = !0);
					}
					for (let e in i) {
						let n = this.sourceCaches[e];
						!!i[e] != !!n.used && n.fire(new t.l("data", {
							sourceDataType: "visibility",
							dataType: "source",
							sourceId: e
						}));
					}
					this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, n && this.fire(new t.l("data", { dataType: "style" }));
				}
				_updateTilesForChangedImages() {
					let e = Object.keys(this._changedImages);
					if (e.length) {
						for (let t in this.sourceCaches) this.sourceCaches[t].reloadTilesForDependencies(["icons", "patterns"], e);
						this._changedImages = {};
					}
				}
				_updateTilesForChangedGlyphs() {
					if (this._glyphsDidChange) {
						for (let e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
						this._glyphsDidChange = !1;
					}
				}
				_updateWorkerLayers(e, t) {
					this.dispatcher.broadcast("UL", {
						layers: this._serializeByIds(e, !1),
						removedIds: t
					});
				}
				_resetUpdates() {
					this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
				}
				setState(e, n = {}) {
					var i;
					this._checkLoaded();
					let a = this.serialize();
					if (e = n.transformStyle ? n.transformStyle(a, e) : e, ((i = n.validate) == null || i) && Nn(this, t.z(e))) return !1;
					(e = t.bL(e)).layers = t.bI(e.layers);
					let o = t.bM(a, e), s = this._getOperationsToPerform(o);
					if (s.unimplemented.length > 0) throw Error(`Unimplemented: ${s.unimplemented.join(", ")}.`);
					if (s.operations.length === 0) return !1;
					for (let e of s.operations) e();
					return this.stylesheet = e, this._serializedLayers = null, !0;
				}
				_getOperationsToPerform(e) {
					let t = [], n = [];
					for (let i of e) switch (i.command) {
						case "setCenter":
						case "setZoom":
						case "setBearing":
						case "setPitch":
						case "setRoll": continue;
						case "addLayer":
							t.push((() => this.addLayer.apply(this, i.args)));
							break;
						case "removeLayer":
							t.push((() => this.removeLayer.apply(this, i.args)));
							break;
						case "setPaintProperty":
							t.push((() => this.setPaintProperty.apply(this, i.args)));
							break;
						case "setLayoutProperty":
							t.push((() => this.setLayoutProperty.apply(this, i.args)));
							break;
						case "setFilter":
							t.push((() => this.setFilter.apply(this, i.args)));
							break;
						case "addSource":
							t.push((() => this.addSource.apply(this, i.args)));
							break;
						case "removeSource":
							t.push((() => this.removeSource.apply(this, i.args)));
							break;
						case "setLayerZoomRange":
							t.push((() => this.setLayerZoomRange.apply(this, i.args)));
							break;
						case "setLight":
							t.push((() => this.setLight.apply(this, i.args)));
							break;
						case "setGeoJSONSourceData":
							t.push((() => this.setGeoJSONSourceData.apply(this, i.args)));
							break;
						case "setGlyphs":
							t.push((() => this.setGlyphs.apply(this, i.args)));
							break;
						case "setSprite":
							t.push((() => this.setSprite.apply(this, i.args)));
							break;
						case "setTerrain":
							t.push((() => this.map.setTerrain.apply(this, i.args)));
							break;
						case "setSky":
							t.push((() => this.setSky.apply(this, i.args)));
							break;
						case "setProjection":
							this.setProjection.apply(this, i.args);
							break;
						case "setGlobalState":
							t.push((() => this.setGlobalState.apply(this, i.args)));
							break;
						case "setTransition":
							t.push((() => {}));
							break;
						default: n.push(i.command);
					}
					return {
						operations: t,
						unimplemented: n
					};
				}
				addImage(e, n) {
					if (this.getImage(e)) return this.fire(new t.k(/* @__PURE__ */ Error(`An image named "${e}" already exists.`)));
					this.imageManager.addImage(e, n), this._afterImageUpdated(e);
				}
				updateImage(e, t) {
					this.imageManager.updateImage(e, t);
				}
				getImage(e) {
					return this.imageManager.getImage(e);
				}
				removeImage(e) {
					if (!this.getImage(e)) return this.fire(new t.k(/* @__PURE__ */ Error(`An image named "${e}" does not exist.`)));
					this.imageManager.removeImage(e), this._afterImageUpdated(e);
				}
				_afterImageUpdated(e) {
					this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
				}
				listImages() {
					return this._checkLoaded(), this.imageManager.listImages();
				}
				addSource(e, n, i = {}) {
					if (this._checkLoaded(), this.sourceCaches[e] !== void 0) throw Error(`Source "${e}" already exists.`);
					if (!n.type) throw Error(`The type property must be defined, but only the following properties were given: ${Object.keys(n).join(", ")}.`);
					if ([
						"vector",
						"raster",
						"geojson",
						"video",
						"image"
					].indexOf(n.type) >= 0 && this._validate(t.z.source, `sources.${e}`, n, null, i)) return;
					this.map && this.map._collectResourceTiming && (n.collectResourceTiming = !0);
					let a = this.sourceCaches[e] = new Re(e, n, this.dispatcher);
					a.style = this, a.setEventedParent(this, (() => ({
						isSourceLoaded: a.loaded(),
						source: a.serialize(),
						sourceId: e
					}))), a.onAdd(this.map), this._changed = !0;
				}
				removeSource(e) {
					if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw Error("There is no source with this ID");
					for (let n in this._layers) if (this._layers[n].source === e) return this.fire(new t.k(/* @__PURE__ */ Error(`Source "${e}" cannot be removed while layer "${n}" is using it.`)));
					let n = this.sourceCaches[e];
					delete this.sourceCaches[e], delete this._updatedSources[e], n.fire(new t.l("data", {
						sourceDataType: "metadata",
						dataType: "source",
						sourceId: e
					})), n.setEventedParent(null), n.onRemove(this.map), this._changed = !0;
				}
				setGeoJSONSourceData(e, t) {
					if (this._checkLoaded(), this.sourceCaches[e] === void 0) throw Error(`There is no source with this ID=${e}`);
					let n = this.sourceCaches[e].getSource();
					if (n.type !== "geojson") throw Error(`geojsonSource.type is ${n.type}, which is !== 'geojson`);
					n.setData(t), this._changed = !0;
				}
				getSource(e) {
					return this.sourceCaches[e] && this.sourceCaches[e].getSource();
				}
				addLayer(e, n, i = {}) {
					this._checkLoaded();
					let a = e.id;
					if (this.getLayer(a)) return void this.fire(new t.k(/* @__PURE__ */ Error(`Layer "${a}" already exists on this map.`)));
					let o;
					if (e.type === "custom") {
						if (Nn(this, t.bN(e))) return;
						o = t.bJ(e, this._globalState);
					} else {
						if ("source" in e && typeof e.source == "object" && (this.addSource(a, e.source), e = t.bL(e), e = t.e(e, { source: a })), this._validate(t.z.layer, `layers.${a}`, e, { arrayIndex: -1 }, i)) return;
						o = t.bJ(e, this._globalState), this._validateLayer(o), o.setEventedParent(this, { layer: { id: a } });
					}
					let s = n ? this._order.indexOf(n) : this._order.length;
					if (n && s === -1) this.fire(new t.k(/* @__PURE__ */ Error(`Cannot add layer "${a}" before non-existing layer "${n}".`)));
					else {
						if (this._order.splice(s, 0, a), this._layerOrderChanged = !0, this._layers[a] = o, this._removedLayers[a] && o.source && o.type !== "custom") {
							let e = this._removedLayers[a];
							delete this._removedLayers[a], e.type === o.type ? (this._updatedSources[o.source] = "reload", this.sourceCaches[o.source].pause()) : this._updatedSources[o.source] = "clear";
						}
						this._updateLayer(o), o.onAdd && o.onAdd(this.map);
					}
				}
				moveLayer(e, n) {
					if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new t.k(/* @__PURE__ */ Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
					if (e === n) return;
					let i = this._order.indexOf(e);
					this._order.splice(i, 1);
					let a = n ? this._order.indexOf(n) : this._order.length;
					n && a === -1 ? this.fire(new t.k(/* @__PURE__ */ Error(`Cannot move layer "${e}" before non-existing layer "${n}".`))) : (this._order.splice(a, 0, e), this._layerOrderChanged = !0);
				}
				removeLayer(e) {
					this._checkLoaded();
					let n = this._layers[e];
					if (!n) return void this.fire(new t.k(/* @__PURE__ */ Error(`Cannot remove non-existing layer "${e}".`)));
					n.setEventedParent(null);
					let i = this._order.indexOf(e);
					this._order.splice(i, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = n, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], n.onRemove && n.onRemove(this.map);
				}
				getLayer(e) {
					return this._layers[e];
				}
				getLayersOrder() {
					return [...this._order];
				}
				hasLayer(e) {
					return e in this._layers;
				}
				setLayerZoomRange(e, n, i) {
					this._checkLoaded();
					let a = this.getLayer(e);
					a ? a.minzoom === n && a.maxzoom === i || (n != null && (a.minzoom = n), i != null && (a.maxzoom = i), this._updateLayer(a)) : this.fire(new t.k(/* @__PURE__ */ Error(`Cannot set the zoom range of non-existing layer "${e}".`)));
				}
				setFilter(e, n, i = {}) {
					this._checkLoaded();
					let a = this.getLayer(e);
					if (a) {
						if (!t.bH(a.filter, n)) return n == null ? (a.setFilter(void 0), void this._updateLayer(a)) : void (this._validate(t.z.filter, `layers.${a.id}.filter`, n, null, i) || (a.setFilter(t.bL(n)), this._updateLayer(a)));
					} else this.fire(new t.k(/* @__PURE__ */ Error(`Cannot filter non-existing layer "${e}".`)));
				}
				getFilter(e) {
					return t.bL(this.getLayer(e).filter);
				}
				setLayoutProperty(e, n, i, a = {}) {
					this._checkLoaded();
					let o = this.getLayer(e);
					o ? t.bH(o.getLayoutProperty(n), i) || (o.setLayoutProperty(n, i, a), this._updateLayer(o)) : this.fire(new t.k(/* @__PURE__ */ Error(`Cannot style non-existing layer "${e}".`)));
				}
				getLayoutProperty(e, n) {
					let i = this.getLayer(e);
					if (i) return i.getLayoutProperty(n);
					this.fire(new t.k(/* @__PURE__ */ Error(`Cannot get style of non-existing layer "${e}".`)));
				}
				setPaintProperty(e, n, i, a = {}) {
					this._checkLoaded();
					let o = this.getLayer(e);
					o ? t.bH(o.getPaintProperty(n), i) || this._updatePaintProperty(o, n, i, a) : this.fire(new t.k(/* @__PURE__ */ Error(`Cannot style non-existing layer "${e}".`)));
				}
				_updatePaintProperty(e, n, i, a = {}) {
					e.setPaintProperty(n, i, a) && this._updateLayer(e), t.bK(e) && n === "raster-fade-duration" && this.sourceCaches[e.source].setRasterFadeDuration(i), this._changed = !0, this._updatedPaintProps[e.id] = !0, this._serializedLayers = null;
				}
				getPaintProperty(e, t) {
					return this.getLayer(e).getPaintProperty(t);
				}
				setFeatureState(e, n) {
					this._checkLoaded();
					let i = e.source, a = e.sourceLayer, o = this.sourceCaches[i];
					if (o === void 0) return void this.fire(new t.k(/* @__PURE__ */ Error(`The source '${i}' does not exist in the map's style.`)));
					let s = o.getSource().type;
					s === "geojson" && a ? this.fire(new t.k(/* @__PURE__ */ Error("GeoJSON sources cannot have a sourceLayer parameter."))) : s !== "vector" || a ? (e.id === void 0 && this.fire(new t.k(/* @__PURE__ */ Error("The feature id parameter must be provided."))), o.setFeatureState(a, e.id, n)) : this.fire(new t.k(/* @__PURE__ */ Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				removeFeatureState(e, n) {
					this._checkLoaded();
					let i = e.source, a = this.sourceCaches[i];
					if (a === void 0) return void this.fire(new t.k(/* @__PURE__ */ Error(`The source '${i}' does not exist in the map's style.`)));
					let o = a.getSource().type, s = o === "vector" ? e.sourceLayer : void 0;
					o !== "vector" || s ? n && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new t.k(/* @__PURE__ */ Error("A feature id is required to remove its specific state property."))) : a.removeFeatureState(s, e.id, n) : this.fire(new t.k(/* @__PURE__ */ Error("The sourceLayer parameter must be provided for vector source types.")));
				}
				getFeatureState(e) {
					this._checkLoaded();
					let n = e.source, i = e.sourceLayer, a = this.sourceCaches[n];
					if (a !== void 0) return a.getSource().type !== "vector" || i ? (e.id === void 0 && this.fire(new t.k(/* @__PURE__ */ Error("The feature id parameter must be provided."))), a.getFeatureState(i, e.id)) : void this.fire(new t.k(/* @__PURE__ */ Error("The sourceLayer parameter must be provided for vector source types.")));
					this.fire(new t.k(/* @__PURE__ */ Error(`The source '${n}' does not exist in the map's style.`)));
				}
				getTransition() {
					return t.e({
						duration: 300,
						delay: 0
					}, this.stylesheet && this.stylesheet.transition);
				}
				serialize() {
					if (!this._loaded) return;
					let e = t.bO(this.sourceCaches, ((e) => e.serialize())), n = this._serializeByIds(this._order, !0), i = this.map.getTerrain() || void 0, a = this.stylesheet;
					return t.bP({
						version: a.version,
						name: a.name,
						metadata: a.metadata,
						light: a.light,
						sky: a.sky,
						center: a.center,
						zoom: a.zoom,
						bearing: a.bearing,
						pitch: a.pitch,
						sprite: a.sprite,
						glyphs: a.glyphs,
						transition: a.transition,
						projection: a.projection,
						sources: e,
						layers: n,
						terrain: i
					}, ((e) => e !== void 0));
				}
				_updateLayer(e) {
					this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0;
				}
				_flattenAndSortRenderedFeatures(e) {
					let t = (e) => this._layers[e].type === "fill-extrusion", n = {}, i = [];
					for (let a = this._order.length - 1; a >= 0; a--) {
						let o = this._order[a];
						if (t(o)) {
							n[o] = a;
							for (let t of e) {
								let e = t[o];
								if (e) for (let t of e) i.push(t);
							}
						}
					}
					i.sort(((e, t) => t.intersectionZ - e.intersectionZ));
					let a = [];
					for (let o = this._order.length - 1; o >= 0; o--) {
						let s = this._order[o];
						if (t(s)) for (let e = i.length - 1; e >= 0; e--) {
							let t = i[e].feature;
							if (n[t.layer.id] < o) break;
							a.push(t), i.pop();
						}
						else for (let t of e) {
							let e = t[s];
							if (e) for (let t of e) a.push(t.feature);
						}
					}
					return a;
				}
				queryRenderedFeatures(e, n, i) {
					n && n.filter && this._validate(t.z.filter, "queryRenderedFeatures.filter", n.filter, null, n);
					let a = {};
					if (n && n.layers) {
						if (!(Array.isArray(n.layers) || n.layers instanceof Set)) return this.fire(new t.k(/* @__PURE__ */ Error("parameters.layers must be an Array or a Set of strings"))), [];
						for (let e of n.layers) {
							let n = this._layers[e];
							if (!n) return this.fire(new t.k(/* @__PURE__ */ Error(`The layer '${e}' does not exist in the map's style and cannot be queried for features.`))), [];
							a[n.source] = !0;
						}
					}
					let o = [];
					n.availableImages = this._availableImages;
					let s = this._serializedAllLayers(), c = n.layers instanceof Set ? n.layers : Array.isArray(n.layers) ? new Set(n.layers) : null, l = Object.assign(Object.assign({}, n), {
						layers: c,
						globalState: this._globalState
					});
					for (let t in this.sourceCaches) n.layers && !a[t] || o.push(ae(this.sourceCaches[t], this._layers, s, e, l, i, this.map.terrain ? (e, t, n) => this.map.terrain.getElevation(e, t, n) : void 0));
					return this.placement && o.push(function(e, t, n, i, a, o, s) {
						let c = {}, l = o.queryRenderedSymbols(i), u = [];
						for (let e of Object.keys(l).map(Number)) u.push(s[e]);
						u.sort(oe);
						for (let n of u) {
							let i = n.featureIndex.lookupSymbolFeatures(l[n.bucketInstanceId], t, n.bucketIndex, n.sourceLayerIndex, {
								filterSpec: a.filter,
								globalState: a.globalState
							}, a.layers, a.availableImages, e);
							for (let e in i) {
								let t = c[e] = c[e] || [], a = i[e];
								a.sort(((e, t) => {
									let i = n.featureSortOrder;
									if (i) {
										let n = i.indexOf(e.featureIndex);
										return i.indexOf(t.featureIndex) - n;
									}
									return t.featureIndex - e.featureIndex;
								}));
								for (let e of a) t.push(e);
							}
						}
						return function(e, t, n) {
							for (let i in e) for (let a of e[i]) z(a, n[t[i].source]);
							return e;
						}(c, e, n);
					}(this._layers, s, this.sourceCaches, e, l, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o);
				}
				querySourceFeatures(e, n) {
					n != null && n.filter && this._validate(t.z.filter, "querySourceFeatures.filter", n.filter, null, n);
					let i = this.sourceCaches[e];
					return i ? function(e, t) {
						let n = e.getRenderableIds().map(((t) => e.getTileByID(t))), i = [], a = {};
						for (let e = 0; e < n.length; e++) {
							let o = n[e], s = o.tileID.canonical.key;
							a[s] || (a[s] = !0, o.querySourceFeatures(i, t));
						}
						return i;
					}(i, n ? Object.assign(Object.assign({}, n), { globalState: this._globalState }) : { globalState: this._globalState }) : [];
				}
				getLight() {
					return this.light.getLight();
				}
				setLight(e, n = {}) {
					this._checkLoaded();
					let i = this.light.getLight(), a = !1;
					for (let n in e) if (!t.bH(e[n], i[n])) {
						a = !0;
						break;
					}
					if (!a) return;
					let o = {
						now: l(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.light.setLight(e, n), this.light.updateTransitions(o);
				}
				getProjection() {
					return this.stylesheet?.projection;
				}
				setProjection(e) {
					if (this._checkLoaded(), this.projection) {
						if (this.projection.name === e.type) return;
						this.projection.destroy(), delete this.projection;
					}
					this.stylesheet.projection = e, this._setProjectionInternal(e.type);
				}
				getSky() {
					return this.stylesheet?.sky;
				}
				setSky(e, n = {}) {
					this._checkLoaded();
					let i = this.getSky(), a = !1;
					if (!e && !i) return;
					if (e && !i) a = !0;
					else if (!e && i) a = !0;
					else for (let n in e) if (!t.bH(e[n], i[n])) {
						a = !0;
						break;
					}
					if (!a) return;
					let o = {
						now: l(),
						transition: t.e({
							duration: 300,
							delay: 0
						}, this.stylesheet.transition)
					};
					this.stylesheet.sky = e, this.sky.setSky(e, n), this.sky.updateTransitions(o);
				}
				_setProjectionInternal(e) {
					let n = function(e, n) {
						let i = { constrain: n };
						if (Array.isArray(e)) {
							let t = new fn({ type: e });
							return {
								projection: t,
								transform: new An(i),
								cameraHelper: new Mn(t)
							};
						}
						switch (e) {
							case "mercator": return {
								projection: new Rt(),
								transform: new Kt(i),
								cameraHelper: new Xt()
							};
							case "globe": {
								let e = new fn({ type: [
									"interpolate",
									["linear"],
									["zoom"],
									11,
									"vertical-perspective",
									12,
									"mercator"
								] });
								return {
									projection: e,
									transform: new An(i),
									cameraHelper: new Mn(e)
								};
							}
							case "vertical-perspective": return {
								projection: new un(),
								transform: new kn(i),
								cameraHelper: new jn()
							};
							default: return t.w(`Unknown projection name: ${e}. Falling back to mercator projection.`), {
								projection: new Rt(),
								transform: new Kt(i),
								cameraHelper: new Xt()
							};
						}
					}(e, this.map.transformConstrain);
					for (let e in this.projection = n.projection, this.map.migrateProjection(n.transform, n.cameraHelper), this.sourceCaches) this.sourceCaches[e].reload();
				}
				_validate(e, n, i, a, o = {}) {
					return (!o || !1 !== o.validate) && Nn(this, e.call(t.z, t.e({
						key: n,
						style: this.serialize(),
						value: i,
						styleSpec: t.v
					}, a)));
				}
				_remove(e = !0) {
					for (let e in this._frameRequest &&= (this._frameRequest.abort(), null), this._loadStyleRequest &&= (this._loadStyleRequest.abort(), null), this._spriteRequest &&= (this._spriteRequest.abort(), null), be().off(H, this._rtlPluginLoaded), this._layers) this._layers[e].setEventedParent(null);
					for (let e in this.sourceCaches) {
						let t = this.sourceCaches[e];
						t.setEventedParent(null), t.onRemove(this.map);
					}
					this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e);
				}
				_clearSource(e) {
					this.sourceCaches[e].clearTiles();
				}
				_reloadSource(e) {
					this.sourceCaches[e].resume(), this.sourceCaches[e].reload();
				}
				_updateSources(e) {
					for (let t in this.sourceCaches) this.sourceCaches[t].update(e, this.map.terrain);
				}
				_generateCollisionBoxes() {
					for (let e in this.sourceCaches) this._reloadSource(e);
				}
				_updatePlacement(e, t, n, i, a = !1) {
					let o = !1, s = !1, c = {};
					for (let t of this._order) {
						let n = this._layers[t];
						if (n.type !== "symbol") continue;
						if (!c[n.source]) {
							let e = this.sourceCaches[n.source];
							c[n.source] = e.getRenderableIds(!0).map(((t) => e.getTileByID(t))).sort(((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1)));
						}
						let i = this.crossTileSymbolIndex.addLayer(n, c[n.source], e.center.lng);
						o ||= i;
					}
					if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a = a || this._layerOrderChanged || n === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(l(), e.zoom)) && (this.pauseablePlacement = new Tt(e, this.map.terrain, this._order, a, t, n, i, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, c), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(l()), s = !0), o && this.pauseablePlacement.placement.setStale()), s || o) for (let e of this._order) {
						let t = this._layers[e];
						t.type === "symbol" && this.placement.updateLayerOpacities(t, c[t.source]);
					}
					return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(l());
				}
				_releaseSymbolFadeTiles() {
					for (let e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles();
				}
				getImages(e, n) {
					return t._(this, void 0, void 0, (function* () {
						let e = yield this.imageManager.getImages(n.icons);
						this._updateTilesForChangedImages();
						let t = this.sourceCaches[n.source];
						return t && t.setDependencies(n.tileID.key, n.type, n.icons), e;
					}));
				}
				getGlyphs(e, n) {
					return t._(this, void 0, void 0, (function* () {
						let e = yield this.glyphManager.getGlyphs(n.stacks), t = this.sourceCaches[n.source];
						return t && t.setDependencies(n.tileID.key, n.type, [""]), e;
					}));
				}
				getGlyphsUrl() {
					return this.stylesheet.glyphs || null;
				}
				setGlyphs(e, n = {}) {
					this._checkLoaded(), e && this._validate(t.z.glyphs, "glyphs", e, null, n) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e));
				}
				getDashes(e, n) {
					return t._(this, void 0, void 0, (function* () {
						let e = {};
						for (let [t, i] of Object.entries(n.dashes)) e[t] = this.lineAtlas.getDash(i.dasharray, i.round);
						return e;
					}));
				}
				addSprite(e, n, i = {}, a) {
					this._checkLoaded();
					let o = [{
						id: e,
						url: n
					}], s = [...y(this.stylesheet.sprite), ...o];
					this._validate(t.z.sprite, "sprite", s, null, i) || (this.stylesheet.sprite = s, this._loadSprite(o, !0, a));
				}
				removeSprite(e) {
					this._checkLoaded();
					let n = y(this.stylesheet.sprite);
					if (n.find(((t) => t.id === e))) {
						if (this._spritesImagesIds[e]) for (let t of this._spritesImagesIds[e]) this.imageManager.removeImage(t), this._changedImages[t] = !0;
						n.splice(n.findIndex(((t) => t.id === e)), 1), this.stylesheet.sprite = n.length > 0 ? n : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.l("data", { dataType: "style" }));
					} else this.fire(new t.k(/* @__PURE__ */ Error(`Sprite "${e}" doesn't exists on this map.`)));
				}
				getSprite() {
					return y(this.stylesheet.sprite);
				}
				setSprite(e, n = {}, i) {
					this._checkLoaded(), e && this._validate(t.z.sprite, "sprite", e, null, n) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, i) : (this._unloadSprite(), i && i(null)));
				}
			}
			var In = t.aJ([{
				name: "a_pos",
				type: "Int16",
				components: 2
			}, {
				name: "a_texture_pos",
				type: "Int16",
				components: 2
			}]);
			class Ln {
				constructor() {
					this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
				}
				bind(e, t, n, i, a, o, s, c, l) {
					this.context = e;
					let u = this.boundPaintVertexBuffers.length !== i.length;
					for (let e = 0; !u && e < i.length; e++) this.boundPaintVertexBuffers[e] !== i[e] && (u = !0);
					!this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== n || u || this.boundIndexBuffer !== a || this.boundVertexOffset !== o || this.boundDynamicVertexBuffer !== s || this.boundDynamicVertexBuffer2 !== c || this.boundDynamicVertexBuffer3 !== l ? this.freshBind(t, n, i, a, o, s, c, l) : (e.bindVertexArray.set(this.vao), s && s.bind(), a && a.dynamicDraw && a.bind(), c && c.bind(), l && l.bind());
				}
				freshBind(e, t, n, i, a, o, s, c) {
					let l = e.numAttributes, u = this.context, d = u.gl;
					this.vao && this.destroy(), this.vao = u.createVertexArray(), u.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = n, this.boundIndexBuffer = i, this.boundVertexOffset = a, this.boundDynamicVertexBuffer = o, this.boundDynamicVertexBuffer2 = s, this.boundDynamicVertexBuffer3 = c, t.enableAttributes(d, e);
					for (let t of n) t.enableAttributes(d, e);
					o && o.enableAttributes(d, e), s && s.enableAttributes(d, e), c && c.enableAttributes(d, e), t.bind(), t.setVertexAttribPointers(d, e, a);
					for (let t of n) t.bind(), t.setVertexAttribPointers(d, e, a);
					o && (o.bind(), o.setVertexAttribPointers(d, e, a)), i && i.bind(), s && (s.bind(), s.setVertexAttribPointers(d, e, a)), c && (c.bind(), c.setVertexAttribPointers(d, e, a)), u.currentNumAttributes = l;
				}
				destroy() {
					this.vao &&= (this.context.deleteVertexArray(this.vao), null);
				}
			}
			let Rn = (e, n, i, a, o) => ({
				u_texture: 0,
				u_ele_delta: e,
				u_fog_matrix: n,
				u_fog_color: i ? i.properties.get("fog-color") : t.bf.white,
				u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1,
				u_fog_ground_blend_opacity: o ? 0 : i ? i.calculateFogBlendOpacity(a) : 0,
				u_horizon_color: i ? i.properties.get("horizon-color") : t.bf.white,
				u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1,
				u_is_globe_mode: o ? 1 : 0
			}), zn = {
				mainMatrix: "u_projection_matrix",
				tileMercatorCoords: "u_projection_tile_mercator_coords",
				clippingPlane: "u_projection_clipping_plane",
				projectionTransition: "u_projection_transition",
				fallbackMatrix: "u_projection_fallback_matrix"
			};
			function Bn(e) {
				let t = [];
				for (let n = 0; n < e.length; n++) {
					if (e[n] === null) continue;
					let i = e[n].split(" ");
					t.push(i.pop());
				}
				return t;
			}
			class Vn {
				constructor(e, n, i, a, o, s, c, l, u = []) {
					let d = e.gl;
					this.program = d.createProgram();
					let f = Bn(n.staticAttributes), p = i ? i.getBinderAttributes() : [], m = f.concat(p), h = Mt.prelude.staticUniforms ? Bn(Mt.prelude.staticUniforms) : [], g = c.staticUniforms ? Bn(c.staticUniforms) : [], _ = n.staticUniforms ? Bn(n.staticUniforms) : [], v = i ? i.getBinderUniforms() : [], y = h.concat(g).concat(_).concat(v), b = [];
					for (let e of y) b.indexOf(e) < 0 && b.push(e);
					let x = i ? i.defines() : [];
					rn(d) && x.unshift("#version 300 es"), o && x.push("#define OVERDRAW_INSPECTOR;"), s && x.push("#define TERRAIN3D;"), l && x.push(l), u && x.push(...u);
					let S = x.concat(Mt.prelude.fragmentSource, c.fragmentSource, n.fragmentSource).join("\n"), C = x.concat(Mt.prelude.vertexSource, c.vertexSource, n.vertexSource).join("\n");
					rn(d) || (S = function(e) {
						return e.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
					}(S), C = function(e) {
						return e.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
					}(C));
					let w = d.createShader(d.FRAGMENT_SHADER);
					if (d.isContextLost()) return void (this.failedToCreate = !0);
					if (d.shaderSource(w, S), d.compileShader(w), !d.getShaderParameter(w, d.COMPILE_STATUS)) throw Error(`Could not compile fragment shader: ${d.getShaderInfoLog(w)}`);
					d.attachShader(this.program, w);
					let T = d.createShader(d.VERTEX_SHADER);
					if (d.isContextLost()) return void (this.failedToCreate = !0);
					if (d.shaderSource(T, C), d.compileShader(T), !d.getShaderParameter(T, d.COMPILE_STATUS)) throw Error(`Could not compile vertex shader: ${d.getShaderInfoLog(T)}`);
					d.attachShader(this.program, T), this.attributes = {};
					let E = {};
					this.numAttributes = m.length;
					for (let e = 0; e < this.numAttributes; e++) m[e] && (d.bindAttribLocation(this.program, e, m[e]), this.attributes[m[e]] = e);
					if (d.linkProgram(this.program), !d.getProgramParameter(this.program, d.LINK_STATUS)) throw Error(`Program failed to link: ${d.getProgramInfoLog(this.program)}`);
					d.deleteShader(T), d.deleteShader(w);
					for (let e = 0; e < b.length; e++) {
						let t = b[e];
						if (t && !E[t]) {
							let e = d.getUniformLocation(this.program, t);
							e && (E[t] = e);
						}
					}
					this.fixedUniforms = a(e, E), this.terrainUniforms = ((e, n) => ({
						u_depth: new t.bQ(e, n.u_depth),
						u_terrain: new t.bQ(e, n.u_terrain),
						u_terrain_dim: new t.bg(e, n.u_terrain_dim),
						u_terrain_matrix: new t.bS(e, n.u_terrain_matrix),
						u_terrain_unpack: new t.bT(e, n.u_terrain_unpack),
						u_terrain_exaggeration: new t.bg(e, n.u_terrain_exaggeration)
					}))(e, E), this.projectionUniforms = ((e, n) => ({
						u_projection_matrix: new t.bS(e, n.u_projection_matrix),
						u_projection_tile_mercator_coords: new t.bT(e, n.u_projection_tile_mercator_coords),
						u_projection_clipping_plane: new t.bT(e, n.u_projection_clipping_plane),
						u_projection_transition: new t.bg(e, n.u_projection_transition),
						u_projection_fallback_matrix: new t.bS(e, n.u_projection_fallback_matrix)
					}))(e, E), this.binderUniforms = i ? i.getUniforms(e, E) : [];
				}
				draw(e, t, n, i, a, o, s, c, l, u, d, f, p, m, h, g, _, v, y) {
					let b = e.gl;
					if (this.failedToCreate) return;
					if (e.program.set(this.program), e.setDepthMode(n), e.setStencilMode(i), e.setColorMode(a), e.setCullFace(o), c) for (let t in e.activeTexture.set(b.TEXTURE2), b.bindTexture(b.TEXTURE_2D, c.depthTexture), e.activeTexture.set(b.TEXTURE3), b.bindTexture(b.TEXTURE_2D, c.texture), this.terrainUniforms) this.terrainUniforms[t].set(c[t]);
					if (l) for (let e in l) this.projectionUniforms[zn[e]].set(l[e]);
					if (s) for (let e in this.fixedUniforms) this.fixedUniforms[e].set(s[e]);
					g && g.setUniforms(e, this.binderUniforms, m, { zoom: h });
					let x = 0;
					switch (t) {
						case b.LINES:
							x = 2;
							break;
						case b.TRIANGLES:
							x = 3;
							break;
						case b.LINE_STRIP: x = 1;
					}
					for (let n of p.get()) {
						let i = n.vaos ||= {};
						(i[u] || (i[u] = new Ln())).bind(e, this, d, g ? g.getPaintVertexBuffers() : [], f, n.vertexOffset, _, v, y), b.drawElements(t, n.primitiveLength * x, b.UNSIGNED_SHORT, n.primitiveOffset * x * 2);
					}
				}
			}
			function Hn(e, n, i) {
				let a = 1 / t.aC(i, 1, n.transform.tileZoom), o = 2 ** i.tileID.overscaledZ, s = i.tileSize * 2 ** n.transform.tileZoom / o, c = s * (i.tileID.canonical.x + i.tileID.wrap * o), l = s * i.tileID.canonical.y;
				return {
					u_image: 0,
					u_texsize: i.imageAtlasTexture.size,
					u_scale: [
						a,
						e.fromScale,
						e.toScale
					],
					u_fade: e.t,
					u_pixel_coord_upper: [c >> 16, l >> 16],
					u_pixel_coord_lower: [65535 & c, 65535 & l]
				};
			}
			let Un = (e, n, i, a) => {
				let o = e.style.light, s = o.properties.get("position"), c = [
					s.x,
					s.y,
					s.z
				], l = t.bW();
				o.properties.get("anchor") === "viewport" && t.bX(l, e.transform.bearingInRadians), t.bY(c, c, l);
				let u = e.transform.transformLightDirection(c), d = o.properties.get("color");
				return {
					u_lightpos: c,
					u_lightpos_globe: u,
					u_lightintensity: o.properties.get("intensity"),
					u_lightcolor: [
						d.r,
						d.g,
						d.b
					],
					u_vertical_gradient: +n,
					u_opacity: i,
					u_fill_translate: a
				};
			}, Wn = (e, n, i, a, o, s, c) => t.e(Un(e, n, i, a), Hn(s, e, c), { u_height_factor: -(2 ** o.overscaledZ) / c.tileSize / 8 }), Gn = (e, n, i, a) => t.e(Hn(n, e, i), { u_fill_translate: a }), Kn = (e, t) => ({
				u_world: e,
				u_fill_translate: t
			}), qn = (e, n, i, a, o) => t.e(Gn(e, n, i, o), { u_world: a }), Jn = (e, n, i, a, o) => {
				let s = e.transform, c, l, u = 0;
				if (i.paint.get("circle-pitch-alignment") === "map") {
					let e = t.aC(n, 1, s.zoom);
					c = !0, l = [e, e], u = e / (t.$ * 2 ** n.tileID.overscaledZ) * 2 * Math.PI * o;
				} else c = !1, l = s.pixelsToGLUnits;
				return {
					u_camera_to_center_distance: s.cameraToCenterDistance,
					u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"),
					u_pitch_with_map: +c,
					u_device_pixel_ratio: e.pixelRatio,
					u_extrude_scale: l,
					u_globe_extrude_scale: u,
					u_translate: a
				};
			}, Yn = (e) => ({ u_pixel_extrude_scale: [1 / e.width, 1 / e.height] }), Xn = (e) => ({ u_viewport_size: [e.width, e.height] }), Zn = (e, t = 1) => ({
				u_color: e,
				u_overlay: 0,
				u_overlay_scale: t
			}), Qn = (e, n, i, a) => {
				let o = t.aC(e, 1, n) / (t.$ * 2 ** e.tileID.overscaledZ) * 2 * Math.PI * a;
				return {
					u_extrude_scale: t.aC(e, 1, n),
					u_intensity: i,
					u_globe_extrude_scale: o
				};
			}, $n = (e, n, i, a) => {
				let o = t.L();
				t.bZ(o, 0, e.width, e.height, 0, 0, 1);
				let s = e.context.gl;
				return {
					u_matrix: o,
					u_world: [s.drawingBufferWidth, s.drawingBufferHeight],
					u_image: i,
					u_color_ramp: a,
					u_opacity: n.paint.get("heatmap-opacity")
				};
			}, er = (e, t, n) => {
				let i = n.paint.get("hillshade-accent-color"), a;
				switch (n.paint.get("hillshade-method")) {
					case "basic":
						a = 4;
						break;
					case "combined":
						a = 1;
						break;
					case "igor":
						a = 2;
						break;
					case "multidirectional":
						a = 3;
						break;
					default: a = 0;
				}
				let o = n.getIlluminationProperties();
				for (let t = 0; t < o.directionRadians.length; t++) n.paint.get("hillshade-illumination-anchor") === "viewport" && (o.directionRadians[t] += e.transform.bearingInRadians);
				return {
					u_image: 0,
					u_latrange: nr(0, t.tileID),
					u_exaggeration: n.paint.get("hillshade-exaggeration"),
					u_altitudes: o.altitudeRadians,
					u_azimuths: o.directionRadians,
					u_accent: i,
					u_method: a,
					u_highlights: o.highlightColor,
					u_shadows: o.shadowColor
				};
			}, tr = (e, n) => {
				let i = n.stride, a = t.L();
				return t.bZ(a, 0, t.$, -t.$, 0, 0, 1), t.M(a, a, [
					0,
					-t.$,
					0
				]), {
					u_matrix: a,
					u_image: 1,
					u_dimension: [i, i],
					u_zoom: e.overscaledZ,
					u_unpack: n.getUnpackVector()
				};
			};
			function nr(e, n) {
				let i = 2 ** n.canonical.z, a = n.canonical.y;
				return [new t.a1(0, a / i).toLngLat().lat, new t.a1(0, (a + 1) / i).toLngLat().lat];
			}
			let rr = (e, t, n = 0) => ({
				u_image: 0,
				u_unpack: t.getUnpackVector(),
				u_dimension: [t.stride, t.stride],
				u_elevation_stops: 1,
				u_color_stops: 4,
				u_color_ramp_size: n,
				u_opacity: e.paint.get("color-relief-opacity")
			}), ir = (e, n, i, a) => {
				let o = e.transform;
				return {
					u_translation: ur(e, n, i),
					u_ratio: a / t.aC(n, 1, o.zoom),
					u_device_pixel_ratio: e.pixelRatio,
					u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]]
				};
			}, ar = (e, n, i, a, o) => t.e(ir(e, n, i, a), {
				u_image: 0,
				u_image_height: o
			}), or = (e, n, i, a, o) => {
				let s = e.transform, c = lr(n, s);
				return {
					u_translation: ur(e, n, i),
					u_texsize: n.imageAtlasTexture.size,
					u_ratio: a / t.aC(n, 1, s.zoom),
					u_device_pixel_ratio: e.pixelRatio,
					u_image: 0,
					u_scale: [
						c,
						o.fromScale,
						o.toScale
					],
					u_fade: o.t,
					u_units_to_pixels: [1 / s.pixelsToGLUnits[0], 1 / s.pixelsToGLUnits[1]]
				};
			}, sr = (e, n, i, a, o) => {
				let s = lr(n, e.transform);
				return t.e(ir(e, n, i, a), {
					u_tileratio: s,
					u_crossfade_from: o.fromScale,
					u_crossfade_to: o.toScale,
					u_image: 0,
					u_mix: o.t,
					u_lineatlas_width: e.lineAtlas.width,
					u_lineatlas_height: e.lineAtlas.height
				});
			}, cr = (e, n, i, a, o, s) => {
				let c = lr(n, e.transform);
				return t.e(ir(e, n, i, a), {
					u_image: 0,
					u_image_height: s,
					u_tileratio: c,
					u_crossfade_from: o.fromScale,
					u_crossfade_to: o.toScale,
					u_image_dash: 1,
					u_mix: o.t,
					u_lineatlas_width: e.lineAtlas.width,
					u_lineatlas_height: e.lineAtlas.height
				});
			};
			function lr(e, n) {
				return 1 / t.aC(e, 1, n.tileZoom);
			}
			function ur(e, n, i) {
				return t.aD(e.transform, n, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"));
			}
			let dr = (e, t, n, i, a) => {
				return {
					u_tl_parent: e,
					u_scale_parent: t,
					u_buffer_scale: 1,
					u_fade_t: n.mix,
					u_opacity: n.opacity * i.paint.get("raster-opacity"),
					u_image0: 0,
					u_image1: 1,
					u_brightness_low: i.paint.get("raster-brightness-min"),
					u_brightness_high: i.paint.get("raster-brightness-max"),
					u_saturation_factor: (s = i.paint.get("raster-saturation"), s > 0 ? 1 - 1 / (1.001 - s) : -s),
					u_contrast_factor: (o = i.paint.get("raster-contrast"), o > 0 ? 1 / (1 - o) : 1 + o),
					u_spin_weights: fr(i.paint.get("raster-hue-rotate")),
					u_coords_top: [
						a[0].x,
						a[0].y,
						a[1].x,
						a[1].y
					],
					u_coords_bottom: [
						a[3].x,
						a[3].y,
						a[2].x,
						a[2].y
					]
				};
				var o, s;
			};
			function fr(e) {
				e *= Math.PI / 180;
				let t = Math.sin(e), n = Math.cos(e);
				return [
					(2 * n + 1) / 3,
					(-Math.sqrt(3) * t - n + 1) / 3,
					(Math.sqrt(3) * t - n + 1) / 3
				];
			}
			let pr = (e, t, n, i, a, o, s, c, l, u, d, f, p) => {
				let m = s.transform;
				return {
					u_is_size_zoom_constant: +(e === "constant" || e === "source"),
					u_is_size_feature_constant: +(e === "constant" || e === "camera"),
					u_size_t: t ? t.uSizeT : 0,
					u_size: t ? t.uSize : 0,
					u_camera_to_center_distance: m.cameraToCenterDistance,
					u_pitch: m.pitch / 360 * 2 * Math.PI,
					u_rotate_symbol: +n,
					u_aspect_ratio: m.width / m.height,
					u_fade_change: s.options.fadeDuration ? s.symbolFadeChange : 1,
					u_label_plane_matrix: c,
					u_coord_matrix: l,
					u_is_text: +d,
					u_pitch_with_map: +i,
					u_is_along_line: a,
					u_is_variable_anchor: o,
					u_texsize: f,
					u_texture: 0,
					u_translation: u,
					u_pitched_scale: p
				};
			}, mr = (e, n, i, a, o, s, c, l, u, d, f, p, m, h) => {
				let g = c.transform;
				return t.e(pr(e, n, i, a, o, s, c, l, u, d, f, p, h), {
					u_gamma_scale: a ? Math.cos(g.pitch * Math.PI / 180) * g.cameraToCenterDistance : 1,
					u_device_pixel_ratio: c.pixelRatio,
					u_is_halo: 1
				});
			}, hr = (e, n, i, a, o, s, c, l, u, d, f, p, m) => t.e(mr(e, n, i, a, o, s, c, l, u, d, !0, f, 0, m), {
				u_texsize_icon: p,
				u_texture_icon: 1
			}), gr = (e, t) => ({
				u_opacity: e,
				u_color: t
			}), _r = (e, n, i, a, o) => t.e(function(e, n, i, a) {
				let o = i.imageManager.getPattern(e.from.toString()), s = i.imageManager.getPattern(e.to.toString()), { width: c, height: l } = i.imageManager.getPixelSize(), u = 2 ** a.tileID.overscaledZ, d = a.tileSize * 2 ** i.transform.tileZoom / u, f = d * (a.tileID.canonical.x + a.tileID.wrap * u), p = d * a.tileID.canonical.y;
				return {
					u_image: 0,
					u_pattern_tl_a: o.tl,
					u_pattern_br_a: o.br,
					u_pattern_tl_b: s.tl,
					u_pattern_br_b: s.br,
					u_texsize: [c, l],
					u_mix: n.t,
					u_pattern_size_a: o.displaySize,
					u_pattern_size_b: s.displaySize,
					u_scale_a: n.fromScale,
					u_scale_b: n.toScale,
					u_tile_units_to_pixels: 1 / t.aC(a, 1, i.transform.tileZoom),
					u_pixel_coord_upper: [f >> 16, p >> 16],
					u_pixel_coord_lower: [65535 & f, 65535 & p]
				};
			}(i, o, n, a), { u_opacity: e }), vr = (e, t) => {}, yr = {
				fillExtrusion: (e, n) => ({
					u_lightpos: new t.bU(e, n.u_lightpos),
					u_lightpos_globe: new t.bU(e, n.u_lightpos_globe),
					u_lightintensity: new t.bg(e, n.u_lightintensity),
					u_lightcolor: new t.bU(e, n.u_lightcolor),
					u_vertical_gradient: new t.bg(e, n.u_vertical_gradient),
					u_opacity: new t.bg(e, n.u_opacity),
					u_fill_translate: new t.bV(e, n.u_fill_translate)
				}),
				fillExtrusionPattern: (e, n) => ({
					u_lightpos: new t.bU(e, n.u_lightpos),
					u_lightpos_globe: new t.bU(e, n.u_lightpos_globe),
					u_lightintensity: new t.bg(e, n.u_lightintensity),
					u_lightcolor: new t.bU(e, n.u_lightcolor),
					u_vertical_gradient: new t.bg(e, n.u_vertical_gradient),
					u_height_factor: new t.bg(e, n.u_height_factor),
					u_opacity: new t.bg(e, n.u_opacity),
					u_fill_translate: new t.bV(e, n.u_fill_translate),
					u_image: new t.bQ(e, n.u_image),
					u_texsize: new t.bV(e, n.u_texsize),
					u_pixel_coord_upper: new t.bV(e, n.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bV(e, n.u_pixel_coord_lower),
					u_scale: new t.bU(e, n.u_scale),
					u_fade: new t.bg(e, n.u_fade)
				}),
				fill: (e, n) => ({ u_fill_translate: new t.bV(e, n.u_fill_translate) }),
				fillPattern: (e, n) => ({
					u_image: new t.bQ(e, n.u_image),
					u_texsize: new t.bV(e, n.u_texsize),
					u_pixel_coord_upper: new t.bV(e, n.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bV(e, n.u_pixel_coord_lower),
					u_scale: new t.bU(e, n.u_scale),
					u_fade: new t.bg(e, n.u_fade),
					u_fill_translate: new t.bV(e, n.u_fill_translate)
				}),
				fillOutline: (e, n) => ({
					u_world: new t.bV(e, n.u_world),
					u_fill_translate: new t.bV(e, n.u_fill_translate)
				}),
				fillOutlinePattern: (e, n) => ({
					u_world: new t.bV(e, n.u_world),
					u_image: new t.bQ(e, n.u_image),
					u_texsize: new t.bV(e, n.u_texsize),
					u_pixel_coord_upper: new t.bV(e, n.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bV(e, n.u_pixel_coord_lower),
					u_scale: new t.bU(e, n.u_scale),
					u_fade: new t.bg(e, n.u_fade),
					u_fill_translate: new t.bV(e, n.u_fill_translate)
				}),
				circle: (e, n) => ({
					u_camera_to_center_distance: new t.bg(e, n.u_camera_to_center_distance),
					u_scale_with_map: new t.bQ(e, n.u_scale_with_map),
					u_pitch_with_map: new t.bQ(e, n.u_pitch_with_map),
					u_extrude_scale: new t.bV(e, n.u_extrude_scale),
					u_device_pixel_ratio: new t.bg(e, n.u_device_pixel_ratio),
					u_globe_extrude_scale: new t.bg(e, n.u_globe_extrude_scale),
					u_translate: new t.bV(e, n.u_translate)
				}),
				collisionBox: (e, n) => ({ u_pixel_extrude_scale: new t.bV(e, n.u_pixel_extrude_scale) }),
				collisionCircle: (e, n) => ({ u_viewport_size: new t.bV(e, n.u_viewport_size) }),
				debug: (e, n) => ({
					u_color: new t.bR(e, n.u_color),
					u_overlay: new t.bQ(e, n.u_overlay),
					u_overlay_scale: new t.bg(e, n.u_overlay_scale)
				}),
				depth: vr,
				clippingMask: vr,
				heatmap: (e, n) => ({
					u_extrude_scale: new t.bg(e, n.u_extrude_scale),
					u_intensity: new t.bg(e, n.u_intensity),
					u_globe_extrude_scale: new t.bg(e, n.u_globe_extrude_scale)
				}),
				heatmapTexture: (e, n) => ({
					u_matrix: new t.bS(e, n.u_matrix),
					u_world: new t.bV(e, n.u_world),
					u_image: new t.bQ(e, n.u_image),
					u_color_ramp: new t.bQ(e, n.u_color_ramp),
					u_opacity: new t.bg(e, n.u_opacity)
				}),
				hillshade: (e, n) => ({
					u_image: new t.bQ(e, n.u_image),
					u_latrange: new t.bV(e, n.u_latrange),
					u_exaggeration: new t.bg(e, n.u_exaggeration),
					u_altitudes: new t.b$(e, n.u_altitudes),
					u_azimuths: new t.b$(e, n.u_azimuths),
					u_accent: new t.bR(e, n.u_accent),
					u_method: new t.bQ(e, n.u_method),
					u_shadows: new t.b_(e, n.u_shadows),
					u_highlights: new t.b_(e, n.u_highlights)
				}),
				hillshadePrepare: (e, n) => ({
					u_matrix: new t.bS(e, n.u_matrix),
					u_image: new t.bQ(e, n.u_image),
					u_dimension: new t.bV(e, n.u_dimension),
					u_zoom: new t.bg(e, n.u_zoom),
					u_unpack: new t.bT(e, n.u_unpack)
				}),
				colorRelief: (e, n) => ({
					u_image: new t.bQ(e, n.u_image),
					u_unpack: new t.bT(e, n.u_unpack),
					u_dimension: new t.bV(e, n.u_dimension),
					u_elevation_stops: new t.bQ(e, n.u_elevation_stops),
					u_color_stops: new t.bQ(e, n.u_color_stops),
					u_color_ramp_size: new t.bQ(e, n.u_color_ramp_size),
					u_opacity: new t.bg(e, n.u_opacity)
				}),
				line: (e, n) => ({
					u_translation: new t.bV(e, n.u_translation),
					u_ratio: new t.bg(e, n.u_ratio),
					u_device_pixel_ratio: new t.bg(e, n.u_device_pixel_ratio),
					u_units_to_pixels: new t.bV(e, n.u_units_to_pixels)
				}),
				lineGradient: (e, n) => ({
					u_translation: new t.bV(e, n.u_translation),
					u_ratio: new t.bg(e, n.u_ratio),
					u_device_pixel_ratio: new t.bg(e, n.u_device_pixel_ratio),
					u_units_to_pixels: new t.bV(e, n.u_units_to_pixels),
					u_image: new t.bQ(e, n.u_image),
					u_image_height: new t.bg(e, n.u_image_height)
				}),
				linePattern: (e, n) => ({
					u_translation: new t.bV(e, n.u_translation),
					u_texsize: new t.bV(e, n.u_texsize),
					u_ratio: new t.bg(e, n.u_ratio),
					u_device_pixel_ratio: new t.bg(e, n.u_device_pixel_ratio),
					u_image: new t.bQ(e, n.u_image),
					u_units_to_pixels: new t.bV(e, n.u_units_to_pixels),
					u_scale: new t.bU(e, n.u_scale),
					u_fade: new t.bg(e, n.u_fade)
				}),
				lineSDF: (e, n) => ({
					u_translation: new t.bV(e, n.u_translation),
					u_ratio: new t.bg(e, n.u_ratio),
					u_device_pixel_ratio: new t.bg(e, n.u_device_pixel_ratio),
					u_units_to_pixels: new t.bV(e, n.u_units_to_pixels),
					u_image: new t.bQ(e, n.u_image),
					u_mix: new t.bg(e, n.u_mix),
					u_tileratio: new t.bg(e, n.u_tileratio),
					u_crossfade_from: new t.bg(e, n.u_crossfade_from),
					u_crossfade_to: new t.bg(e, n.u_crossfade_to),
					u_lineatlas_width: new t.bg(e, n.u_lineatlas_width),
					u_lineatlas_height: new t.bg(e, n.u_lineatlas_height)
				}),
				lineGradientSDF: (e, n) => ({
					u_translation: new t.bV(e, n.u_translation),
					u_ratio: new t.bg(e, n.u_ratio),
					u_device_pixel_ratio: new t.bg(e, n.u_device_pixel_ratio),
					u_units_to_pixels: new t.bV(e, n.u_units_to_pixels),
					u_image: new t.bQ(e, n.u_image),
					u_image_height: new t.bg(e, n.u_image_height),
					u_tileratio: new t.bg(e, n.u_tileratio),
					u_crossfade_from: new t.bg(e, n.u_crossfade_from),
					u_crossfade_to: new t.bg(e, n.u_crossfade_to),
					u_image_dash: new t.bQ(e, n.u_image_dash),
					u_mix: new t.bg(e, n.u_mix),
					u_lineatlas_width: new t.bg(e, n.u_lineatlas_width),
					u_lineatlas_height: new t.bg(e, n.u_lineatlas_height)
				}),
				raster: (e, n) => ({
					u_tl_parent: new t.bV(e, n.u_tl_parent),
					u_scale_parent: new t.bg(e, n.u_scale_parent),
					u_buffer_scale: new t.bg(e, n.u_buffer_scale),
					u_fade_t: new t.bg(e, n.u_fade_t),
					u_opacity: new t.bg(e, n.u_opacity),
					u_image0: new t.bQ(e, n.u_image0),
					u_image1: new t.bQ(e, n.u_image1),
					u_brightness_low: new t.bg(e, n.u_brightness_low),
					u_brightness_high: new t.bg(e, n.u_brightness_high),
					u_saturation_factor: new t.bg(e, n.u_saturation_factor),
					u_contrast_factor: new t.bg(e, n.u_contrast_factor),
					u_spin_weights: new t.bU(e, n.u_spin_weights),
					u_coords_top: new t.bT(e, n.u_coords_top),
					u_coords_bottom: new t.bT(e, n.u_coords_bottom)
				}),
				symbolIcon: (e, n) => ({
					u_is_size_zoom_constant: new t.bQ(e, n.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bQ(e, n.u_is_size_feature_constant),
					u_size_t: new t.bg(e, n.u_size_t),
					u_size: new t.bg(e, n.u_size),
					u_camera_to_center_distance: new t.bg(e, n.u_camera_to_center_distance),
					u_pitch: new t.bg(e, n.u_pitch),
					u_rotate_symbol: new t.bQ(e, n.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e, n.u_aspect_ratio),
					u_fade_change: new t.bg(e, n.u_fade_change),
					u_label_plane_matrix: new t.bS(e, n.u_label_plane_matrix),
					u_coord_matrix: new t.bS(e, n.u_coord_matrix),
					u_is_text: new t.bQ(e, n.u_is_text),
					u_pitch_with_map: new t.bQ(e, n.u_pitch_with_map),
					u_is_along_line: new t.bQ(e, n.u_is_along_line),
					u_is_variable_anchor: new t.bQ(e, n.u_is_variable_anchor),
					u_texsize: new t.bV(e, n.u_texsize),
					u_texture: new t.bQ(e, n.u_texture),
					u_translation: new t.bV(e, n.u_translation),
					u_pitched_scale: new t.bg(e, n.u_pitched_scale)
				}),
				symbolSDF: (e, n) => ({
					u_is_size_zoom_constant: new t.bQ(e, n.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bQ(e, n.u_is_size_feature_constant),
					u_size_t: new t.bg(e, n.u_size_t),
					u_size: new t.bg(e, n.u_size),
					u_camera_to_center_distance: new t.bg(e, n.u_camera_to_center_distance),
					u_pitch: new t.bg(e, n.u_pitch),
					u_rotate_symbol: new t.bQ(e, n.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e, n.u_aspect_ratio),
					u_fade_change: new t.bg(e, n.u_fade_change),
					u_label_plane_matrix: new t.bS(e, n.u_label_plane_matrix),
					u_coord_matrix: new t.bS(e, n.u_coord_matrix),
					u_is_text: new t.bQ(e, n.u_is_text),
					u_pitch_with_map: new t.bQ(e, n.u_pitch_with_map),
					u_is_along_line: new t.bQ(e, n.u_is_along_line),
					u_is_variable_anchor: new t.bQ(e, n.u_is_variable_anchor),
					u_texsize: new t.bV(e, n.u_texsize),
					u_texture: new t.bQ(e, n.u_texture),
					u_gamma_scale: new t.bg(e, n.u_gamma_scale),
					u_device_pixel_ratio: new t.bg(e, n.u_device_pixel_ratio),
					u_is_halo: new t.bQ(e, n.u_is_halo),
					u_translation: new t.bV(e, n.u_translation),
					u_pitched_scale: new t.bg(e, n.u_pitched_scale)
				}),
				symbolTextAndIcon: (e, n) => ({
					u_is_size_zoom_constant: new t.bQ(e, n.u_is_size_zoom_constant),
					u_is_size_feature_constant: new t.bQ(e, n.u_is_size_feature_constant),
					u_size_t: new t.bg(e, n.u_size_t),
					u_size: new t.bg(e, n.u_size),
					u_camera_to_center_distance: new t.bg(e, n.u_camera_to_center_distance),
					u_pitch: new t.bg(e, n.u_pitch),
					u_rotate_symbol: new t.bQ(e, n.u_rotate_symbol),
					u_aspect_ratio: new t.bg(e, n.u_aspect_ratio),
					u_fade_change: new t.bg(e, n.u_fade_change),
					u_label_plane_matrix: new t.bS(e, n.u_label_plane_matrix),
					u_coord_matrix: new t.bS(e, n.u_coord_matrix),
					u_is_text: new t.bQ(e, n.u_is_text),
					u_pitch_with_map: new t.bQ(e, n.u_pitch_with_map),
					u_is_along_line: new t.bQ(e, n.u_is_along_line),
					u_is_variable_anchor: new t.bQ(e, n.u_is_variable_anchor),
					u_texsize: new t.bV(e, n.u_texsize),
					u_texsize_icon: new t.bV(e, n.u_texsize_icon),
					u_texture: new t.bQ(e, n.u_texture),
					u_texture_icon: new t.bQ(e, n.u_texture_icon),
					u_gamma_scale: new t.bg(e, n.u_gamma_scale),
					u_device_pixel_ratio: new t.bg(e, n.u_device_pixel_ratio),
					u_is_halo: new t.bQ(e, n.u_is_halo),
					u_translation: new t.bV(e, n.u_translation),
					u_pitched_scale: new t.bg(e, n.u_pitched_scale)
				}),
				background: (e, n) => ({
					u_opacity: new t.bg(e, n.u_opacity),
					u_color: new t.bR(e, n.u_color)
				}),
				backgroundPattern: (e, n) => ({
					u_opacity: new t.bg(e, n.u_opacity),
					u_image: new t.bQ(e, n.u_image),
					u_pattern_tl_a: new t.bV(e, n.u_pattern_tl_a),
					u_pattern_br_a: new t.bV(e, n.u_pattern_br_a),
					u_pattern_tl_b: new t.bV(e, n.u_pattern_tl_b),
					u_pattern_br_b: new t.bV(e, n.u_pattern_br_b),
					u_texsize: new t.bV(e, n.u_texsize),
					u_mix: new t.bg(e, n.u_mix),
					u_pattern_size_a: new t.bV(e, n.u_pattern_size_a),
					u_pattern_size_b: new t.bV(e, n.u_pattern_size_b),
					u_scale_a: new t.bg(e, n.u_scale_a),
					u_scale_b: new t.bg(e, n.u_scale_b),
					u_pixel_coord_upper: new t.bV(e, n.u_pixel_coord_upper),
					u_pixel_coord_lower: new t.bV(e, n.u_pixel_coord_lower),
					u_tile_units_to_pixels: new t.bg(e, n.u_tile_units_to_pixels)
				}),
				terrain: (e, n) => ({
					u_texture: new t.bQ(e, n.u_texture),
					u_ele_delta: new t.bg(e, n.u_ele_delta),
					u_fog_matrix: new t.bS(e, n.u_fog_matrix),
					u_fog_color: new t.bR(e, n.u_fog_color),
					u_fog_ground_blend: new t.bg(e, n.u_fog_ground_blend),
					u_fog_ground_blend_opacity: new t.bg(e, n.u_fog_ground_blend_opacity),
					u_horizon_color: new t.bR(e, n.u_horizon_color),
					u_horizon_fog_blend: new t.bg(e, n.u_horizon_fog_blend),
					u_is_globe_mode: new t.bg(e, n.u_is_globe_mode)
				}),
				terrainDepth: (e, n) => ({ u_ele_delta: new t.bg(e, n.u_ele_delta) }),
				terrainCoords: (e, n) => ({
					u_texture: new t.bQ(e, n.u_texture),
					u_terrain_coords_id: new t.bg(e, n.u_terrain_coords_id),
					u_ele_delta: new t.bg(e, n.u_ele_delta)
				}),
				projectionErrorMeasurement: (e, n) => ({
					u_input: new t.bg(e, n.u_input),
					u_output_expected: new t.bg(e, n.u_output_expected)
				}),
				atmosphere: (e, n) => ({
					u_sun_pos: new t.bU(e, n.u_sun_pos),
					u_atmosphere_blend: new t.bg(e, n.u_atmosphere_blend),
					u_globe_position: new t.bU(e, n.u_globe_position),
					u_globe_radius: new t.bg(e, n.u_globe_radius),
					u_inv_proj_matrix: new t.bS(e, n.u_inv_proj_matrix)
				}),
				sky: (e, n) => ({
					u_sky_color: new t.bR(e, n.u_sky_color),
					u_horizon_color: new t.bR(e, n.u_horizon_color),
					u_horizon: new t.bV(e, n.u_horizon),
					u_horizon_normal: new t.bV(e, n.u_horizon_normal),
					u_sky_horizon_blend: new t.bg(e, n.u_sky_horizon_blend),
					u_sky_blend: new t.bg(e, n.u_sky_blend)
				})
			};
			class br {
				constructor(e, t, n) {
					this.context = e;
					let i = e.gl;
					this.buffer = i.createBuffer(), this.dynamicDraw = !!n, this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? i.DYNAMIC_DRAW : i.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer;
				}
				bind() {
					this.context.bindElementBuffer.set(this.buffer);
				}
				updateData(e) {
					let t = this.context.gl;
					if (!this.dynamicDraw) throw Error("Attempted to update data while not in dynamic mode.");
					this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			let xr = {
				Int8: "BYTE",
				Uint8: "UNSIGNED_BYTE",
				Int16: "SHORT",
				Uint16: "UNSIGNED_SHORT",
				Int32: "INT",
				Uint32: "UNSIGNED_INT",
				Float32: "FLOAT"
			};
			class Sr {
				constructor(e, t, n, i) {
					this.length = t.length, this.attributes = n, this.itemSize = t.bytesPerElement, this.dynamicDraw = i, this.context = e;
					let a = e.gl;
					this.buffer = a.createBuffer(), e.bindVertexBuffer.set(this.buffer), a.bufferData(a.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer;
				}
				bind() {
					this.context.bindVertexBuffer.set(this.buffer);
				}
				updateData(e) {
					if (e.length !== this.length) throw Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
					let t = this.context.gl;
					this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);
				}
				enableAttributes(e, t) {
					for (let n = 0; n < this.attributes.length; n++) {
						let i = t.attributes[this.attributes[n].name];
						i !== void 0 && e.enableVertexAttribArray(i);
					}
				}
				setVertexAttribPointers(e, t, n) {
					for (let i = 0; i < this.attributes.length; i++) {
						let a = this.attributes[i], o = t.attributes[a.name];
						o !== void 0 && e.vertexAttribPointer(o, a.components, e[xr[a.type]], !1, this.itemSize, a.offset + this.itemSize * (n || 0));
					}
				}
				destroy() {
					this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
				}
			}
			class Cr {
				constructor(e) {
					this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
				}
				get() {
					return this.current;
				}
				set(e) {}
				getDefault() {
					return this.default;
				}
				setDefault() {
					this.set(this.default);
				}
			}
			class wr extends Cr {
				getDefault() {
					return t.bf.transparent;
				}
				set(e) {
					let t = this.current;
					(e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
				}
			}
			class Tr extends Cr {
				getDefault() {
					return 1;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
				}
			}
			class Er extends Cr {
				getDefault() {
					return 0;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
				}
			}
			class Dr extends Cr {
				getDefault() {
					return [
						!0,
						!0,
						!0,
						!0
					];
				}
				set(e) {
					let t = this.current;
					(e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
				}
			}
			class Or extends Cr {
				getDefault() {
					return !0;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
				}
			}
			class kr extends Cr {
				getDefault() {
					return 255;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
				}
			}
			class Ar extends Cr {
				getDefault() {
					return {
						func: this.gl.ALWAYS,
						ref: 0,
						mask: 255
					};
				}
				set(e) {
					let t = this.current;
					(e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
				}
			}
			class jr extends Cr {
				getDefault() {
					let e = this.gl;
					return [
						e.KEEP,
						e.KEEP,
						e.KEEP
					];
				}
				set(e) {
					let t = this.current;
					(e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
				}
			}
			class Mr extends Cr {
				getDefault() {
					return !1;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;
				}
			}
			class Nr extends Cr {
				getDefault() {
					return [0, 1];
				}
				set(e) {
					let t = this.current;
					(e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
				}
			}
			class Pr extends Cr {
				getDefault() {
					return !1;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;
				}
			}
			class Fr extends Cr {
				getDefault() {
					return this.gl.LESS;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
				}
			}
			class Ir extends Cr {
				getDefault() {
					return !1;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;
				}
			}
			class Lr extends Cr {
				getDefault() {
					let e = this.gl;
					return [e.ONE, e.ZERO];
				}
				set(e) {
					let t = this.current;
					(e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1);
				}
			}
			class Rr extends Cr {
				getDefault() {
					return t.bf.transparent;
				}
				set(e) {
					let t = this.current;
					(e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
				}
			}
			class zr extends Cr {
				getDefault() {
					return this.gl.FUNC_ADD;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1);
				}
			}
			class Br extends Cr {
				getDefault() {
					return !1;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;
				}
			}
			class Vr extends Cr {
				getDefault() {
					return this.gl.BACK;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
				}
			}
			class Hr extends Cr {
				getDefault() {
					return this.gl.CCW;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
				}
			}
			class Ur extends Cr {
				getDefault() {
					return null;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
				}
			}
			class Wr extends Cr {
				getDefault() {
					return this.gl.TEXTURE0;
				}
				set(e) {
					(e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
				}
			}
			class Gr extends Cr {
				getDefault() {
					let e = this.gl;
					return [
						0,
						0,
						e.drawingBufferWidth,
						e.drawingBufferHeight
					];
				}
				set(e) {
					let t = this.current;
					(e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
				}
			}
			class Kr extends Cr {
				getDefault() {
					return null;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
				}
			}
			class qr extends Cr {
				getDefault() {
					return null;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
				}
			}
			class Jr extends Cr {
				getDefault() {
					return null;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;
				}
			}
			class Yr extends Cr {
				getDefault() {
					return null;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
				}
			}
			class Xr extends Cr {
				getDefault() {
					return null;
				}
				set(e) {
					let t = this.gl;
					t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
				}
			}
			class Zr extends Cr {
				getDefault() {
					return null;
				}
				set(e) {
					var t;
					if (e === this.current && !this.dirty) return;
					let n = this.gl;
					rn(n) ? n.bindVertexArray(e) : (t = n.getExtension("OES_vertex_array_object")) == null || t.bindVertexArrayOES(e), this.current = e, this.dirty = !1;
				}
			}
			class Qr extends Cr {
				getDefault() {
					return 4;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
				}
			}
			class $r extends Cr {
				getDefault() {
					return !1;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
				}
			}
			class ei extends Cr {
				getDefault() {
					return !1;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					let t = this.gl;
					t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
				}
			}
			class ti extends Cr {
				constructor(e, t) {
					super(e), this.context = e, this.parent = t;
				}
				getDefault() {
					return null;
				}
			}
			class ni extends ti {
				setDirty() {
					this.dirty = !0;
				}
				set(e) {
					if (e === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					let t = this.gl;
					t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
				}
			}
			class ri extends ti {
				set(e) {
					if (e === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					let t = this.gl;
					t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
				}
			}
			class ii extends ti {
				set(e) {
					if (e === this.current && !this.dirty) return;
					this.context.bindFramebuffer.set(this.parent);
					let t = this.gl;
					t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = !1;
				}
			}
			let ai = "Framebuffer is not complete";
			class oi {
				constructor(e, t, n, i, a) {
					this.context = e, this.width = t, this.height = n;
					let o = e.gl, s = this.framebuffer = o.createFramebuffer();
					if (this.colorAttachment = new ni(e, s), i) this.depthAttachment = a ? new ii(e, s) : new ri(e, s);
					else if (a) throw Error("Stencil cannot be set without depth");
					if (o.checkFramebufferStatus(o.FRAMEBUFFER) !== o.FRAMEBUFFER_COMPLETE) throw Error(ai);
				}
				destroy() {
					let e = this.context.gl, t = this.colorAttachment.get();
					if (t && e.deleteTexture(t), this.depthAttachment) {
						let t = this.depthAttachment.get();
						t && e.deleteRenderbuffer(t);
					}
					e.deleteFramebuffer(this.framebuffer);
				}
			}
			class si {
				constructor(e) {
					if (this.gl = e, this.clearColor = new wr(this), this.clearDepth = new Tr(this), this.clearStencil = new Er(this), this.colorMask = new Dr(this), this.depthMask = new Or(this), this.stencilMask = new kr(this), this.stencilFunc = new Ar(this), this.stencilOp = new jr(this), this.stencilTest = new Mr(this), this.depthRange = new Nr(this), this.depthTest = new Pr(this), this.depthFunc = new Fr(this), this.blend = new Ir(this), this.blendFunc = new Lr(this), this.blendColor = new Rr(this), this.blendEquation = new zr(this), this.cullFace = new Br(this), this.cullFaceSide = new Vr(this), this.frontFace = new Hr(this), this.program = new Ur(this), this.activeTexture = new Wr(this), this.viewport = new Gr(this), this.bindFramebuffer = new Kr(this), this.bindRenderbuffer = new qr(this), this.bindTexture = new Jr(this), this.bindVertexBuffer = new Yr(this), this.bindElementBuffer = new Xr(this), this.bindVertexArray = new Zr(this), this.pixelStoreUnpack = new Qr(this), this.pixelStoreUnpackPremultiplyAlpha = new $r(this), this.pixelStoreUnpackFlipY = new ei(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), rn(e)) {
						this.HALF_FLOAT = e.HALF_FLOAT;
						let t = e.getExtension("EXT_color_buffer_half_float");
						this.RGBA16F = e.RGBA16F ?? t?.RGBA16F_EXT, this.RGB16F = e.RGB16F ?? t?.RGB16F_EXT, e.getExtension("EXT_color_buffer_float");
					} else e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear"), this.HALF_FLOAT = e.getExtension("OES_texture_half_float")?.HALF_FLOAT_OES;
				}
				setDefault() {
					this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
				}
				setDirty() {
					this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
				}
				createIndexBuffer(e, t) {
					return new br(this, e, t);
				}
				createVertexBuffer(e, t, n) {
					return new Sr(this, e, t, n);
				}
				createRenderbuffer(e, t, n) {
					let i = this.gl, a = i.createRenderbuffer();
					return this.bindRenderbuffer.set(a), i.renderbufferStorage(i.RENDERBUFFER, e, t, n), this.bindRenderbuffer.set(null), a;
				}
				createFramebuffer(e, t, n, i) {
					return new oi(this, e, t, n, i);
				}
				clear({ color: e, depth: t, stencil: n }) {
					let i = this.gl, a = 0;
					e && (a |= i.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([
						!0,
						!0,
						!0,
						!0
					])), t !== void 0 && (a |= i.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), n !== void 0 && (a |= i.STENCIL_BUFFER_BIT, this.clearStencil.set(n), this.stencilMask.set(255)), i.clear(a);
				}
				setCullFace(e) {
					!1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
				}
				setDepthMode(e) {
					e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
				}
				setStencilMode(e) {
					e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([
						e.fail,
						e.depthFail,
						e.pass
					]), this.stencilFunc.set({
						func: e.test.func,
						ref: e.ref,
						mask: e.test.mask
					})) : this.stencilTest.set(!1);
				}
				setColorMode(e) {
					t.bH(e.blendFunction, Zt.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask);
				}
				createVertexArray() {
					return rn(this.gl) ? this.gl.createVertexArray() : this.gl.getExtension("OES_vertex_array_object")?.createVertexArrayOES();
				}
				deleteVertexArray(e) {
					return rn(this.gl) ? this.gl.deleteVertexArray(e) : this.gl.getExtension("OES_vertex_array_object")?.deleteVertexArrayOES(e);
				}
				unbindVAO() {
					this.bindVertexArray.set(null);
				}
			}
			let ci;
			function li(e, n, i, a, o) {
				let s = e.context, c = e.transform, l = s.gl, u = e.useProgram("collisionBox"), d = [], f = 0, p = 0;
				for (let t = 0; t < a.length; t++) {
					let m = a[t], h = n.getTile(m).getBucket(i);
					if (!h) continue;
					let g = o ? h.textCollisionBox : h.iconCollisionBox, _ = h.collisionCircleArray;
					_.length > 0 && (d.push({
						circleArray: _,
						circleOffset: p,
						coord: m
					}), f += _.length / 4, p = f), g && u.draw(s, l.LINES, $t.disabled, tn.disabled, e.colorModeForRenderPass(), K.disabled, Yn(e.transform), e.style.map.terrain && e.style.map.terrain.getTerrainData(m), c.getProjectionData({
						overscaledTileID: m,
						applyGlobeMatrix: !0,
						applyTerrainMatrix: !0
					}), i.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, null, e.transform.zoom, null, null, g.collisionVertexBuffer);
				}
				if (!o || !d.length) return;
				let m = e.useProgram("collisionCircle"), h = new t.c0();
				h.resize(4 * f), h._trim();
				let g = 0;
				for (let e of d) for (let t = 0; t < e.circleArray.length / 4; t++) {
					let n = 4 * t, i = e.circleArray[n + 0], a = e.circleArray[n + 1], o = e.circleArray[n + 2], s = e.circleArray[n + 3];
					h.emplace(g++, i, a, o, s, 0), h.emplace(g++, i, a, o, s, 1), h.emplace(g++, i, a, o, s, 2), h.emplace(g++, i, a, o, s, 3);
				}
				(!ci || ci.length < 2 * f) && (ci = function(e) {
					let n = 2 * e, i = new t.c2();
					i.resize(n), i._trim();
					for (let e = 0; e < n; e++) {
						let t = 6 * e;
						i.uint16[t + 0] = 4 * e + 0, i.uint16[t + 1] = 4 * e + 1, i.uint16[t + 2] = 4 * e + 2, i.uint16[t + 3] = 4 * e + 2, i.uint16[t + 4] = 4 * e + 3, i.uint16[t + 5] = 4 * e + 0;
					}
					return i;
				}(f));
				let _ = s.createIndexBuffer(ci, !0), v = s.createVertexBuffer(h, t.c1.members, !0);
				for (let n of d) {
					let a = Xn(e.transform);
					m.draw(s, l.TRIANGLES, $t.disabled, tn.disabled, e.colorModeForRenderPass(), K.disabled, a, e.style.map.terrain && e.style.map.terrain.getTerrainData(n.coord), null, i.id, v, _, t.aM.simpleSegment(0, 2 * n.circleOffset, n.circleArray.length, n.circleArray.length / 2), null, e.transform.zoom, null, null, null);
				}
				v.destroy(), _.destroy();
			}
			let ui = t.ai(new Float32Array(16));
			function di(e, n, i, a, o, s) {
				let { horizontalAlign: c, verticalAlign: l } = t.aH(e);
				return new t.P((-(c - .5) * n / o + a[0]) * s, (-(l - .5) * i / o + a[1]) * s);
			}
			function fi(e, n, i, a, o, s) {
				let c = n.tileAnchorPoint.add(new t.P(n.translation[0], n.translation[1]));
				if (n.pitchWithMap) {
					let e = a.mult(s);
					i || (e = e.rotate(-o));
					let t = c.add(e);
					return Ke(t.x, t.y, n.pitchedLabelPlaneMatrix, n.getElevation).point;
				}
				if (i) {
					let t = et(n.tileAnchorPoint.x + 1, n.tileAnchorPoint.y, n).point.sub(e), i = Math.atan(t.y / t.x) + (t.x < 0 ? Math.PI : 0);
					return e.add(a.rotate(i));
				}
				return e.add(a);
			}
			function pi(e, n, i, a, o, s, c, l, u, d, f, p) {
				let m = e.text.placedSymbolArray, h = e.text.dynamicLayoutVertexArray, g = e.icon.dynamicLayoutVertexArray, _ = {};
				h.clear();
				for (let g = 0; g < m.length; g++) {
					let v = m.get(g), y = v.hidden || !v.crossTileID || e.allowVerticalPlacement && !v.placedOrientation ? null : a[v.crossTileID];
					if (y) {
						let a = new t.P(v.anchorX, v.anchorY), m = {
							getElevation: p,
							width: o.width,
							height: o.height,
							pitchedLabelPlaneMatrix: s,
							pitchWithMap: i,
							transform: o,
							tileAnchorPoint: a,
							translation: d,
							unwrappedTileID: f
						}, g = i ? nt(a.x, a.y, m) : et(a.x, a.y, m), b = qe(o.cameraToCenterDistance, g.signedDistanceFromCamera), x = t.ap(e.textSizeData, l, v) * b / t.aB;
						i && (x *= e.tilePixelRatio / c);
						let { width: S, height: C, anchor: w, textOffset: T, textBoxScale: E } = y, O = di(w, S, C, T, E, x), k = o.getPitchedTextCorrection(a.x + d[0], a.y + d[1], f), A = fi(g.point, m, n, O, -o.bearingInRadians, k), j = e.allowVerticalPlacement && v.placedOrientation === t.ao.vertical ? Math.PI / 2 : 0;
						for (let e = 0; e < v.numGlyphs; e++) t.av(h, A, j);
						u && v.associatedIconIndex >= 0 && (_[v.associatedIconIndex] = {
							shiftedAnchor: A,
							angle: j
						});
					} else st(v.numGlyphs, h);
				}
				if (u) {
					g.clear();
					let n = e.icon.placedSymbolArray;
					for (let e = 0; e < n.length; e++) {
						let i = n.get(e);
						if (i.hidden) st(i.numGlyphs, g);
						else {
							let n = _[e];
							if (n) for (let e = 0; e < i.numGlyphs; e++) t.av(g, n.shiftedAnchor, n.angle);
							else st(i.numGlyphs, g);
						}
					}
					e.icon.dynamicLayoutVertexBuffer.updateData(g);
				}
				e.text.dynamicLayoutVertexBuffer.updateData(h);
			}
			function mi(e, t, n) {
				return n.iconsInText && t ? "symbolTextAndIcon" : e ? "symbolSDF" : "symbolIcon";
			}
			function hi(e, n, i, a, o, s, c, l, u, d, f, p, m) {
				let h = e.context, g = h.gl, _ = e.transform, v = l === "map", y = u === "map", b = l !== "viewport" && i.layout.get("symbol-placement") !== "point", x = v && !y && !b, S = !i.layout.get("symbol-sort-key").isConstant(), C = !1, w = e.getDepthModeForSublayer(0, $t.ReadOnly), T = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset"), E = [], O = _.getCircleRadiusCorrection();
				for (let l of a) {
					let a = n.getTile(l), u = a.getBucket(i);
					if (!u) continue;
					let f = o ? u.text : u.icon;
					if (!f || !f.segments.get().length || !f.hasVisibleVertices) continue;
					let p = f.programConfigurations.get(i.id), h = o || u.sdfIcons, w = o ? u.textSizeData : u.iconSizeData, k = y || _.pitch !== 0, A = e.useProgram(mi(h, o, u), p), j = t.an(w, _.zoom), M = e.style.map.terrain && e.style.map.terrain.getTerrainData(l), N, P, F, I, ee = [0, 0], L = null;
					if (o) P = a.glyphAtlasTexture, F = g.LINEAR, N = a.glyphAtlasTexture.size, u.iconsInText && (ee = a.imageAtlasTexture.size, L = a.imageAtlasTexture, I = k || e.options.rotating || e.options.zooming || w.kind === "composite" || w.kind === "camera" ? g.LINEAR : g.NEAREST);
					else {
						let t = i.layout.get("icon-size").constantOr(0) !== 1 || u.iconsNeedLinear;
						P = a.imageAtlasTexture, F = h || e.options.rotating || e.options.zooming || t || k ? g.LINEAR : g.NEAREST, N = a.imageAtlasTexture.size;
					}
					let R = t.aC(a, 1, e.transform.zoom), te = We(v, e.transform, R), ne = t.L();
					t.aq(ne, te);
					let ie = W(y, v, e.transform, R), ae = t.aD(_, a, s, c), oe = _.getProjectionData({
						overscaledTileID: l,
						applyGlobeMatrix: !m,
						applyTerrainMatrix: !0
					}), z = T && u.hasTextData(), se = i.layout.get("icon-text-fit") !== "none" && z && u.hasIconData();
					if (b) {
						let t = e.style.map.terrain ? (t, n) => e.style.map.terrain.getElevation(l, t, n) : null, n = i.layout.get("text-rotation-alignment") === "map";
						G(u, e, o, te, ne, y, d, n, l.toUnwrapped(), _.width, _.height, ae, t);
					}
					let ce = o && T || se, le = b || ce ? ui : y ? te : e.transform.clipSpaceToPixelsMatrix, ue = h && i.paint.get(o ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0, de;
					de = h ? u.iconsInText ? hr(w.kind, j, x, y, b, ce, e, le, ie, ae, N, ee, O) : mr(w.kind, j, x, y, b, ce, e, le, ie, ae, o, N, 0, O) : pr(w.kind, j, x, y, b, ce, e, le, ie, ae, o, N, O);
					let fe = {
						program: A,
						buffers: f,
						uniformValues: de,
						projectionData: oe,
						atlasTexture: P,
						atlasTextureIcon: L,
						atlasInterpolation: F,
						atlasInterpolationIcon: I,
						isSDF: h,
						hasHalo: ue
					};
					if (S && u.canOverlap) {
						C = !0;
						let e = f.segments.get();
						for (let n of e) E.push({
							segments: new t.aM([n]),
							sortKey: n.sortKey,
							state: fe,
							terrainData: M
						});
					} else E.push({
						segments: f.segments,
						sortKey: 0,
						state: fe,
						terrainData: M
					});
				}
				C && E.sort(((e, t) => e.sortKey - t.sortKey));
				for (let t of E) {
					let n = t.state;
					if (h.activeTexture.set(g.TEXTURE0), n.atlasTexture.bind(n.atlasInterpolation, g.CLAMP_TO_EDGE), n.atlasTextureIcon && (h.activeTexture.set(g.TEXTURE1), n.atlasTextureIcon && n.atlasTextureIcon.bind(n.atlasInterpolationIcon, g.CLAMP_TO_EDGE)), n.isSDF) {
						let a = n.uniformValues;
						n.hasHalo && (a.u_is_halo = 1, gi(n.buffers, t.segments, i, e, n.program, w, f, p, a, n.projectionData, t.terrainData)), a.u_is_halo = 0;
					}
					gi(n.buffers, t.segments, i, e, n.program, w, f, p, n.uniformValues, n.projectionData, t.terrainData);
				}
			}
			function gi(e, t, n, i, a, o, s, c, l, u, d) {
				let f = i.context;
				a.draw(f, f.gl.TRIANGLES, o, s, c, K.backCCW, l, d, u, n.id, e.layoutVertexBuffer, e.indexBuffer, t, n.paint, i.transform.zoom, e.programConfigurations.get(n.id), e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer);
			}
			function _i(e, n, i, a, o) {
				let s = e.context, c = s.gl, l = tn.disabled, u = new Zt([c.ONE, c.ONE], t.bf.transparent, [
					!0,
					!0,
					!0,
					!0
				]), d = n.getBucket(i);
				if (!d) return;
				let f = a.key, p = i.heatmapFbos.get(f);
				p || (p = yi(s, n.tileSize, n.tileSize), i.heatmapFbos.set(f, p)), s.bindFramebuffer.set(p.framebuffer), s.viewport.set([
					0,
					0,
					n.tileSize,
					n.tileSize
				]), s.clear({ color: t.bf.transparent });
				let m = d.programConfigurations.get(i.id), h = e.useProgram("heatmap", m, !o), g = e.transform.getProjectionData({
					overscaledTileID: n.tileID,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				}), _ = e.style.map.terrain.getTerrainData(a);
				h.draw(s, c.TRIANGLES, $t.disabled, l, u, K.disabled, Qn(n, e.transform.zoom, i.paint.get("heatmap-intensity"), 1), _, g, i.id, d.layoutVertexBuffer, d.indexBuffer, d.segments, i.paint, e.transform.zoom, m);
			}
			function vi(e, t, n, i, a) {
				let o = e.context, s = o.gl, c = e.transform;
				o.setColorMode(e.colorModeForRenderPass());
				let l = bi(o, t), u = n.key, d = t.heatmapFbos.get(u);
				if (!d) return;
				o.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, d.colorAttachment.get()), o.activeTexture.set(s.TEXTURE1), l.bind(s.LINEAR, s.CLAMP_TO_EDGE);
				let f = c.getProjectionData({
					overscaledTileID: n,
					applyTerrainMatrix: a,
					applyGlobeMatrix: !i
				});
				e.useProgram("heatmapTexture").draw(o, s.TRIANGLES, $t.disabled, tn.disabled, e.colorModeForRenderPass(), K.disabled, $n(e, t, 0, 1), null, f, t.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments, t.paint, c.zoom), d.destroy(), t.heatmapFbos.delete(u);
			}
			function yi(e, t, n) {
				let i = e.gl, a = i.createTexture();
				i.bindTexture(i.TEXTURE_2D, a), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR);
				let o = e.HALF_FLOAT ?? i.UNSIGNED_BYTE, s = e.RGBA16F ?? i.RGBA;
				i.texImage2D(i.TEXTURE_2D, 0, s, t, n, 0, i.RGBA, o, null);
				let c = e.createFramebuffer(t, n, !1, !1);
				return c.colorAttachment.set(a), c;
			}
			function bi(e, n) {
				return n.colorRampTexture ||= new t.T(e, n.colorRamp, e.gl.RGBA), n.colorRampTexture;
			}
			function xi(e, n, i, a, o, s, c, l) {
				let u = 256;
				if (o.stepInterpolant) {
					let a = n.getSource().maxzoom, o = c.canonical.z === a ? Math.ceil(1 << e.transform.maxZoom - c.canonical.z) : 1;
					u = t.ae(t.c4(s.maxLineLength / t.$ * 1024 * o), 256, i.maxTextureSize);
				}
				return l.gradient = t.c5({
					expression: o.gradientExpression(),
					evaluationKey: "lineProgress",
					resolution: u,
					image: l.gradient || void 0,
					clips: s.lineClipsArray
				}), l.texture ? l.texture.update(l.gradient) : l.texture = new t.T(i, l.gradient, a.RGBA), l.version = o.gradientVersion, l.texture;
			}
			function Si(e, t, n, i, a) {
				e.activeTexture.set(t.TEXTURE0), n.imageAtlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE), i.updatePaintBuffers(a);
			}
			function Ci(e, t, n, i, a, o) {
				(a || e.lineAtlas.dirty) && (t.activeTexture.set(n.TEXTURE0), e.lineAtlas.bind(t)), i.updatePaintBuffers(o);
			}
			function wi(e, t, n, i, a, o, s) {
				let c = o.gradients[a.id], l = c.texture;
				a.gradientVersion !== c.version && (l = xi(e, t, n, i, a, o, s, c)), n.activeTexture.set(i.TEXTURE0), l.bind(a.stepInterpolant ? i.NEAREST : i.LINEAR, i.CLAMP_TO_EDGE);
			}
			function Ti(e, t, n, i, a, o, s, c, l) {
				let u = o.gradients[a.id], d = u.texture;
				a.gradientVersion !== u.version && (d = xi(e, t, n, i, a, o, s, u)), n.activeTexture.set(i.TEXTURE0), d.bind(a.stepInterpolant ? i.NEAREST : i.LINEAR, i.CLAMP_TO_EDGE), n.activeTexture.set(i.TEXTURE1), e.lineAtlas.bind(n), c.updatePaintBuffers(l);
			}
			function Ei(e, t, n, i, a) {
				if (!n || !i || !i.imageAtlas) return;
				let o = i.imageAtlas.patternPositions, s = o[n.to.toString()], c = o[n.from.toString()];
				if (!s && c && (s = c), !c && s && (c = s), !s || !c) {
					let e = a.getPaintProperty(t);
					s = o[e], c = o[e];
				}
				s && c && e.setConstantPatternPositions(s, c);
			}
			function Di(e, n, i, a, o, s, c, l) {
				let u = e.context.gl, d = "fill-pattern", f = i.paint.get(d), p = f && f.constantOr(1), m = i.getCrossfadeParameters(), h, g, _, v, y, b = e.transform, x = i.paint.get("fill-translate"), S = i.paint.get("fill-translate-anchor");
				c ? (g = p && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", h = u.LINES) : (g = p ? "fillPattern" : "fill", h = u.TRIANGLES);
				let C = f.constantOr(null);
				for (let f of a) {
					let a = n.getTile(f);
					if (p && !a.patternsLoaded()) continue;
					let w = a.getBucket(i);
					if (!w) continue;
					let T = w.programConfigurations.get(i.id), E = e.useProgram(g, T), O = e.style.map.terrain && e.style.map.terrain.getTerrainData(f);
					p && (e.context.activeTexture.set(u.TEXTURE0), a.imageAtlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE), T.updatePaintBuffers(m)), Ei(T, d, C, a, i);
					let k = b.getProjectionData({
						overscaledTileID: f,
						applyGlobeMatrix: !l,
						applyTerrainMatrix: !0
					}), A = t.aD(b, a, x, S);
					if (c) {
						v = w.indexBuffer2, y = w.segments2;
						let t = [u.drawingBufferWidth, u.drawingBufferHeight];
						_ = g === "fillOutlinePattern" && p ? qn(e, m, a, t, A) : Kn(t, A);
					} else v = w.indexBuffer, y = w.segments, _ = p ? Gn(e, m, a, A) : { u_fill_translate: A };
					let j = e.stencilModeForClipping(f);
					E.draw(e.context, h, o, j, s, K.backCCW, _, O, k, i.id, w.layoutVertexBuffer, v, y, i.paint, e.transform.zoom, T);
				}
			}
			function Oi(e, n, i, a, o, s, c, l) {
				let u = e.context, d = u.gl, f = "fill-extrusion-pattern", p = i.paint.get(f), m = p.constantOr(1), h = i.getCrossfadeParameters(), g = i.paint.get("fill-extrusion-opacity"), _ = p.constantOr(null), v = e.transform;
				for (let p of a) {
					let a = n.getTile(p), y = a.getBucket(i);
					if (!y) continue;
					let b = e.style.map.terrain && e.style.map.terrain.getTerrainData(p), x = y.programConfigurations.get(i.id), S = e.useProgram(m ? "fillExtrusionPattern" : "fillExtrusion", x);
					m && (e.context.activeTexture.set(d.TEXTURE0), a.imageAtlasTexture.bind(d.LINEAR, d.CLAMP_TO_EDGE), x.updatePaintBuffers(h));
					let C = v.getProjectionData({
						overscaledTileID: p,
						applyGlobeMatrix: !l,
						applyTerrainMatrix: !0
					});
					Ei(x, f, _, a, i);
					let w = t.aD(v, a, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor")), T = i.paint.get("fill-extrusion-vertical-gradient"), E = m ? Wn(e, T, g, w, p, h, a) : Un(e, T, g, w);
					S.draw(u, u.gl.TRIANGLES, o, s, c, K.backCCW, E, b, C, i.id, y.layoutVertexBuffer, y.indexBuffer, y.segments, i.paint, e.transform.zoom, x, e.style.map.terrain && y.centroidVertexBuffer);
				}
			}
			function ki(e, t, n, i, a, o, s, c, l) {
				let u = e.style.projection, d = e.context, f = e.transform, p = d.gl, m = [`#define NUM_ILLUMINATION_SOURCES ${n.paint.get("hillshade-highlight-color").values.length}`], h = e.useProgram("hillshade", null, !1, m), g = !e.options.moving;
				for (let m of i) {
					let i = t.getTile(m), _ = i.fbo;
					if (!_) continue;
					let v = u.getMeshFromTileID(d, m.canonical, c, !0, "raster"), y = e.style.map.terrain?.getTerrainData(m);
					d.activeTexture.set(p.TEXTURE0), p.bindTexture(p.TEXTURE_2D, _.colorAttachment.get());
					let b = f.getProjectionData({
						overscaledTileID: m,
						aligned: g,
						applyGlobeMatrix: !l,
						applyTerrainMatrix: !0
					});
					h.draw(d, p.TRIANGLES, o, a[m.overscaledZ], s, K.backCCW, er(e, i, n), y, b, n.id, v.vertexBuffer, v.indexBuffer, v.segments);
				}
			}
			function Ai(e, n, i, a, o, s, c, l, u) {
				let d = e.style.projection, f = e.context, p = e.transform, m = f.gl, h = e.useProgram("colorRelief"), g = !e.options.moving, _ = !0, v = 0;
				for (let y of a) {
					let a = n.getTile(y), b = a.dem;
					if (_) {
						let e = m.getParameter(m.MAX_TEXTURE_SIZE), { elevationTexture: t, colorTexture: n } = i.getColorRampTextures(f, e, b.getUnpackVector());
						f.activeTexture.set(m.TEXTURE1), t.bind(m.NEAREST, m.CLAMP_TO_EDGE), f.activeTexture.set(m.TEXTURE4), n.bind(m.LINEAR, m.CLAMP_TO_EDGE), _ = !1, v = t.size[0];
					}
					if (!b || !b.data) continue;
					let x = b.stride, S = b.getPixels();
					if (f.activeTexture.set(m.TEXTURE0), f.pixelStoreUnpackPremultiplyAlpha.set(!1), a.demTexture = a.demTexture || e.getTileTexture(x), a.demTexture) {
						let e = a.demTexture;
						e.update(S, { premultiply: !1 }), e.bind(m.LINEAR, m.CLAMP_TO_EDGE);
					} else a.demTexture = new t.T(f, S, m.RGBA, { premultiply: !1 }), a.demTexture.bind(m.LINEAR, m.CLAMP_TO_EDGE);
					let C = d.getMeshFromTileID(f, y.canonical, l, !0, "raster"), w = e.style.map.terrain?.getTerrainData(y), T = p.getProjectionData({
						overscaledTileID: y,
						aligned: g,
						applyGlobeMatrix: !u,
						applyTerrainMatrix: !0
					});
					h.draw(f, m.TRIANGLES, s, o[y.overscaledZ], c, K.backCCW, rr(i, a.dem, v), w, T, i.id, C.vertexBuffer, C.indexBuffer, C.segments);
				}
			}
			let ji = [
				new t.P(0, 0),
				new t.P(t.$, 0),
				new t.P(t.$, t.$),
				new t.P(0, t.$)
			];
			function Mi(e, t, n, i, a, o, s, c, l = !1, u = !1) {
				let d = i[i.length - 1].overscaledZ, f = e.context, p = f.gl, m = e.useProgram("raster"), h = e.transform, g = e.style.projection, _ = e.colorModeForRenderPass(), v = !e.options.moving, y = n.paint.get("raster-opacity"), b = n.paint.get("raster-resampling"), x = n.paint.get("raster-fade-duration"), S = !!e.style.map.terrain;
				for (let C of i) {
					let i = e.getDepthModeForSublayer(C.overscaledZ - d, y === 1 ? $t.ReadWrite : $t.ReadOnly, p.LESS), w = t.getTile(C), T = b === "nearest" ? p.NEAREST : p.LINEAR;
					f.activeTexture.set(p.TEXTURE0), w.texture.bind(T, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST), f.activeTexture.set(p.TEXTURE1);
					let { parentTile: E, parentScaleBy: O, parentTopLeft: k, fadeValues: A } = Ni(w, t, x, S);
					w.fadeOpacity = A.tileOpacity, E ? (E.fadeOpacity = A.parentTileOpacity, E.texture.bind(T, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST)) : w.texture.bind(T, p.CLAMP_TO_EDGE, p.LINEAR_MIPMAP_NEAREST), w.texture.useMipmap && f.extTextureFilterAnisotropic && e.transform.pitch > 20 && p.texParameterf(p.TEXTURE_2D, f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f.extTextureFilterAnisotropicMax);
					let j = e.style.map.terrain && e.style.map.terrain.getTerrainData(C), M = h.getProjectionData({
						overscaledTileID: C,
						aligned: v,
						applyGlobeMatrix: !u,
						applyTerrainMatrix: !0
					}), N = dr(k, O, A.fadeMix, n, c), P = g.getMeshFromTileID(f, C.canonical, o, s, "raster");
					m.draw(f, p.TRIANGLES, i, a ? a[C.overscaledZ] : tn.disabled, _, l ? K.frontCCW : K.backCCW, N, j, M, n.id, P.vertexBuffer, P.indexBuffer, P.segments);
				}
			}
			function Ni(e, n, i, a) {
				let o = {
					parentTile: null,
					parentScaleBy: 1,
					parentTopLeft: [0, 0],
					fadeValues: {
						tileOpacity: 1,
						parentTileOpacity: 1,
						fadeMix: {
							opacity: 1,
							mix: 0
						}
					}
				};
				if (i === 0 || a) return o;
				if (e.fadingParentID) {
					let a = n._getLoadedTile(e.fadingParentID);
					if (!a) return o;
					let s = 2 ** (a.tileID.overscaledZ - e.tileID.overscaledZ), c = [e.tileID.canonical.x * s % 1, e.tileID.canonical.y * s % 1], u = function(e, n, i) {
						let a = l(), o = (a - n.timeAdded) / i, s = e.fadingDirection === Se.Incoming, c = t.ae((a - e.timeAdded) / i, 0, 1), u = t.ae(1 - o, 0, 1), d = s ? c : u;
						return {
							tileOpacity: d,
							parentTileOpacity: s ? u : c,
							fadeMix: {
								opacity: 1,
								mix: 1 - d
							}
						};
					}(e, a, i);
					return {
						parentTile: a,
						parentScaleBy: s,
						parentTopLeft: c,
						fadeValues: u
					};
				}
				return e.selfFading ? {
					parentTile: null,
					parentScaleBy: 1,
					parentTopLeft: [0, 0],
					fadeValues: function(e, n) {
						let i = (l() - e.timeAdded) / n, a = t.ae(i, 0, 1);
						return {
							tileOpacity: a,
							fadeMix: {
								opacity: a,
								mix: 0
							}
						};
					}(e, i)
				} : o;
			}
			let Pi = new t.bf(1, 0, 0, 1), Fi = new t.bf(0, 1, 0, 1), Ii = new t.bf(0, 0, 1, 1), Li = new t.bf(1, 0, 1, 1), Ri = new t.bf(0, 1, 1, 1);
			function zi(e, t, n, i) {
				Vi(e, 0, t + n / 2, e.transform.width, n, i);
			}
			function Bi(e, t, n, i) {
				Vi(e, t - n / 2, 0, n, e.transform.height, i);
			}
			function Vi(e, t, n, i, a, o) {
				let s = e.context, c = s.gl;
				c.enable(c.SCISSOR_TEST), c.scissor(t * e.pixelRatio, n * e.pixelRatio, i * e.pixelRatio, a * e.pixelRatio), s.clear({ color: o }), c.disable(c.SCISSOR_TEST);
			}
			function Hi(e, n, i) {
				let a = e.context, o = a.gl, s = e.useProgram("debug"), c = $t.disabled, l = tn.disabled, u = e.colorModeForRenderPass(), d = "$debug", f = e.style.map.terrain && e.style.map.terrain.getTerrainData(i);
				a.activeTexture.set(o.TEXTURE0);
				let p = n.getTileByID(i.key).latestRawTileData, m = Math.floor((p && p.byteLength || 0) / 1024), h = n.getTile(i).tileSize, g = 512 / Math.min(h, 512) * (i.overscaledZ / e.transform.zoom) * .5, _ = i.canonical.toString();
				i.overscaledZ !== i.canonical.z && (_ += ` => ${i.overscaledZ}`), function(e, t) {
					e.initDebugOverlayCanvas();
					let n = e.debugOverlayCanvas, i = e.context.gl, a = e.debugOverlayCanvas.getContext("2d");
					a.clearRect(0, 0, n.width, n.height), a.shadowColor = "white", a.shadowBlur = 2, a.lineWidth = 1.5, a.strokeStyle = "white", a.textBaseline = "top", a.font = "bold 36px Open Sans, sans-serif", a.fillText(t, 5, 5), a.strokeText(t, 5, 5), e.debugOverlayTexture.update(n), e.debugOverlayTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE);
				}(e, `${_} ${m}kB`);
				let v = e.transform.getProjectionData({
					overscaledTileID: i,
					applyGlobeMatrix: !0,
					applyTerrainMatrix: !0
				});
				s.draw(a, o.TRIANGLES, c, l, Zt.alphaBlended, K.disabled, Zn(t.bf.transparent, g), null, v, d, e.debugBuffer, e.quadTriangleIndexBuffer, e.debugSegments), s.draw(a, o.LINE_STRIP, c, l, u, K.disabled, Zn(t.bf.red), f, v, d, e.debugBuffer, e.tileBorderIndexBuffer, e.debugSegments);
			}
			function Ui(e, t, n, i) {
				let { isRenderingGlobe: a } = i, o = e.context, s = o.gl, c = e.transform, l = e.colorModeForRenderPass(), u = e.getDepthModeFor3D(), d = e.useProgram("terrain");
				o.bindFramebuffer.set(null), o.viewport.set([
					0,
					0,
					e.width,
					e.height
				]);
				for (let i of n) {
					let n = t.getTerrainMesh(i.tileID), f = e.renderToTexture.getTexture(i), p = t.getTerrainData(i.tileID);
					o.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, f.texture);
					let m = t.getMeshFrameDelta(c.zoom), h = c.calculateFogMatrix(i.tileID.toUnwrapped()), g = Rn(m, h, e.style.sky, c.pitch, a), _ = c.getProjectionData({
						overscaledTileID: i.tileID,
						applyTerrainMatrix: !1,
						applyGlobeMatrix: !0
					});
					d.draw(o, s.TRIANGLES, u, tn.disabled, l, K.backCCW, g, p, _, "terrain", n.vertexBuffer, n.indexBuffer, n.segments);
				}
			}
			function Wi(e, n) {
				if (!n.mesh) {
					let i = new t.aL();
					i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1);
					let a = new t.aN();
					a.emplaceBack(0, 1, 2), a.emplaceBack(0, 2, 3), n.mesh = new Pt(e.createVertexBuffer(i, Ft.members), e.createIndexBuffer(a), t.aM.simpleSegment(0, 0, i.length, a.length));
				}
				return n.mesh;
			}
			class Gi {
				constructor(e, n) {
					this.context = new si(e), this.transform = n, this._tileTextures = {}, this.terrainFacilitator = {
						dirty: !0,
						matrix: t.ai(new Float64Array(16)),
						renderTime: 0
					}, this.setup(), this.numSublayers = Re.maxUnderzooming + Re.maxOverzooming + 1, this.depthEpsilon = 1 / 2 ** 16, this.crossTileSymbolIndex = new At();
				}
				resize(e, t, n) {
					if (this.width = Math.floor(e * n), this.height = Math.floor(t * n), this.pixelRatio = n, this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.style) for (let e of this.style._order) this.style._layers[e].resize();
				}
				setup() {
					let e = this.context, n = new t.aL();
					n.emplaceBack(0, 0), n.emplaceBack(t.$, 0), n.emplaceBack(0, t.$), n.emplaceBack(t.$, t.$), this.tileExtentBuffer = e.createVertexBuffer(n, Ft.members), this.tileExtentSegments = t.aM.simpleSegment(0, 0, 4, 2);
					let i = new t.aL();
					i.emplaceBack(0, 0), i.emplaceBack(t.$, 0), i.emplaceBack(0, t.$), i.emplaceBack(t.$, t.$), this.debugBuffer = e.createVertexBuffer(i, Ft.members), this.debugSegments = t.aM.simpleSegment(0, 0, 4, 5);
					let a = new t.c7();
					a.emplaceBack(0, 0, 0, 0), a.emplaceBack(t.$, 0, t.$, 0), a.emplaceBack(0, t.$, 0, t.$), a.emplaceBack(t.$, t.$, t.$, t.$), this.rasterBoundsBuffer = e.createVertexBuffer(a, In.members), this.rasterBoundsSegments = t.aM.simpleSegment(0, 0, 4, 2);
					let o = new t.aL();
					o.emplaceBack(0, 0), o.emplaceBack(t.$, 0), o.emplaceBack(0, t.$), o.emplaceBack(t.$, t.$), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(o, Ft.members), this.rasterBoundsSegmentsPosOnly = t.aM.simpleSegment(0, 0, 4, 5);
					let s = new t.aL();
					s.emplaceBack(0, 0), s.emplaceBack(1, 0), s.emplaceBack(0, 1), s.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(s, Ft.members), this.viewportSegments = t.aM.simpleSegment(0, 0, 4, 2);
					let c = new t.c8();
					c.emplaceBack(0), c.emplaceBack(1), c.emplaceBack(3), c.emplaceBack(2), c.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(c);
					let l = new t.aN();
					l.emplaceBack(1, 0, 2), l.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(l);
					let u = this.context.gl;
					this.stencilClearMode = new tn({
						func: u.ALWAYS,
						mask: 0
					}, 0, 255, u.ZERO, u.ZERO, u.ZERO), this.tileExtentMesh = new Pt(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
				}
				clearStencil() {
					let e = this.context, n = e.gl;
					this.nextStencilID = 1, this.currentStencilSource = void 0;
					let i = t.L();
					t.bZ(i, 0, this.width, this.height, 0, 0, 1), t.N(i, i, [
						n.drawingBufferWidth,
						n.drawingBufferHeight,
						0
					]);
					let a = {
						mainMatrix: i,
						tileMercatorCoords: [
							0,
							0,
							1,
							1
						],
						clippingPlane: [
							0,
							0,
							0,
							0
						],
						projectionTransition: 0,
						fallbackMatrix: i
					};
					this.useProgram("clippingMask", null, !0).draw(e, n.TRIANGLES, $t.disabled, this.stencilClearMode, Zt.disabled, K.disabled, null, null, a, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
				}
				_renderTileClippingMasks(e, t, n) {
					if (this.currentStencilSource === e.source || !e.isTileClipped() || !t || !t.length) return;
					this.currentStencilSource = e.source, this.nextStencilID + t.length > 256 && this.clearStencil();
					let i = this.context;
					i.setColorMode(Zt.disabled), i.setDepthMode($t.disabled);
					let a = {};
					for (let e of t) a[e.key] = this.nextStencilID++;
					this._renderTileMasks(a, t, n, !0), this._renderTileMasks(a, t, n, !1), this._tileClippingMaskIDs = a;
				}
				_renderTileMasks(e, t, n, i) {
					let a = this.context, o = a.gl, s = this.style.projection, c = this.transform, l = this.useProgram("clippingMask");
					for (let u of t) {
						let t = e[u.key], d = this.style.map.terrain && this.style.map.terrain.getTerrainData(u), f = s.getMeshFromTileID(this.context, u.canonical, i, !0, "stencil"), p = c.getProjectionData({
							overscaledTileID: u,
							applyGlobeMatrix: !n,
							applyTerrainMatrix: !0
						});
						l.draw(a, o.TRIANGLES, $t.disabled, new tn({
							func: o.ALWAYS,
							mask: 0
						}, t, 255, o.KEEP, o.KEEP, o.REPLACE), Zt.disabled, n ? K.disabled : K.backCCW, null, d, p, "$clipping", f.vertexBuffer, f.indexBuffer, f.segments);
					}
				}
				_renderTilesDepthBuffer() {
					let e = this.context, t = e.gl, n = this.style.projection, i = this.transform, a = this.useProgram("depth"), o = this.getDepthModeFor3D(), s = Ie(i, { tileSize: i.tileSize });
					for (let c of s) {
						let s = this.style.map.terrain && this.style.map.terrain.getTerrainData(c), l = n.getMeshFromTileID(this.context, c.canonical, !0, !0, "raster"), u = i.getProjectionData({
							overscaledTileID: c,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						});
						a.draw(e, t.TRIANGLES, o, tn.disabled, Zt.disabled, K.backCCW, null, s, u, "$clipping", l.vertexBuffer, l.indexBuffer, l.segments);
					}
				}
				stencilModeFor3D() {
					this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
					let e = this.nextStencilID++, t = this.context.gl;
					return new tn({
						func: t.NOTEQUAL,
						mask: 255
					}, e, 255, t.KEEP, t.KEEP, t.REPLACE);
				}
				stencilModeForClipping(e) {
					let t = this.context.gl;
					return new tn({
						func: t.EQUAL,
						mask: 255
					}, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE);
				}
				getStencilConfigForOverlapAndUpdateStencilID(e) {
					let t = this.context.gl, n = e.sort(((e, t) => t.overscaledZ - e.overscaledZ)), i = n[n.length - 1].overscaledZ, a = n[0].overscaledZ - i + 1;
					if (a > 1) {
						this.currentStencilSource = void 0, this.nextStencilID + a > 256 && this.clearStencil();
						let e = {};
						for (let n = 0; n < a; n++) e[n + i] = new tn({
							func: t.GEQUAL,
							mask: 255
						}, n + this.nextStencilID, 255, t.KEEP, t.KEEP, t.REPLACE);
						return this.nextStencilID += a, [e, n];
					}
					return [{ [i]: tn.disabled }, n];
				}
				stencilConfigForOverlapTwoPass(e) {
					let t = this.context.gl, n = e.sort(((e, t) => t.overscaledZ - e.overscaledZ)), i = n[n.length - 1].overscaledZ, a = n[0].overscaledZ - i + 1;
					if (this.clearStencil(), a > 1) {
						let e = {}, o = {};
						for (let n = 0; n < a; n++) e[n + i] = new tn({
							func: t.GREATER,
							mask: 255
						}, a + 1 + n, 255, t.KEEP, t.KEEP, t.REPLACE), o[n + i] = new tn({
							func: t.GREATER,
							mask: 255
						}, 1 + n, 255, t.KEEP, t.KEEP, t.REPLACE);
						return this.nextStencilID = 2 * a + 1, [
							e,
							o,
							n
						];
					}
					return this.nextStencilID = 3, [
						{ [i]: new tn({
							func: t.GREATER,
							mask: 255
						}, 2, 255, t.KEEP, t.KEEP, t.REPLACE) },
						{ [i]: new tn({
							func: t.GREATER,
							mask: 255
						}, 1, 255, t.KEEP, t.KEEP, t.REPLACE) },
						n
					];
				}
				colorModeForRenderPass() {
					let e = this.context.gl;
					if (this._showOverdrawInspector) {
						let n = 1 / 8;
						return new Zt([e.CONSTANT_COLOR, e.ONE], new t.bf(n, n, n, 0), [
							!0,
							!0,
							!0,
							!0
						]);
					}
					return this.renderPass === "opaque" ? Zt.unblended : Zt.alphaBlended;
				}
				getDepthModeForSublayer(e, t, n) {
					if (!this.opaquePassEnabledForLayer()) return $t.disabled;
					let i = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
					return new $t(n || this.context.gl.LEQUAL, t, [i, i]);
				}
				getDepthModeFor3D() {
					return new $t(this.context.gl.LEQUAL, $t.ReadWrite, this.depthRangeFor3D);
				}
				opaquePassEnabledForLayer() {
					return this.currentLayer < this.opaquePassCutoff;
				}
				render(e, n) {
					var i;
					this.style = e, this.options = n, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(l()), this.imageManager.beginFrame();
					let a = this.style._order, o = this.style.sourceCaches, s = {}, c = {}, u = {}, d = {
						isRenderingToTexture: !1,
						isRenderingGlobe: e.projection?.transitionState > 0
					};
					for (let e in o) {
						let t = o[e];
						t.used && t.prepare(this.context), s[e] = t.getVisibleCoordinates(!1), c[e] = s[e].slice().reverse(), u[e] = t.getVisibleCoordinates(!0).reverse();
					}
					this.opaquePassCutoff = Infinity;
					for (let e = 0; e < a.length; e++) if (this.style._layers[a[e]].is3D()) {
						this.opaquePassCutoff = e;
						break;
					}
					this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
					for (let e of a) {
						let t = this.style._layers[e];
						if (!t.hasOffscreenPass() || t.isHidden(this.transform.zoom)) continue;
						let n = c[t.source];
						(t.type === "custom" || n.length) && this.renderLayer(this, o[t.source], t, n, d);
					}
					if ((i = this.style.projection) == null || i.updateGPUdependent({
						context: this.context,
						useProgram: (e) => this.useProgram(e)
					}), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.bindFramebuffer.set(null), this.context.clear({
						color: n.showOverdrawInspector ? t.bf.black : t.bf.transparent,
						depth: 1
					}), this.clearStencil(), this.style.sky && function(e, t) {
						let n = e.context, i = n.gl, a = ((e, t, n) => {
							let i = Math.cos(t.rollInRadians), a = Math.sin(t.rollInRadians), o = ke(t), s = t.getProjectionData({
								overscaledTileID: null,
								applyGlobeMatrix: !0,
								applyTerrainMatrix: !0
							}).projectionTransition;
							return {
								u_sky_color: e.properties.get("sky-color"),
								u_horizon_color: e.properties.get("horizon-color"),
								u_horizon: [(t.width / 2 - o * a) * n, (t.height / 2 + o * i) * n],
								u_horizon_normal: [-a, i],
								u_sky_horizon_blend: e.properties.get("sky-horizon-blend") * t.height / 2 * n,
								u_sky_blend: s
							};
						})(t, e.style.map.transform, e.pixelRatio), o = new $t(i.LEQUAL, $t.ReadWrite, [0, 1]), s = tn.disabled, c = e.colorModeForRenderPass(), l = e.useProgram("sky"), u = Wi(n, t);
						l.draw(n, i.TRIANGLES, o, s, c, K.disabled, a, null, void 0, "sky", u.vertexBuffer, u.indexBuffer, u.segments);
					}(this, this.style.sky), this._showOverdrawInspector = n.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = a.length - 1; this.currentLayer >= 0; this.currentLayer--) {
						let e = this.style._layers[a[this.currentLayer]], t = o[e.source], n = s[e.source];
						this._renderTileClippingMasks(e, n, !1), this.renderLayer(this, t, e, n, d);
					}
					this.renderPass = "translucent";
					let f = !1;
					for (this.currentLayer = 0; this.currentLayer < a.length; this.currentLayer++) {
						let e = this.style._layers[a[this.currentLayer]], t = o[e.source];
						if (this.renderToTexture && this.renderToTexture.renderLayer(e, d)) continue;
						this.opaquePassEnabledForLayer() || f || (f = !0, d.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
						let n = (e.type === "symbol" ? u : c)[e.source];
						this._renderTileClippingMasks(e, s[e.source], !!this.renderToTexture), this.renderLayer(this, t, e, n, d);
					}
					if (d.isRenderingGlobe && function(e, n, i) {
						let a = e.context, o = a.gl, s = e.useProgram("atmosphere"), c = new $t(o.LEQUAL, $t.ReadOnly, [0, 1]), l = e.transform, u = function(e, n) {
							let i = e.properties.get("position"), a = [
								-i.x,
								-i.y,
								-i.z
							], o = t.ai(new Float64Array(16));
							return e.properties.get("anchor") === "map" && (t.b6(o, o, n.rollInRadians), t.b7(o, o, -n.pitchInRadians), t.b6(o, o, n.bearingInRadians), t.b7(o, o, n.center.lat * Math.PI / 180), t.bz(o, o, -n.center.lng * Math.PI / 180)), t.c6(a, a, o), a;
						}(i, e.transform), d = l.getProjectionData({
							overscaledTileID: null,
							applyGlobeMatrix: !0,
							applyTerrainMatrix: !0
						}), f = n.properties.get("atmosphere-blend") * d.projectionTransition;
						if (f === 0) return;
						let p = gn(l.worldSize, l.center.lat), m = l.inverseProjectionMatrix, h = new Float64Array(4);
						h[3] = 1, t.aw(h, h, l.modelViewProjectionMatrix), h[0] /= h[3], h[1] /= h[3], h[2] /= h[3], h[3] = 1, t.aw(h, h, m), h[0] /= h[3], h[1] /= h[3], h[2] /= h[3], h[3] = 1;
						let g = ((e, t, n, i, a) => ({
							u_sun_pos: e,
							u_atmosphere_blend: t,
							u_globe_position: n,
							u_globe_radius: i,
							u_inv_proj_matrix: a
						}))(u, f, [
							h[0],
							h[1],
							h[2]
						], p, m), _ = Wi(a, n);
						s.draw(a, o.TRIANGLES, c, tn.disabled, Zt.alphaBlended, K.disabled, g, null, null, "atmosphere", _.vertexBuffer, _.indexBuffer, _.segments);
					}(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
						let e = function(e, t) {
							let n = null, i = Object.values(e._layers).flatMap(((n) => n.source && !n.isHidden(t) ? [e.sourceCaches[n.source]] : [])), a = i.filter(((e) => e.getSource().type === "vector")), o = i.filter(((e) => e.getSource().type !== "vector")), s = (e) => {
								(!n || n.getSource().maxzoom < e.getSource().maxzoom) && (n = e);
							};
							return a.forEach(((e) => s(e))), n || o.forEach(((e) => s(e))), n;
						}(this.style, this.transform.zoom);
						e && function(e, t, n) {
							for (let i = 0; i < n.length; i++) Hi(e, t, n[i]);
						}(this, e, e.getVisibleCoordinates());
					}
					this.options.showPadding && function(e) {
						let t = e.transform.padding;
						zi(e, e.transform.height - (t.top || 0), 3, Pi), zi(e, t.bottom || 0, 3, Fi), Bi(e, t.left || 0, 3, Ii), Bi(e, e.transform.width - (t.right || 0), 3, Li);
						let n = e.transform.centerPoint;
						(function(e, t, n, i) {
							Vi(e, t - 1, n - 10, 2, 20, i), Vi(e, t - 10, n - 1, 20, 2, i);
						})(e, n.x, e.transform.height - n.y, Ri);
					}(this), this.context.setDefault();
				}
				maybeDrawDepthAndCoords(e) {
					if (!this.style || !this.style.map || !this.style.map.terrain) return;
					let n = this.terrainFacilitator.matrix, i = this.transform.modelViewProjectionMatrix, a = this.terrainFacilitator.dirty;
					a ||= e ? !t.c9(n, i) : !t.ca(n, i), a ||= this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime), a && (t.cb(n, i), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(e, n) {
						let i = e.context, a = i.gl, o = e.transform, s = Zt.unblended, c = new $t(a.LEQUAL, $t.ReadWrite, [0, 1]), l = n.sourceCache.getRenderableTiles(), u = e.useProgram("terrainDepth");
						i.bindFramebuffer.set(n.getFramebuffer("depth").framebuffer), i.viewport.set([
							0,
							0,
							e.width / devicePixelRatio,
							e.height / devicePixelRatio
						]), i.clear({
							color: t.bf.transparent,
							depth: 1
						});
						for (let e of l) {
							let t = n.getTerrainMesh(e.tileID), l = n.getTerrainData(e.tileID), d = o.getProjectionData({
								overscaledTileID: e.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							}), f = { u_ele_delta: n.getMeshFrameDelta(o.zoom) };
							u.draw(i, a.TRIANGLES, c, tn.disabled, s, K.backCCW, f, l, d, "terrain", t.vertexBuffer, t.indexBuffer, t.segments);
						}
						i.bindFramebuffer.set(null), i.viewport.set([
							0,
							0,
							e.width,
							e.height
						]);
					}(this, this.style.map.terrain), function(e, n) {
						let i = e.context, a = i.gl, o = e.transform, s = Zt.unblended, c = new $t(a.LEQUAL, $t.ReadWrite, [0, 1]), l = n.getCoordsTexture(), u = n.sourceCache.getRenderableTiles(), d = e.useProgram("terrainCoords");
						i.bindFramebuffer.set(n.getFramebuffer("coords").framebuffer), i.viewport.set([
							0,
							0,
							e.width / devicePixelRatio,
							e.height / devicePixelRatio
						]), i.clear({
							color: t.bf.transparent,
							depth: 1
						}), n.coordsIndex = [];
						for (let e of u) {
							let t = n.getTerrainMesh(e.tileID), u = n.getTerrainData(e.tileID);
							i.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, l.texture);
							let f = {
								u_terrain_coords_id: (255 - n.coordsIndex.length) / 255,
								u_texture: 0,
								u_ele_delta: n.getMeshFrameDelta(o.zoom)
							}, p = o.getProjectionData({
								overscaledTileID: e.tileID,
								applyTerrainMatrix: !1,
								applyGlobeMatrix: !0
							});
							d.draw(i, a.TRIANGLES, c, tn.disabled, s, K.backCCW, f, u, p, "terrain", t.vertexBuffer, t.indexBuffer, t.segments), n.coordsIndex.push(e.tileID.key);
						}
						i.bindFramebuffer.set(null), i.viewport.set([
							0,
							0,
							e.width,
							e.height
						]);
					}(this, this.style.map.terrain));
				}
				renderLayer(e, n, i, a, o) {
					i.isHidden(this.transform.zoom) || (i.type === "background" || i.type === "custom" || (a || []).length) && (this.id = i.id, t.cc(i) ? function(e, n, i, a, o, s) {
						if (e.renderPass !== "translucent") return;
						let { isRenderingToTexture: c } = s, l = tn.disabled, u = e.colorModeForRenderPass();
						(i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e, n, i, a, o, s, c, l, u) {
							let d = n.transform, f = n.style.map.terrain, p = o === "map", m = s === "map";
							for (let o of e) {
								let e = a.getTile(o), s = e.getBucket(i);
								if (!s || !s.text || !s.text.segments.get().length) continue;
								let h = t.an(s.textSizeData, d.zoom), g = t.aC(e, 1, n.transform.zoom), _ = We(p, n.transform, g), v = i.layout.get("icon-text-fit") !== "none" && s.hasIconData();
								if (h) {
									let n = 2 ** (d.zoom - e.tileID.overscaledZ), i = f ? (e, t) => f.getElevation(o, e, t) : null;
									pi(s, p, m, u, d, _, n, h, v, t.aD(d, e, c, l), o.toUnwrapped(), i);
								}
							}
						}(a, e, i, n, i.layout.get("text-rotation-alignment"), i.layout.get("text-pitch-alignment"), i.paint.get("text-translate"), i.paint.get("text-translate-anchor"), o), i.paint.get("icon-opacity").constantOr(1) !== 0 && hi(e, n, i, a, !1, i.paint.get("icon-translate"), i.paint.get("icon-translate-anchor"), i.layout.get("icon-rotation-alignment"), i.layout.get("icon-pitch-alignment"), i.layout.get("icon-keep-upright"), l, u, c), i.paint.get("text-opacity").constantOr(1) !== 0 && hi(e, n, i, a, !0, i.paint.get("text-translate"), i.paint.get("text-translate-anchor"), i.layout.get("text-rotation-alignment"), i.layout.get("text-pitch-alignment"), i.layout.get("text-keep-upright"), l, u, c), n.map.showCollisionBoxes && (li(e, n, i, a, !0), li(e, n, i, a, !1));
					}(e, n, i, a, this.style.placement.variableOffsets, o) : t.cd(i) ? function(e, n, i, a, o) {
						if (e.renderPass !== "translucent") return;
						let { isRenderingToTexture: s } = o, c = i.paint.get("circle-opacity"), l = i.paint.get("circle-stroke-width"), u = i.paint.get("circle-stroke-opacity"), d = !i.layout.get("circle-sort-key").isConstant();
						if (c.constantOr(1) === 0 && (l.constantOr(1) === 0 || u.constantOr(1) === 0)) return;
						let f = e.context, p = f.gl, m = e.transform, h = e.getDepthModeForSublayer(0, $t.ReadOnly), g = tn.disabled, _ = e.colorModeForRenderPass(), v = [], y = m.getCircleRadiusCorrection();
						for (let o = 0; o < a.length; o++) {
							let c = a[o], l = n.getTile(c), u = l.getBucket(i);
							if (!u) continue;
							let f = i.paint.get("circle-translate"), p = i.paint.get("circle-translate-anchor"), h = t.aD(m, l, f, p), g = u.programConfigurations.get(i.id), _ = e.useProgram("circle", g), b = u.layoutVertexBuffer, x = u.indexBuffer, S = e.style.map.terrain && e.style.map.terrain.getTerrainData(c), C = {
								programConfiguration: g,
								program: _,
								layoutVertexBuffer: b,
								indexBuffer: x,
								uniformValues: Jn(e, l, i, h, y),
								terrainData: S,
								projectionData: m.getProjectionData({
									overscaledTileID: c,
									applyGlobeMatrix: !s,
									applyTerrainMatrix: !0
								})
							};
							if (d) {
								let e = u.segments.get();
								for (let n of e) v.push({
									segments: new t.aM([n]),
									sortKey: n.sortKey,
									state: C
								});
							} else v.push({
								segments: u.segments,
								sortKey: 0,
								state: C
							});
						}
						d && v.sort(((e, t) => e.sortKey - t.sortKey));
						for (let t of v) {
							let { programConfiguration: n, program: a, layoutVertexBuffer: o, indexBuffer: s, uniformValues: c, terrainData: l, projectionData: u } = t.state;
							a.draw(f, p.TRIANGLES, h, g, _, K.backCCW, c, l, u, i.id, o, s, t.segments, i.paint, e.transform.zoom, n);
						}
					}(e, n, i, a, o) : t.ce(i) ? function(e, n, i, a, o) {
						if (i.paint.get("heatmap-opacity") === 0) return;
						let s = e.context, { isRenderingToTexture: c, isRenderingGlobe: l } = o;
						if (e.style.map.terrain) {
							for (let t of a) {
								let a = n.getTile(t);
								n.hasRenderableParent(t) || (e.renderPass === "offscreen" ? _i(e, a, i, t, l) : e.renderPass === "translucent" && vi(e, i, t, c, l));
							}
							s.viewport.set([
								0,
								0,
								e.width,
								e.height
							]);
						} else e.renderPass === "offscreen" ? function(e, n, i, a) {
							let o = e.context, s = o.gl, c = e.transform, l = tn.disabled, u = new Zt([s.ONE, s.ONE], t.bf.transparent, [
								!0,
								!0,
								!0,
								!0
							]);
							(function(e, n, i) {
								let a = e.gl;
								e.activeTexture.set(a.TEXTURE1), e.viewport.set([
									0,
									0,
									n.width / 4,
									n.height / 4
								]);
								let o = i.heatmapFbos.get(t.c3);
								o ? (a.bindTexture(a.TEXTURE_2D, o.colorAttachment.get()), e.bindFramebuffer.set(o.framebuffer)) : (o = yi(e, n.width / 4, n.height / 4), i.heatmapFbos.set(t.c3, o));
							})(o, e, i), o.clear({ color: t.bf.transparent });
							for (let t = 0; t < a.length; t++) {
								let d = a[t];
								if (n.hasRenderableParent(d)) continue;
								let f = n.getTile(d), p = f.getBucket(i);
								if (!p) continue;
								let m = p.programConfigurations.get(i.id), h = e.useProgram("heatmap", m), g = c.getProjectionData({
									overscaledTileID: d,
									applyGlobeMatrix: !0,
									applyTerrainMatrix: !1
								}), _ = c.getCircleRadiusCorrection();
								h.draw(o, s.TRIANGLES, $t.disabled, l, u, K.backCCW, Qn(f, c.zoom, i.paint.get("heatmap-intensity"), _), null, g, i.id, p.layoutVertexBuffer, p.indexBuffer, p.segments, i.paint, c.zoom, m);
							}
							o.viewport.set([
								0,
								0,
								e.width,
								e.height
							]);
						}(e, n, i, a) : e.renderPass === "translucent" && function(e, n) {
							let i = e.context, a = i.gl;
							i.setColorMode(e.colorModeForRenderPass());
							let o = n.heatmapFbos.get(t.c3);
							o && (i.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, o.colorAttachment.get()), i.activeTexture.set(a.TEXTURE1), bi(i, n).bind(a.LINEAR, a.CLAMP_TO_EDGE), e.useProgram("heatmapTexture").draw(i, a.TRIANGLES, $t.disabled, tn.disabled, e.colorModeForRenderPass(), K.disabled, $n(e, n, 0, 1), null, null, n.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, n.paint, e.transform.zoom));
						}(e, i);
					}(e, n, i, a, o) : t.cf(i) ? function(e, t, n, i, a) {
						if (e.renderPass !== "translucent") return;
						let { isRenderingToTexture: o } = a, s = n.paint.get("line-opacity"), c = n.paint.get("line-width");
						if (s.constantOr(1) === 0 || c.constantOr(1) === 0) return;
						let l = e.getDepthModeForSublayer(0, $t.ReadOnly), u = e.colorModeForRenderPass(), d = n.paint.get("line-dasharray"), f = d.constantOr(1), p = n.paint.get("line-pattern"), m = p.constantOr(1), h = n.paint.get("line-gradient"), g = n.getCrossfadeParameters(), _;
						_ = m ? "linePattern" : f && h ? "lineGradientSDF" : f ? "lineSDF" : h ? "lineGradient" : "line";
						let v = e.context, y = v.gl, b = e.transform, x = !0;
						for (let a of i) {
							let i = t.getTile(a);
							if (m && !i.patternsLoaded()) continue;
							let s = i.getBucket(n);
							if (!s) continue;
							let c = s.programConfigurations.get(n.id), S = e.context.program.get(), C = e.useProgram(_, c), w = x || C.program !== S, T = e.style.map.terrain && e.style.map.terrain.getTerrainData(a), E = p.constantOr(null), O = d && d.constantOr(null);
							if (E && i.imageAtlas) {
								let e = i.imageAtlas, t = e.patternPositions[E.to.toString()], n = e.patternPositions[E.from.toString()];
								t && n && c.setConstantPatternPositions(t, n);
							} else if (O) {
								let t = n.layout.get("line-cap") === "round", i = e.lineAtlas.getDash(O.to, t), a = e.lineAtlas.getDash(O.from, t);
								c.setConstantDashPositions(i, a);
							}
							let k = b.getProjectionData({
								overscaledTileID: a,
								applyGlobeMatrix: !o,
								applyTerrainMatrix: !0
							}), A = b.getPixelScale(), j;
							m ? (j = or(e, i, n, A, g), Si(v, y, i, c, g)) : f && h ? (j = cr(e, i, n, A, g, s.lineClipsArray.length), Ti(e, t, v, y, n, s, a, c, g)) : f ? (j = sr(e, i, n, A, g), Ci(e, v, y, c, w, g)) : h ? (j = ar(e, i, n, A, s.lineClipsArray.length), wi(e, t, v, y, n, s, a)) : j = ir(e, i, n, A);
							let M = e.stencilModeForClipping(a);
							C.draw(v, y.TRIANGLES, l, M, u, K.disabled, j, T, k, n.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, n.paint, e.transform.zoom, c, s.layoutVertexBuffer2), x = !1;
						}
					}(e, n, i, a, o) : t.cg(i) ? function(e, n, i, a, o) {
						let s = i.paint.get("fill-color"), c = i.paint.get("fill-opacity");
						if (c.constantOr(1) === 0) return;
						let { isRenderingToTexture: l } = o, u = e.colorModeForRenderPass(), d = i.paint.get("fill-pattern"), f = e.opaquePassEnabledForLayer() && !d.constantOr(1) && s.constantOr(t.bf.transparent).a === 1 && c.constantOr(0) === 1 ? "opaque" : "translucent";
						if (e.renderPass === f) {
							let t = e.getDepthModeForSublayer(1, e.renderPass === "opaque" ? $t.ReadWrite : $t.ReadOnly);
							Di(e, n, i, a, t, u, !1, l);
						}
						if (e.renderPass === "translucent" && i.paint.get("fill-antialias")) {
							let t = e.getDepthModeForSublayer(i.getPaintProperty("fill-outline-color") ? 2 : 0, $t.ReadOnly);
							Di(e, n, i, a, t, u, !0, l);
						}
					}(e, n, i, a, o) : t.ch(i) ? function(e, t, n, i, a) {
						let o = n.paint.get("fill-extrusion-opacity");
						if (o === 0) return;
						let { isRenderingToTexture: s } = a;
						if (e.renderPass === "translucent") {
							let a = new $t(e.context.gl.LEQUAL, $t.ReadWrite, e.depthRangeFor3D);
							if (o !== 1 || n.paint.get("fill-extrusion-pattern").constantOr(1)) Oi(e, t, n, i, a, tn.disabled, Zt.disabled, s), Oi(e, t, n, i, a, e.stencilModeFor3D(), e.colorModeForRenderPass(), s);
							else {
								let o = e.colorModeForRenderPass();
								Oi(e, t, n, i, a, tn.disabled, o, s);
							}
						}
					}(e, n, i, a, o) : t.ci(i) ? function(e, n, i, a, o) {
						if (e.renderPass !== "offscreen" && e.renderPass !== "translucent") return;
						let { isRenderingToTexture: s } = o, c = e.context, l = e.style.projection.useSubdivision, u = e.getDepthModeForSublayer(0, $t.ReadOnly), d = e.colorModeForRenderPass();
						if (e.renderPass === "offscreen") (function(e, n, i, a, o, s, c) {
							let l = e.context, u = l.gl;
							for (let d of i) {
								let i = n.getTile(d), f = i.dem;
								if (!f || !f.data || !i.needsHillshadePrepare) continue;
								let p = f.dim, m = f.stride, h = f.getPixels();
								if (l.activeTexture.set(u.TEXTURE1), l.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || e.getTileTexture(m), i.demTexture) {
									let e = i.demTexture;
									e.update(h, { premultiply: !1 }), e.bind(u.NEAREST, u.CLAMP_TO_EDGE);
								} else i.demTexture = new t.T(l, h, u.RGBA, { premultiply: !1 }), i.demTexture.bind(u.NEAREST, u.CLAMP_TO_EDGE);
								l.activeTexture.set(u.TEXTURE0);
								let g = i.fbo;
								if (!g) {
									let e = new t.T(l, {
										width: p,
										height: p,
										data: null
									}, u.RGBA);
									e.bind(u.LINEAR, u.CLAMP_TO_EDGE), g = i.fbo = l.createFramebuffer(p, p, !0, !1), g.colorAttachment.set(e.texture);
								}
								l.bindFramebuffer.set(g.framebuffer), l.viewport.set([
									0,
									0,
									p,
									p
								]), e.useProgram("hillshadePrepare").draw(l, u.TRIANGLES, o, s, c, K.disabled, tr(i.tileID, f), null, null, a.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments), i.needsHillshadePrepare = !1;
							}
						})(e, n, a, i, u, tn.disabled, d), c.viewport.set([
							0,
							0,
							e.width,
							e.height
						]);
						else if (e.renderPass === "translucent") if (l) {
							let [t, o, c] = e.stencilConfigForOverlapTwoPass(a);
							ki(e, n, i, c, t, u, d, !1, s), ki(e, n, i, c, o, u, d, !0, s);
						} else {
							let [t, o] = e.getStencilConfigForOverlapAndUpdateStencilID(a);
							ki(e, n, i, o, t, u, d, !1, s);
						}
					}(e, n, i, a, o) : t.cj(i) ? function(e, t, n, i, a) {
						if (e.renderPass !== "translucent" || !i.length) return;
						let { isRenderingToTexture: o } = a, s = e.style.projection.useSubdivision, c = e.getDepthModeForSublayer(0, $t.ReadOnly), l = e.colorModeForRenderPass();
						if (s) {
							let [a, s, u] = e.stencilConfigForOverlapTwoPass(i);
							Ai(e, t, n, u, a, c, l, !1, o), Ai(e, t, n, u, s, c, l, !0, o);
						} else {
							let [a, s] = e.getStencilConfigForOverlapAndUpdateStencilID(i);
							Ai(e, t, n, s, a, c, l, !1, o);
						}
					}(e, n, i, a, o) : t.bK(i) ? function(e, t, n, i, a) {
						if (e.renderPass !== "translucent" || n.paint.get("raster-opacity") === 0 || !i.length) return;
						let { isRenderingToTexture: o } = a, s = t.getSource(), c = e.style.projection.useSubdivision;
						if (s instanceof V) Mi(e, t, n, i, null, !1, !1, s.tileCoords, s.flippedWindingOrder, o);
						else if (c) {
							let [a, s, c] = e.stencilConfigForOverlapTwoPass(i);
							Mi(e, t, n, c, a, !1, !0, ji, !1, o), Mi(e, t, n, c, s, !0, !0, ji, !1, o);
						} else {
							let [a, s] = e.getStencilConfigForOverlapAndUpdateStencilID(i);
							Mi(e, t, n, s, a, !1, !0, ji, !1, o);
						}
					}(e, n, i, a, o) : t.ck(i) ? function(e, t, n, i, a) {
						let o = n.paint.get("background-color"), s = n.paint.get("background-opacity");
						if (s === 0) return;
						let { isRenderingToTexture: c } = a, l = e.context, u = l.gl, d = e.style.projection, f = e.transform, p = f.tileSize, m = n.paint.get("background-pattern");
						if (e.isPatternMissing(m)) return;
						let h = !m && o.a === 1 && s === 1 && e.opaquePassEnabledForLayer() ? "opaque" : "translucent";
						if (e.renderPass !== h) return;
						let g = tn.disabled, _ = e.getDepthModeForSublayer(0, h === "opaque" ? $t.ReadWrite : $t.ReadOnly), v = e.colorModeForRenderPass(), y = e.useProgram(m ? "backgroundPattern" : "background"), b = i || Ie(f, {
							tileSize: p,
							terrain: e.style.map.terrain
						});
						m && (l.activeTexture.set(u.TEXTURE0), e.imageManager.bind(e.context));
						let x = n.getCrossfadeParameters();
						for (let t of b) {
							let i = f.getProjectionData({
								overscaledTileID: t,
								applyGlobeMatrix: !c,
								applyTerrainMatrix: !0
							}), a = m ? _r(s, e, m, {
								tileID: t,
								tileSize: p
							}, x) : gr(s, o), h = e.style.map.terrain && e.style.map.terrain.getTerrainData(t), b = d.getMeshFromTileID(l, t.canonical, !1, !0, "raster");
							y.draw(l, u.TRIANGLES, _, g, v, K.backCCW, a, h, i, n.id, b.vertexBuffer, b.indexBuffer, b.segments);
						}
					}(e, 0, i, a, o) : t.cl(i) && function(e, t, n, i) {
						let { isRenderingGlobe: a } = i, o = e.context, s = n.implementation, c = e.style.projection, l = e.transform, u = l.getProjectionDataForCustomLayer(a), d = {
							farZ: l.farZ,
							nearZ: l.nearZ,
							fov: l.fov * Math.PI / 180,
							modelViewProjectionMatrix: l.modelViewProjectionMatrix,
							projectionMatrix: l.projectionMatrix,
							shaderData: {
								variantName: c.shaderVariantName,
								vertexShaderPrelude: `const float PI = 3.141592653589793;\nuniform mat4 u_projection_matrix;\n${c.shaderPreludeCode.vertexSource}`,
								define: c.shaderDefine
							},
							defaultProjectionData: u
						}, f = s.renderingMode ? s.renderingMode : "2d";
						if (e.renderPass === "offscreen") {
							let t = s.prerender;
							t && (e.setCustomLayerDefaults(), o.setColorMode(e.colorModeForRenderPass()), t.call(s, o.gl, d), o.setDirty(), e.setBaseState());
						} else if (e.renderPass === "translucent") {
							e.setCustomLayerDefaults(), o.setColorMode(e.colorModeForRenderPass()), o.setStencilMode(tn.disabled);
							let t = f === "3d" ? e.getDepthModeFor3D() : e.getDepthModeForSublayer(0, $t.ReadOnly);
							o.setDepthMode(t), s.render(o.gl, d), o.setDirty(), e.setBaseState(), o.bindFramebuffer.set(null);
						}
					}(e, 0, i, o));
				}
				saveTileTexture(e) {
					let t = this._tileTextures[e.size[0]];
					t ? t.push(e) : this._tileTextures[e.size[0]] = [e];
				}
				getTileTexture(e) {
					let t = this._tileTextures[e];
					return t && t.length > 0 ? t.pop() : null;
				}
				isPatternMissing(e) {
					if (!e) return !1;
					if (!e.from || !e.to) return !0;
					let t = this.imageManager.getPattern(e.from.toString()), n = this.imageManager.getPattern(e.to.toString());
					return !t || !n;
				}
				useProgram(e, t, n = !1, i = []) {
					this.cache = this.cache || {};
					let a = !!this.style.map.terrain, o = this.style.projection, s = n ? Mt.projectionMercator : o.shaderPreludeCode, c = n ? It : o.shaderDefine, l = e + (t ? t.cacheKey : "") + `/${n ? Lt : o.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (a ? "/terrain" : "") + (i ? `/${i.join("/")}` : "");
					return this.cache[l] || (this.cache[l] = new Vn(this.context, Mt[e], t, yr[e], this._showOverdrawInspector, a, s, c, i)), this.cache[l];
				}
				setCustomLayerDefaults() {
					this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
				}
				setBaseState() {
					let e = this.context.gl;
					this.context.cullFace.set(!1), this.context.viewport.set([
						0,
						0,
						this.width,
						this.height
					]), this.context.blendEquation.set(e.FUNC_ADD);
				}
				initDebugOverlayCanvas() {
					this.debugOverlayCanvas ?? (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
				}
				destroy() {
					this.debugOverlayTexture && this.debugOverlayTexture.destroy();
				}
				overLimit() {
					let { drawingBufferWidth: e, drawingBufferHeight: t } = this.context.gl;
					return this.width !== e || this.height !== t;
				}
			}
			function Ki(e, t) {
				let n, i = !1, a = null, o = null, s = () => {
					a = null, i &&= (e.apply(o, n), a = setTimeout(s, t), !1);
				};
				return (...e) => (i = !0, o = this, n = e, a || s(), a);
			}
			class qi {
				constructor(e) {
					this._getCurrentHash = () => {
						let e = window.location.hash.replace("#", "");
						if (this._hashName) {
							let t;
							return e.split("&").map(((e) => e.split("="))).forEach(((e) => {
								e[0] === this._hashName && (t = e);
							})), (t && t[1] || "").split("/");
						}
						return e.split("/");
					}, this._onHashChange = () => {
						let e = this._getCurrentHash();
						if (!this._isValidHash(e)) return !1;
						let t = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e[3] || 0) : this._map.getBearing();
						return this._map.jumpTo({
							center: [+e[2], +e[1]],
							zoom: +e[0],
							bearing: t,
							pitch: +(e[4] || 0)
						}), !0;
					}, this._updateHashUnthrottled = () => {
						let e = window.location.href.replace(/(#.*)?$/, this.getHashString());
						window.history.replaceState(window.history.state, null, e);
					}, this._removeHash = () => {
						let e = this._getCurrentHash();
						if (e.length === 0) return;
						let t = e.join("/"), n = t;
						n.split("&").length > 0 && (n = n.split("&")[0]), this._hashName && (n = `${this._hashName}=${t}`);
						let i = window.location.hash.replace(n, "");
						i.startsWith("#&") ? i = i.slice(0, 1) + i.slice(2) : i === "#" && (i = "");
						let a = window.location.href.replace(/(#.+)?$/, i);
						a = a.replace("&&", "&"), window.history.replaceState(window.history.state, null, a);
					}, this._updateHash = Ki(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e);
				}
				addTo(e) {
					return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
				}
				remove() {
					return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
				}
				getHashString(e) {
					let t = this._map.getCenter(), n = Math.round(100 * this._map.getZoom()) / 100, i = 10 ** Math.ceil((n * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), a = Math.round(t.lng * i) / i, o = Math.round(t.lat * i) / i, s = this._map.getBearing(), c = this._map.getPitch(), l = "";
					if (l += e ? `/${a}/${o}/${n}` : `${n}/${o}/${a}`, (s || c) && (l += "/" + Math.round(10 * s) / 10), c && (l += `/${Math.round(c)}`), this._hashName) {
						let e = this._hashName, t = !1, n = window.location.hash.slice(1).split("&").map(((n) => {
							let i = n.split("=")[0];
							return i === e ? (t = !0, `${i}=${l}`) : n;
						})).filter(((e) => e));
						return t || n.push(`${e}=${l}`), `#${n.join("&")}`;
					}
					return `#${l}`;
				}
				_isValidHash(e) {
					if (e.length < 3 || e.some(isNaN)) return !1;
					try {
						new t.S(+e[2], +e[1]);
					} catch {
						return !1;
					}
					let n = +e[0], i = +(e[3] || 0), a = +(e[4] || 0);
					return n >= this._map.getMinZoom() && n <= this._map.getMaxZoom() && i >= -180 && i <= 180 && a >= this._map.getMinPitch() && a <= this._map.getMaxPitch();
				}
			}
			let Ji = {
				linearity: .3,
				easing: t.cm(0, 0, .3, 1)
			}, Yi = t.e({
				deceleration: 2500,
				maxSpeed: 1400
			}, Ji), Xi = t.e({
				deceleration: 20,
				maxSpeed: 1400
			}, Ji), Zi = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Ji), Qi = t.e({
				deceleration: 1e3,
				maxSpeed: 90
			}, Ji), $i = t.e({
				deceleration: 1e3,
				maxSpeed: 360
			}, Ji);
			class ea {
				constructor(e) {
					this._map = e, this.clear();
				}
				clear() {
					this._inertiaBuffer = [];
				}
				record(e) {
					this._drainInertiaBuffer(), this._inertiaBuffer.push({
						time: l(),
						settings: e
					});
				}
				_drainInertiaBuffer() {
					let e = this._inertiaBuffer, t = l();
					for (; e.length > 0 && t - e[0].time > 160;) e.shift();
				}
				_onMoveEnd(e) {
					if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
					let n = {
						zoom: 0,
						bearing: 0,
						pitch: 0,
						roll: 0,
						pan: new t.P(0, 0),
						pinchAround: void 0,
						around: void 0
					};
					for (let { settings: e } of this._inertiaBuffer) n.zoom += e.zoomDelta || 0, n.bearing += e.bearingDelta || 0, n.pitch += e.pitchDelta || 0, n.roll += e.rollDelta || 0, e.panDelta && n.pan._add(e.panDelta), e.around && (n.around = e.around), e.pinchAround && (n.pinchAround = e.pinchAround);
					let i = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a = {};
					if (n.pan.mag()) {
						let o = na(n.pan.mag(), i, t.e({}, Yi, e || {})), s = n.pan.mult(o.amount / n.pan.mag()), c = this._map.cameraHelper.handlePanInertia(s, this._map.transform);
						a.center = c.easingCenter, a.offset = c.easingOffset, ta(a, o);
					}
					if (n.zoom) {
						let e = na(n.zoom, i, Xi);
						a.zoom = this._map.transform.zoom + e.amount, ta(a, e);
					}
					if (n.bearing) {
						let e = na(n.bearing, i, Zi);
						a.bearing = this._map.transform.bearing + t.ae(e.amount, -179, 179), ta(a, e);
					}
					if (n.pitch) {
						let e = na(n.pitch, i, Qi);
						a.pitch = this._map.transform.pitch + e.amount, ta(a, e);
					}
					if (n.roll) {
						let e = na(n.roll, i, $i);
						a.roll = this._map.transform.roll + t.ae(e.amount, -179, 179), ta(a, e);
					}
					if (a.zoom || a.bearing) {
						let e = n.pinchAround === void 0 ? n.around : n.pinchAround;
						a.around = e ? this._map.unproject(e) : this._map.getCenter();
					}
					return this.clear(), t.e(a, { noMoveStart: !0 });
				}
			}
			function ta(e, t) {
				(!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);
			}
			function na(e, n, i) {
				let { maxSpeed: a, linearity: o, deceleration: s } = i, c = t.ae(e * o / (n / 1e3), -a, a), l = Math.abs(c) / (s * o);
				return {
					easing: i.easing,
					duration: 1e3 * l,
					amount: c * (l / 2)
				};
			}
			class ra extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e, n, i, a = {}) {
					i = i instanceof MouseEvent ? i : new MouseEvent(e, i);
					let o = u.mousePos(n.getCanvas(), i), s = n.unproject(o);
					super(e, t.e({
						point: o,
						lngLat: s,
						originalEvent: i
					}, a)), this._defaultPrevented = !1, this.target = n;
				}
			}
			class ia extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e, n, i) {
					let a = e === "touchend" ? i.changedTouches : i.touches, o = u.touchPos(n.getCanvasContainer(), a), s = o.map(((e) => n.unproject(e))), c = o.reduce(((e, t, n, i) => e.add(t.div(i.length))), new t.P(0, 0));
					super(e, {
						points: o,
						point: c,
						lngLats: s,
						lngLat: n.unproject(c),
						originalEvent: i
					}), this._defaultPrevented = !1;
				}
			}
			class aa extends t.l {
				preventDefault() {
					this._defaultPrevented = !0;
				}
				get defaultPrevented() {
					return this._defaultPrevented;
				}
				constructor(e, t, n) {
					super(e, { originalEvent: n }), this._defaultPrevented = !1;
				}
			}
			class oa {
				constructor(e, t) {
					this._map = e, this._clickTolerance = t.clickTolerance;
				}
				reset() {
					delete this._mousedownPos;
				}
				wheel(e) {
					return this._firePreventable(new aa(e.type, this._map, e));
				}
				mousedown(e, t) {
					return this._mousedownPos = t, this._firePreventable(new ra(e.type, this._map, e));
				}
				mouseup(e) {
					this._map.fire(new ra(e.type, this._map, e));
				}
				click(e, t) {
					this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || this._map.fire(new ra(e.type, this._map, e));
				}
				dblclick(e) {
					return this._firePreventable(new ra(e.type, this._map, e));
				}
				mouseover(e) {
					this._map.fire(new ra(e.type, this._map, e));
				}
				mouseout(e) {
					this._map.fire(new ra(e.type, this._map, e));
				}
				touchstart(e) {
					return this._firePreventable(new ia(e.type, this._map, e));
				}
				touchmove(e) {
					this._map.fire(new ia(e.type, this._map, e));
				}
				touchend(e) {
					this._map.fire(new ia(e.type, this._map, e));
				}
				touchcancel(e) {
					this._map.fire(new ia(e.type, this._map, e));
				}
				_firePreventable(e) {
					if (this._map.fire(e), e.defaultPrevented) return {};
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class sa {
				constructor(e) {
					this._map = e;
				}
				reset() {
					this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
				}
				mousemove(e) {
					this._map.fire(new ra(e.type, this._map, e));
				}
				mousedown() {
					this._delayContextMenu = !0, this._ignoreContextMenu = !1;
				}
				mouseup() {
					this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ra("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
				}
				contextmenu(e) {
					this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new ra(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
				}
				isEnabled() {
					return !0;
				}
				isActive() {
					return !1;
				}
				enable() {}
				disable() {}
			}
			class ca {
				constructor(e) {
					this._map = e;
				}
				get transform() {
					return this._map._requestedCameraState || this._map.transform;
				}
				get center() {
					return {
						lng: this.transform.center.lng,
						lat: this.transform.center.lat
					};
				}
				get zoom() {
					return this.transform.zoom;
				}
				get pitch() {
					return this.transform.pitch;
				}
				get bearing() {
					return this.transform.bearing;
				}
				unproject(e) {
					return this.transform.screenPointToLocation(t.P.convert(e), this._map.terrain);
				}
			}
			class la {
				constructor(e, t) {
					this._map = e, this._tr = new ca(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
				enable() {
					this.isEnabled() || (this._enabled = !0);
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				mousedown(e, t) {
					this.isEnabled() && e.shiftKey && e.button === 0 && (u.disableDrag(), this._startPos = this._lastPos = t, this._active = !0);
				}
				mousemoveWindow(e, t) {
					if (!this._active) return;
					let n = t;
					if (this._lastPos.equals(n) || !this._box && n.dist(this._startPos) < this._clickTolerance) return;
					let i = this._startPos;
					this._lastPos = n, this._box || (this._box = u.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e));
					let a = Math.min(i.x, n.x), o = Math.max(i.x, n.x), s = Math.min(i.y, n.y), c = Math.max(i.y, n.y);
					u.setTransform(this._box, `translate(${a}px,${s}px)`), this._box.style.width = o - a + "px", this._box.style.height = c - s + "px";
				}
				mouseupWindow(e, n) {
					if (!this._active || e.button !== 0) return;
					let i = this._startPos, a = n;
					if (this.reset(), u.suppressClick(), i.x !== a.x || i.y !== a.y) return this._map.fire(new t.l("boxzoomend", { originalEvent: e })), { cameraAnimation: (e) => e.fitScreenCoordinates(i, a, this._tr.bearing, { linear: !0 }) };
					this._fireEvent("boxzoomcancel", e);
				}
				keydown(e) {
					this._active && e.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", e));
				}
				reset() {
					this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box &&= (u.remove(this._box), null), u.enableDrag(), delete this._startPos, delete this._lastPos;
				}
				_fireEvent(e, n) {
					return this._map.fire(new t.l(e, { originalEvent: n }));
				}
			}
			function q(e, t) {
				if (e.length !== t.length) throw Error(`The number of touches and points are not equal - touches ${e.length}, points ${t.length}`);
				let n = {};
				for (let i = 0; i < e.length; i++) n[e[i].identifier] = t[i];
				return n;
			}
			class ua {
				constructor(e) {
					this.reset(), this.numTouches = e.numTouches;
				}
				reset() {
					delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
				}
				touchstart(e, n, i) {
					(this.centroid || i.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp), i.length === this.numTouches && (this.centroid = function(e) {
						let n = new t.P(0, 0);
						for (let t of e) n._add(t);
						return n.div(e.length);
					}(n), this.touches = q(i, n)));
				}
				touchmove(e, t, n) {
					if (this.aborted || !this.centroid) return;
					let i = q(n, t);
					for (let e in this.touches) {
						let t = i[e];
						(!t || t.dist(this.touches[e]) > 30) && (this.aborted = !0);
					}
				}
				touchend(e, t, n) {
					if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), n.length === 0) {
						let e = !this.aborted && this.centroid;
						if (this.reset(), e) return e;
					}
				}
			}
			class da {
				constructor(e) {
					this.singleTap = new ua(e), this.numTaps = e.numTaps, this.reset();
				}
				reset() {
					this.lastTime = Infinity, delete this.lastTap, this.count = 0, this.singleTap.reset();
				}
				touchstart(e, t, n) {
					this.singleTap.touchstart(e, t, n);
				}
				touchmove(e, t, n) {
					this.singleTap.touchmove(e, t, n);
				}
				touchend(e, t, n) {
					let i = this.singleTap.touchend(e, t, n);
					if (i) {
						let t = e.timeStamp - this.lastTime < 500, n = !this.lastTap || this.lastTap.dist(i) < 30;
						if (t && n || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = i, this.count === this.numTaps) return this.reset(), i;
					}
				}
			}
			class fa {
				constructor(e) {
					this._tr = new ca(e), this._zoomIn = new da({
						numTouches: 1,
						numTaps: 2
					}), this._zoomOut = new da({
						numTouches: 2,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
				}
				touchstart(e, t, n) {
					this._zoomIn.touchstart(e, t, n), this._zoomOut.touchstart(e, t, n);
				}
				touchmove(e, t, n) {
					this._zoomIn.touchmove(e, t, n), this._zoomOut.touchmove(e, t, n);
				}
				touchend(e, t, n) {
					let i = this._zoomIn.touchend(e, t, n), a = this._zoomOut.touchend(e, t, n), o = this._tr;
					return i ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t) => t.easeTo({
						duration: 300,
						zoom: o.zoom + 1,
						around: o.unproject(i)
					}, { originalEvent: e }) }) : a ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: (t) => t.easeTo({
						duration: 300,
						zoom: o.zoom - 1,
						around: o.unproject(a)
					}, { originalEvent: e }) }) : void 0;
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class pa {
				constructor(e) {
					this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset();
				}
				reset(e) {
					this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e);
				}
				_move(...e) {
					let t = this._moveFunction(...e);
					if (t.bearingDelta || t.pitchDelta || t.rollDelta || t.around || t.panDelta) return this._active = !0, t;
				}
				dragStart(e, t) {
					this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(t) ? t[0] : t, this._activateOnStart && this._lastPoint && (this._active = !0));
				}
				dragMove(e, t) {
					if (!this.isEnabled()) return;
					let n = this._lastPoint;
					if (!n) return;
					if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e);
					let i = Array.isArray(t) ? t[0] : t;
					return !this._moved && i.dist(n) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = i, this._move(n, i));
				}
				dragEnd(e) {
					this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && u.suppressClick(), this.reset(e));
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				getClickTolerance() {
					return this._clickTolerance;
				}
			}
			let ma = {
				0: 1,
				2: 2
			};
			class ha {
				constructor(e) {
					this._correctEvent = e.checkCorrectEvent;
				}
				startMove(e) {
					this._eventButton = u.mouseButton(e);
				}
				endMove(e) {
					delete this._eventButton;
				}
				isValidStartEvent(e) {
					return this._correctEvent(e);
				}
				isValidMoveEvent(e) {
					return !function(e, t) {
						let n = ma[t];
						return e.buttons === void 0 || (e.buttons & n) !== n;
					}(e, this._eventButton);
				}
				isValidEndEvent(e) {
					return u.mouseButton(e) === this._eventButton;
				}
			}
			class ga {
				constructor() {
					this._firstTouch = void 0;
				}
				_isOneFingerTouch(e) {
					return e.targetTouches.length === 1;
				}
				_isSameTouchEvent(e) {
					return e.targetTouches[0].identifier === this._firstTouch;
				}
				startMove(e) {
					this._firstTouch = e.targetTouches[0].identifier;
				}
				endMove(e) {
					delete this._firstTouch;
				}
				isValidStartEvent(e) {
					return this._isOneFingerTouch(e);
				}
				isValidMoveEvent(e) {
					return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
				}
				isValidEndEvent(e) {
					return this._isOneFingerTouch(e) && this._isSameTouchEvent(e);
				}
			}
			class _a {
				constructor(e = new ha({ checkCorrectEvent: () => !0 }), t = new ga()) {
					this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = t;
				}
				_executeRelevantHandler(e, t, n) {
					return e instanceof MouseEvent ? t(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? n(e) : void 0;
				}
				startMove(e) {
					this._executeRelevantHandler(e, ((e) => this.mouseMoveStateManager.startMove(e)), ((e) => this.oneFingerTouchMoveStateManager.startMove(e)));
				}
				endMove(e) {
					this._executeRelevantHandler(e, ((e) => this.mouseMoveStateManager.endMove(e)), ((e) => this.oneFingerTouchMoveStateManager.endMove(e)));
				}
				isValidStartEvent(e) {
					return this._executeRelevantHandler(e, ((e) => this.mouseMoveStateManager.isValidStartEvent(e)), ((e) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e)));
				}
				isValidMoveEvent(e) {
					return this._executeRelevantHandler(e, ((e) => this.mouseMoveStateManager.isValidMoveEvent(e)), ((e) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e)));
				}
				isValidEndEvent(e) {
					return this._executeRelevantHandler(e, ((e) => this.mouseMoveStateManager.isValidEndEvent(e)), ((e) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e)));
				}
			}
			let J = (e) => {
				e.mousedown = e.dragStart, e.mousemoveWindow = e.dragMove, e.mouseup = e.dragEnd, e.contextmenu = (e) => {
					e.preventDefault();
				};
			};
			class va {
				constructor(e, t) {
					this._clickTolerance = e.clickTolerance || 1, this._map = t, this.reset();
				}
				reset() {
					this._active = !1, this._touches = {}, this._sum = new t.P(0, 0);
				}
				_shouldBePrevented(e) {
					return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
				}
				touchstart(e, t, n) {
					return this._calculateTransform(e, t, n);
				}
				touchmove(e, t, n) {
					if (this._active) {
						if (!this._shouldBePrevented(n.length)) return e.preventDefault(), this._calculateTransform(e, t, n);
						this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e);
					}
				}
				touchend(e, t, n) {
					this._calculateTransform(e, t, n), this._active && this._shouldBePrevented(n.length) && this.reset();
				}
				touchcancel() {
					this.reset();
				}
				_calculateTransform(e, n, i) {
					i.length > 0 && (this._active = !0);
					let a = q(i, n), o = new t.P(0, 0), s = new t.P(0, 0), c = 0;
					for (let e in a) {
						let t = a[e], n = this._touches[e];
						n && (o._add(t), s._add(t.sub(n)), c++, a[e] = t);
					}
					if (this._touches = a, this._shouldBePrevented(c) || !s.mag()) return;
					let l = s.div(c);
					return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
						around: o.div(c),
						panDelta: l
					};
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class ya {
				constructor() {
					this.reset();
				}
				reset() {
					this._active = !1, delete this._firstTwoTouches;
				}
				touchstart(e, t, n) {
					this._firstTwoTouches || n.length < 2 || (this._firstTwoTouches = [n[0].identifier, n[1].identifier], this._start([t[0], t[1]]));
				}
				touchmove(e, t, n) {
					if (!this._firstTwoTouches) return;
					e.preventDefault();
					let [i, a] = this._firstTwoTouches, o = ba(n, t, i), s = ba(n, t, a);
					if (!o || !s) return;
					let c = this._aroundCenter ? null : o.add(s).div(2);
					return this._move([o, s], c, e);
				}
				touchend(e, t, n) {
					if (!this._firstTwoTouches) return;
					let [i, a] = this._firstTwoTouches, o = ba(n, t, i), s = ba(n, t, a);
					o && s || (this._active && u.suppressClick(), this.reset());
				}
				touchcancel() {
					this.reset();
				}
				enable(e) {
					this._enabled = !0, this._aroundCenter = !!e && e.around === "center";
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active;
				}
			}
			function ba(e, t, n) {
				for (let i = 0; i < e.length; i++) if (e[i].identifier === n) return t[i];
			}
			function xa(e, t) {
				return Math.log(e / t) / Math.LN2;
			}
			class Sa extends ya {
				reset() {
					super.reset(), delete this._distance, delete this._startDistance;
				}
				_start(e) {
					this._startDistance = this._distance = e[0].dist(e[1]);
				}
				_move(e, t) {
					let n = this._distance;
					if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(xa(this._distance, this._startDistance)) < .1)) return this._active = !0, {
						zoomDelta: xa(this._distance, n),
						pinchAround: t
					};
				}
			}
			function Ca(e, t) {
				return 180 * e.angleWith(t) / Math.PI;
			}
			class wa extends ya {
				reset() {
					super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
				}
				_start(e) {
					this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
				}
				_move(e, t, n) {
					let i = this._vector;
					if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, {
						bearingDelta: Ca(this._vector, i),
						pinchAround: t
					};
				}
				_isBelowThreshold(e) {
					this._minDiameter = Math.min(this._minDiameter, e.mag());
					let t = 25 / (Math.PI * this._minDiameter) * 360, n = Ca(e, this._startVector);
					return Math.abs(n) < t;
				}
			}
			function Ta(e) {
				return Math.abs(e.y) > Math.abs(e.x);
			}
			class Ea extends ya {
				constructor(e) {
					super(), this._currentTouchCount = 0, this._map = e;
				}
				reset() {
					super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
				}
				touchstart(e, t, n) {
					super.touchstart(e, t, n), this._currentTouchCount = n.length;
				}
				_start(e) {
					this._lastPoints = e, Ta(e[0].sub(e[1])) && (this._valid = !1);
				}
				_move(e, t, n) {
					if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
					let i = e[0].sub(this._lastPoints[0]), a = e[1].sub(this._lastPoints[1]);
					return this._valid = this.gestureBeginsVertically(i, a, n.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (i.y + a.y) / 2 * -.5 }) : void 0;
				}
				gestureBeginsVertically(e, t, n) {
					if (this._valid !== void 0) return this._valid;
					let i = e.mag() >= 2, a = t.mag() >= 2;
					if (!i && !a) return;
					if (!i || !a) return this._firstMove === void 0 && (this._firstMove = n), n - this._firstMove < 100 && void 0;
					let o = e.y > 0 == t.y > 0;
					return Ta(e) && Ta(t) && o;
				}
			}
			let Da = {
				panStep: 100,
				bearingStep: 15,
				pitchStep: 10
			};
			class Oa {
				constructor(e) {
					this._tr = new ca(e);
					let t = Da;
					this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;
				}
				reset() {
					this._active = !1;
				}
				keydown(e) {
					if (e.altKey || e.ctrlKey || e.metaKey) return;
					let t = 0, n = 0, i = 0, a = 0, o = 0;
					switch (e.keyCode) {
						case 61:
						case 107:
						case 171:
						case 187:
							t = 1;
							break;
						case 189:
						case 109:
						case 173:
							t = -1;
							break;
						case 37:
							e.shiftKey ? n = -1 : (e.preventDefault(), a = -1);
							break;
						case 39:
							e.shiftKey ? n = 1 : (e.preventDefault(), a = 1);
							break;
						case 38:
							e.shiftKey ? i = 1 : (e.preventDefault(), o = -1);
							break;
						case 40:
							e.shiftKey ? i = -1 : (e.preventDefault(), o = 1);
							break;
						default: return;
					}
					return this._rotationDisabled && (n = 0, i = 0), { cameraAnimation: (s) => {
						let c = this._tr;
						s.easeTo({
							duration: 300,
							easeId: "keyboardHandler",
							easing: ka,
							zoom: t ? Math.round(c.zoom) + t * (e.shiftKey ? 2 : 1) : c.zoom,
							bearing: c.bearing + n * this._bearingStep,
							pitch: c.pitch + i * this._pitchStep,
							offset: [-a * this._panStep, -o * this._panStep],
							center: c.center
						}, { originalEvent: e });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
				disableRotation() {
					this._rotationDisabled = !0;
				}
				enableRotation() {
					this._rotationDisabled = !1;
				}
			}
			function ka(e) {
				return e * (2 - e);
			}
			let Aa = 4.000244140625;
			class ja {
				constructor(e, t) {
					this._onTimeout = (e) => {
						this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
					}, this._map = e, this._tr = new ca(e), this._triggerRenderFrame = t, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222;
				}
				setZoomRate(e) {
					this._defaultZoomRate = e;
				}
				setWheelZoomRate(e) {
					this._wheelZoomRate = e;
				}
				isEnabled() {
					return !!this._enabled;
				}
				isActive() {
					return !!this._active || this._finishTimeout !== void 0;
				}
				isZooming() {
					return !!this._zooming;
				}
				enable(e) {
					this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && e.around === "center");
				}
				disable() {
					this.isEnabled() && (this._enabled = !1);
				}
				_shouldBePrevented(e) {
					return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e));
				}
				wheel(e) {
					if (!this.isEnabled()) return;
					if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
					let t = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY, n = l(), i = n - (this._lastWheelEventTime || 0);
					this._lastWheelEventTime = n, t !== 0 && t % Aa == 0 ? this._type = "wheel" : t !== 0 && Math.abs(t) < 4 ? this._type = "trackpad" : i > 400 ? (this._type = null, this._lastValue = t, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(i * t) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t += this._lastValue)), e.shiftKey && t && (t /= 4), this._type && (this._lastWheelEvent = e, this._delta -= t, this._active || this._start(e)), e.preventDefault();
				}
				_start(e) {
					if (!this._delta) return;
					this._frameId &&= null, this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
					let n = u.mousePos(this._map.getCanvas(), e), i = this._tr;
					this._aroundPoint = this._aroundCenter ? i.transform.locationToScreenPoint(t.S.convert(i.center)) : n, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
				}
				renderFrame() {
					if (!this._frameId || (this._frameId = null, !this.isActive())) return;
					let e = this._tr.transform;
					if (typeof this._lastExpectedZoom == "number") {
						let t = e.zoom - this._lastExpectedZoom;
						typeof this._startZoom == "number" && (this._startZoom += t), typeof this._targetZoom == "number" && (this._targetZoom += t);
					}
					if (this._delta !== 0) {
						let n = this._type === "wheel" && Math.abs(this._delta) > Aa ? this._wheelZoomRate : this._defaultZoomRate, i = 2 / (1 + Math.exp(-Math.abs(this._delta * n)));
						this._delta < 0 && i !== 0 && (i = 1 / i);
						let a = typeof this._targetZoom == "number" ? t.ah(this._targetZoom) : e.scale;
						this._targetZoom = e.constrain(e.getCameraLngLat(), t.ak(a * i)).zoom, this._type === "wheel" && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
					}
					let n = typeof this._targetZoom == "number" ? this._targetZoom : e.zoom, i = this._startZoom, a = this._easing, o, s = !1;
					if (this._type === "wheel" && i && a) {
						let e = l() - this._lastWheelEventTime, c = Math.min((e + 5) / 200, 1), u = a(c);
						o = t.C.number(i, n, u), c < 1 ? this._frameId ||= !0 : s = !0;
					} else o = n, s = !0;
					return this._active = !0, s && (this._active = !1, this._finishTimeout = setTimeout((() => {
						this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
					}), 200)), this._lastExpectedZoom = o, {
						noInertia: !0,
						needsRenderFrame: !s,
						zoomDelta: o - e.zoom,
						around: this._aroundPoint,
						originalEvent: this._lastWheelEvent
					};
				}
				_smoothOutEasing(e) {
					let n = t.co;
					if (this._prevEase) {
						let e = this._prevEase, i = (l() - e.start) / e.duration, a = e.easing(i + .01) - e.easing(i), o = .27 / Math.sqrt(a * a + 1e-4) * .01, s = Math.sqrt(.0729 - o * o);
						n = t.cm(o, s, .25, 1);
					}
					return this._prevEase = {
						start: l(),
						duration: e,
						easing: n
					}, n;
				}
				reset() {
					this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
				}
			}
			class Ma {
				constructor(e, t) {
					this._clickZoom = e, this._tapZoom = t;
				}
				enable() {
					this._clickZoom.enable(), this._tapZoom.enable();
				}
				disable() {
					this._clickZoom.disable(), this._tapZoom.disable();
				}
				isEnabled() {
					return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
				}
				isActive() {
					return this._clickZoom.isActive() || this._tapZoom.isActive();
				}
			}
			class Na {
				constructor(e) {
					this._tr = new ca(e), this.reset();
				}
				reset() {
					this._active = !1;
				}
				dblclick(e, t) {
					return e.preventDefault(), { cameraAnimation: (n) => {
						n.easeTo({
							duration: 300,
							zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
							around: this._tr.unproject(t)
						}, { originalEvent: e });
					} };
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Pa {
				constructor() {
					this._tap = new da({
						numTouches: 1,
						numTaps: 1
					}), this.reset();
				}
				reset() {
					this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
				}
				touchstart(e, t, n) {
					if (!this._swipePoint) if (this._tapTime) {
						let i = t[0], a = e.timeStamp - this._tapTime < 500, o = this._tapPoint.dist(i) < 30;
						a && o ? n.length > 0 && (this._swipePoint = i, this._swipeTouch = n[0].identifier) : this.reset();
					} else this._tap.touchstart(e, t, n);
				}
				touchmove(e, t, n) {
					if (this._tapTime) {
						if (this._swipePoint) {
							if (n[0].identifier !== this._swipeTouch) return;
							let i = t[0], a = i.y - this._swipePoint.y;
							return this._swipePoint = i, e.preventDefault(), this._active = !0, { zoomDelta: a / 128 };
						}
					} else this._tap.touchmove(e, t, n);
				}
				touchend(e, t, n) {
					if (this._tapTime) this._swipePoint && n.length === 0 && this.reset();
					else {
						let i = this._tap.touchend(e, t, n);
						i && (this._tapTime = e.timeStamp, this._tapPoint = i);
					}
				}
				touchcancel() {
					this.reset();
				}
				enable() {
					this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this.reset();
				}
				isEnabled() {
					return this._enabled;
				}
				isActive() {
					return this._active;
				}
			}
			class Fa {
				constructor(e, t, n) {
					this._el = e, this._mousePan = t, this._touchPan = n;
				}
				enable(e) {
					this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
				}
				disable() {
					this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
				}
				isEnabled() {
					return this._mousePan.isEnabled() && this._touchPan.isEnabled();
				}
				isActive() {
					return this._mousePan.isActive() || this._touchPan.isActive();
				}
			}
			class Ia {
				constructor(e, t, n, i) {
					this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = t, this._mousePitch = n, this._mouseRoll = i;
				}
				enable() {
					this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
				}
				disable() {
					this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
				}
				isEnabled() {
					return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
				}
				isActive() {
					return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
				}
			}
			class La {
				constructor(e, t, n, i) {
					this._el = e, this._touchZoom = t, this._touchRotate = n, this._tapDragZoom = i, this._rotationDisabled = !1, this._enabled = !0;
				}
				enable(e) {
					this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
				}
				disable() {
					this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
				}
				isEnabled() {
					return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
				}
				isActive() {
					return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
				}
				disableRotation() {
					this._rotationDisabled = !0, this._touchRotate.disable();
				}
				enableRotation() {
					this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
				}
			}
			class Ra {
				constructor(e, t) {
					this._bypassKey = navigator.userAgent.indexOf("Mac") === -1 ? "ctrlKey" : "metaKey", this._map = e, this._options = t, this._enabled = !1;
				}
				isActive() {
					return !1;
				}
				reset() {}
				_setupUI() {
					if (this._container) return;
					let e = this._map.getCanvasContainer();
					e.classList.add("maplibregl-cooperative-gestures"), this._container = u.create("div", "maplibregl-cooperative-gesture-screen", e);
					let t = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
					this._bypassKey === "metaKey" && (t = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
					let n = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), i = document.createElement("div");
					i.className = "maplibregl-desktop-message", i.textContent = t, this._container.appendChild(i);
					let a = document.createElement("div");
					a.className = "maplibregl-mobile-message", a.textContent = n, this._container.appendChild(a), this._container.setAttribute("aria-hidden", "true");
				}
				_destroyUI() {
					this._container && (u.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
				}
				enable() {
					this._setupUI(), this._enabled = !0;
				}
				disable() {
					this._enabled = !1, this._destroyUI();
				}
				isEnabled() {
					return this._enabled;
				}
				isBypassed(e) {
					return e[this._bypassKey];
				}
				notifyGestureBlocked(e, n) {
					this._enabled && (this._map.fire(new t.l("cooperativegestureprevented", {
						gestureType: e,
						originalEvent: n
					})), this._container.classList.add("maplibregl-show"), setTimeout((() => {
						this._container.classList.remove("maplibregl-show");
					}), 100));
				}
			}
			let za = (e) => e.zoom || e.drag || e.roll || e.pitch || e.rotate;
			class Ba extends t.l {}
			function Va(e) {
				return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta || e.rollDelta;
			}
			class Ha {
				constructor(e, n) {
					this.handleWindowEvent = (e) => {
						this.handleEvent(e, `${e.type}Window`);
					}, this.handleEvent = (e, n) => {
						if (e.type === "blur") return void this.stop(!0);
						this._updatingCamera = !0;
						let i = e.type === "renderFrame" ? void 0 : e, a = { needsRenderFrame: !1 }, o = {}, s = {};
						for (let { handlerName: c, handler: l, allowed: d } of this._handlers) {
							if (!l.isEnabled()) continue;
							let f;
							if (this._blockedByActive(s, d, c)) l.reset();
							else if (l[n || e.type]) {
								if (t.cp(e, n || e.type)) {
									let t = u.mousePos(this._map.getCanvas(), e);
									f = l[n || e.type](e, t);
								} else if (t.cq(e, n || e.type)) {
									let t = this._getMapTouches(e.touches), i = u.touchPos(this._map.getCanvas(), t);
									f = l[n || e.type](e, i, t);
								} else t.cr(n || e.type) || (f = l[n || e.type](e));
								this.mergeHandlerResult(a, o, f, c, i), f && f.needsRenderFrame && this._triggerRenderFrame();
							}
							(f || l.isActive()) && (s[c] = l);
						}
						let c = {};
						for (let e in this._previousActiveHandlers) s[e] || (c[e] = i);
						this._previousActiveHandlers = s, (Object.keys(c).length || Va(a)) && (this._changes.push([
							a,
							o,
							c
						]), this._triggerRenderFrame()), (Object.keys(s).length || Va(a)) && this._map._stop(!0), this._updatingCamera = !1;
						let { cameraAnimation: l } = a;
						l && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], l(this._map));
					}, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ea(e), this._bearingSnap = n.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(n);
					let i = this._el;
					this._listeners = [
						[
							i,
							"touchstart",
							{ passive: !0 }
						],
						[
							i,
							"touchmove",
							{ passive: !1 }
						],
						[
							i,
							"touchend",
							void 0
						],
						[
							i,
							"touchcancel",
							void 0
						],
						[
							i,
							"mousedown",
							void 0
						],
						[
							i,
							"mousemove",
							void 0
						],
						[
							i,
							"mouseup",
							void 0
						],
						[
							document,
							"mousemove",
							{ capture: !0 }
						],
						[
							document,
							"mouseup",
							void 0
						],
						[
							i,
							"mouseover",
							void 0
						],
						[
							i,
							"mouseout",
							void 0
						],
						[
							i,
							"dblclick",
							void 0
						],
						[
							i,
							"click",
							void 0
						],
						[
							i,
							"keydown",
							{ capture: !1 }
						],
						[
							i,
							"keyup",
							void 0
						],
						[
							i,
							"wheel",
							{ passive: !1 }
						],
						[
							i,
							"contextmenu",
							void 0
						],
						[
							window,
							"blur",
							void 0
						]
					];
					for (let [e, t, n] of this._listeners) u.addEventListener(e, t, e === document ? this.handleWindowEvent : this.handleEvent, n);
				}
				destroy() {
					for (let [e, t, n] of this._listeners) u.removeEventListener(e, t, e === document ? this.handleWindowEvent : this.handleEvent, n);
				}
				_addDefaultHandlers(e) {
					let n = this._map, i = n.getCanvasContainer();
					this._add("mapEvent", new oa(n, e));
					let a = n.boxZoom = new la(n, e);
					this._add("boxZoom", a), e.interactive && e.boxZoom && a.enable();
					let o = n.cooperativeGestures = new Ra(n, e.cooperativeGestures);
					this._add("cooperativeGestures", o), e.cooperativeGestures && o.enable();
					let s = new fa(n), c = new Na(n);
					n.doubleClickZoom = new Ma(c, s), this._add("tapZoom", s), this._add("clickZoom", c), e.interactive && e.doubleClickZoom && n.doubleClickZoom.enable();
					let l = new Pa();
					this._add("tapDragZoom", l);
					let d = n.touchPitch = new Ea(n);
					this._add("touchPitch", d), e.interactive && e.touchPitch && n.touchPitch.enable(e.touchPitch);
					let f = () => n.project(n.getCenter()), p = function({ enable: e, clickTolerance: n, aroundCenter: i = !0, minPixelCenterThreshold: a = 100, rotateDegreesPerPixelMoved: o = .8 }, s) {
						let c = new ha({ checkCorrectEvent: (e) => u.mouseButton(e) === 0 && e.ctrlKey || u.mouseButton(e) === 2 && !e.ctrlKey });
						return new pa({
							clickTolerance: n,
							move: (e, n) => {
								let c = s();
								if (i && Math.abs(c.y - e.y) > a) return { bearingDelta: t.cn(new t.P(e.x, n.y), n, c) };
								let l = (n.x - e.x) * o;
								return i && n.y < c.y && (l = -l), { bearingDelta: l };
							},
							moveStateManager: c,
							enable: e,
							assignEvents: J
						});
					}(e, f), m = function({ enable: e, clickTolerance: t, pitchDegreesPerPixelMoved: n = -.5 }) {
						let i = new ha({ checkCorrectEvent: (e) => u.mouseButton(e) === 0 && e.ctrlKey || u.mouseButton(e) === 2 });
						return new pa({
							clickTolerance: t,
							move: (e, t) => ({ pitchDelta: (t.y - e.y) * n }),
							moveStateManager: i,
							enable: e,
							assignEvents: J
						});
					}(e), h = function({ enable: e, clickTolerance: t, rollDegreesPerPixelMoved: n = .3 }, i) {
						let a = new ha({ checkCorrectEvent: (e) => u.mouseButton(e) === 2 && e.ctrlKey });
						return new pa({
							clickTolerance: t,
							move: (e, t) => {
								let a = i(), o = (t.x - e.x) * n;
								return t.y < a.y && (o = -o), { rollDelta: o };
							},
							moveStateManager: a,
							enable: e,
							assignEvents: J
						});
					}(e, f);
					n.dragRotate = new Ia(e, p, m, h), this._add("mouseRotate", p, ["mousePitch"]), this._add("mousePitch", m, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", h, ["mousePitch"]), e.interactive && e.dragRotate && n.dragRotate.enable();
					let g = function({ enable: e, clickTolerance: t }) {
						let n = new ha({ checkCorrectEvent: (e) => u.mouseButton(e) === 0 && !e.ctrlKey });
						return new pa({
							clickTolerance: t,
							move: (e, t) => ({
								around: t,
								panDelta: t.sub(e)
							}),
							activateOnStart: !0,
							moveStateManager: n,
							enable: e,
							assignEvents: J
						});
					}(e), _ = new va(e, n);
					n.dragPan = new Fa(i, g, _), this._add("mousePan", g), this._add("touchPan", _, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && n.dragPan.enable(e.dragPan);
					let v = new wa(), y = new Sa();
					n.touchZoomRotate = new La(i, y, v, l), this._add("touchRotate", v, ["touchPan", "touchZoom"]), this._add("touchZoom", y, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && n.touchZoomRotate.enable(e.touchZoomRotate), this._add("blockableMapEvent", new sa(n));
					let b = n.scrollZoom = new ja(n, (() => this._triggerRenderFrame()));
					this._add("scrollZoom", b, ["mousePan"]), e.interactive && e.scrollZoom && n.scrollZoom.enable(e.scrollZoom);
					let x = n.keyboard = new Oa(n);
					this._add("keyboard", x), e.interactive && e.keyboard && n.keyboard.enable();
				}
				_add(e, t, n) {
					this._handlers.push({
						handlerName: e,
						handler: t,
						allowed: n
					}), this._handlersById[e] = t;
				}
				stop(e) {
					if (!this._updatingCamera) {
						for (let { handler: e } of this._handlers) e.reset();
						this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [];
					}
				}
				isActive() {
					for (let { handler: e } of this._handlers) if (e.isActive()) return !0;
					return !1;
				}
				isZooming() {
					return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
				}
				isRotating() {
					return !!this._eventsInProgress.rotate;
				}
				isMoving() {
					return !!za(this._eventsInProgress) || this.isZooming();
				}
				_blockedByActive(e, t, n) {
					for (let i in e) if (i !== n && (!t || t.indexOf(i) < 0)) return !0;
					return !1;
				}
				_getMapTouches(e) {
					let t = [];
					for (let n of e) this._el.contains(n.target) && t.push(n);
					return t;
				}
				mergeHandlerResult(e, n, i, a, o) {
					if (!i) return;
					t.e(e, i);
					let s = {
						handlerName: a,
						originalEvent: i.originalEvent || o
					};
					i.zoomDelta !== void 0 && (n.zoom = s), i.panDelta !== void 0 && (n.drag = s), i.rollDelta !== void 0 && (n.roll = s), i.pitchDelta !== void 0 && (n.pitch = s), i.bearingDelta !== void 0 && (n.rotate = s);
				}
				_applyChanges() {
					let e = {}, n = {}, i = {};
					for (let [a, o, s] of this._changes) a.panDelta && (e.panDelta = (e.panDelta || new t.P(0, 0))._add(a.panDelta)), a.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + a.zoomDelta), a.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + a.bearingDelta), a.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + a.pitchDelta), a.rollDelta && (e.rollDelta = (e.rollDelta || 0) + a.rollDelta), a.around !== void 0 && (e.around = a.around), a.pinchAround !== void 0 && (e.pinchAround = a.pinchAround), a.noInertia && (e.noInertia = a.noInertia), t.e(n, o), t.e(i, s);
					this._updateMapTransform(e, n, i), this._changes = [];
				}
				_updateMapTransform(e, t, n) {
					let i = this._map, a = i._getTransformForUpdate(), o = i.terrain;
					if (!(Va(e) || o && this._terrainMovement)) return this._fireEvents(t, n, !0);
					i._stop(!0);
					let { panDelta: s, zoomDelta: c, bearingDelta: l, pitchDelta: u, rollDelta: d, around: f, pinchAround: p } = e;
					p !== void 0 && (f = p), f ||= i.transform.centerPoint, o && !a.isPointOnMapSurface(f) && (f = a.centerPoint);
					let m = {
						panDelta: s,
						zoomDelta: c,
						rollDelta: d,
						pitchDelta: u,
						bearingDelta: l,
						around: f
					};
					this._map.cameraHelper.useGlobeControls && !a.isPointOnMapSurface(f) && (f = a.centerPoint);
					let h = f.distSqr(a.centerPoint) < .01 ? a.center : a.screenPointToLocation(s ? f.sub(s) : f);
					this._handleMapControls({
						terrain: o,
						tr: a,
						deltasForHelper: m,
						preZoomAroundLoc: h,
						combinedEventsInProgress: t,
						panDelta: s
					}), i._applyUpdatedTransform(a), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(t, n, !0);
				}
				_handleMapControls({ terrain: e, tr: t, deltasForHelper: n, preZoomAroundLoc: i, combinedEventsInProgress: a, panDelta: o }) {
					let s = this._map.cameraHelper;
					if (s.handleMapControlsRollPitchBearingZoom(n, t), e) return s.useGlobeControls ? (this._terrainMovement || !a.drag && !a.zoom || (this._terrainMovement = !0, this._map._elevationFreeze = !0), void s.handleMapControlsPan(n, t, i)) : this._terrainMovement || !a.drag && !a.zoom ? void (a.drag && this._terrainMovement && o ? t.setCenter(t.screenPointToLocation(t.centerPoint.sub(o))) : s.handleMapControlsPan(n, t, i)) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, void s.handleMapControlsPan(n, t, i));
					s.handleMapControlsPan(n, t, i);
				}
				_fireEvents(e, n, i) {
					let a = za(this._eventsInProgress), o = za(e), c = {};
					for (let t in e) {
						let { originalEvent: n } = e[t];
						this._eventsInProgress[t] || (c[`${t}start`] = n), this._eventsInProgress[t] = e[t];
					}
					for (let e in !a && o && this._fireEvent("movestart", o.originalEvent), c) this._fireEvent(e, c[e]);
					for (let t in o && this._fireEvent("move", o.originalEvent), e) {
						let { originalEvent: n } = e[t];
						this._fireEvent(t, n);
					}
					let l = {}, u;
					for (let e in this._eventsInProgress) {
						let { handlerName: t, originalEvent: i } = this._eventsInProgress[e];
						this._handlersById[t].isActive() || (delete this._eventsInProgress[e], u = n[t] || i, l[`${e}end`] = u);
					}
					for (let e in l) this._fireEvent(e, l[e]);
					let d = za(this._eventsInProgress), f = (a || o) && !d;
					if (f && this._terrainMovement) {
						this._map._elevationFreeze = !1, this._terrainMovement = !1;
						let e = this._map._getTransformForUpdate();
						this._map.getCenterClampedToGround() && e.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e);
					}
					if (i && f) {
						this._updatingCamera = !0;
						let e = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), n = (e) => e !== 0 && -this._bearingSnap < e && e < this._bearingSnap;
						!e || !e.essential && s.prefersReducedMotion ? (this._map.fire(new t.l("moveend", { originalEvent: u })), n(this._map.getBearing()) && this._map.resetNorth()) : (n(e.bearing || this._map.getBearing()) && (e.bearing = 0), e.freezeElevation = !0, this._map.easeTo(e, { originalEvent: u })), this._updatingCamera = !1;
					}
				}
				_fireEvent(e, n) {
					this._map.fire(new t.l(e, n ? { originalEvent: n } : {}));
				}
				_requestFrame() {
					return this._map.triggerRepaint(), this._map._renderTaskQueue.add(((e) => {
						delete this._frameId, this.handleEvent(new Ba("renderFrame", { timeStamp: e })), this._applyChanges();
					}));
				}
				_triggerRenderFrame() {
					this._frameId === void 0 && (this._frameId = this._requestFrame());
				}
			}
			class Ua extends t.E {
				constructor(e, t, n) {
					super(), this._renderFrameCallback = () => {
						let e = Math.min((l() - this._easeStart) / this._easeOptions.duration, 1);
						this._onEaseFrame(this._easeOptions.easing(e)), e < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
					}, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = n.bearingSnap, this.cameraHelper = t, this.on("moveend", (() => {
						delete this._requestedCameraState;
					}));
				}
				migrateProjection(e, t) {
					e.apply(this.transform), this.transform = e, this.cameraHelper = t;
				}
				getCenter() {
					return new t.S(this.transform.center.lng, this.transform.center.lat);
				}
				setCenter(e, t) {
					return this.jumpTo({ center: e }, t);
				}
				getCenterElevation() {
					return this.transform.elevation;
				}
				setCenterElevation(e, t) {
					return this.jumpTo({ elevation: e }, t), this;
				}
				getCenterClampedToGround() {
					return this._centerClampedToGround;
				}
				setCenterClampedToGround(e) {
					this._centerClampedToGround = e;
				}
				panBy(e, n, i) {
					return e = t.P.convert(e).mult(-1), this.panTo(this.transform.center, t.e({ offset: e }, n), i);
				}
				panTo(e, n, i) {
					return this.easeTo(t.e({ center: e }, n), i);
				}
				getZoom() {
					return this.transform.zoom;
				}
				setZoom(e, t) {
					return this.jumpTo({ zoom: e }, t), this;
				}
				zoomTo(e, n, i) {
					return this.easeTo(t.e({ zoom: e }, n), i);
				}
				zoomIn(e, t) {
					return this.zoomTo(this.getZoom() + 1, e, t), this;
				}
				zoomOut(e, t) {
					return this.zoomTo(this.getZoom() - 1, e, t), this;
				}
				getVerticalFieldOfView() {
					return this.transform.fov;
				}
				setVerticalFieldOfView(e, n) {
					return e != this.transform.fov && (this.transform.setFov(e), this.fire(new t.l("movestart", n)).fire(new t.l("move", n)).fire(new t.l("moveend", n))), this;
				}
				getBearing() {
					return this.transform.bearing;
				}
				setBearing(e, t) {
					return this.jumpTo({ bearing: e }, t), this;
				}
				getPadding() {
					return this.transform.padding;
				}
				setPadding(e, t) {
					return this.jumpTo({ padding: e }, t), this;
				}
				rotateTo(e, n, i) {
					return this.easeTo(t.e({ bearing: e }, n), i);
				}
				resetNorth(e, n) {
					return this.rotateTo(0, t.e({ duration: 1e3 }, e), n), this;
				}
				resetNorthPitch(e, n) {
					return this.easeTo(t.e({
						bearing: 0,
						pitch: 0,
						roll: 0,
						duration: 1e3
					}, e), n), this;
				}
				snapToNorth(e, t) {
					return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;
				}
				getPitch() {
					return this.transform.pitch;
				}
				setPitch(e, t) {
					return this.jumpTo({ pitch: e }, t), this;
				}
				getRoll() {
					return this.transform.roll;
				}
				setRoll(e, t) {
					return this.jumpTo({ roll: e }, t), this;
				}
				cameraForBounds(e, t) {
					e = ce.convert(e).adjustAntiMeridian();
					let n = t && t.bearing || 0;
					return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), n, t);
				}
				_cameraForBoxAndBearing(e, n, i, a) {
					let o = {
						top: 0,
						bottom: 0,
						right: 0,
						left: 0
					};
					if (typeof (a = t.e({
						padding: o,
						offset: [0, 0],
						maxZoom: this.transform.maxZoom
					}, a)).padding == "number") {
						let e = a.padding;
						a.padding = {
							top: e,
							bottom: e,
							right: e,
							left: e
						};
					}
					let s = t.e(o, a.padding);
					a.padding = s;
					let c = this.transform, l = new ce(e, n);
					return this.cameraHelper.cameraForBoxAndBearing(a, s, l, i, c);
				}
				fitBounds(e, t, n) {
					return this._fitInternal(this.cameraForBounds(e, t), t, n);
				}
				fitScreenCoordinates(e, n, i, a, o) {
					return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e)), this.transform.screenPointToLocation(t.P.convert(n)), i, a), a, o);
				}
				_fitInternal(e, n, i) {
					return e ? (delete (n = t.e(e, n)).padding, n.linear ? this.easeTo(n, i) : this.flyTo(n, i)) : this;
				}
				jumpTo(e, n) {
					this.stop();
					let i = this._getTransformForUpdate(), a = !1, o = !1, s = !1, c = i.zoom;
					this.cameraHelper.handleJumpToCenterZoom(i, e);
					let l = i.zoom !== c;
					return "elevation" in e && i.elevation !== +e.elevation && i.setElevation(+e.elevation), "bearing" in e && i.bearing !== +e.bearing && (a = !0, i.setBearing(+e.bearing)), "pitch" in e && i.pitch !== +e.pitch && (o = !0, i.setPitch(+e.pitch)), "roll" in e && i.roll !== +e.roll && (s = !0, i.setRoll(+e.roll)), e.padding == null || i.isPaddingEqual(e.padding) || i.setPadding(e.padding), this._applyUpdatedTransform(i), this.fire(new t.l("movestart", n)).fire(new t.l("move", n)), l && this.fire(new t.l("zoomstart", n)).fire(new t.l("zoom", n)).fire(new t.l("zoomend", n)), a && this.fire(new t.l("rotatestart", n)).fire(new t.l("rotate", n)).fire(new t.l("rotateend", n)), o && this.fire(new t.l("pitchstart", n)).fire(new t.l("pitch", n)).fire(new t.l("pitchend", n)), s && this.fire(new t.l("rollstart", n)).fire(new t.l("roll", n)).fire(new t.l("rollend", n)), this.fire(new t.l("moveend", n));
				}
				calculateCameraOptionsFromTo(e, n, i, a = 0) {
					let o = t.a1.fromLngLat(e, n), s = t.a1.fromLngLat(i, a), c = s.x - o.x, l = s.y - o.y, u = s.z - o.z, d = Math.hypot(c, l, u);
					if (d === 0) throw Error("Can't calculate camera options with same From and To");
					let f = Math.hypot(c, l), p = t.ak(this.transform.cameraToCenterDistance / d / this.transform.tileSize), m = 180 * Math.atan2(c, -l) / Math.PI, h = 180 * Math.acos(f / d) / Math.PI;
					return h = u < 0 ? 90 - h : 90 + h, {
						center: s.toLngLat(),
						elevation: a,
						zoom: p,
						pitch: h,
						bearing: m
					};
				}
				calculateCameraOptionsFromCameraLngLatAltRotation(e, t, n, i, a) {
					let o = this.transform.calculateCenterFromCameraLngLatAlt(e, t, n, i);
					return {
						center: o.center,
						elevation: o.elevation,
						zoom: o.zoom,
						bearing: n,
						pitch: i,
						roll: a
					};
				}
				easeTo(e, n) {
					this._stop(!1, e.easeId), (!1 === (e = t.e({
						offset: [0, 0],
						duration: 500,
						easing: t.co
					}, e)).animate || !e.essential && s.prefersReducedMotion) && (e.duration = 0);
					let i = this._getTransformForUpdate(), a = this.getBearing(), o = i.pitch, c = i.roll, l = "bearing" in e ? this._normalizeBearing(e.bearing, a) : a, u = "pitch" in e ? +e.pitch : o, d = "roll" in e ? this._normalizeBearing(e.roll, c) : c, f = "padding" in e ? e.padding : i.padding, p = t.P.convert(e.offset), m, h;
					e.around && (m = t.S.convert(e.around), h = i.locationToScreenPoint(m));
					let g = {
						moving: this._moving,
						zooming: this._zooming,
						rotating: this._rotating,
						pitching: this._pitching,
						rolling: this._rolling
					}, _ = this.cameraHelper.handleEaseTo(i, {
						bearing: l,
						pitch: u,
						roll: d,
						padding: f,
						around: m,
						aroundPoint: h,
						offsetAsPoint: p,
						offset: e.offset,
						zoom: e.zoom,
						center: e.center
					});
					return this._rotating = this._rotating || a !== l, this._pitching = this._pitching || u !== o, this._rolling = this._rolling || d !== c, this._padding = !i.isPaddingEqual(f), this._zooming = this._zooming || _.isZooming, this._easeId = e.easeId, this._prepareEase(n, e.noMoveStart, g), this.terrain && this._prepareElevation(_.elevationCenter), this._ease(((t) => {
						_.easeFunc(t), this.terrain && !e.freezeElevation && this._updateElevation(t), this._applyUpdatedTransform(i), this._fireMoveEvents(n);
					}), ((t) => {
						this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(n, t);
					}), e), this;
				}
				_prepareEase(e, n, i = {}) {
					this._moving = !0, n || i.moving || this.fire(new t.l("movestart", e)), this._zooming && !i.zooming && this.fire(new t.l("zoomstart", e)), this._rotating && !i.rotating && this.fire(new t.l("rotatestart", e)), this._pitching && !i.pitching && this.fire(new t.l("pitchstart", e)), this._rolling && !i.rolling && this.fire(new t.l("rollstart", e));
				}
				_prepareElevation(e) {
					this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0;
				}
				_updateElevation(e) {
					this._elevationStart !== void 0 && this._elevationCenter !== void 0 || this._prepareElevation(this.transform.center), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
					let n = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
					if (e < 1 && n !== this._elevationTarget) {
						let t = this._elevationTarget - this._elevationStart;
						this._elevationStart += e * (t - (n - (t * e + this._elevationStart)) / (1 - e)), this._elevationTarget = n;
					}
					this.transform.setElevation(t.C.number(this._elevationStart, this._elevationTarget, e));
				}
				_finalizeElevation() {
					this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
				}
				_getTransformForUpdate() {
					return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState ||= this.transform.clone(), this._requestedCameraState) : this.transform;
				}
				_elevateCameraIfInsideTerrain(e) {
					if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {};
					let t = e.getCameraLngLat(), n = e.getCameraAltitude(), i = this.terrain ? this.terrain.getElevationForLngLatZoom(t, e.zoom) : 0;
					if (n < i) {
						let n = this.calculateCameraOptionsFromTo(t, i, e.center, e.elevation);
						return {
							pitch: n.pitch,
							zoom: n.zoom
						};
					}
					return {};
				}
				_applyUpdatedTransform(e) {
					let t = [];
					if (t.push(((e) => this._elevateCameraIfInsideTerrain(e))), this.transformCameraUpdate && t.push(((e) => this.transformCameraUpdate(e))), !t.length) return;
					let n = e.clone();
					for (let e of t) {
						let t = n.clone(), { center: i, zoom: a, roll: o, pitch: s, bearing: c, elevation: l } = e(t);
						i && t.setCenter(i), l !== void 0 && t.setElevation(l), a !== void 0 && t.setZoom(a), o !== void 0 && t.setRoll(o), s !== void 0 && t.setPitch(s), c !== void 0 && t.setBearing(c), n.apply(t);
					}
					this.transform.apply(n);
				}
				_fireMoveEvents(e) {
					this.fire(new t.l("move", e)), this._zooming && this.fire(new t.l("zoom", e)), this._rotating && this.fire(new t.l("rotate", e)), this._pitching && this.fire(new t.l("pitch", e)), this._rolling && this.fire(new t.l("roll", e));
				}
				_afterEase(e, n) {
					if (this._easeId && n && this._easeId === n) return;
					delete this._easeId;
					let i = this._zooming, a = this._rotating, o = this._pitching, s = this._rolling;
					this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, i && this.fire(new t.l("zoomend", e)), a && this.fire(new t.l("rotateend", e)), o && this.fire(new t.l("pitchend", e)), s && this.fire(new t.l("rollend", e)), this.fire(new t.l("moveend", e));
				}
				flyTo(e, n) {
					if (!e.essential && s.prefersReducedMotion) {
						let i = t.Q(e, [
							"center",
							"zoom",
							"bearing",
							"pitch",
							"roll",
							"elevation",
							"padding"
						]);
						return this.jumpTo(i, n);
					}
					this.stop(), e = t.e({
						offset: [0, 0],
						speed: 1.2,
						curve: 1.42,
						easing: t.co
					}, e);
					let i = this._getTransformForUpdate(), a = i.bearing, o = i.pitch, c = i.roll, l = i.padding, u = "bearing" in e ? this._normalizeBearing(e.bearing, a) : a, d = "pitch" in e ? +e.pitch : o, f = "roll" in e ? this._normalizeBearing(e.roll, c) : c, p = "padding" in e ? e.padding : i.padding, m = t.P.convert(e.offset), h = i.centerPoint.add(m), g = i.screenPointToLocation(h), _ = this.cameraHelper.handleFlyTo(i, {
						bearing: u,
						pitch: d,
						roll: f,
						padding: p,
						locationAtOffset: g,
						offsetAsPoint: m,
						center: e.center,
						minZoom: e.minZoom,
						zoom: e.zoom
					}), v = e.curve, y = Math.max(i.width, i.height), b = y / _.scaleOfZoom, x = _.pixelPathLength;
					typeof _.scaleOfMinZoom == "number" && (v = Math.sqrt(y / _.scaleOfMinZoom / x * 2));
					let S = v * v;
					function C(e) {
						let t = (b * b - y * y + (e ? -1 : 1) * S * S * x * x) / (2 * (e ? b : y) * S * x);
						return Math.log(Math.sqrt(t * t + 1) - t);
					}
					function w(e) {
						return (Math.exp(e) - Math.exp(-e)) / 2;
					}
					function T(e) {
						return (Math.exp(e) + Math.exp(-e)) / 2;
					}
					let E = C(!1), O = function(e) {
						return T(E) / T(E + v * e);
					}, k = function(e) {
						return y * ((T(E) * (w(t = E + v * e) / T(t)) - w(E)) / S) / x;
						var t;
					}, A = (C(!0) - E) / v;
					if (Math.abs(x) < 2e-6 || !isFinite(A)) {
						if (Math.abs(y - b) < 1e-6) return this.easeTo(e, n);
						let t = b < y ? -1 : 1;
						A = Math.abs(Math.log(b / y)) / v, k = () => 0, O = (e) => Math.exp(t * v * e);
					}
					return e.duration = "duration" in e ? +e.duration : 1e3 * A / ("screenSpeed" in e ? +e.screenSpeed / v : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = a !== u, this._pitching = d !== o, this._rolling = f !== c, this._padding = !i.isPaddingEqual(p), this._prepareEase(n, !1), this.terrain && this._prepareElevation(_.targetCenter), this._ease(((s) => {
						let g = s * A, v = 1 / O(g), y = k(g);
						this._rotating && i.setBearing(t.C.number(a, u, s)), this._pitching && i.setPitch(t.C.number(o, d, s)), this._rolling && i.setRoll(t.C.number(c, f, s)), this._padding && (i.interpolatePadding(l, p, s), h = i.centerPoint.add(m)), _.easeFunc(s, v, y, h), this.terrain && !e.freezeElevation && this._updateElevation(s), this._applyUpdatedTransform(i), this._fireMoveEvents(n);
					}), (() => {
						this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(n);
					}), e), this;
				}
				isEasing() {
					return !!this._easeFrameId;
				}
				stop() {
					return this._stop();
				}
				_stop(e, t) {
					var n;
					if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
						let e = this._onEaseEnd;
						delete this._onEaseEnd, e.call(this, t);
					}
					return e || (n = this.handlers) == null || n.stop(!1), this;
				}
				_ease(e, t, n) {
					!1 === n.animate || n.duration === 0 ? (e(1), t()) : (this._easeStart = l(), this._easeOptions = n, this._onEaseFrame = e, this._onEaseEnd = t, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
				}
				_normalizeBearing(e, n) {
					e = t.aO(e, -180, 180);
					let i = Math.abs(e - n);
					return Math.abs(e - 360 - n) < i && (e -= 360), Math.abs(e + 360 - n) < i && (e += 360), e;
				}
				queryTerrainElevation(e) {
					return this.terrain ? this.terrain.getElevationForLngLatZoom(t.S.convert(e), this.transform.tileZoom) : null;
				}
			}
			let Wa = {
				compact: !0,
				customAttribution: "<a href=\"https://maplibre.org/\" target=\"_blank\">MapLibre</a>"
			};
			class Ga {
				constructor(e = Wa) {
					this._toggleAttribution = () => {
						this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
					}, this._updateData = (e) => {
						!e || e.sourceDataType !== "metadata" && e.sourceDataType !== "visibility" && e.dataType !== "style" && e.type !== "terrain" || this._updateAttributions();
					}, this._updateCompact = () => {
						this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
					}, this._updateCompactMinimize = () => {
						this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
					}, this.options = e;
				}
				getDefaultPosition() {
					return "bottom-right";
				}
				onAdd(e) {
					return this._map = e, this._compact = this.options.compact, this._container = u.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = u.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = u.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
				}
				onRemove() {
					u.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
				}
				_setElementTitle(e, t) {
					let n = this._map._getUIString(`AttributionControl.${t}`);
					e.title = n, e.setAttribute("aria-label", n);
				}
				_updateAttributions() {
					if (!this._map.style) return;
					let e = [];
					if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(((e) => typeof e == "string" ? e : ""))) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)), this._map.style.stylesheet) {
						let e = this._map.style.stylesheet;
						this.styleOwner = e.owner, this.styleId = e.id;
					}
					let t = this._map.style.sourceCaches;
					for (let n in t) {
						let i = t[n];
						if (i.used || i.usedForTerrain) {
							let t = i.getSource();
							t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);
						}
					}
					e = e.filter(((e) => String(e).trim())), e.sort(((e, t) => e.length - t.length)), e = e.filter(((t, n) => {
						for (let i = n + 1; i < e.length; i++) if (e[i].indexOf(t) >= 0) return !1;
						return !0;
					}));
					let n = e.join(" | ");
					n !== this._attribHTML && (this._attribHTML = n, e.length ? (this._innerContainer.innerHTML = u.sanitize(n), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
				}
			}
			class Ka {
				constructor(e = {}) {
					this._updateCompact = () => {
						let e = this._container.children;
						if (e.length) {
							let t = e[0];
							this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 !== this._compact && t.classList.add("maplibregl-compact") : t.classList.remove("maplibregl-compact");
						}
					}, this.options = e;
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e) {
					this._map = e, this._compact = this.options && this.options.compact, this._container = u.create("div", "maplibregl-ctrl");
					let t = u.create("a", "maplibregl-ctrl-logo");
					return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://maplibre.org/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
				}
				onRemove() {
					u.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
				}
			}
			class qa {
				constructor() {
					this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
				}
				add(e) {
					let t = ++this._id;
					return this._queue.push({
						callback: e,
						id: t,
						cancelled: !1
					}), t;
				}
				remove(e) {
					let t = this._currentlyRunning, n = t ? this._queue.concat(t) : this._queue;
					for (let t of n) if (t.id === e) return void (t.cancelled = !0);
				}
				run(e = 0) {
					if (this._currentlyRunning) throw Error("Attempting to run(), but is already running.");
					let t = this._currentlyRunning = this._queue;
					this._queue = [];
					for (let n of t) if (!n.cancelled && (n.callback(e), this._cleared)) break;
					this._cleared = !1, this._currentlyRunning = !1;
				}
				clear() {
					this._currentlyRunning && (this._cleared = !0), this._queue = [];
				}
			}
			var Y = t.aJ([{
				name: "a_pos3d",
				type: "Int16",
				components: 3
			}]);
			class Z extends t.E {
				constructor(e) {
					super(), this._lastTilesetChange = l(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize;
				}
				destruct() {
					this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
				}
				update(e, n) {
					this.sourceCache.update(e, n), this._renderableTilesKeys = [];
					let i = {};
					for (let a of Ie(e, {
						tileSize: this.tileSize,
						minzoom: this.minzoom,
						maxzoom: this.maxzoom,
						reparseOverscaled: !1,
						terrain: n,
						calculateTileZoom: this.sourceCache._source.calculateTileZoom
					})) i[a.key] = !0, this._renderableTilesKeys.push(a.key), this._tiles[a.key] || (a.terrainRttPosMatrix32f = new Float64Array(16), t.bZ(a.terrainRttPosMatrix32f, 0, t.$, t.$, 0, 0, 1), this._tiles[a.key] = new Ce(a, this.tileSize), this._lastTilesetChange = l());
					for (let e in this._tiles) i[e] || delete this._tiles[e];
				}
				freeRtt(e) {
					for (let t in this._tiles) {
						let n = this._tiles[t];
						(!e || n.tileID.equals(e) || n.tileID.isChildOf(e) || e.isChildOf(n.tileID)) && (n.rtt = []);
					}
				}
				getRenderableTiles() {
					return this._renderableTilesKeys.map(((e) => this.getTileByID(e)));
				}
				getTileByID(e) {
					return this._tiles[e];
				}
				getTerrainCoords(e, t) {
					return t ? this._getTerrainCoordsForTileRanges(e, t) : this._getTerrainCoordsForRegularTile(e);
				}
				_getTerrainCoordsForRegularTile(e) {
					let n = {};
					for (let i of this._renderableTilesKeys) {
						let a = this._tiles[i].tileID, o = e.clone(), s = t.ba();
						if (a.canonical.equals(e.canonical)) t.bZ(s, 0, t.$, t.$, 0, 0, 1);
						else if (a.canonical.isChildOf(e.canonical)) {
							let n = a.canonical.z - e.canonical.z, i = a.canonical.x - (a.canonical.x >> n << n), o = a.canonical.y - (a.canonical.y >> n << n), c = t.$ >> n;
							t.bZ(s, 0, c, c, 0, 0, 1), t.M(s, s, [
								-i * c,
								-o * c,
								0
							]);
						} else {
							if (!e.canonical.isChildOf(a.canonical)) continue;
							{
								let n = e.canonical.z - a.canonical.z, i = e.canonical.x - (e.canonical.x >> n << n), o = e.canonical.y - (e.canonical.y >> n << n), c = t.$ >> n;
								t.bZ(s, 0, t.$, t.$, 0, 0, 1), t.M(s, s, [
									i * c,
									o * c,
									0
								]), t.N(s, s, [
									1 / 2 ** n,
									1 / 2 ** n,
									0
								]);
							}
						}
						o.terrainRttPosMatrix32f = new Float32Array(s), n[i] = o;
					}
					return n;
				}
				_getTerrainCoordsForTileRanges(e, n) {
					let i = {};
					for (let a of this._renderableTilesKeys) {
						let o = this._tiles[a].tileID;
						if (!this._isWithinTileRanges(o, n)) continue;
						let s = e.clone(), c = t.ba();
						if (o.canonical.z === e.canonical.z) {
							let n = e.canonical.x - o.canonical.x, i = e.canonical.y - o.canonical.y;
							t.bZ(c, 0, t.$, t.$, 0, 0, 1), t.M(c, c, [
								n * t.$,
								i * t.$,
								0
							]);
						} else if (o.canonical.z > e.canonical.z) {
							let n = o.canonical.z - e.canonical.z, i = o.canonical.x - (o.canonical.x >> n << n), a = o.canonical.y - (o.canonical.y >> n << n), s = e.canonical.x - (o.canonical.x >> n), l = e.canonical.y - (o.canonical.y >> n), u = t.$ >> n;
							t.bZ(c, 0, u, u, 0, 0, 1), t.M(c, c, [
								-i * u + s * t.$,
								-a * u + l * t.$,
								0
							]);
						} else {
							let n = e.canonical.z - o.canonical.z, i = e.canonical.x - (e.canonical.x >> n << n), a = e.canonical.y - (e.canonical.y >> n << n), s = (e.canonical.x >> n) - o.canonical.x, l = (e.canonical.y >> n) - o.canonical.y, u = t.$ << n;
							t.bZ(c, 0, u, u, 0, 0, 1), t.M(c, c, [
								i * t.$ + s * u,
								a * t.$ + l * u,
								0
							]);
						}
						s.terrainRttPosMatrix32f = new Float32Array(c), i[a] = s;
					}
					return i;
				}
				getSourceTile(e, t) {
					let n = this.sourceCache._source, i = e.overscaledZ - this.deltaZoom;
					if (i > n.maxzoom && (i = n.maxzoom), i < n.minzoom) return null;
					this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(i).key);
					let a = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
					if ((!a || !a.dem) && t) for (; i >= n.minzoom && (!a || !a.dem);) a = this.sourceCache.getTileByID(e.scaledTo(i--).key);
					return a;
				}
				anyTilesAfterTime(e = Date.now()) {
					return this._lastTilesetChange >= e;
				}
				_isWithinTileRanges(e, t) {
					return t[e.canonical.z] && e.canonical.x >= t[e.canonical.z].minTileX && e.canonical.x <= t[e.canonical.z].maxTileX && e.canonical.y >= t[e.canonical.z].minTileY && e.canonical.y <= t[e.canonical.z].maxTileY;
				}
			}
			class Ja {
				constructor(e, t, n) {
					this._meshCache = {}, this.painter = e, this.sourceCache = new Z(t), this.options = n, this.exaggeration = typeof n.exaggeration == "number" ? n.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
				}
				getDEMElevation(e, n, i, a = t.$) {
					if (!(n >= 0 && n < a && i >= 0 && i < a)) return 0;
					let o = this.getTerrainData(e), s = o.tile?.dem;
					if (!s) return 0;
					let c = t.cs([], [n / a * t.$, i / a * t.$], o.u_terrain_matrix), l = [c[0] * s.dim, c[1] * s.dim], u = Math.floor(l[0]), d = Math.floor(l[1]), f = l[0] - u, p = l[1] - d;
					return s.get(u, d) * (1 - f) * (1 - p) + s.get(u + 1, d) * f * (1 - p) + s.get(u, d + 1) * (1 - f) * p + s.get(u + 1, d + 1) * f * p;
				}
				getElevationForLngLatZoom(e, n) {
					if (!t.ct(n, e.wrap())) return 0;
					let { tileID: i, mercatorX: a, mercatorY: o } = this._getOverscaledTileIDFromLngLatZoom(e, n);
					return this.getElevation(i, a % t.$, o % t.$, t.$);
				}
				getElevation(e, n, i, a = t.$) {
					return this.getDEMElevation(e, n, i, a) * this.exaggeration;
				}
				getTerrainData(e) {
					if (!this._emptyDemTexture) {
						let e = this.painter.context, n = new t.R({
							width: 1,
							height: 1
						}, new Uint8Array(4));
						this._emptyDepthTexture = new t.T(e, n, e.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [
							0,
							0,
							0,
							0
						], this._emptyDemTexture = new t.T(e, new t.R({
							width: 1,
							height: 1
						}), e.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.ai([]);
					}
					let n = this.sourceCache.getSourceTile(e, !0);
					if (n && n.dem && (!n.demTexture || n.needsTerrainPrepare)) {
						let e = this.painter.context;
						n.demTexture = this.painter.getTileTexture(n.dem.stride), n.demTexture ? n.demTexture.update(n.dem.getPixels(), { premultiply: !1 }) : n.demTexture = new t.T(e, n.dem.getPixels(), e.gl.RGBA, { premultiply: !1 }), n.demTexture.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), n.needsTerrainPrepare = !1;
					}
					let i = n && n + n.tileID.key + e.key;
					if (i && !this._demMatrixCache[i]) {
						let i = this.sourceCache.sourceCache._source.maxzoom, a = e.canonical.z - n.tileID.canonical.z;
						e.overscaledZ > e.canonical.z && (e.canonical.z >= i ? a = e.canonical.z - i : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
						let o = e.canonical.x - (e.canonical.x >> a << a), s = e.canonical.y - (e.canonical.y >> a << a), c = t.cu(new Float64Array(16), [
							1 / (t.$ << a),
							1 / (t.$ << a),
							0
						]);
						t.M(c, c, [
							o * t.$,
							s * t.$,
							0
						]), this._demMatrixCache[e.key] = {
							matrix: c,
							coord: e
						};
					}
					return {
						u_depth: 2,
						u_terrain: 3,
						u_terrain_dim: n && n.dem && n.dem.dim || 1,
						u_terrain_matrix: i ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
						u_terrain_unpack: n && n.dem && n.dem.getUnpackVector() || this._emptyDemUnpack,
						u_terrain_exaggeration: this.exaggeration,
						texture: (n && n.demTexture || this._emptyDemTexture).texture,
						depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
						tile: n
					};
				}
				getFramebuffer(e) {
					let n = this.painter, i = n.width / devicePixelRatio, a = n.height / devicePixelRatio;
					return !this._fbo || this._fbo.width === i && this._fbo.height === a || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new t.T(n.context, {
						width: i,
						height: a,
						data: null
					}, n.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new t.T(n.context, {
						width: i,
						height: a,
						data: null
					}, n.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(n.context.gl.NEAREST, n.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = n.context.createFramebuffer(i, a, !0, !1), this._fbo.depthAttachment.set(n.context.createRenderbuffer(n.context.gl.DEPTH_COMPONENT16, i, a))), this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
				}
				getCoordsTexture() {
					let e = this.painter.context;
					if (this._coordsTexture) return this._coordsTexture;
					let n = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
					for (let e = 0, t = 0; e < this._coordsTextureSize; e++) for (let i = 0; i < this._coordsTextureSize; i++, t += 4) n[t + 0] = 255 & i, n[t + 1] = 255 & e, n[t + 2] = i >> 8 << 4 | e >> 8, n[t + 3] = 0;
					let i = new t.R({
						width: this._coordsTextureSize,
						height: this._coordsTextureSize
					}, new Uint8Array(n.buffer)), a = new t.T(e, i, e.gl.RGBA, { premultiply: !1 });
					return a.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = a, a;
				}
				pointCoordinate(e) {
					this.painter.maybeDrawDepthAndCoords(!0);
					let n = new Uint8Array(4), i = this.painter.context, a = i.gl, o = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), s = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), c = Math.round(this.painter.height / devicePixelRatio);
					i.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a.readPixels(o, c - s - 1, 1, 1, a.RGBA, a.UNSIGNED_BYTE, n), i.bindFramebuffer.set(null);
					let l = n[0] + (n[2] >> 4 << 8), u = n[1] + ((15 & n[2]) << 8), d = this.coordsIndex[255 - n[3]], f = d && this.sourceCache.getTileByID(d);
					if (!f) return null;
					let p = this._coordsTextureSize, m = (1 << f.tileID.canonical.z) * p;
					return new t.a1((f.tileID.canonical.x * p + l) / m + f.tileID.wrap, (f.tileID.canonical.y * p + u) / m, this.getElevation(f.tileID, l, u, p));
				}
				depthAtPoint(e) {
					let t = new Uint8Array(4), n = this.painter.context, i = n.gl;
					return n.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), i.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, i.RGBA, i.UNSIGNED_BYTE, t), n.bindFramebuffer.set(null), (t[0] / 16777216 + t[1] / 65536 + t[2] / 256 + t[3]) / 256;
				}
				getTerrainMesh(e) {
					let n = this.painter.style.projection?.transitionState > 0, i = n && e.canonical.y === 0, a = n && e.canonical.y === (1 << e.canonical.z) - 1, o = `m_${i ? "n" : ""}_${a ? "s" : ""}`;
					if (this._meshCache[o]) return this._meshCache[o];
					let s = this.painter.context, c = new t.cv(), l = new t.aN(), u = this.meshSize, d = t.$ / u, f = u * u;
					for (let e = 0; e <= u; e++) for (let t = 0; t <= u; t++) c.emplaceBack(t * d, e * d, 0);
					for (let e = 0; e < f; e += u + 1) for (let t = 0; t < u; t++) l.emplaceBack(t + e, u + t + e + 1, u + t + e + 2), l.emplaceBack(t + e, u + t + e + 2, t + e + 1);
					let p = c.length, m = p + (u + 1), h = (u + 1) * u, g = i ? t.bh : 0, _ = i ? 0 : 1, v = a ? t.bi : t.$, y = a ? 0 : 1;
					for (let e = 0; e <= u; e++) c.emplaceBack(e * d, g, _);
					for (let e = 0; e <= u; e++) c.emplaceBack(e * d, v, y);
					for (let e = 0; e < u; e++) l.emplaceBack(h + e, m + e, m + e + 1), l.emplaceBack(h + e, m + e + 1, h + e + 1), l.emplaceBack(0 + e, p + e + 1, p + e), l.emplaceBack(0 + e, 0 + e + 1, p + e + 1);
					let b = c.length, x = b + 2 * (u + 1);
					for (let e of [0, 1]) for (let n = 0; n <= u; n++) for (let i of [0, 1]) c.emplaceBack(e * t.$, n * d, i);
					for (let e = 0; e < 2 * u; e += 2) l.emplaceBack(b + e, b + e + 1, b + e + 3), l.emplaceBack(b + e, b + e + 3, b + e + 2), l.emplaceBack(x + e, x + e + 3, x + e + 1), l.emplaceBack(x + e, x + e + 2, x + e + 3);
					let S = new Pt(s.createVertexBuffer(c, Y.members), s.createIndexBuffer(l), t.aM.simpleSegment(0, 0, c.length, l.length));
					return this._meshCache[o] = S, S;
				}
				getMeshFrameDelta(e) {
					return 2 * Math.PI * t.bu / 2 ** Math.max(e, 0) / 5;
				}
				getMinTileElevationForLngLatZoom(e, t) {
					let { tileID: n } = this._getOverscaledTileIDFromLngLatZoom(e, t);
					return this.getMinMaxElevation(n).minElevation ?? 0;
				}
				getMinMaxElevation(e) {
					let t = this.getTerrainData(e).tile, n = {
						minElevation: null,
						maxElevation: null
					};
					return t && t.dem && (n.minElevation = t.dem.min * this.exaggeration, n.maxElevation = t.dem.max * this.exaggeration), n;
				}
				_getOverscaledTileIDFromLngLatZoom(e, n) {
					let i = t.a1.fromLngLat(e.wrap()), a = (1 << n) * t.$, o = i.x * a, s = i.y * a, c = Math.floor(o / t.$), l = Math.floor(s / t.$);
					return {
						tileID: new t.Z(n, 0, n, c, l),
						mercatorX: o,
						mercatorY: s
					};
				}
			}
			class Ya {
				constructor(e, t, n) {
					this._context = e, this._size = t, this._tileSize = n, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
				}
				destruct() {
					for (let e of this._objects) e.texture.destroy(), e.fbo.destroy();
				}
				_createObject(e) {
					let n = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), i = new t.T(this._context, {
						width: this._tileSize,
						height: this._tileSize,
						data: null
					}, this._context.gl.RGBA);
					return i.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), n.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), n.colorAttachment.set(i.texture), {
						id: e,
						fbo: n,
						texture: i,
						stamp: -1,
						inUse: !1
					};
				}
				getObjectForId(e) {
					return this._objects[e];
				}
				useObject(e) {
					e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter(((t) => e.id !== t)), this._recentlyUsed.push(e.id);
				}
				stampObject(e) {
					e.stamp = ++this._stamp;
				}
				getOrCreateFreeObject() {
					for (let e of this._recentlyUsed) if (!this._objects[e].inUse) return this._objects[e];
					if (this._objects.length >= this._size) throw Error("No free RenderPool available, call freeAllObjects() required!");
					let e = this._createObject(this._objects.length);
					return this._objects.push(e), e;
				}
				freeObject(e) {
					e.inUse = !1;
				}
				freeAllObjects() {
					for (let e of this._objects) this.freeObject(e);
				}
				isFull() {
					return !(this._objects.length < this._size) && !1 === this._objects.some(((e) => !e.inUse));
				}
			}
			let Xa = {
				background: !0,
				fill: !0,
				line: !0,
				raster: !0,
				hillshade: !0,
				"color-relief": !0
			};
			class Za {
				constructor(e, t) {
					this.painter = e, this.terrain = t, this.pool = new Ya(e.context, 30, t.sourceCache.tileSize * t.qualityFactor);
				}
				destruct() {
					this.pool.destruct();
				}
				getTexture(e) {
					return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture;
				}
				prepareForRender(e, t) {
					for (let n in this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter(((n) => !e._layers[n].isHidden(t))), this._coordsAscending = {}, e.sourceCaches) {
						this._coordsAscending[n] = {};
						let t = e.sourceCaches[n].getVisibleCoordinates(), i = e.sourceCaches[n].getSource(), a = i instanceof V ? i.terrainTileRanges : null;
						for (let e of t) {
							let t = this.terrain.sourceCache.getTerrainCoords(e, a);
							for (let e in t) this._coordsAscending[n][e] || (this._coordsAscending[n][e] = []), this._coordsAscending[n][e].push(t[e]);
						}
					}
					this._coordsAscendingStr = {};
					for (let t of e._order) {
						let n = e._layers[t], i = n.source;
						if (Xa[n.type] && !this._coordsAscendingStr[i]) for (let e in this._coordsAscendingStr[i] = {}, this._coordsAscending[i]) this._coordsAscendingStr[i][e] = this._coordsAscending[i][e].map(((e) => e.key)).sort().join();
					}
					for (let e of this._renderableTiles) for (let t in this._coordsAscendingStr) {
						let n = this._coordsAscendingStr[t][e.tileID.key];
						n && n !== e.rttCoords[t] && (e.rtt = []);
					}
				}
				renderLayer(e, n) {
					if (e.isHidden(this.painter.transform.zoom)) return !1;
					let i = Object.assign(Object.assign({}, n), { isRenderingToTexture: !0 }), a = e.type, o = this.painter, s = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
					if (Xa[a] && (this._prevType && Xa[this._prevType] || this._stacks.push([]), this._prevType = a, this._stacks[this._stacks.length - 1].push(e.id), !s)) return !0;
					if (Xa[this._prevType] || Xa[a] && s) {
						this._prevType = a;
						let e = this._stacks.length - 1, n = this._stacks[e] || [];
						for (let a of this._renderableTiles) {
							if (this.pool.isFull() && (Ui(this.painter, this.terrain, this._rttTiles, i), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(a), a.rtt[e]) {
								let t = this.pool.getObjectForId(a.rtt[e].id);
								if (t.stamp === a.rtt[e].stamp) {
									this.pool.useObject(t);
									continue;
								}
							}
							let s = this.pool.getOrCreateFreeObject();
							this.pool.useObject(s), this.pool.stampObject(s), a.rtt[e] = {
								id: s.id,
								stamp: s.stamp
							}, o.context.bindFramebuffer.set(s.fbo.framebuffer), o.context.clear({
								color: t.bf.transparent,
								stencil: 0
							}), o.currentStencilSource = void 0;
							for (let e = 0; e < n.length; e++) {
								let t = o.style._layers[n[e]], c = t.source ? this._coordsAscending[t.source][a.tileID.key] : [a.tileID];
								o.context.viewport.set([
									0,
									0,
									s.fbo.width,
									s.fbo.height
								]), o._renderTileClippingMasks(t, c, !0), o.renderLayer(o, o.style.sourceCaches[t.source], t, c, i), t.source && (a.rttCoords[t.source] = this._coordsAscendingStr[t.source][a.tileID.key]);
							}
						}
						return Ui(this.painter, this.terrain, this._rttTiles, i), this._rttTiles = [], this.pool.freeAllObjects(), Xa[a];
					}
					return !1;
				}
			}
			let Qa = {
				"AttributionControl.ToggleAttribution": "Toggle attribution",
				"AttributionControl.MapFeedback": "Map feedback",
				"FullscreenControl.Enter": "Enter fullscreen",
				"FullscreenControl.Exit": "Exit fullscreen",
				"GeolocateControl.FindMyLocation": "Find my location",
				"GeolocateControl.LocationNotAvailable": "Location not available",
				"LogoControl.Title": "MapLibre logo",
				"Map.Title": "Map",
				"Marker.Title": "Map marker",
				"NavigationControl.ResetBearing": "Reset bearing to north",
				"NavigationControl.ZoomIn": "Zoom in",
				"NavigationControl.ZoomOut": "Zoom out",
				"Popup.Close": "Close popup",
				"ScaleControl.Feet": "ft",
				"ScaleControl.Meters": "m",
				"ScaleControl.Kilometers": "km",
				"ScaleControl.Miles": "mi",
				"ScaleControl.NauticalMiles": "nm",
				"GlobeControl.Enable": "Enable globe",
				"GlobeControl.Disable": "Disable globe",
				"TerrainControl.Enable": "Enable terrain",
				"TerrainControl.Disable": "Disable terrain",
				"CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
				"CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map",
				"CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
			}, $a = n, eo = {
				hash: !1,
				interactive: !0,
				bearingSnap: 7,
				attributionControl: Wa,
				maplibreLogo: !1,
				refreshExpiredTiles: !0,
				canvasContextAttributes: {
					antialias: !1,
					preserveDrawingBuffer: !1,
					powerPreference: "high-performance",
					failIfMajorPerformanceCaveat: !1,
					desynchronized: !1,
					contextType: void 0
				},
				scrollZoom: !0,
				minZoom: -2,
				maxZoom: 22,
				minPitch: 0,
				maxPitch: 60,
				boxZoom: !0,
				dragRotate: !0,
				dragPan: !0,
				keyboard: !0,
				doubleClickZoom: !0,
				touchZoomRotate: !0,
				touchPitch: !0,
				cooperativeGestures: !1,
				trackResize: !0,
				center: [0, 0],
				elevation: 0,
				zoom: 0,
				bearing: 0,
				pitch: 0,
				roll: 0,
				renderWorldCopies: !0,
				maxTileCacheSize: null,
				maxTileCacheZoomLevels: t.a.MAX_TILE_CACHE_ZOOM_LEVELS,
				transformRequest: null,
				transformCameraUpdate: null,
				transformConstrain: null,
				fadeDuration: 300,
				crossSourceCollisions: !0,
				clickTolerance: 3,
				localIdeographFontFamily: "sans-serif",
				pitchWithRotate: !0,
				rollEnabled: !1,
				validateStyle: !0,
				maxCanvasSize: [4096, 4096],
				cancelPendingTileRequestsWhileZooming: !0,
				centerClampedToGround: !0
			}, to = {
				showCompass: !0,
				showZoom: !0,
				visualizePitch: !1,
				visualizeRoll: !0
			};
			class no {
				constructor(e, n, i = !1) {
					this.mousedown = (e) => {
						this.startMove(e, u.mousePos(this.element, e)), u.addEventListener(window, "mousemove", this.mousemove), u.addEventListener(window, "mouseup", this.mouseup);
					}, this.mousemove = (e) => {
						this.move(e, u.mousePos(this.element, e));
					}, this.mouseup = (e) => {
						this._rotatePitchHandler.dragEnd(e), this.offTemp();
					}, this.touchstart = (e) => {
						e.targetTouches.length === 1 ? (this._startPos = this._lastPos = u.touchPos(this.element, e.targetTouches)[0], this.startMove(e, this._startPos), u.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), u.addEventListener(window, "touchend", this.touchend)) : this.reset();
					}, this.touchmove = (e) => {
						e.targetTouches.length === 1 ? (this._lastPos = u.touchPos(this.element, e.targetTouches)[0], this.move(e, this._lastPos)) : this.reset();
					}, this.touchend = (e) => {
						e.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this.reset = () => {
						this._rotatePitchHandler.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
					}, this._clickTolerance = 10, this.element = n;
					let a = new _a();
					this._rotatePitchHandler = new pa({
						clickTolerance: 3,
						move: (e, a) => {
							let o = n.getBoundingClientRect(), s = new t.P((o.bottom - o.top) / 2, (o.right - o.left) / 2);
							return {
								bearingDelta: t.cn(new t.P(e.x, a.y), a, s),
								pitchDelta: i ? -.5 * (a.y - e.y) : void 0
							};
						},
						moveStateManager: a,
						enable: !0,
						assignEvents: () => {}
					}), this.map = e, u.addEventListener(n, "mousedown", this.mousedown), u.addEventListener(n, "touchstart", this.touchstart, { passive: !1 }), u.addEventListener(n, "touchcancel", this.reset);
				}
				startMove(e, t) {
					this._rotatePitchHandler.dragStart(e, t), u.disableDrag();
				}
				move(e, t) {
					let n = this.map, { bearingDelta: i, pitchDelta: a } = this._rotatePitchHandler.dragMove(e, t) || {};
					i && n.setBearing(n.getBearing() + i), a && n.setPitch(n.getPitch() + a);
				}
				off() {
					let e = this.element;
					u.removeEventListener(e, "mousedown", this.mousedown), u.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), u.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), u.removeEventListener(window, "touchend", this.touchend), u.removeEventListener(e, "touchcancel", this.reset), this.offTemp();
				}
				offTemp() {
					u.enableDrag(), u.removeEventListener(window, "mousemove", this.mousemove), u.removeEventListener(window, "mouseup", this.mouseup), u.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), u.removeEventListener(window, "touchend", this.touchend);
				}
			}
			let ro;
			function io(e, n, i, a = !1) {
				if (a || !i.getCoveringTilesDetailsProvider().allowWorldCopies()) return e?.wrap();
				let o = new t.S(e.lng, e.lat);
				if (e = new t.S(e.lng, e.lat), n) {
					let a = new t.S(e.lng - 360, e.lat), o = new t.S(e.lng + 360, e.lat), s = i.locationToScreenPoint(e).distSqr(n);
					i.locationToScreenPoint(a).distSqr(n) < s ? e = a : i.locationToScreenPoint(o).distSqr(n) < s && (e = o);
				}
				for (; Math.abs(e.lng - i.center.lng) > 180;) {
					let t = i.locationToScreenPoint(e);
					if (t.x >= 0 && t.y >= 0 && t.x <= i.width && t.y <= i.height) break;
					e.lng > i.center.lng ? e.lng -= 360 : e.lng += 360;
				}
				return e.lng !== o.lng && i.isPointOnMapSurface(i.locationToScreenPoint(e)) ? e : o;
			}
			let ao = {
				center: "translate(-50%,-50%)",
				top: "translate(-50%,0)",
				"top-left": "translate(0,0)",
				"top-right": "translate(-100%,0)",
				bottom: "translate(-50%,-100%)",
				"bottom-left": "translate(0,-100%)",
				"bottom-right": "translate(-100%,-100%)",
				left: "translate(0,-50%)",
				right: "translate(-100%,-50%)"
			};
			function oo(e, t, n) {
				let i = e.classList;
				for (let e in ao) i.remove(`maplibregl-${n}-anchor-${e}`);
				i.add(`maplibregl-${n}-anchor-${t}`);
			}
			class so extends t.E {
				constructor(e) {
					if (super(), this._onKeyPress = (e) => {
						let t = e.code, n = e.charCode || e.keyCode;
						t !== "Space" && t !== "Enter" && n !== 32 && n !== 13 || this.togglePopup();
					}, this._onMapClick = (e) => {
						let t = e.originalEvent.target, n = this._element;
						this._popup && (t === n || n.contains(t)) && this.togglePopup();
					}, this._update = (e) => {
						if (!this._map) return;
						let t = this._map.loaded() && !this._map.isMoving();
						(e?.type === "terrain" || e?.type === "render" && !t) && this._map.once("render", this._update), this._lngLat = io(this._lngLat, this._flatPos, this._map.transform), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
						let n = "";
						this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? n = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (n = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
						let i = "";
						this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? i = "rotateX(0deg)" : this._pitchAlignment === "map" && (i = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e && e.type !== "moveend" || (this._pos = this._pos.round()), u.setTransform(this._element, `${ao[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i} ${n}`), s.frameAsync(new AbortController()).then((() => {
							this._updateOpacity(e && e.type === "moveend");
						})).catch((() => {}));
					}, this._onMove = (e) => {
						if (!this._isDragging) {
							let t = this._clickTolerance || this._map._clickTolerance;
							this._isDragging = e.point.dist(this._pointerdownPos) >= t;
						}
						this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new t.l("dragstart"))), this.fire(new t.l("drag")));
					}, this._onUp = () => {
						this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new t.l("dragend")), this._state = "inactive";
					}, this._addDragHandler = (e) => {
						this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(this._pos).add(this._offset), this._pointerdownPos = e.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
					}, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(e?.opacity, e?.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = t.P.convert(e && e.offset || [0, 0]);
					else {
						this._defaultMarker = !0, this._element = u.create("div");
						let n = u.createNS("http://www.w3.org/2000/svg", "svg");
						n.setAttributeNS(null, "display", "block"), n.setAttributeNS(null, "height", "41px"), n.setAttributeNS(null, "width", "27px"), n.setAttributeNS(null, "viewBox", "0 0 27 41");
						let i = u.createNS("http://www.w3.org/2000/svg", "g");
						i.setAttributeNS(null, "stroke", "none"), i.setAttributeNS(null, "stroke-width", "1"), i.setAttributeNS(null, "fill", "none"), i.setAttributeNS(null, "fill-rule", "evenodd");
						let a = u.createNS("http://www.w3.org/2000/svg", "g");
						a.setAttributeNS(null, "fill-rule", "nonzero");
						let o = u.createNS("http://www.w3.org/2000/svg", "g");
						o.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), o.setAttributeNS(null, "fill", "#000000");
						for (let e of [
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "10.5",
								ry: "5.25002273"
							},
							{
								rx: "9.5",
								ry: "4.77275007"
							},
							{
								rx: "8.5",
								ry: "4.29549936"
							},
							{
								rx: "7.5",
								ry: "3.81822308"
							},
							{
								rx: "6.5",
								ry: "3.34094679"
							},
							{
								rx: "5.5",
								ry: "2.86367051"
							},
							{
								rx: "4.5",
								ry: "2.38636864"
							}
						]) {
							let t = u.createNS("http://www.w3.org/2000/svg", "ellipse");
							t.setAttributeNS(null, "opacity", "0.04"), t.setAttributeNS(null, "cx", "10.5"), t.setAttributeNS(null, "cy", "5.80029008"), t.setAttributeNS(null, "rx", e.rx), t.setAttributeNS(null, "ry", e.ry), o.appendChild(t);
						}
						let s = u.createNS("http://www.w3.org/2000/svg", "g");
						s.setAttributeNS(null, "fill", this._color);
						let c = u.createNS("http://www.w3.org/2000/svg", "path");
						c.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), s.appendChild(c);
						let l = u.createNS("http://www.w3.org/2000/svg", "g");
						l.setAttributeNS(null, "opacity", "0.25"), l.setAttributeNS(null, "fill", "#000000");
						let d = u.createNS("http://www.w3.org/2000/svg", "path");
						d.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), l.appendChild(d);
						let f = u.createNS("http://www.w3.org/2000/svg", "g");
						f.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), f.setAttributeNS(null, "fill", "#FFFFFF");
						let p = u.createNS("http://www.w3.org/2000/svg", "g");
						p.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
						let m = u.createNS("http://www.w3.org/2000/svg", "circle");
						m.setAttributeNS(null, "fill", "#000000"), m.setAttributeNS(null, "opacity", "0.25"), m.setAttributeNS(null, "cx", "5.5"), m.setAttributeNS(null, "cy", "5.5"), m.setAttributeNS(null, "r", "5.4999962");
						let h = u.createNS("http://www.w3.org/2000/svg", "circle");
						h.setAttributeNS(null, "fill", "#FFFFFF"), h.setAttributeNS(null, "cx", "5.5"), h.setAttributeNS(null, "cy", "5.5"), h.setAttributeNS(null, "r", "5.4999962"), p.appendChild(m), p.appendChild(h), a.appendChild(o), a.appendChild(s), a.appendChild(l), a.appendChild(f), a.appendChild(p), n.appendChild(a), n.setAttributeNS(null, "height", 41 * this._scale + "px"), n.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(n), this._offset = t.P.convert(e && e.offset || [0, -14]);
					}
					if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", ((e) => {
						e.preventDefault();
					})), this._element.addEventListener("mousedown", ((e) => {
						e.preventDefault();
					})), oo(this._element, this._anchor, "marker"), e && e.className) for (let t of e.className.split(" ")) this._element.classList.add(t);
					this._popup = null;
				}
				addTo(e) {
					return this.remove(), this._map = e, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), this._element.hasAttribute("role") || this._element.setAttribute("role", "button"), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
				}
				remove() {
					return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), u.remove(this._element), this._popup && this._popup.remove(), this;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e) {
					return this._lngLat = t.S.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
				}
				getElement() {
					return this._element;
				}
				setPopup(e) {
					if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
						if (!("offset" in e.options)) {
							let t = 38.1, n = 13.5, i = 13.5 / Math.SQRT2;
							e.options.offset = this._defaultMarker ? {
								top: [0, 0],
								"top-left": [0, 0],
								"top-right": [0, 0],
								bottom: [0, -t],
								"bottom-left": [i, -1 * (t - n + i)],
								"bottom-right": [-i, -1 * (t - n + i)],
								left: [n, -1 * (t - n)],
								right: [-n, -1 * (t - n)]
							} : this._offset;
						}
						this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
					}
					return this;
				}
				setSubpixelPositioning(e) {
					return this._subpixelPositioning = e, this;
				}
				getPopup() {
					return this._popup;
				}
				togglePopup() {
					let e = this._popup;
					return this._element.style.opacity === this._opacityWhenCovered || e && (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map))), this;
				}
				_updateOpacity(e = !1) {
					var n;
					let i = this._map?.terrain, a = this._map.transform.isLocationOccluded(this._lngLat);
					if (!i || a) {
						let e = a ? this._opacityWhenCovered : this._opacity;
						this._element.style.opacity !== e && (this._element.style.opacity = e);
						return;
					}
					if (e) this._opacityTimeout = null;
					else {
						if (this._opacityTimeout) return;
						this._opacityTimeout = setTimeout((() => {
							this._opacityTimeout = null;
						}), 100);
					}
					let o = this._map, s = o.terrain.depthAtPoint(this._pos), c = o.terrain.getElevationForLngLatZoom(this._lngLat, o.transform.tileZoom);
					if (o.transform.lngLatToCameraDepth(this._lngLat, c) - s < .006) return void (this._element.style.opacity = this._opacity);
					let l = -this._offset.y / o.transform.pixelsPerMeter, u = Math.sin(o.getPitch() * Math.PI / 180) * l, d = o.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), f = o.transform.lngLatToCameraDepth(this._lngLat, c + u) - d > .006;
					(n = this._popup) != null && n.isOpen() && f && this._popup.remove(), this._element.style.opacity = f ? this._opacityWhenCovered : this._opacity;
				}
				getOffset() {
					return this._offset;
				}
				setOffset(e) {
					return this._offset = t.P.convert(e), this._update(), this;
				}
				addClassName(e) {
					this._element.classList.add(e);
				}
				removeClassName(e) {
					this._element.classList.remove(e);
				}
				toggleClassName(e) {
					return this._element.classList.toggle(e);
				}
				setDraggable(e) {
					return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
				}
				isDraggable() {
					return this._draggable;
				}
				setRotation(e) {
					return this._rotation = e || 0, this._update(), this;
				}
				getRotation() {
					return this._rotation;
				}
				setRotationAlignment(e) {
					return this._rotationAlignment = e || "auto", this._update(), this;
				}
				getRotationAlignment() {
					return this._rotationAlignment;
				}
				setPitchAlignment(e) {
					return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment, this._update(), this;
				}
				getPitchAlignment() {
					return this._pitchAlignment;
				}
				setOpacity(e, t) {
					return (this._opacity === void 0 || e === void 0 && t === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), e !== void 0 && (this._opacity = e), t !== void 0 && (this._opacityWhenCovered = t), this._map && this._updateOpacity(!0), this;
				}
			}
			let co = {
				positionOptions: {
					enableHighAccuracy: !1,
					maximumAge: 0,
					timeout: 6e3
				},
				fitBoundsOptions: { maxZoom: 15 },
				trackUserLocation: !1,
				showAccuracyCircle: !0,
				showUserLocation: !0
			}, lo = 0, uo = !1, fo = {
				maxWidth: 100,
				unit: "metric"
			};
			function po(e, t, n) {
				let i = n && n.maxWidth || 100, a = e._container.clientHeight / 2, o = e._container.clientWidth / 2, s = e.unproject([o - i / 2, a]), c = e.unproject([o + i / 2, a]), l = Math.round(e.project(c).x - e.project(s).x), u = Math.min(i, l, e._container.clientWidth), d = s.distanceTo(c);
				if (n && n.unit === "imperial") {
					let n = 3.2808 * d;
					n > 5280 ? mo(t, u, n / 5280, e._getUIString("ScaleControl.Miles")) : mo(t, u, n, e._getUIString("ScaleControl.Feet"));
				} else n && n.unit === "nautical" ? mo(t, u, d / 1852, e._getUIString("ScaleControl.NauticalMiles")) : d >= 1e3 ? mo(t, u, d / 1e3, e._getUIString("ScaleControl.Kilometers")) : mo(t, u, d, e._getUIString("ScaleControl.Meters"));
			}
			function mo(e, t, n, i) {
				let a = function(e) {
					let t = 10 ** (`${Math.floor(e)}`.length - 1), n = e / t;
					return n = n >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : n >= 1 ? 1 : function(e) {
						let t = 10 ** Math.ceil(-Math.log(e) / Math.LN10);
						return Math.round(e * t) / t;
					}(n), t * n;
				}(n);
				e.style.width = t * (a / n) + "px", e.innerHTML = `${a}&nbsp;${i}`;
			}
			let ho = {
				closeButton: !0,
				closeOnClick: !0,
				focusAfterOpen: !0,
				className: "",
				maxWidth: "240px",
				subpixelPositioning: !1,
				locationOccludedOpacity: void 0
			}, go = [
				"a[href]",
				"[tabindex]:not([tabindex='-1'])",
				"[contenteditable]:not([contenteditable='false'])",
				"button:not([disabled])",
				"input:not([disabled])",
				"select:not([disabled])",
				"textarea:not([disabled])"
			].join(", ");
			function _o(e) {
				if (e) {
					if (typeof e == "number") {
						let n = Math.round(Math.abs(e) / Math.SQRT2);
						return {
							center: new t.P(0, 0),
							top: new t.P(0, e),
							"top-left": new t.P(n, n),
							"top-right": new t.P(-n, n),
							bottom: new t.P(0, -e),
							"bottom-left": new t.P(n, -n),
							"bottom-right": new t.P(-n, -n),
							left: new t.P(e, 0),
							right: new t.P(-e, 0)
						};
					}
					if (e instanceof t.P || Array.isArray(e)) {
						let n = t.P.convert(e);
						return {
							center: n,
							top: n,
							"top-left": n,
							"top-right": n,
							bottom: n,
							"bottom-left": n,
							"bottom-right": n,
							left: n,
							right: n
						};
					}
					return {
						center: t.P.convert(e.center || [0, 0]),
						top: t.P.convert(e.top || [0, 0]),
						"top-left": t.P.convert(e["top-left"] || [0, 0]),
						"top-right": t.P.convert(e["top-right"] || [0, 0]),
						bottom: t.P.convert(e.bottom || [0, 0]),
						"bottom-left": t.P.convert(e["bottom-left"] || [0, 0]),
						"bottom-right": t.P.convert(e["bottom-right"] || [0, 0]),
						left: t.P.convert(e.left || [0, 0]),
						right: t.P.convert(e.right || [0, 0])
					};
				}
				return _o(new t.P(0, 0));
			}
			let vo = n;
			e.AJAXError = t.cz, e.Event = t.l, e.Evented = t.E, e.LngLat = t.S, e.MercatorCoordinate = t.a1, e.Point = t.P, e.addProtocol = t.cA, e.config = t.a, e.removeProtocol = t.cB, e.AttributionControl = Ga, e.BoxZoomHandler = la, e.CanvasSource = he, e.CooperativeGesturesHandler = Ra, e.DoubleClickZoomHandler = Ma, e.DragPanHandler = Fa, e.DragRotateHandler = Ia, e.EdgeInsets = zt, e.FullscreenControl = class extends t.E {
				constructor(e = {}) {
					super(), this._onFullscreenChange = () => {
						let e = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
						for (; e?.shadowRoot?.fullscreenElement;) e = e.shadowRoot.fullscreenElement;
						e === this._container !== this._fullscreen && this._handleFullscreenChange();
					}, this._onClickFullscreen = () => {
						this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
					}, this._fullscreen = !1, e && e.container && (e.container instanceof HTMLElement ? this._container = e.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
				}
				onAdd(e) {
					return this._map = e, this._container ||= this._map.getContainer(), this._controlContainer = u.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
				}
				onRemove() {
					u.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_setupUI() {
					let e = this._fullscreenButton = u.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
					u.create("span", "maplibregl-ctrl-icon", e).setAttribute("aria-hidden", "true"), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
				}
				_updateTitle() {
					let e = this._getTitle();
					this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.title = e;
				}
				_getTitle() {
					return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
				}
				_isFullscreen() {
					return this._fullscreen;
				}
				_handleFullscreenChange() {
					this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
				}
				_exitFullscreen() {
					window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
				}
				_requestFullscreen() {
					this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
				}
				_togglePseudoFullScreen() {
					this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
				}
			}, e.GeoJSONSource = pe, e.GeolocateControl = class extends t.E {
				constructor(e) {
					super(), this._onSuccess = (e) => {
						if (this._map) {
							if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new t.l("outofmaxbounds", e)), this._updateMarker(), void this._finish();
							if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) {
								case "WAITING_ACTIVE":
								case "ACTIVE_LOCK":
								case "ACTIVE_ERROR":
									this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
									break;
								case "BACKGROUND":
								case "BACKGROUND_ERROR":
									this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
									break;
								default: throw Error(`Unexpected watchState ${this._watchState}`);
							}
							this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.l("geolocate", e)), this._finish();
						}
					}, this._updateCamera = (e) => {
						let n = new t.S(e.coords.longitude, e.coords.latitude), i = e.coords.accuracy, a = this._map.getBearing(), o = t.e({ bearing: a }, this.options.fitBoundsOptions), s = ce.fromLngLat(n, i);
						this._map.fitBounds(s, o, { geolocateSource: !0 });
					}, this._updateMarker = (e) => {
						if (e) {
							let n = new t.S(e.coords.longitude, e.coords.latitude);
							this._accuracyCircleMarker.setLngLat(n).addTo(this._map), this._userLocationDotMarker.setLngLat(n).addTo(this._map), this._accuracy = e.coords.accuracy, this._updateCircleRadiusIfNeeded();
						} else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
					}, this._onUpdate = () => {
						this._updateCircleRadiusIfNeeded();
					}, this._onError = (e) => {
						if (this._map) {
							if (e.code === 1) {
								this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
								let e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.title = e, this._geolocateButton.setAttribute("aria-label", e), this._geolocationWatchID !== void 0 && this._clearWatch();
							} else {
								if (e.code === 3 && uo) return;
								this._setErrorState();
							}
							this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.l("error", e)), this._finish();
						}
					}, this._finish = () => {
						this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
					}, this._setupUI = () => {
						this._map && (this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this._geolocateButton = u.create("button", "maplibregl-ctrl-geolocate", this._container), u.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
					}, this._finishSetupUI = (e) => {
						if (this._map) {
							if (!1 === e) {
								t.w("Geolocation support is not available so the GeolocateControl will be disabled.");
								let e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
								this._geolocateButton.disabled = !0, this._geolocateButton.title = e, this._geolocateButton.setAttribute("aria-label", e);
							} else {
								let e = this._map._getUIString("GeolocateControl.FindMyLocation");
								this._geolocateButton.disabled = !1, this._geolocateButton.title = e, this._geolocateButton.setAttribute("aria-label", e);
							}
							this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = u.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new so({ element: this._dotElement }), this._circleElement = u.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new so({
								element: this._circleElement,
								pitchAlignment: "map"
							}), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onUpdate), this._map.on("move", this._onUpdate), this._map.on("rotate", this._onUpdate), this._map.on("pitch", this._onUpdate)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", ((e) => {
								let n = e?.[0] instanceof ResizeObserverEntry;
								e.geolocateSource || this._watchState !== "ACTIVE_LOCK" || n || this._map.isZooming() || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.l("trackuserlocationend")), this.fire(new t.l("userlocationlostfocus")));
							}));
						}
					}, this.options = t.e({}, co, e);
				}
				onAdd(e) {
					return this._map = e, this._container = u.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
						return t._(this, arguments, void 0, (function* (e = !1) {
							if (ro !== void 0 && !e) return ro;
							if (window.navigator.permissions === void 0) return ro = !!window.navigator.geolocation, ro;
							try {
								ro = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
							} catch {
								ro = !!window.navigator.geolocation;
							}
							return ro;
						}));
					}().then(((e) => this._finishSetupUI(e))), this._container;
				}
				onRemove() {
					this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), u.remove(this._container), this._map.off("zoom", this._onUpdate), this._map.off("move", this._onUpdate), this._map.off("rotate", this._onUpdate), this._map.off("pitch", this._onUpdate), this._map = void 0, lo = 0, uo = !1;
				}
				_isOutOfMapMaxBounds(e) {
					let t = this._map.getMaxBounds(), n = e.coords;
					return t && (n.longitude < t.getWest() || n.longitude > t.getEast() || n.latitude < t.getSouth() || n.latitude > t.getNorth());
				}
				_setErrorState() {
					switch (this._watchState) {
						case "WAITING_ACTIVE":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
							break;
						case "ACTIVE_LOCK":
							this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "BACKGROUND":
							this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
							break;
						case "ACTIVE_ERROR":
						case "BACKGROUND_ERROR":
						case "OFF":
						case void 0: break;
						default: throw Error(`Unexpected watchState ${this._watchState}`);
					}
				}
				_updateCircleRadiusIfNeeded() {
					let e = this._userLocationDotMarker.getLngLat();
					if (!(this.options.showUserLocation && this.options.showAccuracyCircle && this._accuracy && e)) return;
					let t = this._map.project(e), n = this._map.unproject([t.x + 100, t.y]), i = e.distanceTo(n) / 100, a = 2 * this._accuracy / i;
					this._circleElement.style.width = `${a.toFixed(2)}px`, this._circleElement.style.height = `${a.toFixed(2)}px`;
				}
				trigger() {
					if (!this._setup) return t.w("Geolocate control triggered before added to a map"), !1;
					if (this.options.trackUserLocation) {
						switch (this._watchState) {
							case "OFF":
								this._watchState = "WAITING_ACTIVE", this.fire(new t.l("trackuserlocationstart"));
								break;
							case "WAITING_ACTIVE":
							case "ACTIVE_LOCK":
							case "ACTIVE_ERROR":
							case "BACKGROUND_ERROR":
								lo--, uo = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.l("trackuserlocationend"));
								break;
							case "BACKGROUND":
								this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.l("trackuserlocationstart")), this.fire(new t.l("userlocationfocus"));
								break;
							default: throw Error(`Unexpected watchState ${this._watchState}`);
						}
						switch (this._watchState) {
							case "WAITING_ACTIVE":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "ACTIVE_LOCK":
								this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
								break;
							case "OFF": break;
							default: throw Error(`Unexpected watchState ${this._watchState}`);
						}
						if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
						else if (this._geolocationWatchID === void 0) {
							let e;
							this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), lo++, lo > 1 ? (e = {
								maximumAge: 6e5,
								timeout: 0
							}, uo = !0) : (e = this.options.positionOptions, uo = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e);
						}
					} else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
					return !0;
				}
				_clearWatch() {
					window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
				}
			}, e.GlobeControl = class {
				constructor() {
					this._toggleProjection = () => {
						let e = this._map.getProjection()?.type;
						this._map.setProjection(e !== "mercator" && e ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
					}, this._updateGlobeIcon = () => {
						this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), this._map.getProjection()?.type === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
					};
				}
				onAdd(e) {
					return this._map = e, this._container = u.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = u.create("button", "maplibregl-ctrl-globe", this._container), u.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
				}
				onRemove() {
					u.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
				}
			}, e.Hash = qi, e.ImageSource = V, e.KeyboardHandler = Oa, e.LngLatBounds = ce, e.LogoControl = Ka, e.Map = class extends Ua {
				constructor(e) {
					t.cw.mark(t.cx.create);
					let n = Object.assign(Object.assign(Object.assign({}, eo), e), { canvasContextAttributes: Object.assign(Object.assign({}, eo.canvasContextAttributes), e.canvasContextAttributes) });
					if (n.minZoom != null && n.maxZoom != null && n.minZoom > n.maxZoom) throw Error("maxZoom must be greater than or equal to minZoom");
					if (n.minPitch != null && n.maxPitch != null && n.minPitch > n.maxPitch) throw Error("maxPitch must be greater than or equal to minPitch");
					if (n.minPitch != null && n.minPitch < 0) throw Error("minPitch must be greater than or equal to 0");
					if (n.maxPitch != null && n.maxPitch > 180) throw Error("maxPitch must be less than or equal to 180");
					let i = new Kt(), a = new Xt();
					if (n.minZoom !== void 0 && i.setMinZoom(n.minZoom), n.maxZoom !== void 0 && i.setMaxZoom(n.maxZoom), n.minPitch !== void 0 && i.setMinPitch(n.minPitch), n.maxPitch !== void 0 && i.setMaxPitch(n.maxPitch), n.renderWorldCopies !== void 0 && i.setRenderWorldCopies(n.renderWorldCopies), n.transformConstrain !== null && i.setConstrain(n.transformConstrain), super(i, a, { bearingSnap: n.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new qa(), this._controls = [], this._mapId = t.a7(), this._contextLost = (e) => {
						e.preventDefault(), this._frameRequest &&= (this._frameRequest.abort(), null), this.fire(new t.l("webglcontextlost", { originalEvent: e }));
					}, this._contextRestored = (e) => {
						this._setupPainter(), this.resize(), this._update(), this.fire(new t.l("webglcontextrestored", { originalEvent: e }));
					}, this._onMapScroll = (e) => {
						if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
					}, this._onWindowOnline = () => {
						this._update();
					}, this._interactive = n.interactive, this._maxTileCacheSize = n.maxTileCacheSize, this._maxTileCacheZoomLevels = n.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, n.canvasContextAttributes), this._trackResize = !0 === n.trackResize, this._bearingSnap = n.bearingSnap, this._centerClampedToGround = n.centerClampedToGround, this._refreshExpiredTiles = !0 === n.refreshExpiredTiles, this._fadeDuration = n.fadeDuration, this._crossSourceCollisions = !0 === n.crossSourceCollisions, this._collectResourceTiming = !0 === n.collectResourceTiming, this._locale = Object.assign(Object.assign({}, Qa), n.locale), this._clickTolerance = n.clickTolerance, this._overridePixelRatio = n.pixelRatio, this._maxCanvasSize = n.maxCanvasSize, this.transformCameraUpdate = n.transformCameraUpdate, this.transformConstrain = n.transformConstrain, this.cancelPendingTileRequestsWhileZooming = !0 === n.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = _.addThrottleControl((() => this.isMoving())), this._requestManager = new v(n.transformRequest), typeof n.container == "string") {
						if (this._container = document.getElementById(n.container), !this._container) throw Error(`Container '${n.container}' not found.`);
					} else {
						if (!(n.container instanceof HTMLElement)) throw Error("Invalid type: 'container' must be a String or HTMLElement.");
						this._container = n.container;
					}
					if (n.maxBounds && this.setMaxBounds(n.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => {
						this.painter.terrainFacilitator.dirty = !0, this._update(!0);
					})), this.once("idle", (() => {
						this._idleTriggered = !0;
					})), typeof window < "u") {
						addEventListener("online", this._onWindowOnline, !1);
						let e = !1, t = Ki(((e) => {
							this._trackResize && !this._removed && (this.resize(e), this.redraw());
						}), 50);
						this._resizeObserver = new ResizeObserver(((n) => {
							e ? t(n) : e = !0;
						})), this._resizeObserver.observe(this._container);
					}
					this.handlers = new Ha(this, n), this._hash = n.hash && new qi(typeof n.hash == "string" && n.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
						center: n.center,
						elevation: n.elevation,
						zoom: n.zoom,
						bearing: n.bearing,
						pitch: n.pitch,
						roll: n.roll
					}), n.bounds && (this.resize(), this.fitBounds(n.bounds, t.e({}, n.fitBoundsOptions, { duration: 0 }))));
					let o = typeof n.style == "string" || n.style?.projection?.type !== "globe";
					this.resize(null, o), this._localIdeographFontFamily = n.localIdeographFontFamily, this._validateStyle = n.validateStyle, n.style && this.setStyle(n.style, { localIdeographFontFamily: n.localIdeographFontFamily }), n.attributionControl && this.addControl(new Ga(typeof n.attributionControl == "boolean" ? void 0 : n.attributionControl)), n.maplibreLogo && this.addControl(new Ka(), n.logoPosition), this.on("style.load", (() => {
						if (o || this._resizeTransform(), this.transform.unmodified) {
							let e = t.Q(this.style.stylesheet, [
								"center",
								"zoom",
								"bearing",
								"pitch",
								"roll"
							]);
							this.jumpTo(e);
						}
					})), this.on("data", ((e) => {
						this._update(e.dataType === "style"), this.fire(new t.l(`${e.dataType}data`, e));
					})), this.on("dataloading", ((e) => {
						this.fire(new t.l(`${e.dataType}dataloading`, e));
					})), this.on("dataabort", ((e) => {
						this.fire(new t.l("sourcedataabort", e));
					}));
				}
				_getMapId() {
					return this._mapId;
				}
				setGlobalStateProperty(e, t) {
					return this.style.setGlobalStateProperty(e, t), this._update(!0);
				}
				getGlobalState() {
					return this.style.getGlobalState();
				}
				addControl(e, n) {
					if (n === void 0 && (n = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"), !e || !e.onAdd) return this.fire(new t.k(/* @__PURE__ */ Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
					let i = e.onAdd(this);
					this._controls.push(e);
					let a = this._controlPositions[n];
					return n.indexOf("bottom") === -1 ? a.appendChild(i) : a.insertBefore(i, a.firstChild), this;
				}
				removeControl(e) {
					if (!e || !e.onRemove) return this.fire(new t.k(/* @__PURE__ */ Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
					let n = this._controls.indexOf(e);
					return n > -1 && this._controls.splice(n, 1), e.onRemove(this), this;
				}
				hasControl(e) {
					return this._controls.indexOf(e) > -1;
				}
				coveringTiles(e) {
					return Ie(this.transform, e);
				}
				calculateCameraOptionsFromTo(e, t, n, i) {
					return i == null && this.terrain && (i = this.terrain.getElevationForLngLatZoom(n, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e, t, n, i);
				}
				resize(e, n = !0) {
					let [i, a] = this._containerDimensions(), o = this._getClampedPixelRatio(i, a);
					if (this._resizeCanvas(i, a, o), this.painter.resize(i, a, o), this.painter.overLimit()) {
						let e = this.painter.context.gl;
						this._maxCanvasSize = [e.drawingBufferWidth, e.drawingBufferHeight];
						let t = this._getClampedPixelRatio(i, a);
						this._resizeCanvas(i, a, t), this.painter.resize(i, a, t);
					}
					this._resizeTransform(n);
					let s = !this._moving;
					return s && (this.stop(), this.fire(new t.l("movestart", e)).fire(new t.l("move", e))), this.fire(new t.l("resize", e)), s && this.fire(new t.l("moveend", e)), this;
				}
				_resizeTransform(e = !0) {
					var t;
					let [n, i] = this._containerDimensions();
					this.transform.resize(n, i, e), (t = this._requestedCameraState) == null || t.resize(n, i, e);
				}
				_getClampedPixelRatio(e, t) {
					let { 0: n, 1: i } = this._maxCanvasSize, a = this.getPixelRatio(), o = e * a, s = t * a;
					return Math.min(o > n ? n / o : 1, s > i ? i / s : 1) * a;
				}
				getPixelRatio() {
					return this._overridePixelRatio ?? devicePixelRatio;
				}
				setPixelRatio(e) {
					this._overridePixelRatio = e, this.resize();
				}
				getBounds() {
					return this.transform.getBounds();
				}
				getMaxBounds() {
					return this.transform.getMaxBounds();
				}
				setMaxBounds(e) {
					return this.transform.setMaxBounds(ce.convert(e)), this._update();
				}
				setMinZoom(e) {
					if ((e ??= -2) >= -2 && e <= this.transform.maxZoom) return this.transform.setMinZoom(e), this._update(), this.getZoom() < e && this.setZoom(e), this;
					throw Error("minZoom must be between -2 and the current maxZoom, inclusive");
				}
				getMinZoom() {
					return this.transform.minZoom;
				}
				setMaxZoom(e) {
					if ((e ??= 22) >= this.transform.minZoom) return this.transform.setMaxZoom(e), this._update(), this.getZoom() > e && this.setZoom(e), this;
					throw Error("maxZoom must be greater than the current minZoom");
				}
				getMaxZoom() {
					return this.transform.maxZoom;
				}
				setMinPitch(e) {
					if ((e ??= 0) < 0) throw Error("minPitch must be greater than or equal to 0");
					if (e >= 0 && e <= this.transform.maxPitch) return this.transform.setMinPitch(e), this._update(), this.getPitch() < e && this.setPitch(e), this;
					throw Error("minPitch must be between 0 and the current maxPitch, inclusive");
				}
				getMinPitch() {
					return this.transform.minPitch;
				}
				setMaxPitch(e) {
					if ((e ??= 60) > 180) throw Error("maxPitch must be less than or equal to 180");
					if (e >= this.transform.minPitch) return this.transform.setMaxPitch(e), this._update(), this.getPitch() > e && this.setPitch(e), this;
					throw Error("maxPitch must be greater than the current minPitch");
				}
				getMaxPitch() {
					return this.transform.maxPitch;
				}
				getRenderWorldCopies() {
					return this.transform.renderWorldCopies;
				}
				setRenderWorldCopies(e) {
					return this.transform.setRenderWorldCopies(e), this._update();
				}
				setTransformConstrain(e) {
					return this.transform.setConstrain(e), this._update();
				}
				project(e) {
					return this.transform.locationToScreenPoint(t.S.convert(e), this.style && this.terrain);
				}
				unproject(e) {
					return this.transform.screenPointToLocation(t.P.convert(e), this.terrain);
				}
				isMoving() {
					return this._moving || this.handlers?.isMoving();
				}
				isZooming() {
					return this._zooming || this.handlers?.isZooming();
				}
				isRotating() {
					return this._rotating || this.handlers?.isRotating();
				}
				_createDelegatedListener(e, t, n) {
					if (e === "mouseenter" || e === "mouseover") {
						let i = !1;
						return {
							layers: t,
							listener: n,
							delegates: {
								mousemove: (a) => {
									let o = t.filter(((e) => this.getLayer(e))), s = o.length === 0 ? [] : this.queryRenderedFeatures(a.point, { layers: o });
									s.length ? i || (i = !0, n.call(this, new ra(e, this, a.originalEvent, { features: s }))) : i = !1;
								},
								mouseout: () => {
									i = !1;
								}
							}
						};
					}
					if (e === "mouseleave" || e === "mouseout") {
						let i = !1;
						return {
							layers: t,
							listener: n,
							delegates: {
								mousemove: (a) => {
									let o = t.filter(((e) => this.getLayer(e)));
									(o.length === 0 ? [] : this.queryRenderedFeatures(a.point, { layers: o })).length ? i = !0 : i && (i = !1, n.call(this, new ra(e, this, a.originalEvent)));
								},
								mouseout: (t) => {
									i && (i = !1, n.call(this, new ra(e, this, t.originalEvent)));
								}
							}
						};
					}
					{
						let i = (e) => {
							let i = t.filter(((e) => this.getLayer(e))), a = i.length === 0 ? [] : this.queryRenderedFeatures(e.point, { layers: i });
							a.length && (e.features = a, n.call(this, e), delete e.features);
						};
						return {
							layers: t,
							listener: n,
							delegates: { [e]: i }
						};
					}
				}
				_saveDelegatedListener(e, t) {
					this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(t);
				}
				_removeDelegatedListener(e, t, n) {
					if (!this._delegatedListeners || !this._delegatedListeners[e]) return;
					let i = this._delegatedListeners[e];
					for (let e = 0; e < i.length; e++) {
						let a = i[e];
						if (a.listener === n && a.layers.length === t.length && a.layers.every(((e) => t.includes(e)))) {
							for (let e in a.delegates) this.off(e, a.delegates[e]);
							i.splice(e, 1);
							return;
						}
					}
				}
				on(e, t, n) {
					if (n === void 0) return super.on(e, t);
					let i = typeof t == "string" ? [t] : t, a = this._createDelegatedListener(e, i, n);
					for (let t in this._saveDelegatedListener(e, a), a.delegates) this.on(t, a.delegates[t]);
					return { unsubscribe: () => {
						this._removeDelegatedListener(e, i, n);
					} };
				}
				once(e, t, n) {
					if (n === void 0) return super.once(e, t);
					let i = typeof t == "string" ? [t] : t, a = this._createDelegatedListener(e, i, n);
					for (let t in a.delegates) {
						let o = a.delegates[t];
						a.delegates[t] = (...t) => {
							this._removeDelegatedListener(e, i, n), o(...t);
						};
					}
					for (let t in this._saveDelegatedListener(e, a), a.delegates) this.once(t, a.delegates[t]);
					return this;
				}
				off(e, t, n) {
					return n === void 0 ? super.off(e, t) : (this._removeDelegatedListener(e, typeof t == "string" ? [t] : t, n), this);
				}
				queryRenderedFeatures(e, n) {
					if (!this.style) return [];
					let i, a = e instanceof t.P || Array.isArray(e), o = a ? e : [[0, 0], [this.transform.width, this.transform.height]];
					if (n = n || (a ? {} : e) || {}, o instanceof t.P || typeof o[0] == "number") i = [t.P.convert(o)];
					else {
						let e = t.P.convert(o[0]), n = t.P.convert(o[1]);
						i = [
							e,
							new t.P(n.x, e.y),
							n,
							new t.P(e.x, n.y),
							e
						];
					}
					return this.style.queryRenderedFeatures(i, n, this.transform);
				}
				querySourceFeatures(e, t) {
					return this.style.querySourceFeatures(e, t);
				}
				setStyle(e, n) {
					return !1 !== (n = t.e({}, {
						localIdeographFontFamily: this._localIdeographFontFamily,
						validate: this._validateStyle
					}, n)).diff && n.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, n), this) : (this._localIdeographFontFamily = n.localIdeographFontFamily, this._updateStyle(e, n));
				}
				setTransformRequest(e) {
					return this._requestManager.setTransformRequest(e), this;
				}
				_getUIString(e) {
					let t = this._locale[e];
					if (t == null) throw Error(`Missing UI string '${e}'`);
					return t;
				}
				_updateStyle(e, t) {
					var n;
					if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(e, t)));
					let i = this.style && t.transformStyle ? this.style.serialize() : void 0;
					return this.style && (this.style.setEventedParent(null), this.style._remove(!e)), e ? (this.style = new Fn(this, t || {}), this.style.setEventedParent(this, { style: this.style }), typeof e == "string" ? this.style.loadURL(e, t, i) : this.style.loadJSON(e, t, i), this) : ((n = this.style?.projection) == null || n.destroy(), delete this.style, this);
				}
				_lazyInitEmptyStyle() {
					this.style || (this.style = new Fn(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
				}
				_diffStyle(e, n) {
					if (typeof e == "string") {
						let i = this._requestManager.transformRequest(e, "Style");
						t.j(i, new AbortController()).then(((e) => {
							this._updateDiff(e.data, n);
						})).catch(((e) => {
							e && this.fire(new t.k(e));
						}));
					} else typeof e == "object" && this._updateDiff(e, n);
				}
				_updateDiff(e, n) {
					try {
						this.style.setState(e, n) && this._update(!0);
					} catch (i) {
						t.w(`Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`), this._updateStyle(e, n);
					}
				}
				getStyle() {
					if (this.style) return this.style.serialize();
				}
				isStyleLoaded() {
					return this.style ? this.style.loaded() : t.w("There is no style added to the map.");
				}
				addSource(e, t) {
					return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0);
				}
				isSourceLoaded(e) {
					let n = this.style && this.style.sourceCaches[e];
					if (n !== void 0) return n.loaded();
					this.fire(new t.k(/* @__PURE__ */ Error(`There is no source with ID '${e}'`)));
				}
				setTerrain(e) {
					if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e) {
						let n = this.style.sourceCaches[e.source];
						if (!n) throw Error(`cannot load terrain, because there exists no source with ID: ${e.source}`);
						for (let i in this.terrain === null && n.reload(), this.style._layers) {
							let n = this.style._layers[i];
							n.type === "hillshade" && n.source === e.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."), n.type === "color-relief" && n.source === e.source && t.w("You are using the same source for a color-relief layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
						}
						this.terrain = new Ja(this.painter, n, e), this.painter.renderToTexture = new Za(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t) => {
							t.dataType === "style" ? this.terrain.sourceCache.freeRtt() : t.dataType === "source" && t.tile && (t.sourceId !== e.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), t.source?.type === "image" ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(t.tile.tileID));
						}, this.style.on("data", this._terrainDataCallback);
					} else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
					return this.fire(new t.l("terrain", { terrain: e })), this;
				}
				getTerrain() {
					return this.terrain?.options ?? null;
				}
				areTilesLoaded() {
					let e = this.style && this.style.sourceCaches;
					for (let t in e) {
						let n = e[t]._tiles;
						for (let e in n) {
							let t = n[e];
							if (t.state !== "loaded" && t.state !== "errored") return !1;
						}
					}
					return !0;
				}
				removeSource(e) {
					return this.style.removeSource(e), this._update(!0);
				}
				getSource(e) {
					return this.style.getSource(e);
				}
				setSourceTileLodParams(e, t, n) {
					if (n) {
						let i = this.getSource(n);
						if (!i) throw Error(`There is no source with ID "${n}", cannot set LOD parameters`);
						i.calculateTileZoom = U(Math.max(1, e), Math.max(1, t));
					} else for (let n in this.style.sourceCaches) this.style.sourceCaches[n].getSource().calculateTileZoom = U(Math.max(1, e), Math.max(1, t));
					return this._update(!0), this;
				}
				refreshTiles(e, n) {
					let i = this.style.sourceCaches[e];
					if (!i) throw Error(`There is no source cache with ID "${e}", cannot refresh tile`);
					n === void 0 ? i.reload(!0) : i.refreshTiles(n.map(((e) => new t.a4(e.z, e.x, e.y))));
				}
				addImage(e, n, i = {}) {
					let { pixelRatio: a = 1, sdf: o = !1, stretchX: c, stretchY: l, content: u, textFitWidth: d, textFitHeight: f } = i;
					if (this._lazyInitEmptyStyle(), !(n instanceof HTMLImageElement || t.b(n))) {
						if (n.width === void 0 || n.height === void 0) return this.fire(new t.k(/* @__PURE__ */ Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
						{
							let { width: i, height: s, data: p } = n, m = n;
							return this.style.addImage(e, {
								data: new t.R({
									width: i,
									height: s
								}, new Uint8Array(p)),
								pixelRatio: a,
								stretchX: c,
								stretchY: l,
								content: u,
								textFitWidth: d,
								textFitHeight: f,
								sdf: o,
								version: 0,
								userImage: m
							}), m.onAdd && m.onAdd(this, e), this;
						}
					}
					{
						let { width: i, height: p, data: m } = s.getImageData(n);
						this.style.addImage(e, {
							data: new t.R({
								width: i,
								height: p
							}, m),
							pixelRatio: a,
							stretchX: c,
							stretchY: l,
							content: u,
							textFitWidth: d,
							textFitHeight: f,
							sdf: o,
							version: 0
						});
					}
				}
				updateImage(e, n) {
					let i = this.style.getImage(e);
					if (!i) return this.fire(new t.k(/* @__PURE__ */ Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
					let { width: a, height: o, data: c } = n instanceof HTMLImageElement || t.b(n) ? s.getImageData(n) : n;
					if (a === void 0 || o === void 0) return this.fire(new t.k(/* @__PURE__ */ Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
					if (a !== i.data.width || o !== i.data.height) return this.fire(new t.k(/* @__PURE__ */ Error("The width and height of the updated image must be that same as the previous version of the image")));
					let l = !(n instanceof HTMLImageElement || t.b(n));
					return i.data.replace(c, l), this.style.updateImage(e, i), this;
				}
				getImage(e) {
					return this.style.getImage(e);
				}
				hasImage(e) {
					return e ? !!this.style.getImage(e) : (this.fire(new t.k(/* @__PURE__ */ Error("Missing required image id"))), !1);
				}
				removeImage(e) {
					this.style.removeImage(e);
				}
				loadImage(e) {
					return _.getImage(this._requestManager.transformRequest(e, "Image"), new AbortController());
				}
				listImages() {
					return this.style.listImages();
				}
				addLayer(e, t) {
					return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0);
				}
				moveLayer(e, t) {
					return this.style.moveLayer(e, t), this._update(!0);
				}
				removeLayer(e) {
					return this.style.removeLayer(e), this._update(!0);
				}
				getLayer(e) {
					return this.style.getLayer(e);
				}
				getLayersOrder() {
					return this.style.getLayersOrder();
				}
				setLayerZoomRange(e, t, n) {
					return this.style.setLayerZoomRange(e, t, n), this._update(!0);
				}
				setFilter(e, t, n = {}) {
					return this.style.setFilter(e, t, n), this._update(!0);
				}
				getFilter(e) {
					return this.style.getFilter(e);
				}
				setPaintProperty(e, t, n, i = {}) {
					return this.style.setPaintProperty(e, t, n, i), this._update(!0);
				}
				getPaintProperty(e, t) {
					return this.style.getPaintProperty(e, t);
				}
				setLayoutProperty(e, t, n, i = {}) {
					return this.style.setLayoutProperty(e, t, n, i), this._update(!0);
				}
				getLayoutProperty(e, t) {
					return this.style.getLayoutProperty(e, t);
				}
				setGlyphs(e, t = {}) {
					return this._lazyInitEmptyStyle(), this.style.setGlyphs(e, t), this._update(!0);
				}
				getGlyphs() {
					return this.style.getGlyphsUrl();
				}
				addSprite(e, t, n = {}) {
					return this._lazyInitEmptyStyle(), this.style.addSprite(e, t, n, ((e) => {
						e || this._update(!0);
					})), this;
				}
				removeSprite(e) {
					return this._lazyInitEmptyStyle(), this.style.removeSprite(e), this._update(!0);
				}
				getSprite() {
					return this.style.getSprite();
				}
				setSprite(e, t = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSprite(e, t, ((e) => {
						e || this._update(!0);
					})), this;
				}
				setLight(e, t = {}) {
					return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0);
				}
				getLight() {
					return this.style.getLight();
				}
				setSky(e, t = {}) {
					return this._lazyInitEmptyStyle(), this.style.setSky(e, t), this._update(!0);
				}
				getSky() {
					return this.style.getSky();
				}
				setFeatureState(e, t) {
					return this.style.setFeatureState(e, t), this._update();
				}
				removeFeatureState(e, t) {
					return this.style.removeFeatureState(e, t), this._update();
				}
				getFeatureState(e) {
					return this.style.getFeatureState(e);
				}
				getContainer() {
					return this._container;
				}
				getCanvasContainer() {
					return this._canvasContainer;
				}
				getCanvas() {
					return this._canvas;
				}
				_containerDimensions() {
					let e = 0, t = 0;
					return this._container && (e = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [e, t];
				}
				_setupContainer() {
					let e = this._container;
					e.classList.add("maplibregl-map");
					let t = this._canvasContainer = u.create("div", "maplibregl-canvas-container", e);
					this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = u.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
					let n = this._containerDimensions(), i = this._getClampedPixelRatio(n[0], n[1]);
					this._resizeCanvas(n[0], n[1], i);
					let a = this._controlContainer = u.create("div", "maplibregl-control-container", e), o = this._controlPositions = {};
					[
						"top-left",
						"top-right",
						"bottom-left",
						"bottom-right"
					].forEach(((e) => {
						o[e] = u.create("div", `maplibregl-ctrl-${e} `, a);
					})), this._container.addEventListener("scroll", this._onMapScroll, !1);
				}
				_resizeCanvas(e, t, n) {
					this._canvas.width = Math.floor(n * e), this._canvas.height = Math.floor(n * t), this._canvas.style.width = `${e}px`, this._canvas.style.height = `${t}px`;
				}
				_setupPainter() {
					let e = Object.assign(Object.assign({}, this._canvasContextAttributes), {
						alpha: !0,
						depth: !0,
						stencil: !0,
						premultipliedAlpha: !0
					}), t = null;
					this._canvas.addEventListener("webglcontextcreationerror", ((n) => {
						t = { requestedAttributes: e }, n && (t.statusMessage = n.statusMessage, t.type = n.type);
					}), { once: !0 });
					let n = null;
					if (n = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e) : this._canvas.getContext("webgl2", e) || this._canvas.getContext("webgl", e), !n) {
						let e = "Failed to initialize WebGL";
						throw t ? (t.message = e, Error(JSON.stringify(t))) : Error(e);
					}
					this.painter = new Gi(n, this.transform), d.testSupport(n);
				}
				migrateProjection(e, n) {
					super.migrateProjection(e, n), this.painter.transform = e, this.fire(new t.l("projectiontransition", { newProjection: this.style.projection.name }));
				}
				loaded() {
					return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
				}
				_update(e) {
					return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
				}
				_requestRenderFrame(e) {
					return this._update(), this._renderTaskQueue.add(e);
				}
				_cancelRenderFrame(e) {
					this._renderTaskQueue.remove(e);
				}
				_render(e) {
					var n;
					let i = this._idleTriggered ? this._fadeDuration : 0, a = this.style.projection?.transitionState > 0;
					if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e), this._removed) return;
					let o = !1;
					if (this.style && this._styleDirty) {
						this._styleDirty = !1;
						let e = this.transform.zoom, n = l();
						this.style.zoomHistory.update(e, n);
						let a = new t.F(e, {
							now: n,
							fadeDuration: i,
							zoomHistory: this.style.zoomHistory,
							transition: this.style.getTransition()
						}), s = a.crossFadingFactor();
						s === 1 && s === this._crossFadingFactor || (o = !0, this._crossFadingFactor = s), this.style.update(a);
					}
					let s = this.style.projection?.transitionState > 0 !== a;
					(n = this.style.projection) == null || n.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(this.style.projection?.transitionState, this.style.projection?.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || s) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, i, this._crossSourceCollisions, s), this.painter.render(this.style, {
						showTileBoundaries: this.showTileBoundaries,
						showOverdrawInspector: this._showOverdrawInspector,
						rotating: this.isRotating(),
						zooming: this.isZooming(),
						moving: this.isMoving(),
						fadeDuration: i,
						showPadding: this.showPadding
					}), this.fire(new t.l("render")), this.loaded() && !this._loaded && (this._loaded = !0, t.cw.mark(t.cx.load), this.fire(new t.l("load"))), this.style && (this.style.hasTransitions() || o) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
					let c = this._sourcesDirty || this._styleDirty || this._placementDirty;
					return c || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.l("idle")), !this._loaded || this._fullyLoaded || c || (this._fullyLoaded = !0, t.cw.mark(t.cx.fullLoad)), this;
				}
				redraw() {
					return this.style && (this._frameRequest &&= (this._frameRequest.abort(), null), this._render(0)), this;
				}
				remove() {
					var e;
					this._hash && this._hash.remove();
					for (let e of this._controls) e.onRemove(this);
					this._controls = [], this._frameRequest &&= (this._frameRequest.abort(), null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), _.removeThrottleControl(this._imageQueueHandle), (e = this._resizeObserver) == null || e.disconnect();
					let n = this.painter.context.gl.getExtension("WEBGL_lose_context");
					n != null && n.loseContext && n.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), u.remove(this._canvasContainer), u.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), t.cw.clearMetrics(), this._removed = !0, this.fire(new t.l("remove"));
				}
				triggerRepaint() {
					this.style && !this._frameRequest && (this._frameRequest = new AbortController(), s.frame(this._frameRequest, ((e) => {
						t.cw.frame(e), this._frameRequest = null;
						try {
							this._render(e);
						} catch (e) {
							if (!t.cy(e) && !function(e) {
								return e.message === ai;
							}(e)) throw e;
						}
					}), (() => {})));
				}
				get showTileBoundaries() {
					return !!this._showTileBoundaries;
				}
				set showTileBoundaries(e) {
					this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update());
				}
				get showPadding() {
					return !!this._showPadding;
				}
				set showPadding(e) {
					this._showPadding !== e && (this._showPadding = e, this._update());
				}
				get showCollisionBoxes() {
					return !!this._showCollisionBoxes;
				}
				set showCollisionBoxes(e) {
					this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update());
				}
				get showOverdrawInspector() {
					return !!this._showOverdrawInspector;
				}
				set showOverdrawInspector(e) {
					this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update());
				}
				get repaint() {
					return !!this._repaint;
				}
				set repaint(e) {
					this._repaint !== e && (this._repaint = e, this.triggerRepaint());
				}
				get vertices() {
					return !!this._vertices;
				}
				set vertices(e) {
					this._vertices = e, this._update();
				}
				get version() {
					return $a;
				}
				getCameraTargetElevation() {
					return this.transform.elevation;
				}
				getProjection() {
					return this.style.getProjection();
				}
				setProjection(e) {
					return this._lazyInitEmptyStyle(), this.style.setProjection(e), this._update(!0);
				}
			}, e.MapMouseEvent = ra, e.MapTouchEvent = ia, e.MapWheelEvent = aa, e.Marker = so, e.NavigationControl = class {
				constructor(e) {
					this._updateZoomButtons = () => {
						let e = this._map.getZoom(), t = e === this._map.getMaxZoom(), n = e === this._map.getMinZoom();
						this._zoomInButton.disabled = t, this._zoomOutButton.disabled = n, this._zoomInButton.setAttribute("aria-disabled", t.toString()), this._zoomOutButton.setAttribute("aria-disabled", n.toString());
					}, this._rotateCompassArrow = () => {
						this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.cos(this._map.transform.pitchInRadians) ** .5}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.cos(this._map.transform.pitchInRadians) ** .5}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
					}, this._setButtonTitle = (e, t) => {
						let n = this._map._getUIString(`NavigationControl.${t}`);
						e.title = n, e.setAttribute("aria-label", n);
					}, this.options = t.e({}, to, e), this._container = u.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", ((e) => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", ((e) => this._map.zoomIn({}, { originalEvent: e }))), u.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", ((e) => this._map.zoomOut({}, { originalEvent: e }))), u.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", ((e) => {
						this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e });
					})), this._compassIcon = u.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
				}
				onAdd(e) {
					return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new no(this._map, this._compass, this.options.visualizePitch)), this._container;
				}
				onRemove() {
					u.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
				}
				_createButton(e, t) {
					let n = u.create("button", e, this._container);
					return n.type = "button", n.addEventListener("click", t), n;
				}
			}, e.Popup = class extends t.E {
				constructor(e) {
					super(), this._updateOpacity = () => {
						this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : "");
					}, this.remove = () => (this._content && u.remove(this._content), this._container && (u.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.l("close"))), this), this._onMouseUp = (e) => {
						this._update(e.point);
					}, this._onMouseMove = (e) => {
						this._update(e.point);
					}, this._onDrag = (e) => {
						this._update(e.point);
					}, this._update = (e) => {
						if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
						if (!this._container) {
							if (this._container = u.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = u.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (let e of this.options.className.split(" ")) this._container.classList.add(e);
							this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
						}
						if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = io(this._lngLat, this._flatPos, this._map.transform, this._trackPointer), this._trackPointer && !e) return;
						let t = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
						this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
						let n = this.options.anchor, i = _o(this.options.offset);
						if (!n) {
							let e = this._container.offsetWidth, a = this._container.offsetHeight, o;
							o = t.y + i.bottom.y < a ? ["top"] : t.y > this._map.transform.height - a ? ["bottom"] : [], t.x < e / 2 ? o.push("left") : t.x > this._map.transform.width - e / 2 && o.push("right"), n = o.length === 0 ? "bottom" : o.join("-");
						}
						let a = t.add(i[n]);
						this.options.subpixelPositioning || (a = a.round()), u.setTransform(this._container, `${ao[n]} translate(${a.x}px,${a.y}px)`), oo(this._container, n, "popup"), this._updateOpacity();
					}, this._onClose = () => {
						this.remove();
					}, this.options = t.e(Object.create(ho), e);
				}
				addTo(e) {
					return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.l("open")), this;
				}
				isOpen() {
					return !!this._map;
				}
				getLngLat() {
					return this._lngLat;
				}
				setLngLat(e) {
					return this._lngLat = t.S.convert(e), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
				}
				trackPointer() {
					return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
				}
				getElement() {
					return this._container;
				}
				setText(e) {
					return this.setDOMContent(document.createTextNode(e));
				}
				setHTML(e) {
					let t = document.createDocumentFragment(), n = document.createElement("body"), i;
					for (n.innerHTML = e; i = n.firstChild, i;) t.appendChild(i);
					return this.setDOMContent(t);
				}
				getMaxWidth() {
					return this._container?.style.maxWidth;
				}
				setMaxWidth(e) {
					return this.options.maxWidth = e, this._update(), this;
				}
				setDOMContent(e) {
					if (this._content) for (; this._content.hasChildNodes();) this._content.firstChild && this._content.removeChild(this._content.firstChild);
					else this._content = u.create("div", "maplibregl-popup-content", this._container);
					return this._content.appendChild(e), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
				}
				addClassName(e) {
					return this._container && this._container.classList.add(e), this;
				}
				removeClassName(e) {
					return this._container && this._container.classList.remove(e), this;
				}
				setOffset(e) {
					return this.options.offset = e, this._update(), this;
				}
				toggleClassName(e) {
					if (this._container) return this._container.classList.toggle(e);
				}
				setSubpixelPositioning(e) {
					this.options.subpixelPositioning = e;
				}
				_createCloseButton() {
					this.options.closeButton && (this._closeButton = u.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
				}
				_focusFirstElement() {
					if (!this.options.focusAfterOpen || !this._container) return;
					let e = this._container.querySelector(go);
					e && e.focus();
				}
			}, e.RasterDEMTileSource = fe, e.RasterTileSource = de, e.ScaleControl = class {
				constructor(e) {
					this._onMove = () => {
						po(this._map, this._container, this.options);
					}, this.setUnit = (e) => {
						this.options.unit = e, po(this._map, this._container, this.options);
					}, this.options = Object.assign(Object.assign({}, fo), e);
				}
				getDefaultPosition() {
					return "bottom-left";
				}
				onAdd(e) {
					return this._map = e, this._container = u.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
				}
				onRemove() {
					u.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
				}
			}, e.ScrollZoomHandler = ja, e.Style = Fn, e.TerrainControl = class {
				constructor(e) {
					this._toggleTerrain = () => {
						this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
					}, this._updateTerrainIcon = () => {
						this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
					}, this.options = e;
				}
				onAdd(e) {
					return this._map = e, this._container = u.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = u.create("button", "maplibregl-ctrl-terrain", this._container), u.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
				}
				onRemove() {
					u.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
				}
			}, e.TwoFingersTouchPitchHandler = Ea, e.TwoFingersTouchRotateHandler = wa, e.TwoFingersTouchZoomHandler = Sa, e.TwoFingersTouchZoomRotateHandler = La, e.VectorTileSource = ue, e.VideoSource = me, e.addSourceType = (e, n) => t._(void 0, void 0, void 0, (function* () {
				if (_e(e)) throw Error(`A source type called "${e}" already exists.`);
				((e, t) => {
					ge[e] = t;
				})(e, n);
			})), e.clearPrewarmedResources = function() {
				let e = ee;
				e && (e.isPreloaded() && e.numActive() === 1 ? (e.release(P), ee = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
			}, e.createTileMesh = sn, e.getMaxParallelImageRequests = function() {
				return t.a.MAX_PARALLEL_IMAGE_REQUESTS;
			}, e.getRTLTextPluginStatus = function() {
				return be().getRTLTextPluginStatus();
			}, e.getVersion = function() {
				return vo;
			}, e.getWorkerCount = function() {
				return F.workerCount;
			}, e.getWorkerUrl = function() {
				return t.a.WORKER_URL;
			}, e.importScriptInWorkers = function(e) {
				return ne().broadcast("IS", e);
			}, e.isTimeFrozen = function() {
				return c.isFrozen();
			}, e.prewarm = function() {
				R().acquire(P);
			}, e.restoreNow = function() {
				c.restoreNow();
			}, e.setMaxParallelImageRequests = function(e) {
				t.a.MAX_PARALLEL_IMAGE_REQUESTS = e;
			}, e.setNow = function(e) {
				c.setNow(e);
			}, e.setRTLTextPlugin = function(e, t) {
				return be().setRTLTextPlugin(e, t);
			}, e.setWorkerCount = function(e) {
				F.workerCount = e;
			}, e.setWorkerUrl = function(e) {
				t.a.WORKER_URL = e;
			};
		})), e;
	}));
})))()), e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(e, t, n) {
	let i = (t - e) / Math.max(0, n), a = Math.floor(Math.log10(i)), o = i / 10 ** a, s = o >= e10 ? 10 : o >= e5 ? 5 : o >= e2 ? 2 : 1, c, l, u;
	return a < 0 ? (u = 10 ** -a / s, c = Math.round(e * u), l = Math.round(t * u), c / u < e && ++c, l / u > t && --l, u = -u) : (u = 10 ** a * s, c = Math.round(e / u), l = Math.round(t / u), c * u < e && ++c, l * u > t && --l), l < c && .5 <= n && n < 2 ? tickSpec(e, t, n * 2) : [
		c,
		l,
		u
	];
}
function ticks(e, t, n) {
	if (t = +t, e = +e, n = +n, !(n > 0)) return [];
	if (e === t) return [e];
	let i = t < e, [a, o, s] = i ? tickSpec(t, e, n) : tickSpec(e, t, n);
	if (!(o >= a)) return [];
	let c = o - a + 1, l = Array(c);
	if (i) if (s < 0) for (let e = 0; e < c; ++e) l[e] = (o - e) / -s;
	else for (let e = 0; e < c; ++e) l[e] = (o - e) * s;
	else if (s < 0) for (let e = 0; e < c; ++e) l[e] = (a + e) / -s;
	else for (let e = 0; e < c; ++e) l[e] = (a + e) * s;
	return l;
}
function tickIncrement(e, t, n) {
	return t = +t, e = +e, n = +n, tickSpec(e, t, n)[2];
}
function tickStep(e, t, n) {
	t = +t, e = +e, n = +n;
	let i = t < e, a = i ? tickIncrement(t, e, n) : tickIncrement(e, t, n);
	return (i ? -1 : 1) * (a < 0 ? 1 / -a : a);
}
function initInterpolator(e, t) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			typeof e == "function" ? this.interpolator(e) : this.range(e);
			break;
		default:
			this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
			break;
	}
	return this;
}
function define_default(e, t, n) {
	e.prototype = t.prototype = n, n.constructor = e;
}
function extend(e, t) {
	var n = Object.create(e.prototype);
	for (var i in t) n[i] = t[i];
	return n;
}
function Color() {}
var darker = .7, brighter = 1 / darker, reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = /* @__PURE__ */ RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = /* @__PURE__ */ RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = /* @__PURE__ */ RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = /* @__PURE__ */ RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = /* @__PURE__ */ RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = /* @__PURE__ */ RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`), named = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
define_default(Color, color, {
	copy(e) {
		return Object.assign(new this.constructor(), this, e);
	},
	displayable() {
		return this.rgb().displayable();
	},
	hex: color_formatHex,
	formatHex: color_formatHex,
	formatHex8: color_formatHex8,
	formatHsl: color_formatHsl,
	formatRgb: color_formatRgb,
	toString: color_formatRgb
});
function color_formatHex() {
	return this.rgb().formatHex();
}
function color_formatHex8() {
	return this.rgb().formatHex8();
}
function color_formatHsl() {
	return hslConvert(this).formatHsl();
}
function color_formatRgb() {
	return this.rgb().formatRgb();
}
function color(e) {
	var t, n;
	return e = (e + "").trim().toLowerCase(), (t = reHex.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? rgbn(t) : n === 3 ? new Rgb(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? rgba(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? rgba(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = reRgbInteger.exec(e)) ? new Rgb(t[1], t[2], t[3], 1) : (t = reRgbPercent.exec(e)) ? new Rgb(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = reRgbaInteger.exec(e)) ? rgba(t[1], t[2], t[3], t[4]) : (t = reRgbaPercent.exec(e)) ? rgba(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = reHslPercent.exec(e)) ? hsla(t[1], t[2] / 100, t[3] / 100, 1) : (t = reHslaPercent.exec(e)) ? hsla(t[1], t[2] / 100, t[3] / 100, t[4]) : named.hasOwnProperty(e) ? rgbn(named[e]) : e === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(e) {
	return new Rgb(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function rgba(e, t, n, i) {
	return i <= 0 && (e = t = n = NaN), new Rgb(e, t, n, i);
}
function rgbConvert(e) {
	return e instanceof Color || (e = color(e)), e ? (e = e.rgb(), new Rgb(e.r, e.g, e.b, e.opacity)) : new Rgb();
}
function rgb(e, t, n, i) {
	return arguments.length === 1 ? rgbConvert(e) : new Rgb(e, t, n, i ?? 1);
}
function Rgb(e, t, n, i) {
	this.r = +e, this.g = +t, this.b = +n, this.opacity = +i;
}
define_default(Rgb, rgb, extend(Color, {
	brighter(e) {
		return e = e == null ? brighter : brighter ** +e, new Rgb(this.r * e, this.g * e, this.b * e, this.opacity);
	},
	darker(e) {
		return e = e == null ? darker : darker ** +e, new Rgb(this.r * e, this.g * e, this.b * e, this.opacity);
	},
	rgb() {
		return this;
	},
	clamp() {
		return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
	},
	displayable() {
		return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
	},
	hex: rgb_formatHex,
	formatHex: rgb_formatHex,
	formatHex8: rgb_formatHex8,
	formatRgb: rgb_formatRgb,
	toString: rgb_formatRgb
}));
function rgb_formatHex() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
	let e = clampa(this.opacity);
	return `${e === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function clampa(e) {
	return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function clampi(e) {
	return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function hex(e) {
	return e = clampi(e), (e < 16 ? "0" : "") + e.toString(16);
}
function hsla(e, t, n, i) {
	return i <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Hsl(e, t, n, i);
}
function hslConvert(e) {
	if (e instanceof Hsl) return new Hsl(e.h, e.s, e.l, e.opacity);
	if (e instanceof Color || (e = color(e)), !e) return new Hsl();
	if (e instanceof Hsl) return e;
	e = e.rgb();
	var t = e.r / 255, n = e.g / 255, i = e.b / 255, a = Math.min(t, n, i), o = Math.max(t, n, i), s = NaN, c = o - a, l = (o + a) / 2;
	return c ? (s = t === o ? (n - i) / c + (n < i) * 6 : n === o ? (i - t) / c + 2 : (t - n) / c + 4, c /= l < .5 ? o + a : 2 - o - a, s *= 60) : c = l > 0 && l < 1 ? 0 : s, new Hsl(s, c, l, e.opacity);
}
function hsl(e, t, n, i) {
	return arguments.length === 1 ? hslConvert(e) : new Hsl(e, t, n, i ?? 1);
}
function Hsl(e, t, n, i) {
	this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
}
define_default(Hsl, hsl, extend(Color, {
	brighter(e) {
		return e = e == null ? brighter : brighter ** +e, new Hsl(this.h, this.s, this.l * e, this.opacity);
	},
	darker(e) {
		return e = e == null ? darker : darker ** +e, new Hsl(this.h, this.s, this.l * e, this.opacity);
	},
	rgb() {
		var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, i = n + (n < .5 ? n : 1 - n) * t, a = 2 * n - i;
		return new Rgb(hsl2rgb(e >= 240 ? e - 240 : e + 120, a, i), hsl2rgb(e, a, i), hsl2rgb(e < 120 ? e + 240 : e - 120, a, i), this.opacity);
	},
	clamp() {
		return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
	},
	displayable() {
		return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
	},
	formatHsl() {
		let e = clampa(this.opacity);
		return `${e === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
	}
}));
function clamph(e) {
	return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function clampt(e) {
	return Math.max(0, Math.min(1, e || 0));
}
function hsl2rgb(e, t, n) {
	return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
function basis(e, t, n, i, a) {
	var o = e * e, s = o * e;
	return ((1 - 3 * e + 3 * o - s) * t + (4 - 6 * o + 3 * s) * n + (1 + 3 * e + 3 * o - 3 * s) * i + s * a) / 6;
}
function basis_default(e) {
	var t = e.length - 1;
	return function(n) {
		var i = n <= 0 ? n = 0 : n >= 1 ? (n = 1, t - 1) : Math.floor(n * t), a = e[i], o = e[i + 1], s = i > 0 ? e[i - 1] : 2 * a - o, c = i < t - 1 ? e[i + 2] : 2 * o - a;
		return basis((n - i / t) * t, s, a, o, c);
	};
}
var constant_default = (e) => () => e;
function linear(e, t) {
	return function(n) {
		return e + n * t;
	};
}
function exponential(e, t, n) {
	return e **= +n, t = t ** +n - e, n = 1 / n, function(i) {
		return (e + i * t) ** +n;
	};
}
function gamma(e) {
	return (e = +e) == 1 ? nogamma : function(t, n) {
		return n - t ? exponential(t, n, e) : constant_default(isNaN(t) ? n : t);
	};
}
function nogamma(e, t) {
	var n = t - e;
	return n ? linear(e, n) : constant_default(isNaN(e) ? t : e);
}
var rgb_default = (function e(t) {
	var n = gamma(t);
	function i(e, t) {
		var i = n((e = rgb(e)).r, (t = rgb(t)).r), a = n(e.g, t.g), o = n(e.b, t.b), s = nogamma(e.opacity, t.opacity);
		return function(t) {
			return e.r = i(t), e.g = a(t), e.b = o(t), e.opacity = s(t), e + "";
		};
	}
	return i.gamma = e, i;
})(1);
function rgbSpline(e) {
	return function(t) {
		var n = t.length, i = Array(n), a = Array(n), o = Array(n), s, c;
		for (s = 0; s < n; ++s) c = rgb(t[s]), i[s] = c.r || 0, a[s] = c.g || 0, o[s] = c.b || 0;
		return i = e(i), a = e(a), o = e(o), c.opacity = 1, function(e) {
			return c.r = i(e), c.g = a(e), c.b = o(e), c + "";
		};
	};
}
var rgbBasis = rgbSpline(basis_default);
function numberArray_default(e, t) {
	t ||= [];
	var n = e ? Math.min(t.length, e.length) : 0, i = t.slice(), a;
	return function(o) {
		for (a = 0; a < n; ++a) i[a] = e[a] * (1 - o) + t[a] * o;
		return i;
	};
}
function isNumberArray$1(e) {
	return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function genericArray(e, t) {
	var n = t ? t.length : 0, i = e ? Math.min(n, e.length) : 0, a = Array(i), o = Array(n), s;
	for (s = 0; s < i; ++s) a[s] = value_default(e[s], t[s]);
	for (; s < n; ++s) o[s] = t[s];
	return function(e) {
		for (s = 0; s < i; ++s) o[s] = a[s](e);
		return o;
	};
}
function date_default(e, t) {
	var n = /* @__PURE__ */ new Date();
	return e = +e, t = +t, function(i) {
		return n.setTime(e * (1 - i) + t * i), n;
	};
}
function number_default(e, t) {
	return e = +e, t = +t, function(n) {
		return e * (1 - n) + t * n;
	};
}
function object_default(e, t) {
	var n = {}, i = {}, a;
	for (a in (typeof e != "object" || !e) && (e = {}), (typeof t != "object" || !t) && (t = {}), t) a in e ? n[a] = value_default(e[a], t[a]) : i[a] = t[a];
	return function(e) {
		for (a in n) i[a] = n[a](e);
		return i;
	};
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(e) {
	return function() {
		return e;
	};
}
function one(e) {
	return function(t) {
		return e(t) + "";
	};
}
function string_default(e, t) {
	var n = reA.lastIndex = reB.lastIndex = 0, i, a, o, s = -1, c = [], l = [];
	for (e += "", t += ""; (i = reA.exec(e)) && (a = reB.exec(t));) (o = a.index) > n && (o = t.slice(n, o), c[s] ? c[s] += o : c[++s] = o), (i = i[0]) === (a = a[0]) ? c[s] ? c[s] += a : c[++s] = a : (c[++s] = null, l.push({
		i: s,
		x: number_default(i, a)
	})), n = reB.lastIndex;
	return n < t.length && (o = t.slice(n), c[s] ? c[s] += o : c[++s] = o), c.length < 2 ? l[0] ? one(l[0].x) : zero(t) : (t = l.length, function(e) {
		for (var n = 0, i; n < t; ++n) c[(i = l[n]).i] = i.x(e);
		return c.join("");
	});
}
function value_default(e, t) {
	var n = typeof t, i;
	return t == null || n === "boolean" ? constant_default(t) : (n === "number" ? number_default : n === "string" ? (i = color(t)) ? (t = i, rgb_default) : string_default : t instanceof color ? rgb_default : t instanceof Date ? date_default : isNumberArray$1(t) ? numberArray_default : Array.isArray(t) ? genericArray : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? object_default : number_default)(e, t);
}
function round_default(e, t) {
	return e = +e, t = +t, function(n) {
		return Math.round(e * (1 - n) + t * n);
	};
}
function identity(e) {
	return e;
}
function formatDecimal_default(e) {
	return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function formatDecimalParts(e, t) {
	if ((n = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
	var n, i = e.slice(0, n);
	return [i.length > 1 ? i[0] + i.slice(2) : i, +e.slice(n + 1)];
}
function exponent_default(e) {
	return e = formatDecimalParts(Math.abs(e)), e ? e[1] : NaN;
}
function formatGroup_default(e, t) {
	return function(n, i) {
		for (var a = n.length, o = [], s = 0, c = e[0], l = 0; a > 0 && c > 0 && (l + c + 1 > i && (c = Math.max(1, i - l)), o.push(n.substring(a -= c, a + c)), !((l += c + 1) > i));) c = e[s = (s + 1) % e.length];
		return o.reverse().join(t);
	};
}
function formatNumerals_default(e) {
	return function(t) {
		return t.replace(/[0-9]/g, function(t) {
			return e[+t];
		});
	};
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(e) {
	if (!(t = re.exec(e))) throw Error("invalid format: " + e);
	var t;
	return new FormatSpecifier({
		fill: t[1],
		align: t[2],
		sign: t[3],
		symbol: t[4],
		zero: t[5],
		width: t[6],
		comma: t[7],
		precision: t[8] && t[8].slice(1),
		trim: t[9],
		type: t[10]
	});
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(e) {
	this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
FormatSpecifier.prototype.toString = function() {
	return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim_default(e) {
	out: for (var t = e.length, n = 1, i = -1, a; n < t; ++n) switch (e[n]) {
		case ".":
			i = a = n;
			break;
		case "0":
			i === 0 && (i = n), a = n;
			break;
		default:
			if (!+e[n]) break out;
			i > 0 && (i = 0);
			break;
	}
	return i > 0 ? e.slice(0, i) + e.slice(a + 1) : e;
}
var prefixExponent;
function formatPrefixAuto_default(e, t) {
	var n = formatDecimalParts(e, t);
	if (!n) return e + "";
	var i = n[0], a = n[1], o = a - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(a / 3))) * 3) + 1, s = i.length;
	return o === s ? i : o > s ? i + Array(o - s + 1).join("0") : o > 0 ? i.slice(0, o) + "." + i.slice(o) : "0." + Array(1 - o).join("0") + formatDecimalParts(e, Math.max(0, t + o - 1))[0];
}
function formatRounded_default(e, t) {
	var n = formatDecimalParts(e, t);
	if (!n) return e + "";
	var i = n[0], a = n[1];
	return a < 0 ? "0." + Array(-a).join("0") + i : i.length > a + 1 ? i.slice(0, a + 1) + "." + i.slice(a + 1) : i + Array(a - i.length + 2).join("0");
}
var formatTypes_default = {
	"%": (e, t) => (e * 100).toFixed(t),
	b: (e) => Math.round(e).toString(2),
	c: (e) => e + "",
	d: formatDecimal_default,
	e: (e, t) => e.toExponential(t),
	f: (e, t) => e.toFixed(t),
	g: (e, t) => e.toPrecision(t),
	o: (e) => Math.round(e).toString(8),
	p: (e, t) => formatRounded_default(e * 100, t),
	r: formatRounded_default,
	s: formatPrefixAuto_default,
	X: (e) => Math.round(e).toString(16).toUpperCase(),
	x: (e) => Math.round(e).toString(16)
};
function identity_default(e) {
	return e;
}
var map = Array.prototype.map, prefixes = [
	"y",
	"z",
	"a",
	"f",
	"p",
	"n",
	"",
	"m",
	"",
	"k",
	"M",
	"G",
	"T",
	"P",
	"E",
	"Z",
	"Y"
];
function locale_default(e) {
	var t = e.grouping === void 0 || e.thousands === void 0 ? identity_default : formatGroup_default(map.call(e.grouping, Number), e.thousands + ""), n = e.currency === void 0 ? "" : e.currency[0] + "", i = e.currency === void 0 ? "" : e.currency[1] + "", a = e.decimal === void 0 ? "." : e.decimal + "", o = e.numerals === void 0 ? identity_default : formatNumerals_default(map.call(e.numerals, String)), s = e.percent === void 0 ? "%" : e.percent + "", c = e.minus === void 0 ? "" : e.minus + "", l = e.nan === void 0 ? "NaN" : e.nan + "";
	function u(e) {
		e = formatSpecifier(e);
		var u = e.fill, d = e.align, f = e.sign, p = e.symbol, m = e.zero, h = e.width, g = e.comma, _ = e.precision, v = e.trim, y = e.type;
		y === "n" ? (g = !0, y = "g") : formatTypes_default[y] || (_ === void 0 && (_ = 12), v = !0, y = "g"), (m || u === "0" && d === "=") && (m = !0, u = "0", d = "=");
		var b = p === "$" ? n : p === "#" && /[boxX]/.test(y) ? "0" + y.toLowerCase() : "", x = p === "$" ? i : /[%p]/.test(y) ? s : "", S = formatTypes_default[y], C = /[defgprs%]/.test(y);
		_ = _ === void 0 ? 6 : /[gprs]/.test(y) ? Math.max(1, Math.min(21, _)) : Math.max(0, Math.min(20, _));
		function w(e) {
			var n = b, i = x, s, p, w;
			if (y === "c") i = S(e) + i, e = "";
			else {
				e = +e;
				var T = e < 0 || 1 / e < 0;
				if (e = isNaN(e) ? l : S(Math.abs(e), _), v && (e = formatTrim_default(e)), T && +e == 0 && f !== "+" && (T = !1), n = (T ? f === "(" ? f : c : f === "-" || f === "(" ? "" : f) + n, i = (y === "s" ? prefixes[8 + prefixExponent / 3] : "") + i + (T && f === "(" ? ")" : ""), C) {
					for (s = -1, p = e.length; ++s < p;) if (w = e.charCodeAt(s), 48 > w || w > 57) {
						i = (w === 46 ? a + e.slice(s + 1) : e.slice(s)) + i, e = e.slice(0, s);
						break;
					}
				}
			}
			g && !m && (e = t(e, Infinity));
			var E = n.length + e.length + i.length, O = E < h ? Array(h - E + 1).join(u) : "";
			switch (g && m && (e = t(O + e, O.length ? h - i.length : Infinity), O = ""), d) {
				case "<":
					e = n + e + i + O;
					break;
				case "=":
					e = n + O + e + i;
					break;
				case "^":
					e = O.slice(0, E = O.length >> 1) + n + e + i + O.slice(E);
					break;
				default:
					e = O + n + e + i;
					break;
			}
			return o(e);
		}
		return w.toString = function() {
			return e + "";
		}, w;
	}
	function d(e, t) {
		var n = u((e = formatSpecifier(e), e.type = "f", e)), i = Math.max(-8, Math.min(8, Math.floor(exponent_default(t) / 3))) * 3, a = 10 ** -i, o = prefixes[8 + i / 3];
		return function(e) {
			return n(a * e) + o;
		};
	}
	return {
		format: u,
		formatPrefix: d
	};
}
var locale, format, formatPrefix;
defaultLocale({
	thousands: ",",
	grouping: [3],
	currency: ["$", ""]
});
function defaultLocale(e) {
	return locale = locale_default(e), format = locale.format, formatPrefix = locale.formatPrefix, locale;
}
function precisionFixed_default(e) {
	return Math.max(0, -exponent_default(Math.abs(e)));
}
function precisionPrefix_default(e, t) {
	return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(t) / 3))) * 3 - exponent_default(Math.abs(e)));
}
function precisionRound_default(e, t) {
	return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, exponent_default(t) - exponent_default(e)) + 1;
}
function tickFormat(e, t, n, i) {
	var a = tickStep(e, t, n), o;
	switch (i = formatSpecifier(i ?? ",f"), i.type) {
		case "s":
			var s = Math.max(Math.abs(e), Math.abs(t));
			return i.precision == null && !isNaN(o = precisionPrefix_default(a, s)) && (i.precision = o), formatPrefix(i, s);
		case "":
		case "e":
		case "g":
		case "p":
		case "r":
			i.precision == null && !isNaN(o = precisionRound_default(a, Math.max(Math.abs(e), Math.abs(t)))) && (i.precision = o - (i.type === "e"));
			break;
		case "f":
		case "%":
			i.precision == null && !isNaN(o = precisionFixed_default(a)) && (i.precision = o - (i.type === "%") * 2);
			break;
	}
	return format(i);
}
function linearish(e) {
	var t = e.domain;
	return e.ticks = function(e) {
		var n = t();
		return ticks(n[0], n[n.length - 1], e ?? 10);
	}, e.tickFormat = function(e, n) {
		var i = t();
		return tickFormat(i[0], i[i.length - 1], e ?? 10, n);
	}, e.nice = function(n) {
		n ??= 10;
		var i = t(), a = 0, o = i.length - 1, s = i[a], c = i[o], l, u, d = 10;
		for (c < s && (u = s, s = c, c = u, u = a, a = o, o = u); d-- > 0;) {
			if (u = tickIncrement(s, c, n), u === l) return i[a] = s, i[o] = c, t(i);
			if (u > 0) s = Math.floor(s / u) * u, c = Math.ceil(c / u) * u;
			else if (u < 0) s = Math.ceil(s * u) / u, c = Math.floor(c * u) / u;
			else break;
			l = u;
		}
		return e;
	}, e;
}
function transformer() {
	var e = 0, t = 1, n, i, a, o, s = identity, c = !1, l;
	function u(e) {
		return e == null || isNaN(e = +e) ? l : s(a === 0 ? .5 : (e = (o(e) - n) * a, c ? Math.max(0, Math.min(1, e)) : e));
	}
	u.domain = function(s) {
		return arguments.length ? ([e, t] = s, n = o(e = +e), i = o(t = +t), a = n === i ? 0 : 1 / (i - n), u) : [e, t];
	}, u.clamp = function(e) {
		return arguments.length ? (c = !!e, u) : c;
	}, u.interpolator = function(e) {
		return arguments.length ? (s = e, u) : s;
	};
	function d(e) {
		return function(t) {
			var n, i;
			return arguments.length ? ([n, i] = t, s = e(n, i), u) : [s(0), s(1)];
		};
	}
	return u.range = d(value_default), u.rangeRound = d(round_default), u.unknown = function(e) {
		return arguments.length ? (l = e, u) : l;
	}, function(s) {
		return o = s, n = s(e), i = s(t), a = n === i ? 0 : 1 / (i - n), u;
	};
}
function copy(e, t) {
	return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function sequential() {
	var e = linearish(transformer()(identity));
	return e.copy = function() {
		return copy(e, sequential());
	}, initInterpolator.apply(e, arguments);
}
function colors_default(e) {
	for (var t = e.length / 6 | 0, n = Array(t), i = 0; i < t;) n[i] = "#" + e.slice(i * 6, ++i * 6);
	return n;
}
var ramp_default = (e) => rgbBasis(e[e.length - 1]), scheme = [
	,
	,
	,
	"fc8d59ffffbf91cf60",
	"d7191cfdae61a6d96a1a9641",
	"d7191cfdae61ffffbfa6d96a1a9641",
	"d73027fc8d59fee08bd9ef8b91cf601a9850",
	"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
	"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
	"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
	"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
	"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
].map(colors_default), RdYlGn_default = ramp_default(scheme);
function turbo_default(e) {
	return e = Math.max(0, Math.min(1, e)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + e * (1172.33 - e * (10793.56 - e * (33300.12 - e * (38394.49 - e * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + e * (557.33 + e * (1225.33 - e * (3574.96 - e * (1073.77 + e * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + e * (3211.1 - e * (15327.97 - e * (27814 - e * (22569.18 - e * 6838.66))))))) + ")";
}
function ramp(e) {
	var t = e.length;
	return function(n) {
		return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
	};
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")), magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")), inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
const WORST_OPACITY_FLOOR = .7;
function computeMinMax(e) {
	if (!e || e.length === 0) return {
		min: 0,
		max: 1,
		empty: !0
	};
	let t = Math.min(...e), n = Math.max(...e);
	return {
		min: t,
		max: n,
		empty: !1
	};
}
function buildColorStops(e, t, n, i, a = .9) {
	if (!isFinite(e) || !isFinite(t) || e === t || n <= 1) return "#9ca3af";
	let o = i === "magma" ? magma : i === "inferno" ? inferno : i === "turbo" ? turbo_default : i === "RdYlGn" ? RdYlGn_default : viridis_default, s = sequential((e) => o(e * a)).domain([t, e]), c = [e, s(e)];
	for (let i = 1; i < n; i++) {
		let a = e + i * (t - e) / (n - 1);
		c.push(a, s(a));
	}
	return [
		"interpolate",
		["linear"],
		["get", "total_emissions"],
		...c
	];
}
function buildOpacityStops(e, t, n = 1, i = .25) {
	return !isFinite(e) || !isFinite(t) || e === t ? .6 : [
		"interpolate",
		["linear"],
		["get", "total_emissions"],
		e,
		n,
		t,
		i
	];
}
function colorForEmissionsValue(e, t, n, i = "RdYlGn", a = .9) {
	if (!isFinite(e) || !isFinite(t) || !isFinite(n) || e === t) return "#9ca3af";
	let o = i === "magma" ? magma : i === "inferno" ? inferno : i === "turbo" ? turbo_default : i === "RdYlGn" ? RdYlGn_default : viridis_default;
	return sequential((e) => o(e * a)).domain([t, e])(n);
}
function useStateMachine(e, t) {
	return import_react.useReducer((e, n) => t[e][n] ?? e, e);
}
var Presence = (e) => {
	let { present: t, children: n } = e, i = usePresence(t), a = typeof n == "function" ? n({ present: i.isPresent }) : import_react.Children.only(n), o = useComposedRefs(i.ref, getElementRef(a));
	return typeof n == "function" || i.isPresent ? import_react.cloneElement(a, { ref: o }) : null;
};
Presence.displayName = "Presence";
function usePresence(e) {
	let [t, n] = import_react.useState(), i = import_react.useRef(null), a = import_react.useRef(e), o = import_react.useRef("none"), [s, c] = useStateMachine(e ? "mounted" : "unmounted", {
		mounted: {
			UNMOUNT: "unmounted",
			ANIMATION_OUT: "unmountSuspended"
		},
		unmountSuspended: {
			MOUNT: "mounted",
			ANIMATION_END: "unmounted"
		},
		unmounted: { MOUNT: "mounted" }
	});
	return import_react.useEffect(() => {
		let e = getAnimationName(i.current);
		o.current = s === "mounted" ? e : "none";
	}, [s]), useLayoutEffect2(() => {
		let t = i.current, n = a.current;
		if (n !== e) {
			let i = o.current, s = getAnimationName(t);
			e ? c("MOUNT") : s === "none" || t?.display === "none" ? c("UNMOUNT") : c(n && i !== s ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e;
		}
	}, [e, c]), useLayoutEffect2(() => {
		if (t) {
			let e, n = t.ownerDocument.defaultView ?? window, s = (o) => {
				let s = getAnimationName(i.current).includes(CSS.escape(o.animationName));
				if (o.target === t && s && (c("ANIMATION_END"), !a.current)) {
					let i = t.style.animationFillMode;
					t.style.animationFillMode = "forwards", e = n.setTimeout(() => {
						t.style.animationFillMode === "forwards" && (t.style.animationFillMode = i);
					});
				}
			}, l = (e) => {
				e.target === t && (o.current = getAnimationName(i.current));
			};
			return t.addEventListener("animationstart", l), t.addEventListener("animationcancel", s), t.addEventListener("animationend", s), () => {
				n.clearTimeout(e), t.removeEventListener("animationstart", l), t.removeEventListener("animationcancel", s), t.removeEventListener("animationend", s);
			};
		} else c("ANIMATION_END");
	}, [t, c]), {
		isPresent: ["mounted", "unmountSuspended"].includes(s),
		ref: import_react.useCallback((e) => {
			i.current = e ? getComputedStyle(e) : null, n(e);
		}, [])
	};
}
function getAnimationName(e) {
	return e?.animationName || "none";
}
function getElementRef(e) {
	let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
	return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var DIALOG_NAME = "Dialog", [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME), [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME), Dialog$1 = (e) => {
	let { __scopeDialog: t, children: n, open: i, defaultOpen: a, onOpenChange: o, modal: s = !0 } = e, c = import_react.useRef(null), l = import_react.useRef(null), [u, d] = useControllableState({
		prop: i,
		defaultProp: a ?? !1,
		onChange: o,
		caller: DIALOG_NAME
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogProvider, {
		scope: t,
		triggerRef: c,
		contentRef: l,
		contentId: useId(),
		titleId: useId(),
		descriptionId: useId(),
		open: u,
		onOpenChange: d,
		onOpenToggle: import_react.useCallback(() => d((e) => !e), [d]),
		modal: s,
		children: n
	});
};
Dialog$1.displayName = DIALOG_NAME;
var TRIGGER_NAME = "DialogTrigger", DialogTrigger = import_react.forwardRef((e, t) => {
	let { __scopeDialog: n,...i } = e, a = useDialogContext(TRIGGER_NAME, n), o = useComposedRefs(t, a.triggerRef);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.button, {
		type: "button",
		"aria-haspopup": "dialog",
		"aria-expanded": a.open,
		"aria-controls": a.contentId,
		"data-state": getState(a.open),
		...i,
		ref: o,
		onClick: composeEventHandlers(e.onClick, a.onOpenToggle)
	});
});
DialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "DialogPortal", [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME, { forceMount: void 0 }), DialogPortal$1 = (e) => {
	let { __scopeDialog: t, forceMount: n, children: i, container: a } = e, o = useDialogContext(PORTAL_NAME, t);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PortalProvider, {
		scope: t,
		forceMount: n,
		children: import_react.Children.map(i, (e) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Presence, {
			present: n || o.open,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal, {
				asChild: !0,
				container: a,
				children: e
			})
		}))
	});
};
DialogPortal$1.displayName = PORTAL_NAME;
var OVERLAY_NAME = "DialogOverlay", DialogOverlay$1 = import_react.forwardRef((e, t) => {
	let n = usePortalContext(OVERLAY_NAME, e.__scopeDialog), { forceMount: i = n.forceMount,...a } = e, o = useDialogContext(OVERLAY_NAME, e.__scopeDialog);
	return o.modal ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Presence, {
		present: i || o.open,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogOverlayImpl, {
			...a,
			ref: t
		})
	}) : null;
});
DialogOverlay$1.displayName = OVERLAY_NAME;
var Slot$1 = /* @__PURE__ */ createSlot("DialogOverlay.RemoveScroll"), DialogOverlayImpl = import_react.forwardRef((e, t) => {
	let { __scopeDialog: n,...i } = e, a = useDialogContext(OVERLAY_NAME, n);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Combination_default, {
		as: Slot$1,
		allowPinchZoom: !0,
		shards: [a.contentRef],
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.div, {
			"data-state": getState(a.open),
			...i,
			ref: t,
			style: {
				pointerEvents: "auto",
				...i.style
			}
		})
	});
}), CONTENT_NAME = "DialogContent", DialogContent$1 = import_react.forwardRef((e, t) => {
	let n = usePortalContext(CONTENT_NAME, e.__scopeDialog), { forceMount: i = n.forceMount,...a } = e, o = useDialogContext(CONTENT_NAME, e.__scopeDialog);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Presence, {
		present: i || o.open,
		children: o.modal ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogContentModal, {
			...a,
			ref: t
		}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogContentNonModal, {
			...a,
			ref: t
		})
	});
});
DialogContent$1.displayName = CONTENT_NAME;
var DialogContentModal = import_react.forwardRef((e, t) => {
	let n = useDialogContext(CONTENT_NAME, e.__scopeDialog), i = import_react.useRef(null), a = useComposedRefs(t, n.contentRef, i);
	return import_react.useEffect(() => {
		let e = i.current;
		if (e) return hideOthers(e);
	}, []), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogContentImpl, {
		...e,
		ref: a,
		trapFocus: n.open,
		disableOutsidePointerEvents: !0,
		onCloseAutoFocus: composeEventHandlers(e.onCloseAutoFocus, (e) => {
			e.preventDefault(), n.triggerRef.current?.focus();
		}),
		onPointerDownOutside: composeEventHandlers(e.onPointerDownOutside, (e) => {
			let t = e.detail.originalEvent, n = t.button === 0 && t.ctrlKey === !0;
			(t.button === 2 || n) && e.preventDefault();
		}),
		onFocusOutside: composeEventHandlers(e.onFocusOutside, (e) => e.preventDefault())
	});
}), DialogContentNonModal = import_react.forwardRef((e, t) => {
	let n = useDialogContext(CONTENT_NAME, e.__scopeDialog), i = import_react.useRef(!1), a = import_react.useRef(!1);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogContentImpl, {
		...e,
		ref: t,
		trapFocus: !1,
		disableOutsidePointerEvents: !1,
		onCloseAutoFocus: (t) => {
			e.onCloseAutoFocus?.(t), t.defaultPrevented || (i.current || n.triggerRef.current?.focus(), t.preventDefault()), i.current = !1, a.current = !1;
		},
		onInteractOutside: (t) => {
			e.onInteractOutside?.(t), t.defaultPrevented || (i.current = !0, t.detail.originalEvent.type === "pointerdown" && (a.current = !0));
			let o = t.target;
			n.triggerRef.current?.contains(o) && t.preventDefault(), t.detail.originalEvent.type === "focusin" && a.current && t.preventDefault();
		}
	});
}), DialogContentImpl = import_react.forwardRef((e, t) => {
	let { __scopeDialog: n, trapFocus: i, onOpenAutoFocus: a, onCloseAutoFocus: o,...s } = e, c = useDialogContext(CONTENT_NAME, n), l = import_react.useRef(null), u = useComposedRefs(t, l);
	return useFocusGuards(), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(FocusScope, {
		asChild: !0,
		loop: !0,
		trapped: i,
		onMountAutoFocus: a,
		onUnmountAutoFocus: o,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DismissableLayer, {
			role: "dialog",
			id: c.contentId,
			"aria-describedby": c.descriptionId,
			"aria-labelledby": c.titleId,
			"data-state": getState(c.open),
			...s,
			ref: u,
			onDismiss: () => c.onOpenChange(!1)
		})
	}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TitleWarning, { titleId: c.titleId }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DescriptionWarning, {
		contentRef: l,
		descriptionId: c.descriptionId
	})] })] });
}), TITLE_NAME = "DialogTitle", DialogTitle$1 = import_react.forwardRef((e, t) => {
	let { __scopeDialog: n,...i } = e, a = useDialogContext(TITLE_NAME, n);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.h2, {
		id: a.titleId,
		...i,
		ref: t
	});
});
DialogTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription", DialogDescription$1 = import_react.forwardRef((e, t) => {
	let { __scopeDialog: n,...i } = e, a = useDialogContext(DESCRIPTION_NAME, n);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.p, {
		id: a.descriptionId,
		...i,
		ref: t
	});
});
DialogDescription$1.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose", DialogClose = import_react.forwardRef((e, t) => {
	let { __scopeDialog: n,...i } = e, a = useDialogContext(CLOSE_NAME, n);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Primitive.button, {
		type: "button",
		...i,
		ref: t,
		onClick: composeEventHandlers(e.onClick, () => a.onOpenChange(!1))
	});
});
DialogClose.displayName = CLOSE_NAME;
function getState(e) {
	return e ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning", [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
	contentName: CONTENT_NAME,
	titleName: TITLE_NAME,
	docsSlug: "dialog"
}), TitleWarning = ({ titleId: e }) => {
	let t = useWarningContext(TITLE_WARNING_NAME), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
	return import_react.useEffect(() => {
		e && (document.getElementById(e) || console.error(n));
	}, [n, e]), null;
}, DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning", DescriptionWarning = ({ contentRef: e, descriptionId: t }) => {
	let n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${useWarningContext(DESCRIPTION_WARNING_NAME).contentName}}.`;
	return import_react.useEffect(() => {
		let i = e.current?.getAttribute("aria-describedby");
		t && i && (document.getElementById(t) || console.warn(n));
	}, [
		n,
		e,
		t
	]), null;
}, Root = Dialog$1, Portal$1 = DialogPortal$1, Overlay = DialogOverlay$1, Content = DialogContent$1, Title = DialogTitle$1, Description = DialogDescription$1, Close = DialogClose;
function Dialog({ ...e }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Root, {
		"data-slot": "dialog",
		...e
	});
}
function DialogPortal({ ...e }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Portal$1, {
		"data-slot": "dialog-portal",
		...e
	});
}
function DialogOverlay({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Overlay, {
		"data-slot": "dialog-overlay",
		className: cn("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", e),
		...t
	});
}
function DialogContent({ className: e, children: t, showCloseButton: n = !0,...i }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DialogPortal, {
		"data-slot": "dialog-portal",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogOverlay, {}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Content, {
			"data-slot": "dialog-content",
			className: cn("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", e),
			...i,
			children: [t, n && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Close, {
				"data-slot": "dialog-close",
				className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(X, {}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					className: "sr-only",
					children: "Close"
				})]
			})]
		})]
	});
}
function DialogHeader({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		"data-slot": "dialog-header",
		className: cn("flex flex-col gap-2 text-center sm:text-left", e),
		...t
	});
}
function DialogTitle({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Title, {
		"data-slot": "dialog-title",
		className: cn("text-lg leading-none font-semibold", e),
		...t
	});
}
function DialogDescription({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Description, {
		"data-slot": "dialog-description",
		className: cn("text-muted-foreground text-sm", e),
		...t
	});
}
function Card({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		"data-slot": "card",
		className: cn("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm", e),
		...t
	});
}
function CardHeader({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		"data-slot": "card-header",
		className: cn("@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6", e),
		...t
	});
}
function CardTitle({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		"data-slot": "card-title",
		className: cn("leading-none font-semibold", e),
		...t
	});
}
function CardContent({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		"data-slot": "card-content",
		className: cn("px-6", e),
		...t
	});
}
var formatNumber$1 = (e) => {
	if (e == null) return "";
	let t = typeof e == "string" ? Number(e) : e;
	return Number.isNaN(t) ? String(e) : Intl.NumberFormat(void 0, { maximumFractionDigits: 0 }).format(t);
};
function ProductEmissionsCard({ product: e, emissionsStats: t, palette: n = "RdYlGn" }) {
	let i = (() => !t || t.empty || !e.total_emissions || t.min === 0 ? null : (e.total_emissions - t.min) / t.min)();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "space-y-2",
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "text-lg text-bold text-left",
				children: [
					e.brand,
					" ",
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
						className: "text-sm text-muted-foreground",
						children: [
							e.product_name,
							" (",
							e.mpa,
							" MPa)"
						]
					})
				]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "text-2xl font-semibold tabular-nums text-left ml-2",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					style: t && !t.empty ? { color: colorForEmissionsValue(t.min, t.max, e.total_emissions, n) } : void 0,
					children: formatNumber$1(e.total_emissions)
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
					className: "ml-1 text-sm opacity-60",
					children: " kg COe"
				})]
			}),
			i !== null && i !== 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
				className: "text-sm text-muted-foreground",
				children: [
					" ",
					formatNumber$1(i * 100),
					"% more emissions than the best product"
				]
			}),
			i !== null && i === 0 && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
				className: "text-sm text-muted-foreground",
				children: [" ", "This is the best option available."]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "grid grid-cols-2 gap-x-3 gap-y-1 text-sm mt-2",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-muted-foreground text-left",
						children: "kg COe / m"
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-right",
						children: formatNumber$1(e.kg_co2e_per_m3)
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-muted-foreground text-left",
						children: "Transport"
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "text-right",
						children: [formatNumber$1(e.plant_to_site_transport_emissions), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
							className: "ml-1 text-[11px] opacity-70",
							children: "kg COe"
						})]
					})
				]
			})
		]
	}) }) });
}
var product_emissions_card_default = ProductEmissionsCard;
function functionalUpdate(e, t) {
	return typeof e == "function" ? e(t) : e;
}
function makeStateUpdater(e, t) {
	return (n) => {
		t.setState((t) => ({
			...t,
			[e]: functionalUpdate(n, t[e])
		}));
	};
}
function isFunction(e) {
	return e instanceof Function;
}
function isNumberArray(e) {
	return Array.isArray(e) && e.every((e) => typeof e == "number");
}
function flattenBy(e, t) {
	let n = [], i = (e) => {
		e.forEach((e) => {
			n.push(e);
			let a = t(e);
			a != null && a.length && i(a);
		});
	};
	return i(e), n;
}
function memo(e, t, n) {
	let i = [], a;
	return (o) => {
		let s;
		n.key && n.debug && (s = Date.now());
		let c = e(o);
		if (!(c.length !== i.length || c.some((e, t) => i[t] !== e))) return a;
		i = c;
		let l;
		if (n.key && n.debug && (l = Date.now()), a = t(...c), n == null || n.onChange == null || n.onChange(a), n.key && n.debug && n != null && n.debug()) {
			let e = Math.round((Date.now() - s) * 100) / 100, t = Math.round((Date.now() - l) * 100) / 100, i = t / 16, a = (e, t) => {
				for (e = String(e); e.length < t;) e = " " + e;
				return e;
			};
			console.info(`%c ${a(t, 5)} /${a(e, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * i, 120))}deg 100% 31%);`, n?.key);
		}
		return a;
	};
}
function getMemoOptions(e, t, n, i) {
	return {
		debug: () => e?.debugAll ?? e[t],
		key: process.env.NODE_ENV === "development" && n,
		onChange: i
	};
}
function createCell(e, t, n, i) {
	let a = {
		id: `${t.id}_${n.id}`,
		row: t,
		column: n,
		getValue: () => t.getValue(i),
		renderValue: () => a.getValue() ?? e.options.renderFallbackValue,
		getContext: memo(() => [
			e,
			n,
			t,
			a
		], (e, t, n, i) => ({
			table: e,
			column: t,
			row: n,
			cell: i,
			getValue: i.getValue,
			renderValue: i.renderValue
		}), getMemoOptions(e.options, "debugCells", "cell.getContext"))
	};
	return e._features.forEach((i) => {
		i.createCell == null || i.createCell(a, n, t, e);
	}, {}), a;
}
function createColumn(e, t, n, i) {
	let a = {
		...e._getDefaultColumnDef(),
		...t
	}, o = a.accessorKey, s = a.id ?? (o ? typeof String.prototype.replaceAll == "function" ? o.replaceAll(".", "_") : o.replace(/\./g, "_") : void 0) ?? (typeof a.header == "string" ? a.header : void 0), c;
	if (a.accessorFn ? c = a.accessorFn : o && (c = o.includes(".") ? (e) => {
		let t = e;
		for (let e of o.split(".")) t = t?.[e], process.env.NODE_ENV !== "production" && t === void 0 && console.warn(`"${e}" in deeply nested key "${o}" returned undefined.`);
		return t;
	} : (e) => e[a.accessorKey]), !s) throw process.env.NODE_ENV === "production" ? Error() : Error(a.accessorFn ? "Columns require an id when using an accessorFn" : "Columns require an id when using a non-string header");
	let l = {
		id: `${String(s)}`,
		accessorFn: c,
		parent: i,
		depth: n,
		columnDef: a,
		columns: [],
		getFlatColumns: memo(() => [!0], () => [l, ...l.columns?.flatMap((e) => e.getFlatColumns())], getMemoOptions(e.options, "debugColumns", "column.getFlatColumns")),
		getLeafColumns: memo(() => [e._getOrderColumnsFn()], (e) => {
			var t;
			if ((t = l.columns) != null && t.length) {
				let t = l.columns.flatMap((e) => e.getLeafColumns());
				return e(t);
			}
			return [l];
		}, getMemoOptions(e.options, "debugColumns", "column.getLeafColumns"))
	};
	for (let t of e._features) t.createColumn == null || t.createColumn(l, e);
	return l;
}
var debug = "debugHeaders";
function createHeader(e, t, n) {
	let i = {
		id: n.id ?? t.id,
		column: t,
		index: n.index,
		isPlaceholder: !!n.isPlaceholder,
		placeholderId: n.placeholderId,
		depth: n.depth,
		subHeaders: [],
		colSpan: 0,
		rowSpan: 0,
		headerGroup: null,
		getLeafHeaders: () => {
			let e = [], t = (n) => {
				n.subHeaders && n.subHeaders.length && n.subHeaders.map(t), e.push(n);
			};
			return t(i), e;
		},
		getContext: () => ({
			table: e,
			header: i,
			column: t
		})
	};
	return e._features.forEach((t) => {
		t.createHeader == null || t.createHeader(i, e);
	}), i;
}
var Headers = { createTable: (e) => {
	e.getHeaderGroups = memo(() => [
		e.getAllColumns(),
		e.getVisibleLeafColumns(),
		e.getState().columnPinning.left,
		e.getState().columnPinning.right
	], (t, n, i, a) => {
		let o = i?.map((e) => n.find((t) => t.id === e)).filter(Boolean) ?? [], s = a?.map((e) => n.find((t) => t.id === e)).filter(Boolean) ?? [], c = n.filter((e) => !(i != null && i.includes(e.id)) && !(a != null && a.includes(e.id)));
		return buildHeaderGroups(t, [
			...o,
			...c,
			...s
		], e);
	}, getMemoOptions(e.options, debug, "getHeaderGroups")), e.getCenterHeaderGroups = memo(() => [
		e.getAllColumns(),
		e.getVisibleLeafColumns(),
		e.getState().columnPinning.left,
		e.getState().columnPinning.right
	], (t, n, i, a) => (n = n.filter((e) => !(i != null && i.includes(e.id)) && !(a != null && a.includes(e.id))), buildHeaderGroups(t, n, e, "center")), getMemoOptions(e.options, debug, "getCenterHeaderGroups")), e.getLeftHeaderGroups = memo(() => [
		e.getAllColumns(),
		e.getVisibleLeafColumns(),
		e.getState().columnPinning.left
	], (t, n, i) => {
		let a = i?.map((e) => n.find((t) => t.id === e)).filter(Boolean) ?? [];
		return buildHeaderGroups(t, a, e, "left");
	}, getMemoOptions(e.options, debug, "getLeftHeaderGroups")), e.getRightHeaderGroups = memo(() => [
		e.getAllColumns(),
		e.getVisibleLeafColumns(),
		e.getState().columnPinning.right
	], (t, n, i) => {
		let a = i?.map((e) => n.find((t) => t.id === e)).filter(Boolean) ?? [];
		return buildHeaderGroups(t, a, e, "right");
	}, getMemoOptions(e.options, debug, "getRightHeaderGroups")), e.getFooterGroups = memo(() => [e.getHeaderGroups()], (e) => [...e].reverse(), getMemoOptions(e.options, debug, "getFooterGroups")), e.getLeftFooterGroups = memo(() => [e.getLeftHeaderGroups()], (e) => [...e].reverse(), getMemoOptions(e.options, debug, "getLeftFooterGroups")), e.getCenterFooterGroups = memo(() => [e.getCenterHeaderGroups()], (e) => [...e].reverse(), getMemoOptions(e.options, debug, "getCenterFooterGroups")), e.getRightFooterGroups = memo(() => [e.getRightHeaderGroups()], (e) => [...e].reverse(), getMemoOptions(e.options, debug, "getRightFooterGroups")), e.getFlatHeaders = memo(() => [e.getHeaderGroups()], (e) => e.map((e) => e.headers).flat(), getMemoOptions(e.options, debug, "getFlatHeaders")), e.getLeftFlatHeaders = memo(() => [e.getLeftHeaderGroups()], (e) => e.map((e) => e.headers).flat(), getMemoOptions(e.options, debug, "getLeftFlatHeaders")), e.getCenterFlatHeaders = memo(() => [e.getCenterHeaderGroups()], (e) => e.map((e) => e.headers).flat(), getMemoOptions(e.options, debug, "getCenterFlatHeaders")), e.getRightFlatHeaders = memo(() => [e.getRightHeaderGroups()], (e) => e.map((e) => e.headers).flat(), getMemoOptions(e.options, debug, "getRightFlatHeaders")), e.getCenterLeafHeaders = memo(() => [e.getCenterFlatHeaders()], (e) => e.filter((e) => {
		var t;
		return !((t = e.subHeaders) != null && t.length);
	}), getMemoOptions(e.options, debug, "getCenterLeafHeaders")), e.getLeftLeafHeaders = memo(() => [e.getLeftFlatHeaders()], (e) => e.filter((e) => {
		var t;
		return !((t = e.subHeaders) != null && t.length);
	}), getMemoOptions(e.options, debug, "getLeftLeafHeaders")), e.getRightLeafHeaders = memo(() => [e.getRightFlatHeaders()], (e) => e.filter((e) => {
		var t;
		return !((t = e.subHeaders) != null && t.length);
	}), getMemoOptions(e.options, debug, "getRightLeafHeaders")), e.getLeafHeaders = memo(() => [
		e.getLeftHeaderGroups(),
		e.getCenterHeaderGroups(),
		e.getRightHeaderGroups()
	], (e, t, n) => [
		...e[0]?.headers ?? [],
		...t[0]?.headers ?? [],
		...n[0]?.headers ?? []
	].map((e) => e.getLeafHeaders()).flat(), getMemoOptions(e.options, debug, "getLeafHeaders"));
} };
function buildHeaderGroups(e, t, n, i) {
	let a = 0, o = function(e, t) {
		t === void 0 && (t = 1), a = Math.max(a, t), e.filter((e) => e.getIsVisible()).forEach((e) => {
			var n;
			(n = e.columns) != null && n.length && o(e.columns, t + 1);
		}, 0);
	};
	o(e);
	let s = [], c = (e, t) => {
		let a = {
			depth: t,
			id: [i, `${t}`].filter(Boolean).join("_"),
			headers: []
		}, o = [];
		e.forEach((e) => {
			let s = [...o].reverse()[0], c = e.column.depth === a.depth, l, u = !1;
			if (c && e.column.parent ? l = e.column.parent : (l = e.column, u = !0), s && s?.column === l) s.subHeaders.push(e);
			else {
				let a = createHeader(n, l, {
					id: [
						i,
						t,
						l.id,
						e?.id
					].filter(Boolean).join("_"),
					isPlaceholder: u,
					placeholderId: u ? `${o.filter((e) => e.column === l).length}` : void 0,
					depth: t,
					index: o.length
				});
				a.subHeaders.push(e), o.push(a);
			}
			a.headers.push(e), e.headerGroup = a;
		}), s.push(a), t > 0 && c(o, t - 1);
	}, l = t.map((e, t) => createHeader(n, e, {
		depth: a,
		index: t
	}));
	c(l, a - 1), s.reverse();
	let u = (e) => e.filter((e) => e.column.getIsVisible()).map((e) => {
		let t = 0, n = 0, i = [0];
		e.subHeaders && e.subHeaders.length ? (i = [], u(e.subHeaders).forEach((e) => {
			let { colSpan: n, rowSpan: a } = e;
			t += n, i.push(a);
		})) : t = 1;
		let a = Math.min(...i);
		return n += a, e.colSpan = t, e.rowSpan = n, {
			colSpan: t,
			rowSpan: n
		};
	});
	return u(s[0]?.headers ?? []), s;
}
var createRow = (e, t, n, i, a, o, s) => {
	let c = {
		id: t,
		index: i,
		original: n,
		depth: a,
		parentId: s,
		_valuesCache: {},
		_uniqueValuesCache: {},
		getValue: (t) => {
			if (c._valuesCache.hasOwnProperty(t)) return c._valuesCache[t];
			let n = e.getColumn(t);
			if (n != null && n.accessorFn) return c._valuesCache[t] = n.accessorFn(c.original, i), c._valuesCache[t];
		},
		getUniqueValues: (t) => {
			if (c._uniqueValuesCache.hasOwnProperty(t)) return c._uniqueValuesCache[t];
			let n = e.getColumn(t);
			if (n != null && n.accessorFn) return n.columnDef.getUniqueValues ? (c._uniqueValuesCache[t] = n.columnDef.getUniqueValues(c.original, i), c._uniqueValuesCache[t]) : (c._uniqueValuesCache[t] = [c.getValue(t)], c._uniqueValuesCache[t]);
		},
		renderValue: (t) => c.getValue(t) ?? e.options.renderFallbackValue,
		subRows: o ?? [],
		getLeafRows: () => flattenBy(c.subRows, (e) => e.subRows),
		getParentRow: () => c.parentId ? e.getRow(c.parentId, !0) : void 0,
		getParentRows: () => {
			let e = [], t = c;
			for (;;) {
				let n = t.getParentRow();
				if (!n) break;
				e.push(n), t = n;
			}
			return e.reverse();
		},
		getAllCells: memo(() => [e.getAllLeafColumns()], (t) => t.map((t) => createCell(e, c, t, t.id)), getMemoOptions(e.options, "debugRows", "getAllCells")),
		_getAllCellsByColumnId: memo(() => [c.getAllCells()], (e) => e.reduce((e, t) => (e[t.column.id] = t, e), {}), getMemoOptions(e.options, "debugRows", "getAllCellsByColumnId"))
	};
	for (let t = 0; t < e._features.length; t++) {
		let n = e._features[t];
		n == null || n.createRow == null || n.createRow(c, e);
	}
	return c;
}, ColumnFaceting = { createColumn: (e, t) => {
	e._getFacetedRowModel = t.options.getFacetedRowModel && t.options.getFacetedRowModel(t, e.id), e.getFacetedRowModel = () => e._getFacetedRowModel ? e._getFacetedRowModel() : t.getPreFilteredRowModel(), e._getFacetedUniqueValues = t.options.getFacetedUniqueValues && t.options.getFacetedUniqueValues(t, e.id), e.getFacetedUniqueValues = () => e._getFacetedUniqueValues ? e._getFacetedUniqueValues() : /* @__PURE__ */ new Map(), e._getFacetedMinMaxValues = t.options.getFacetedMinMaxValues && t.options.getFacetedMinMaxValues(t, e.id), e.getFacetedMinMaxValues = () => {
		if (e._getFacetedMinMaxValues) return e._getFacetedMinMaxValues();
	};
} }, includesString = (e, t, n) => {
	var i, a;
	let o = n == null || (i = n.toString()) == null ? void 0 : i.toLowerCase();
	return !!(!((a = e.getValue(t)) == null || (a = a.toString()) == null || (a = a.toLowerCase()) == null) && a.includes(o));
};
includesString.autoRemove = (e) => testFalsey(e);
var includesStringSensitive = (e, t, n) => {
	var i;
	return !!(!((i = e.getValue(t)) == null || (i = i.toString()) == null) && i.includes(n));
};
includesStringSensitive.autoRemove = (e) => testFalsey(e);
var equalsString = (e, t, n) => {
	var i;
	return ((i = e.getValue(t)) == null || (i = i.toString()) == null ? void 0 : i.toLowerCase()) === n?.toLowerCase();
};
equalsString.autoRemove = (e) => testFalsey(e);
var arrIncludes = (e, t, n) => e.getValue(t)?.includes(n);
arrIncludes.autoRemove = (e) => testFalsey(e);
var arrIncludesAll = (e, t, n) => !n.some((n) => {
	var i;
	return !((i = e.getValue(t)) != null && i.includes(n));
});
arrIncludesAll.autoRemove = (e) => testFalsey(e) || !(e != null && e.length);
var arrIncludesSome = (e, t, n) => n.some((n) => e.getValue(t)?.includes(n));
arrIncludesSome.autoRemove = (e) => testFalsey(e) || !(e != null && e.length);
var equals = (e, t, n) => e.getValue(t) === n;
equals.autoRemove = (e) => testFalsey(e);
var weakEquals = (e, t, n) => e.getValue(t) == n;
weakEquals.autoRemove = (e) => testFalsey(e);
var inNumberRange = (e, t, n) => {
	let [i, a] = n, o = e.getValue(t);
	return o >= i && o <= a;
};
inNumberRange.resolveFilterValue = (e) => {
	let [t, n] = e, i = typeof t == "number" ? t : parseFloat(t), a = typeof n == "number" ? n : parseFloat(n), o = t === null || Number.isNaN(i) ? -Infinity : i, s = n === null || Number.isNaN(a) ? Infinity : a;
	if (o > s) {
		let e = o;
		o = s, s = e;
	}
	return [o, s];
}, inNumberRange.autoRemove = (e) => testFalsey(e) || testFalsey(e[0]) && testFalsey(e[1]);
var filterFns = {
	includesString,
	includesStringSensitive,
	equalsString,
	arrIncludes,
	arrIncludesAll,
	arrIncludesSome,
	equals,
	weakEquals,
	inNumberRange
};
function testFalsey(e) {
	return e == null || e === "";
}
var ColumnFiltering = {
	getDefaultColumnDef: () => ({ filterFn: "auto" }),
	getInitialState: (e) => ({
		columnFilters: [],
		...e
	}),
	getDefaultOptions: (e) => ({
		onColumnFiltersChange: makeStateUpdater("columnFilters", e),
		filterFromLeafRows: !1,
		maxLeafRowFilterDepth: 100
	}),
	createColumn: (e, t) => {
		e.getAutoFilterFn = () => {
			let n = t.getCoreRowModel().flatRows[0]?.getValue(e.id);
			return typeof n == "string" ? filterFns.includesString : typeof n == "number" ? filterFns.inNumberRange : typeof n == "boolean" || typeof n == "object" && n ? filterFns.equals : Array.isArray(n) ? filterFns.arrIncludes : filterFns.weakEquals;
		}, e.getFilterFn = () => isFunction(e.columnDef.filterFn) ? e.columnDef.filterFn : e.columnDef.filterFn === "auto" ? e.getAutoFilterFn() : t.options.filterFns?.[e.columnDef.filterFn] ?? filterFns[e.columnDef.filterFn], e.getCanFilter = () => (e.columnDef.enableColumnFilter ?? !0) && (t.options.enableColumnFilters ?? !0) && (t.options.enableFilters ?? !0) && !!e.accessorFn, e.getIsFiltered = () => e.getFilterIndex() > -1, e.getFilterValue = () => {
			var n;
			return (n = t.getState().columnFilters) == null || (n = n.find((t) => t.id === e.id)) == null ? void 0 : n.value;
		}, e.getFilterIndex = () => t.getState().columnFilters?.findIndex((t) => t.id === e.id) ?? -1, e.setFilterValue = (n) => {
			t.setColumnFilters((t) => {
				let i = e.getFilterFn(), a = t?.find((t) => t.id === e.id), o = functionalUpdate(n, a ? a.value : void 0);
				if (shouldAutoRemoveFilter(i, o, e)) return t?.filter((t) => t.id !== e.id) ?? [];
				let s = {
					id: e.id,
					value: o
				};
				return a ? t?.map((t) => t.id === e.id ? s : t) ?? [] : t != null && t.length ? [...t, s] : [s];
			});
		};
	},
	createRow: (e, t) => {
		e.columnFilters = {}, e.columnFiltersMeta = {};
	},
	createTable: (e) => {
		e.setColumnFilters = (t) => {
			let n = e.getAllLeafColumns();
			e.options.onColumnFiltersChange == null || e.options.onColumnFiltersChange((e) => functionalUpdate(t, e)?.filter((e) => {
				let t = n.find((t) => t.id === e.id);
				if (t) {
					let n = t.getFilterFn();
					if (shouldAutoRemoveFilter(n, e.value, t)) return !1;
				}
				return !0;
			}));
		}, e.resetColumnFilters = (t) => {
			e.setColumnFilters(t ? [] : e.initialState?.columnFilters ?? []);
		}, e.getPreFilteredRowModel = () => e.getCoreRowModel(), e.getFilteredRowModel = () => (!e._getFilteredRowModel && e.options.getFilteredRowModel && (e._getFilteredRowModel = e.options.getFilteredRowModel(e)), e.options.manualFiltering || !e._getFilteredRowModel ? e.getPreFilteredRowModel() : e._getFilteredRowModel());
	}
};
function shouldAutoRemoveFilter(e, t, n) {
	return (e && e.autoRemove ? e.autoRemove(t, n) : !1) || t === void 0 || typeof t == "string" && !t;
}
var aggregationFns = {
	sum: (e, t, n) => n.reduce((t, n) => {
		let i = n.getValue(e);
		return t + (typeof i == "number" ? i : 0);
	}, 0),
	min: (e, t, n) => {
		let i;
		return n.forEach((t) => {
			let n = t.getValue(e);
			n != null && (i > n || i === void 0 && n >= n) && (i = n);
		}), i;
	},
	max: (e, t, n) => {
		let i;
		return n.forEach((t) => {
			let n = t.getValue(e);
			n != null && (i < n || i === void 0 && n >= n) && (i = n);
		}), i;
	},
	extent: (e, t, n) => {
		let i, a;
		return n.forEach((t) => {
			let n = t.getValue(e);
			n != null && (i === void 0 ? n >= n && (i = a = n) : (i > n && (i = n), a < n && (a = n)));
		}), [i, a];
	},
	mean: (e, t) => {
		let n = 0, i = 0;
		if (t.forEach((t) => {
			let a = t.getValue(e);
			a != null && (a = +a) >= a && (++n, i += a);
		}), n) return i / n;
	},
	median: (e, t) => {
		if (!t.length) return;
		let n = t.map((t) => t.getValue(e));
		if (!isNumberArray(n)) return;
		if (n.length === 1) return n[0];
		let i = Math.floor(n.length / 2), a = n.sort((e, t) => e - t);
		return n.length % 2 == 0 ? (a[i - 1] + a[i]) / 2 : a[i];
	},
	unique: (e, t) => Array.from(new Set(t.map((t) => t.getValue(e))).values()),
	uniqueCount: (e, t) => new Set(t.map((t) => t.getValue(e))).size,
	count: (e, t) => t.length
}, ColumnGrouping = {
	getDefaultColumnDef: () => ({
		aggregatedCell: (e) => {
			var t;
			return ((t = e.getValue()) == null || t.toString == null ? void 0 : t.toString()) ?? null;
		},
		aggregationFn: "auto"
	}),
	getInitialState: (e) => ({
		grouping: [],
		...e
	}),
	getDefaultOptions: (e) => ({
		onGroupingChange: makeStateUpdater("grouping", e),
		groupedColumnMode: "reorder"
	}),
	createColumn: (e, t) => {
		e.toggleGrouping = () => {
			t.setGrouping((t) => t != null && t.includes(e.id) ? t.filter((t) => t !== e.id) : [...t ?? [], e.id]);
		}, e.getCanGroup = () => (e.columnDef.enableGrouping ?? !0) && (t.options.enableGrouping ?? !0) && (!!e.accessorFn || !!e.columnDef.getGroupingValue), e.getIsGrouped = () => t.getState().grouping?.includes(e.id), e.getGroupedIndex = () => t.getState().grouping?.indexOf(e.id), e.getToggleGroupingHandler = () => {
			let t = e.getCanGroup();
			return () => {
				t && e.toggleGrouping();
			};
		}, e.getAutoAggregationFn = () => {
			let n = t.getCoreRowModel().flatRows[0]?.getValue(e.id);
			if (typeof n == "number") return aggregationFns.sum;
			if (Object.prototype.toString.call(n) === "[object Date]") return aggregationFns.extent;
		}, e.getAggregationFn = () => {
			if (!e) throw Error();
			return isFunction(e.columnDef.aggregationFn) ? e.columnDef.aggregationFn : e.columnDef.aggregationFn === "auto" ? e.getAutoAggregationFn() : t.options.aggregationFns?.[e.columnDef.aggregationFn] ?? aggregationFns[e.columnDef.aggregationFn];
		};
	},
	createTable: (e) => {
		e.setGrouping = (t) => e.options.onGroupingChange == null ? void 0 : e.options.onGroupingChange(t), e.resetGrouping = (t) => {
			e.setGrouping(t ? [] : e.initialState?.grouping ?? []);
		}, e.getPreGroupedRowModel = () => e.getFilteredRowModel(), e.getGroupedRowModel = () => (!e._getGroupedRowModel && e.options.getGroupedRowModel && (e._getGroupedRowModel = e.options.getGroupedRowModel(e)), e.options.manualGrouping || !e._getGroupedRowModel ? e.getPreGroupedRowModel() : e._getGroupedRowModel());
	},
	createRow: (e, t) => {
		e.getIsGrouped = () => !!e.groupingColumnId, e.getGroupingValue = (n) => {
			if (e._groupingValuesCache.hasOwnProperty(n)) return e._groupingValuesCache[n];
			let i = t.getColumn(n);
			return i != null && i.columnDef.getGroupingValue ? (e._groupingValuesCache[n] = i.columnDef.getGroupingValue(e.original), e._groupingValuesCache[n]) : e.getValue(n);
		}, e._groupingValuesCache = {};
	},
	createCell: (e, t, n, i) => {
		e.getIsGrouped = () => t.getIsGrouped() && t.id === n.groupingColumnId, e.getIsPlaceholder = () => !e.getIsGrouped() && t.getIsGrouped(), e.getIsAggregated = () => {
			var t;
			return !e.getIsGrouped() && !e.getIsPlaceholder() && !!((t = n.subRows) != null && t.length);
		};
	}
};
function orderColumns(e, t, n) {
	if (!(t != null && t.length) || !n) return e;
	let i = e.filter((e) => !t.includes(e.id));
	return n === "remove" ? i : [...t.map((t) => e.find((e) => e.id === t)).filter(Boolean), ...i];
}
var ColumnOrdering = {
	getInitialState: (e) => ({
		columnOrder: [],
		...e
	}),
	getDefaultOptions: (e) => ({ onColumnOrderChange: makeStateUpdater("columnOrder", e) }),
	createColumn: (e, t) => {
		e.getIndex = memo((e) => [_getVisibleLeafColumns(t, e)], (t) => t.findIndex((t) => t.id === e.id), getMemoOptions(t.options, "debugColumns", "getIndex")), e.getIsFirstColumn = (n) => _getVisibleLeafColumns(t, n)[0]?.id === e.id, e.getIsLastColumn = (n) => {
			let i = _getVisibleLeafColumns(t, n);
			return i[i.length - 1]?.id === e.id;
		};
	},
	createTable: (e) => {
		e.setColumnOrder = (t) => e.options.onColumnOrderChange == null ? void 0 : e.options.onColumnOrderChange(t), e.resetColumnOrder = (t) => {
			e.setColumnOrder(t ? [] : e.initialState.columnOrder ?? []);
		}, e._getOrderColumnsFn = memo(() => [
			e.getState().columnOrder,
			e.getState().grouping,
			e.options.groupedColumnMode
		], (e, t, n) => (i) => {
			let a = [];
			if (!(e != null && e.length)) a = i;
			else {
				let t = [...e], n = [...i];
				for (; n.length && t.length;) {
					let e = t.shift(), i = n.findIndex((t) => t.id === e);
					i > -1 && a.push(n.splice(i, 1)[0]);
				}
				a = [...a, ...n];
			}
			return orderColumns(a, t, n);
		}, getMemoOptions(e.options, "debugTable", "_getOrderColumnsFn"));
	}
}, getDefaultColumnPinningState = () => ({
	left: [],
	right: []
}), ColumnPinning = {
	getInitialState: (e) => ({
		columnPinning: getDefaultColumnPinningState(),
		...e
	}),
	getDefaultOptions: (e) => ({ onColumnPinningChange: makeStateUpdater("columnPinning", e) }),
	createColumn: (e, t) => {
		e.pin = (n) => {
			let i = e.getLeafColumns().map((e) => e.id).filter(Boolean);
			t.setColumnPinning((e) => n === "right" ? {
				left: (e?.left ?? []).filter((e) => !(i != null && i.includes(e))),
				right: [...(e?.right ?? []).filter((e) => !(i != null && i.includes(e))), ...i]
			} : n === "left" ? {
				left: [...(e?.left ?? []).filter((e) => !(i != null && i.includes(e))), ...i],
				right: (e?.right ?? []).filter((e) => !(i != null && i.includes(e)))
			} : {
				left: (e?.left ?? []).filter((e) => !(i != null && i.includes(e))),
				right: (e?.right ?? []).filter((e) => !(i != null && i.includes(e)))
			});
		}, e.getCanPin = () => e.getLeafColumns().some((e) => (e.columnDef.enablePinning ?? !0) && (t.options.enableColumnPinning ?? t.options.enablePinning ?? !0)), e.getIsPinned = () => {
			let n = e.getLeafColumns().map((e) => e.id), { left: i, right: a } = t.getState().columnPinning, o = n.some((e) => i?.includes(e)), s = n.some((e) => a?.includes(e));
			return o ? "left" : s ? "right" : !1;
		}, e.getPinnedIndex = () => {
			var n;
			let i = e.getIsPinned();
			return i ? ((n = t.getState().columnPinning) == null || (n = n[i]) == null ? void 0 : n.indexOf(e.id)) ?? -1 : 0;
		};
	},
	createRow: (e, t) => {
		e.getCenterVisibleCells = memo(() => [
			e._getAllVisibleCells(),
			t.getState().columnPinning.left,
			t.getState().columnPinning.right
		], (e, t, n) => {
			let i = [...t ?? [], ...n ?? []];
			return e.filter((e) => !i.includes(e.column.id));
		}, getMemoOptions(t.options, "debugRows", "getCenterVisibleCells")), e.getLeftVisibleCells = memo(() => [e._getAllVisibleCells(), t.getState().columnPinning.left], (e, t) => (t ?? []).map((t) => e.find((e) => e.column.id === t)).filter(Boolean).map((e) => ({
			...e,
			position: "left"
		})), getMemoOptions(t.options, "debugRows", "getLeftVisibleCells")), e.getRightVisibleCells = memo(() => [e._getAllVisibleCells(), t.getState().columnPinning.right], (e, t) => (t ?? []).map((t) => e.find((e) => e.column.id === t)).filter(Boolean).map((e) => ({
			...e,
			position: "right"
		})), getMemoOptions(t.options, "debugRows", "getRightVisibleCells"));
	},
	createTable: (e) => {
		e.setColumnPinning = (t) => e.options.onColumnPinningChange == null ? void 0 : e.options.onColumnPinningChange(t), e.resetColumnPinning = (t) => e.setColumnPinning(t ? getDefaultColumnPinningState() : e.initialState?.columnPinning ?? getDefaultColumnPinningState()), e.getIsSomeColumnsPinned = (t) => {
			let n = e.getState().columnPinning;
			return t ? !!n[t]?.length : !!(n.left?.length || n.right?.length);
		}, e.getLeftLeafColumns = memo(() => [e.getAllLeafColumns(), e.getState().columnPinning.left], (e, t) => (t ?? []).map((t) => e.find((e) => e.id === t)).filter(Boolean), getMemoOptions(e.options, "debugColumns", "getLeftLeafColumns")), e.getRightLeafColumns = memo(() => [e.getAllLeafColumns(), e.getState().columnPinning.right], (e, t) => (t ?? []).map((t) => e.find((e) => e.id === t)).filter(Boolean), getMemoOptions(e.options, "debugColumns", "getRightLeafColumns")), e.getCenterLeafColumns = memo(() => [
			e.getAllLeafColumns(),
			e.getState().columnPinning.left,
			e.getState().columnPinning.right
		], (e, t, n) => {
			let i = [...t ?? [], ...n ?? []];
			return e.filter((e) => !i.includes(e.id));
		}, getMemoOptions(e.options, "debugColumns", "getCenterLeafColumns"));
	}
};
function safelyAccessDocument(e) {
	return e || (typeof document < "u" ? document : null);
}
var defaultColumnSizing = {
	size: 150,
	minSize: 20,
	maxSize: 2 ** 53 - 1
}, getDefaultColumnSizingInfoState = () => ({
	startOffset: null,
	startSize: null,
	deltaOffset: null,
	deltaPercentage: null,
	isResizingColumn: !1,
	columnSizingStart: []
}), ColumnSizing = {
	getDefaultColumnDef: () => defaultColumnSizing,
	getInitialState: (e) => ({
		columnSizing: {},
		columnSizingInfo: getDefaultColumnSizingInfoState(),
		...e
	}),
	getDefaultOptions: (e) => ({
		columnResizeMode: "onEnd",
		columnResizeDirection: "ltr",
		onColumnSizingChange: makeStateUpdater("columnSizing", e),
		onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", e)
	}),
	createColumn: (e, t) => {
		e.getSize = () => {
			let n = t.getState().columnSizing[e.id];
			return Math.min(Math.max(e.columnDef.minSize ?? defaultColumnSizing.minSize, n ?? e.columnDef.size ?? defaultColumnSizing.size), e.columnDef.maxSize ?? defaultColumnSizing.maxSize);
		}, e.getStart = memo((e) => [
			e,
			_getVisibleLeafColumns(t, e),
			t.getState().columnSizing
		], (t, n) => n.slice(0, e.getIndex(t)).reduce((e, t) => e + t.getSize(), 0), getMemoOptions(t.options, "debugColumns", "getStart")), e.getAfter = memo((e) => [
			e,
			_getVisibleLeafColumns(t, e),
			t.getState().columnSizing
		], (t, n) => n.slice(e.getIndex(t) + 1).reduce((e, t) => e + t.getSize(), 0), getMemoOptions(t.options, "debugColumns", "getAfter")), e.resetSize = () => {
			t.setColumnSizing((t) => {
				let { [e.id]: n,...i } = t;
				return i;
			});
		}, e.getCanResize = () => (e.columnDef.enableResizing ?? !0) && (t.options.enableColumnResizing ?? !0), e.getIsResizing = () => t.getState().columnSizingInfo.isResizingColumn === e.id;
	},
	createHeader: (e, t) => {
		e.getSize = () => {
			let t = 0, n = (e) => {
				e.subHeaders.length ? e.subHeaders.forEach(n) : t += e.column.getSize() ?? 0;
			};
			return n(e), t;
		}, e.getStart = () => {
			if (e.index > 0) {
				let t = e.headerGroup.headers[e.index - 1];
				return t.getStart() + t.getSize();
			}
			return 0;
		}, e.getResizeHandler = (n) => {
			let i = t.getColumn(e.column.id), a = i?.getCanResize();
			return (o) => {
				if (!i || !a || (o.persist == null || o.persist(), isTouchStartEvent(o) && o.touches && o.touches.length > 1)) return;
				let s = e.getSize(), c = e ? e.getLeafHeaders().map((e) => [e.column.id, e.column.getSize()]) : [[i.id, i.getSize()]], l = isTouchStartEvent(o) ? Math.round(o.touches[0].clientX) : o.clientX, u = {}, d = (e, n) => {
					typeof n == "number" && (t.setColumnSizingInfo((e) => {
						let i = t.options.columnResizeDirection === "rtl" ? -1 : 1, a = (n - (e?.startOffset ?? 0)) * i, o = Math.max(a / (e?.startSize ?? 0), -.999999);
						return e.columnSizingStart.forEach((e) => {
							let [t, n] = e;
							u[t] = Math.round(Math.max(n + n * o, 0) * 100) / 100;
						}), {
							...e,
							deltaOffset: a,
							deltaPercentage: o
						};
					}), (t.options.columnResizeMode === "onChange" || e === "end") && t.setColumnSizing((e) => ({
						...e,
						...u
					})));
				}, f = (e) => d("move", e), p = (e) => {
					d("end", e), t.setColumnSizingInfo((e) => ({
						...e,
						isResizingColumn: !1,
						startOffset: null,
						startSize: null,
						deltaOffset: null,
						deltaPercentage: null,
						columnSizingStart: []
					}));
				}, m = safelyAccessDocument(n), h = {
					moveHandler: (e) => f(e.clientX),
					upHandler: (e) => {
						m?.removeEventListener("mousemove", h.moveHandler), m?.removeEventListener("mouseup", h.upHandler), p(e.clientX);
					}
				}, g = {
					moveHandler: (e) => (e.cancelable && (e.preventDefault(), e.stopPropagation()), f(e.touches[0].clientX), !1),
					upHandler: (e) => {
						m?.removeEventListener("touchmove", g.moveHandler), m?.removeEventListener("touchend", g.upHandler), e.cancelable && (e.preventDefault(), e.stopPropagation()), p(e.touches[0]?.clientX);
					}
				}, _ = passiveEventSupported() ? { passive: !1 } : !1;
				isTouchStartEvent(o) ? (m?.addEventListener("touchmove", g.moveHandler, _), m?.addEventListener("touchend", g.upHandler, _)) : (m?.addEventListener("mousemove", h.moveHandler, _), m?.addEventListener("mouseup", h.upHandler, _)), t.setColumnSizingInfo((e) => ({
					...e,
					startOffset: l,
					startSize: s,
					deltaOffset: 0,
					deltaPercentage: 0,
					columnSizingStart: c,
					isResizingColumn: i.id
				}));
			};
		};
	},
	createTable: (e) => {
		e.setColumnSizing = (t) => e.options.onColumnSizingChange == null ? void 0 : e.options.onColumnSizingChange(t), e.setColumnSizingInfo = (t) => e.options.onColumnSizingInfoChange == null ? void 0 : e.options.onColumnSizingInfoChange(t), e.resetColumnSizing = (t) => {
			e.setColumnSizing(t ? {} : e.initialState.columnSizing ?? {});
		}, e.resetHeaderSizeInfo = (t) => {
			e.setColumnSizingInfo(t ? getDefaultColumnSizingInfoState() : e.initialState.columnSizingInfo ?? getDefaultColumnSizingInfoState());
		}, e.getTotalSize = () => e.getHeaderGroups()[0]?.headers.reduce((e, t) => e + t.getSize(), 0) ?? 0, e.getLeftTotalSize = () => e.getLeftHeaderGroups()[0]?.headers.reduce((e, t) => e + t.getSize(), 0) ?? 0, e.getCenterTotalSize = () => e.getCenterHeaderGroups()[0]?.headers.reduce((e, t) => e + t.getSize(), 0) ?? 0, e.getRightTotalSize = () => e.getRightHeaderGroups()[0]?.headers.reduce((e, t) => e + t.getSize(), 0) ?? 0;
	}
}, passiveSupported = null;
function passiveEventSupported() {
	if (typeof passiveSupported == "boolean") return passiveSupported;
	let e = !1;
	try {
		let t = { get passive() {
			return e = !0, !1;
		} }, n = () => {};
		window.addEventListener("test", n, t), window.removeEventListener("test", n);
	} catch {
		e = !1;
	}
	return passiveSupported = e, passiveSupported;
}
function isTouchStartEvent(e) {
	return e.type === "touchstart";
}
var ColumnVisibility = {
	getInitialState: (e) => ({
		columnVisibility: {},
		...e
	}),
	getDefaultOptions: (e) => ({ onColumnVisibilityChange: makeStateUpdater("columnVisibility", e) }),
	createColumn: (e, t) => {
		e.toggleVisibility = (n) => {
			e.getCanHide() && t.setColumnVisibility((t) => ({
				...t,
				[e.id]: n ?? !e.getIsVisible()
			}));
		}, e.getIsVisible = () => {
			let n = e.columns;
			return (n.length ? n.some((e) => e.getIsVisible()) : t.getState().columnVisibility?.[e.id]) ?? !0;
		}, e.getCanHide = () => (e.columnDef.enableHiding ?? !0) && (t.options.enableHiding ?? !0), e.getToggleVisibilityHandler = () => (t) => {
			e.toggleVisibility == null || e.toggleVisibility(t.target.checked);
		};
	},
	createRow: (e, t) => {
		e._getAllVisibleCells = memo(() => [e.getAllCells(), t.getState().columnVisibility], (e) => e.filter((e) => e.column.getIsVisible()), getMemoOptions(t.options, "debugRows", "_getAllVisibleCells")), e.getVisibleCells = memo(() => [
			e.getLeftVisibleCells(),
			e.getCenterVisibleCells(),
			e.getRightVisibleCells()
		], (e, t, n) => [
			...e,
			...t,
			...n
		], getMemoOptions(t.options, "debugRows", "getVisibleCells"));
	},
	createTable: (e) => {
		let t = (t, n) => memo(() => [n(), n().filter((e) => e.getIsVisible()).map((e) => e.id).join("_")], (e) => e.filter((e) => e.getIsVisible == null ? void 0 : e.getIsVisible()), getMemoOptions(e.options, "debugColumns", t));
		e.getVisibleFlatColumns = t("getVisibleFlatColumns", () => e.getAllFlatColumns()), e.getVisibleLeafColumns = t("getVisibleLeafColumns", () => e.getAllLeafColumns()), e.getLeftVisibleLeafColumns = t("getLeftVisibleLeafColumns", () => e.getLeftLeafColumns()), e.getRightVisibleLeafColumns = t("getRightVisibleLeafColumns", () => e.getRightLeafColumns()), e.getCenterVisibleLeafColumns = t("getCenterVisibleLeafColumns", () => e.getCenterLeafColumns()), e.setColumnVisibility = (t) => e.options.onColumnVisibilityChange == null ? void 0 : e.options.onColumnVisibilityChange(t), e.resetColumnVisibility = (t) => {
			e.setColumnVisibility(t ? {} : e.initialState.columnVisibility ?? {});
		}, e.toggleAllColumnsVisible = (t) => {
			t ??= !e.getIsAllColumnsVisible(), e.setColumnVisibility(e.getAllLeafColumns().reduce((e, n) => ({
				...e,
				[n.id]: t || !(n.getCanHide != null && n.getCanHide())
			}), {}));
		}, e.getIsAllColumnsVisible = () => !e.getAllLeafColumns().some((e) => !(e.getIsVisible != null && e.getIsVisible())), e.getIsSomeColumnsVisible = () => e.getAllLeafColumns().some((e) => e.getIsVisible == null ? void 0 : e.getIsVisible()), e.getToggleAllColumnsVisibilityHandler = () => (t) => {
			e.toggleAllColumnsVisible(t.target?.checked);
		};
	}
};
function _getVisibleLeafColumns(e, t) {
	return t ? t === "center" ? e.getCenterVisibleLeafColumns() : t === "left" ? e.getLeftVisibleLeafColumns() : e.getRightVisibleLeafColumns() : e.getVisibleLeafColumns();
}
var GlobalFaceting = { createTable: (e) => {
	e._getGlobalFacetedRowModel = e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, "__global__"), e.getGlobalFacetedRowModel = () => e.options.manualFiltering || !e._getGlobalFacetedRowModel ? e.getPreFilteredRowModel() : e._getGlobalFacetedRowModel(), e._getGlobalFacetedUniqueValues = e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, "__global__"), e.getGlobalFacetedUniqueValues = () => e._getGlobalFacetedUniqueValues ? e._getGlobalFacetedUniqueValues() : /* @__PURE__ */ new Map(), e._getGlobalFacetedMinMaxValues = e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, "__global__"), e.getGlobalFacetedMinMaxValues = () => {
		if (e._getGlobalFacetedMinMaxValues) return e._getGlobalFacetedMinMaxValues();
	};
} }, GlobalFiltering = {
	getInitialState: (e) => ({
		globalFilter: void 0,
		...e
	}),
	getDefaultOptions: (e) => ({
		onGlobalFilterChange: makeStateUpdater("globalFilter", e),
		globalFilterFn: "auto",
		getColumnCanGlobalFilter: (t) => {
			var n;
			let i = (n = e.getCoreRowModel().flatRows[0]) == null || (n = n._getAllCellsByColumnId()[t.id]) == null ? void 0 : n.getValue();
			return typeof i == "string" || typeof i == "number";
		}
	}),
	createColumn: (e, t) => {
		e.getCanGlobalFilter = () => (e.columnDef.enableGlobalFilter ?? !0) && (t.options.enableGlobalFilter ?? !0) && (t.options.enableFilters ?? !0) && ((t.options.getColumnCanGlobalFilter == null ? void 0 : t.options.getColumnCanGlobalFilter(e)) ?? !0) && !!e.accessorFn;
	},
	createTable: (e) => {
		e.getGlobalAutoFilterFn = () => filterFns.includesString, e.getGlobalFilterFn = () => {
			let { globalFilterFn: t } = e.options;
			return isFunction(t) ? t : t === "auto" ? e.getGlobalAutoFilterFn() : e.options.filterFns?.[t] ?? filterFns[t];
		}, e.setGlobalFilter = (t) => {
			e.options.onGlobalFilterChange == null || e.options.onGlobalFilterChange(t);
		}, e.resetGlobalFilter = (t) => {
			e.setGlobalFilter(t ? void 0 : e.initialState.globalFilter);
		};
	}
}, RowExpanding = {
	getInitialState: (e) => ({
		expanded: {},
		...e
	}),
	getDefaultOptions: (e) => ({
		onExpandedChange: makeStateUpdater("expanded", e),
		paginateExpandedRows: !0
	}),
	createTable: (e) => {
		let t = !1, n = !1;
		e._autoResetExpanded = () => {
			if (!t) {
				e._queue(() => {
					t = !0;
				});
				return;
			}
			if (e.options.autoResetAll ?? e.options.autoResetExpanded ?? !e.options.manualExpanding) {
				if (n) return;
				n = !0, e._queue(() => {
					e.resetExpanded(), n = !1;
				});
			}
		}, e.setExpanded = (t) => e.options.onExpandedChange == null ? void 0 : e.options.onExpandedChange(t), e.toggleAllRowsExpanded = (t) => {
			t ?? !e.getIsAllRowsExpanded() ? e.setExpanded(!0) : e.setExpanded({});
		}, e.resetExpanded = (t) => {
			e.setExpanded(t ? {} : e.initialState?.expanded ?? {});
		}, e.getCanSomeRowsExpand = () => e.getPrePaginationRowModel().flatRows.some((e) => e.getCanExpand()), e.getToggleAllRowsExpandedHandler = () => (t) => {
			t.persist == null || t.persist(), e.toggleAllRowsExpanded();
		}, e.getIsSomeRowsExpanded = () => {
			let t = e.getState().expanded;
			return t === !0 || Object.values(t).some(Boolean);
		}, e.getIsAllRowsExpanded = () => {
			let t = e.getState().expanded;
			return typeof t == "boolean" ? t === !0 : !(!Object.keys(t).length || e.getRowModel().flatRows.some((e) => !e.getIsExpanded()));
		}, e.getExpandedDepth = () => {
			let t = 0;
			return (e.getState().expanded === !0 ? Object.keys(e.getRowModel().rowsById) : Object.keys(e.getState().expanded)).forEach((e) => {
				let n = e.split(".");
				t = Math.max(t, n.length);
			}), t;
		}, e.getPreExpandedRowModel = () => e.getSortedRowModel(), e.getExpandedRowModel = () => (!e._getExpandedRowModel && e.options.getExpandedRowModel && (e._getExpandedRowModel = e.options.getExpandedRowModel(e)), e.options.manualExpanding || !e._getExpandedRowModel ? e.getPreExpandedRowModel() : e._getExpandedRowModel());
	},
	createRow: (e, t) => {
		e.toggleExpanded = (n) => {
			t.setExpanded((i) => {
				let a = i === !0 ? !0 : !!(i != null && i[e.id]), o = {};
				if (i === !0 ? Object.keys(t.getRowModel().rowsById).forEach((e) => {
					o[e] = !0;
				}) : o = i, n ??= !a, !a && n) return {
					...o,
					[e.id]: !0
				};
				if (a && !n) {
					let { [e.id]: t,...n } = o;
					return n;
				}
				return i;
			});
		}, e.getIsExpanded = () => {
			let n = t.getState().expanded;
			return !!((t.options.getIsRowExpanded == null ? void 0 : t.options.getIsRowExpanded(e)) ?? (n === !0 || n?.[e.id]));
		}, e.getCanExpand = () => {
			var n;
			return (t.options.getRowCanExpand == null ? void 0 : t.options.getRowCanExpand(e)) ?? ((t.options.enableExpanding ?? !0) && !!((n = e.subRows) != null && n.length));
		}, e.getIsAllParentsExpanded = () => {
			let n = !0, i = e;
			for (; n && i.parentId;) i = t.getRow(i.parentId, !0), n = i.getIsExpanded();
			return n;
		}, e.getToggleExpandedHandler = () => {
			let t = e.getCanExpand();
			return () => {
				t && e.toggleExpanded();
			};
		};
	}
}, defaultPageIndex = 0, defaultPageSize = 10, getDefaultPaginationState = () => ({
	pageIndex: defaultPageIndex,
	pageSize: defaultPageSize
}), RowPagination = {
	getInitialState: (e) => ({
		...e,
		pagination: {
			...getDefaultPaginationState(),
			...e?.pagination
		}
	}),
	getDefaultOptions: (e) => ({ onPaginationChange: makeStateUpdater("pagination", e) }),
	createTable: (e) => {
		let t = !1, n = !1;
		e._autoResetPageIndex = () => {
			if (!t) {
				e._queue(() => {
					t = !0;
				});
				return;
			}
			if (e.options.autoResetAll ?? e.options.autoResetPageIndex ?? !e.options.manualPagination) {
				if (n) return;
				n = !0, e._queue(() => {
					e.resetPageIndex(), n = !1;
				});
			}
		}, e.setPagination = (t) => e.options.onPaginationChange == null ? void 0 : e.options.onPaginationChange((e) => functionalUpdate(t, e)), e.resetPagination = (t) => {
			e.setPagination(t ? getDefaultPaginationState() : e.initialState.pagination ?? getDefaultPaginationState());
		}, e.setPageIndex = (t) => {
			e.setPagination((n) => {
				let i = functionalUpdate(t, n.pageIndex), a = e.options.pageCount === void 0 || e.options.pageCount === -1 ? 2 ** 53 - 1 : e.options.pageCount - 1;
				return i = Math.max(0, Math.min(i, a)), {
					...n,
					pageIndex: i
				};
			});
		}, e.resetPageIndex = (t) => {
			var n;
			e.setPageIndex(t ? defaultPageIndex : ((n = e.initialState) == null || (n = n.pagination) == null ? void 0 : n.pageIndex) ?? defaultPageIndex);
		}, e.resetPageSize = (t) => {
			var n;
			e.setPageSize(t ? defaultPageSize : ((n = e.initialState) == null || (n = n.pagination) == null ? void 0 : n.pageSize) ?? defaultPageSize);
		}, e.setPageSize = (t) => {
			e.setPagination((e) => {
				let n = Math.max(1, functionalUpdate(t, e.pageSize)), i = e.pageSize * e.pageIndex, a = Math.floor(i / n);
				return {
					...e,
					pageIndex: a,
					pageSize: n
				};
			});
		}, e.setPageCount = (t) => e.setPagination((n) => {
			let i = functionalUpdate(t, e.options.pageCount ?? -1);
			return typeof i == "number" && (i = Math.max(-1, i)), {
				...n,
				pageCount: i
			};
		}), e.getPageOptions = memo(() => [e.getPageCount()], (e) => {
			let t = [];
			return e && e > 0 && (t = [...Array(e)].fill(null).map((e, t) => t)), t;
		}, getMemoOptions(e.options, "debugTable", "getPageOptions")), e.getCanPreviousPage = () => e.getState().pagination.pageIndex > 0, e.getCanNextPage = () => {
			let { pageIndex: t } = e.getState().pagination, n = e.getPageCount();
			return n === -1 ? !0 : n === 0 ? !1 : t < n - 1;
		}, e.previousPage = () => e.setPageIndex((e) => e - 1), e.nextPage = () => e.setPageIndex((e) => e + 1), e.firstPage = () => e.setPageIndex(0), e.lastPage = () => e.setPageIndex(e.getPageCount() - 1), e.getPrePaginationRowModel = () => e.getExpandedRowModel(), e.getPaginationRowModel = () => (!e._getPaginationRowModel && e.options.getPaginationRowModel && (e._getPaginationRowModel = e.options.getPaginationRowModel(e)), e.options.manualPagination || !e._getPaginationRowModel ? e.getPrePaginationRowModel() : e._getPaginationRowModel()), e.getPageCount = () => e.options.pageCount ?? Math.ceil(e.getRowCount() / e.getState().pagination.pageSize), e.getRowCount = () => e.options.rowCount ?? e.getPrePaginationRowModel().rows.length;
	}
}, getDefaultRowPinningState = () => ({
	top: [],
	bottom: []
}), RowPinning = {
	getInitialState: (e) => ({
		rowPinning: getDefaultRowPinningState(),
		...e
	}),
	getDefaultOptions: (e) => ({ onRowPinningChange: makeStateUpdater("rowPinning", e) }),
	createRow: (e, t) => {
		e.pin = (n, i, a) => {
			let o = i ? e.getLeafRows().map((e) => {
				let { id: t } = e;
				return t;
			}) : [], s = a ? e.getParentRows().map((e) => {
				let { id: t } = e;
				return t;
			}) : [], c = new Set([
				...s,
				e.id,
				...o
			]);
			t.setRowPinning((e) => n === "bottom" ? {
				top: (e?.top ?? []).filter((e) => !(c != null && c.has(e))),
				bottom: [...(e?.bottom ?? []).filter((e) => !(c != null && c.has(e))), ...Array.from(c)]
			} : n === "top" ? {
				top: [...(e?.top ?? []).filter((e) => !(c != null && c.has(e))), ...Array.from(c)],
				bottom: (e?.bottom ?? []).filter((e) => !(c != null && c.has(e)))
			} : {
				top: (e?.top ?? []).filter((e) => !(c != null && c.has(e))),
				bottom: (e?.bottom ?? []).filter((e) => !(c != null && c.has(e)))
			});
		}, e.getCanPin = () => {
			let { enableRowPinning: n, enablePinning: i } = t.options;
			return typeof n == "function" ? n(e) : n ?? i ?? !0;
		}, e.getIsPinned = () => {
			let n = [e.id], { top: i, bottom: a } = t.getState().rowPinning, o = n.some((e) => i?.includes(e)), s = n.some((e) => a?.includes(e));
			return o ? "top" : s ? "bottom" : !1;
		}, e.getPinnedIndex = () => {
			let n = e.getIsPinned();
			return n ? ((n === "top" ? t.getTopRows() : t.getBottomRows())?.map((e) => {
				let { id: t } = e;
				return t;
			}))?.indexOf(e.id) ?? -1 : -1;
		};
	},
	createTable: (e) => {
		e.setRowPinning = (t) => e.options.onRowPinningChange == null ? void 0 : e.options.onRowPinningChange(t), e.resetRowPinning = (t) => e.setRowPinning(t ? getDefaultRowPinningState() : e.initialState?.rowPinning ?? getDefaultRowPinningState()), e.getIsSomeRowsPinned = (t) => {
			let n = e.getState().rowPinning;
			return t ? !!n[t]?.length : !!(n.top?.length || n.bottom?.length);
		}, e._getPinnedRows = (t, n, i) => (e.options.keepPinnedRows ?? !0 ? (n ?? []).map((t) => {
			let n = e.getRow(t, !0);
			return n.getIsAllParentsExpanded() ? n : null;
		}) : (n ?? []).map((e) => t.find((t) => t.id === e))).filter(Boolean).map((e) => ({
			...e,
			position: i
		})), e.getTopRows = memo(() => [e.getRowModel().rows, e.getState().rowPinning.top], (t, n) => e._getPinnedRows(t, n, "top"), getMemoOptions(e.options, "debugRows", "getTopRows")), e.getBottomRows = memo(() => [e.getRowModel().rows, e.getState().rowPinning.bottom], (t, n) => e._getPinnedRows(t, n, "bottom"), getMemoOptions(e.options, "debugRows", "getBottomRows")), e.getCenterRows = memo(() => [
			e.getRowModel().rows,
			e.getState().rowPinning.top,
			e.getState().rowPinning.bottom
		], (e, t, n) => {
			let i = new Set([...t ?? [], ...n ?? []]);
			return e.filter((e) => !i.has(e.id));
		}, getMemoOptions(e.options, "debugRows", "getCenterRows"));
	}
}, RowSelection = {
	getInitialState: (e) => ({
		rowSelection: {},
		...e
	}),
	getDefaultOptions: (e) => ({
		onRowSelectionChange: makeStateUpdater("rowSelection", e),
		enableRowSelection: !0,
		enableMultiRowSelection: !0,
		enableSubRowSelection: !0
	}),
	createTable: (e) => {
		e.setRowSelection = (t) => e.options.onRowSelectionChange == null ? void 0 : e.options.onRowSelectionChange(t), e.resetRowSelection = (t) => e.setRowSelection(t ? {} : e.initialState.rowSelection ?? {}), e.toggleAllRowsSelected = (t) => {
			e.setRowSelection((n) => {
				t = t === void 0 ? !e.getIsAllRowsSelected() : t;
				let i = { ...n }, a = e.getPreGroupedRowModel().flatRows;
				return t ? a.forEach((e) => {
					e.getCanSelect() && (i[e.id] = !0);
				}) : a.forEach((e) => {
					delete i[e.id];
				}), i;
			});
		}, e.toggleAllPageRowsSelected = (t) => e.setRowSelection((n) => {
			let i = t === void 0 ? !e.getIsAllPageRowsSelected() : t, a = { ...n };
			return e.getRowModel().rows.forEach((t) => {
				mutateRowIsSelected(a, t.id, i, !0, e);
			}), a;
		}), e.getPreSelectedRowModel = () => e.getCoreRowModel(), e.getSelectedRowModel = memo(() => [e.getState().rowSelection, e.getCoreRowModel()], (t, n) => Object.keys(t).length ? selectRowsFn(e, n) : {
			rows: [],
			flatRows: [],
			rowsById: {}
		}, getMemoOptions(e.options, "debugTable", "getSelectedRowModel")), e.getFilteredSelectedRowModel = memo(() => [e.getState().rowSelection, e.getFilteredRowModel()], (t, n) => Object.keys(t).length ? selectRowsFn(e, n) : {
			rows: [],
			flatRows: [],
			rowsById: {}
		}, getMemoOptions(e.options, "debugTable", "getFilteredSelectedRowModel")), e.getGroupedSelectedRowModel = memo(() => [e.getState().rowSelection, e.getSortedRowModel()], (t, n) => Object.keys(t).length ? selectRowsFn(e, n) : {
			rows: [],
			flatRows: [],
			rowsById: {}
		}, getMemoOptions(e.options, "debugTable", "getGroupedSelectedRowModel")), e.getIsAllRowsSelected = () => {
			let t = e.getFilteredRowModel().flatRows, { rowSelection: n } = e.getState(), i = !!(t.length && Object.keys(n).length);
			return i && t.some((e) => e.getCanSelect() && !n[e.id]) && (i = !1), i;
		}, e.getIsAllPageRowsSelected = () => {
			let t = e.getPaginationRowModel().flatRows.filter((e) => e.getCanSelect()), { rowSelection: n } = e.getState(), i = !!t.length;
			return i && t.some((e) => !n[e.id]) && (i = !1), i;
		}, e.getIsSomeRowsSelected = () => {
			let t = Object.keys(e.getState().rowSelection ?? {}).length;
			return t > 0 && t < e.getFilteredRowModel().flatRows.length;
		}, e.getIsSomePageRowsSelected = () => {
			let t = e.getPaginationRowModel().flatRows;
			return e.getIsAllPageRowsSelected() ? !1 : t.filter((e) => e.getCanSelect()).some((e) => e.getIsSelected() || e.getIsSomeSelected());
		}, e.getToggleAllRowsSelectedHandler = () => (t) => {
			e.toggleAllRowsSelected(t.target.checked);
		}, e.getToggleAllPageRowsSelectedHandler = () => (t) => {
			e.toggleAllPageRowsSelected(t.target.checked);
		};
	},
	createRow: (e, t) => {
		e.toggleSelected = (n, i) => {
			let a = e.getIsSelected();
			t.setRowSelection((o) => {
				if (n = n === void 0 ? !a : n, e.getCanSelect() && a === n) return o;
				let s = { ...o };
				return mutateRowIsSelected(s, e.id, n, i?.selectChildren ?? !0, t), s;
			});
		}, e.getIsSelected = () => {
			let { rowSelection: n } = t.getState();
			return isRowSelected(e, n);
		}, e.getIsSomeSelected = () => {
			let { rowSelection: n } = t.getState();
			return isSubRowSelected(e, n) === "some";
		}, e.getIsAllSubRowsSelected = () => {
			let { rowSelection: n } = t.getState();
			return isSubRowSelected(e, n) === "all";
		}, e.getCanSelect = () => typeof t.options.enableRowSelection == "function" ? t.options.enableRowSelection(e) : t.options.enableRowSelection ?? !0, e.getCanSelectSubRows = () => typeof t.options.enableSubRowSelection == "function" ? t.options.enableSubRowSelection(e) : t.options.enableSubRowSelection ?? !0, e.getCanMultiSelect = () => typeof t.options.enableMultiRowSelection == "function" ? t.options.enableMultiRowSelection(e) : t.options.enableMultiRowSelection ?? !0, e.getToggleSelectedHandler = () => {
			let t = e.getCanSelect();
			return (n) => {
				t && e.toggleSelected(n.target?.checked);
			};
		};
	}
}, mutateRowIsSelected = (e, t, n, i, a) => {
	var o;
	let s = a.getRow(t, !0);
	n ? (s.getCanMultiSelect() || Object.keys(e).forEach((t) => delete e[t]), s.getCanSelect() && (e[t] = !0)) : delete e[t], i && (o = s.subRows) != null && o.length && s.getCanSelectSubRows() && s.subRows.forEach((t) => mutateRowIsSelected(e, t.id, n, i, a));
};
function selectRowsFn(e, t) {
	let n = e.getState().rowSelection, i = [], a = {}, o = function(e, t) {
		return e.map((e) => {
			var t;
			let s = isRowSelected(e, n);
			if (s && (i.push(e), a[e.id] = e), (t = e.subRows) != null && t.length && (e = {
				...e,
				subRows: o(e.subRows)
			}), s) return e;
		}).filter(Boolean);
	};
	return {
		rows: o(t.rows),
		flatRows: i,
		rowsById: a
	};
}
function isRowSelected(e, t) {
	return t[e.id] ?? !1;
}
function isSubRowSelected(e, t, n) {
	var i;
	if (!((i = e.subRows) != null && i.length)) return !1;
	let a = !0, o = !1;
	return e.subRows.forEach((e) => {
		if (!(o && !a) && (e.getCanSelect() && (isRowSelected(e, t) ? o = !0 : a = !1), e.subRows && e.subRows.length)) {
			let n = isSubRowSelected(e, t);
			n === "all" ? o = !0 : (n === "some" && (o = !0), a = !1);
		}
	}), a ? "all" : o ? "some" : !1;
}
var reSplitAlphaNumeric = /([0-9]+)/gm, alphanumeric = (e, t, n) => compareAlphanumeric(toString(e.getValue(n)).toLowerCase(), toString(t.getValue(n)).toLowerCase()), alphanumericCaseSensitive = (e, t, n) => compareAlphanumeric(toString(e.getValue(n)), toString(t.getValue(n))), text = (e, t, n) => compareBasic(toString(e.getValue(n)).toLowerCase(), toString(t.getValue(n)).toLowerCase()), textCaseSensitive = (e, t, n) => compareBasic(toString(e.getValue(n)), toString(t.getValue(n))), datetime = (e, t, n) => {
	let i = e.getValue(n), a = t.getValue(n);
	return i > a ? 1 : i < a ? -1 : 0;
}, basic = (e, t, n) => compareBasic(e.getValue(n), t.getValue(n));
function compareBasic(e, t) {
	return e === t ? 0 : e > t ? 1 : -1;
}
function toString(e) {
	return typeof e == "number" ? isNaN(e) || e === Infinity || e === -Infinity ? "" : String(e) : typeof e == "string" ? e : "";
}
function compareAlphanumeric(e, t) {
	let n = e.split(reSplitAlphaNumeric).filter(Boolean), i = t.split(reSplitAlphaNumeric).filter(Boolean);
	for (; n.length && i.length;) {
		let e = n.shift(), t = i.shift(), a = parseInt(e, 10), o = parseInt(t, 10), s = [a, o].sort();
		if (isNaN(s[0])) {
			if (e > t) return 1;
			if (t > e) return -1;
			continue;
		}
		if (isNaN(s[1])) return isNaN(a) ? -1 : 1;
		if (a > o) return 1;
		if (o > a) return -1;
	}
	return n.length - i.length;
}
var sortingFns = {
	alphanumeric,
	alphanumericCaseSensitive,
	text,
	textCaseSensitive,
	datetime,
	basic
}, builtInFeatures = [
	Headers,
	ColumnVisibility,
	ColumnOrdering,
	ColumnPinning,
	ColumnFaceting,
	ColumnFiltering,
	GlobalFaceting,
	GlobalFiltering,
	{
		getInitialState: (e) => ({
			sorting: [],
			...e
		}),
		getDefaultColumnDef: () => ({
			sortingFn: "auto",
			sortUndefined: 1
		}),
		getDefaultOptions: (e) => ({
			onSortingChange: makeStateUpdater("sorting", e),
			isMultiSortEvent: (e) => e.shiftKey
		}),
		createColumn: (e, t) => {
			e.getAutoSortingFn = () => {
				let n = t.getFilteredRowModel().flatRows.slice(10), i = !1;
				for (let t of n) {
					let n = t?.getValue(e.id);
					if (Object.prototype.toString.call(n) === "[object Date]") return sortingFns.datetime;
					if (typeof n == "string" && (i = !0, n.split(reSplitAlphaNumeric).length > 1)) return sortingFns.alphanumeric;
				}
				return i ? sortingFns.text : sortingFns.basic;
			}, e.getAutoSortDir = () => typeof t.getFilteredRowModel().flatRows[0]?.getValue(e.id) == "string" ? "asc" : "desc", e.getSortingFn = () => {
				if (!e) throw Error();
				return isFunction(e.columnDef.sortingFn) ? e.columnDef.sortingFn : e.columnDef.sortingFn === "auto" ? e.getAutoSortingFn() : t.options.sortingFns?.[e.columnDef.sortingFn] ?? sortingFns[e.columnDef.sortingFn];
			}, e.toggleSorting = (n, i) => {
				let a = e.getNextSortingOrder(), o = n != null;
				t.setSorting((s) => {
					let c = s?.find((t) => t.id === e.id), l = s?.findIndex((t) => t.id === e.id), u = [], d, f = o ? n : a === "desc";
					return d = s != null && s.length && e.getCanMultiSort() && i ? c ? "toggle" : "add" : s != null && s.length && l !== s.length - 1 ? "replace" : c ? "toggle" : "replace", d === "toggle" && (o || a || (d = "remove")), d === "add" ? (u = [...s, {
						id: e.id,
						desc: f
					}], u.splice(0, u.length - (t.options.maxMultiSortColCount ?? 2 ** 53 - 1))) : u = d === "toggle" ? s.map((t) => t.id === e.id ? {
						...t,
						desc: f
					} : t) : d === "remove" ? s.filter((t) => t.id !== e.id) : [{
						id: e.id,
						desc: f
					}], u;
				});
			}, e.getFirstSortDir = () => e.columnDef.sortDescFirst ?? t.options.sortDescFirst ?? e.getAutoSortDir() === "desc" ? "desc" : "asc", e.getNextSortingOrder = (n) => {
				let i = e.getFirstSortDir(), a = e.getIsSorted();
				return a ? a !== i && (t.options.enableSortingRemoval ?? !0) && (!n || (t.options.enableMultiRemove ?? !0)) ? !1 : a === "desc" ? "asc" : "desc" : i;
			}, e.getCanSort = () => (e.columnDef.enableSorting ?? !0) && (t.options.enableSorting ?? !0) && !!e.accessorFn, e.getCanMultiSort = () => e.columnDef.enableMultiSort ?? t.options.enableMultiSort ?? !!e.accessorFn, e.getIsSorted = () => {
				let n = t.getState().sorting?.find((t) => t.id === e.id);
				return n ? n.desc ? "desc" : "asc" : !1;
			}, e.getSortIndex = () => t.getState().sorting?.findIndex((t) => t.id === e.id) ?? -1, e.clearSorting = () => {
				t.setSorting((t) => t != null && t.length ? t.filter((t) => t.id !== e.id) : []);
			}, e.getToggleSortingHandler = () => {
				let n = e.getCanSort();
				return (i) => {
					n && (i.persist == null || i.persist(), e.toggleSorting == null || e.toggleSorting(void 0, e.getCanMultiSort() ? t.options.isMultiSortEvent == null ? void 0 : t.options.isMultiSortEvent(i) : !1));
				};
			};
		},
		createTable: (e) => {
			e.setSorting = (t) => e.options.onSortingChange == null ? void 0 : e.options.onSortingChange(t), e.resetSorting = (t) => {
				e.setSorting(t ? [] : e.initialState?.sorting ?? []);
			}, e.getPreSortedRowModel = () => e.getGroupedRowModel(), e.getSortedRowModel = () => (!e._getSortedRowModel && e.options.getSortedRowModel && (e._getSortedRowModel = e.options.getSortedRowModel(e)), e.options.manualSorting || !e._getSortedRowModel ? e.getPreSortedRowModel() : e._getSortedRowModel());
		}
	},
	ColumnGrouping,
	RowExpanding,
	RowPagination,
	RowPinning,
	RowSelection,
	ColumnSizing
];
function createTable(e) {
	process.env.NODE_ENV !== "production" && (e.debugAll || e.debugTable) && console.info("Creating Table Instance...");
	let t = [...builtInFeatures, ...e._features ?? []], n = { _features: t }, i = n._features.reduce((e, t) => Object.assign(e, t.getDefaultOptions == null ? void 0 : t.getDefaultOptions(n)), {}), a = (e) => n.options.mergeOptions ? n.options.mergeOptions(i, e) : {
		...i,
		...e
	}, o = { ...e.initialState ?? {} };
	n._features.forEach((e) => {
		o = (e.getInitialState == null ? void 0 : e.getInitialState(o)) ?? o;
	});
	let s = [], c = !1, l = {
		_features: t,
		options: {
			...i,
			...e
		},
		initialState: o,
		_queue: (e) => {
			s.push(e), c || (c = !0, Promise.resolve().then(() => {
				for (; s.length;) s.shift()();
				c = !1;
			}).catch((e) => setTimeout(() => {
				throw e;
			})));
		},
		reset: () => {
			n.setState(n.initialState);
		},
		setOptions: (e) => {
			let t = functionalUpdate(e, n.options);
			n.options = a(t);
		},
		getState: () => n.options.state,
		setState: (e) => {
			n.options.onStateChange == null || n.options.onStateChange(e);
		},
		_getRowId: (e, t, i) => (n.options.getRowId == null ? void 0 : n.options.getRowId(e, t, i)) ?? `${i ? [i.id, t].join(".") : t}`,
		getCoreRowModel: () => (n._getCoreRowModel ||= n.options.getCoreRowModel(n), n._getCoreRowModel()),
		getRowModel: () => n.getPaginationRowModel(),
		getRow: (e, t) => {
			let i = (t ? n.getPrePaginationRowModel() : n.getRowModel()).rowsById[e];
			if (!i && (i = n.getCoreRowModel().rowsById[e], !i)) throw process.env.NODE_ENV === "production" ? Error() : Error(`getRow could not find row with ID: ${e}`);
			return i;
		},
		_getDefaultColumnDef: memo(() => [n.options.defaultColumn], (e) => (e ??= {}, {
			header: (e) => {
				let t = e.header.column.columnDef;
				return t.accessorKey ? t.accessorKey : t.accessorFn ? t.id : null;
			},
			cell: (e) => {
				var t;
				return ((t = e.renderValue()) == null || t.toString == null ? void 0 : t.toString()) ?? null;
			},
			...n._features.reduce((e, t) => Object.assign(e, t.getDefaultColumnDef == null ? void 0 : t.getDefaultColumnDef()), {}),
			...e
		}), getMemoOptions(e, "debugColumns", "_getDefaultColumnDef")),
		_getColumnDefs: () => n.options.columns,
		getAllColumns: memo(() => [n._getColumnDefs()], (e) => {
			let t = function(e, i, a) {
				return a === void 0 && (a = 0), e.map((e) => {
					let o = createColumn(n, e, a, i), s = e;
					return o.columns = s.columns ? t(s.columns, o, a + 1) : [], o;
				});
			};
			return t(e);
		}, getMemoOptions(e, "debugColumns", "getAllColumns")),
		getAllFlatColumns: memo(() => [n.getAllColumns()], (e) => e.flatMap((e) => e.getFlatColumns()), getMemoOptions(e, "debugColumns", "getAllFlatColumns")),
		_getAllFlatColumnsById: memo(() => [n.getAllFlatColumns()], (e) => e.reduce((e, t) => (e[t.id] = t, e), {}), getMemoOptions(e, "debugColumns", "getAllFlatColumnsById")),
		getAllLeafColumns: memo(() => [n.getAllColumns(), n._getOrderColumnsFn()], (e, t) => {
			let n = e.flatMap((e) => e.getLeafColumns());
			return t(n);
		}, getMemoOptions(e, "debugColumns", "getAllLeafColumns")),
		getColumn: (e) => {
			let t = n._getAllFlatColumnsById()[e];
			return process.env.NODE_ENV !== "production" && !t && console.error(`[Table] Column with id '${e}' does not exist.`), t;
		}
	};
	Object.assign(n, l);
	for (let e = 0; e < n._features.length; e++) {
		let t = n._features[e];
		t == null || t.createTable == null || t.createTable(n);
	}
	return n;
}
function getCoreRowModel() {
	return (e) => memo(() => [e.options.data], (t) => {
		let n = {
			rows: [],
			flatRows: [],
			rowsById: {}
		}, i = function(t, a, o) {
			a === void 0 && (a = 0);
			let s = [];
			for (let l = 0; l < t.length; l++) {
				let u = createRow(e, e._getRowId(t[l], l, o), t[l], l, a, void 0, o?.id);
				if (n.flatRows.push(u), n.rowsById[u.id] = u, s.push(u), e.options.getSubRows) {
					var c;
					u.originalSubRows = e.options.getSubRows(t[l], l), (c = u.originalSubRows) != null && c.length && (u.subRows = i(u.originalSubRows, a + 1, u));
				}
			}
			return s;
		};
		return n.rows = i(t), n;
	}, getMemoOptions(e.options, "debugTable", "getRowModel", () => e._autoResetPageIndex()));
}
function getSortedRowModel() {
	return (e) => memo(() => [e.getState().sorting, e.getPreSortedRowModel()], (t, n) => {
		if (!n.rows.length || !(t != null && t.length)) return n;
		let i = e.getState().sorting, a = [], o = i.filter((t) => e.getColumn(t.id)?.getCanSort()), s = {};
		o.forEach((t) => {
			let n = e.getColumn(t.id);
			n && (s[t.id] = {
				sortUndefined: n.columnDef.sortUndefined,
				invertSorting: n.columnDef.invertSorting,
				sortingFn: n.getSortingFn()
			});
		});
		let c = (e) => {
			let t = e.map((e) => ({ ...e }));
			return t.sort((e, t) => {
				for (let n = 0; n < o.length; n += 1) {
					let i = o[n], a = s[i.id], c = a.sortUndefined, l = i?.desc ?? !1, u = 0;
					if (c) {
						let n = e.getValue(i.id), a = t.getValue(i.id), o = n === void 0, s = a === void 0;
						if (o || s) {
							if (c === "first") return o ? -1 : 1;
							if (c === "last") return o ? 1 : -1;
							u = o && s ? 0 : o ? c : -c;
						}
					}
					if (u === 0 && (u = a.sortingFn(e, t, i.id)), u !== 0) return l && (u *= -1), a.invertSorting && (u *= -1), u;
				}
				return e.index - t.index;
			}), t.forEach((e) => {
				var t;
				a.push(e), (t = e.subRows) != null && t.length && (e.subRows = c(e.subRows));
			}), t;
		};
		return {
			rows: c(n.rows),
			flatRows: a,
			rowsById: n.rowsById
		};
	}, getMemoOptions(e.options, "debugTable", "getSortedRowModel", () => e._autoResetPageIndex()));
}
function flexRender(e, t) {
	return e ? isReactComponent(e) ? /* @__PURE__ */ import_react.createElement(e, t) : e : null;
}
function isReactComponent(e) {
	return isClassComponent(e) || typeof e == "function" || isExoticComponent(e);
}
function isClassComponent(e) {
	return typeof e == "function" && (() => {
		let t = Object.getPrototypeOf(e);
		return t.prototype && t.prototype.isReactComponent;
	})();
}
function isExoticComponent(e) {
	return typeof e == "object" && typeof e.$$typeof == "symbol" && ["react.memo", "react.forward_ref"].includes(e.$$typeof.description);
}
function useReactTable(e) {
	let t = {
		state: {},
		onStateChange: () => {},
		renderFallbackValue: null,
		...e
	}, [n] = import_react.useState(() => ({ current: createTable(t) })), [i, a] = import_react.useState(() => n.current.initialState);
	return n.current.setOptions((t) => ({
		...t,
		...e,
		state: {
			...i,
			...e.state
		},
		onStateChange: (t) => {
			a(t), e.onStateChange == null || e.onStateChange(t);
		}
	})), n.current;
}
function Table({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		"data-slot": "table-container",
		className: "relative w-full overflow-x-auto",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("table", {
			"data-slot": "table",
			className: cn("w-full caption-bottom text-sm", e),
			...t
		})
	});
}
function TableHeader({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("thead", {
		"data-slot": "table-header",
		className: cn("[&_tr]:border-b", e),
		...t
	});
}
function TableBody({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tbody", {
		"data-slot": "table-body",
		className: cn("[&_tr:last-child]:border-0", e),
		...t
	});
}
function TableRow({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("tr", {
		"data-slot": "table-row",
		className: cn("hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors", e),
		...t
	});
}
function TableHead({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("th", {
		"data-slot": "table-head",
		className: cn("text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", e),
		...t
	});
}
function TableCell({ className: e,...t }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("td", {
		"data-slot": "table-cell",
		className: cn("p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", e),
		...t
	});
}
var falsyToString = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e;
const cx = clsx;
var buttonVariants = ((e, t) => (n) => {
	if (t?.variants == null) return cx(e, n?.class, n?.className);
	let { variants: i, defaultVariants: a } = t, o = Object.keys(i).map((e) => {
		let t = n?.[e], o = a?.[e];
		if (t === null) return null;
		let s = falsyToString(t) || falsyToString(o);
		return i[e][s];
	}), s = n && Object.entries(n).reduce((e, t) => {
		let [n, i] = t;
		return i === void 0 || (e[n] = i), e;
	}, {}), c = t?.compoundVariants?.reduce((e, t) => {
		let { class: n, className: i,...o } = t;
		return Object.entries(o).every((e) => {
			let [t, n] = e;
			return Array.isArray(n) ? n.includes({
				...a,
				...s
			}[t]) : {
				...a,
				...s
			}[t] === n;
		}) ? [
			...e,
			n,
			i
		] : e;
	}, []);
	return cx(e, o, c, n?.class, n?.className);
})("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", {
	variants: {
		variant: {
			default: "bg-primary text-primary-foreground hover:bg-primary/90",
			destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
			outline: "border bg-background text-foreground shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
			secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
			ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
			link: "text-primary underline-offset-4 hover:underline"
		},
		size: {
			default: "h-9 px-4 py-2 has-[>svg]:px-3",
			sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
			lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
			icon: "size-9",
			"icon-sm": "size-8",
			"icon-lg": "size-10"
		}
	},
	defaultVariants: {
		variant: "default",
		size: "default"
	}
});
function Button({ className: e, variant: t, size: n, asChild: i = !1,...a }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(i ? Slot : "button", {
		"data-slot": "button",
		className: cn(buttonVariants({
			variant: t,
			size: n,
			className: e
		})),
		...a
	});
}
var formatNumber = (e, t = 0) => {
	if (e == null) return "";
	let n = typeof e == "string" ? Number(e) : e;
	return Number.isNaN(n) ? String(e) : Intl.NumberFormat(void 0, { maximumFractionDigits: t }).format(n);
};
function SortableHeader({ title: e, column: t }) {
	let n = t.getIsSorted();
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
		variant: "ghost",
		onClick: () => t.toggleSorting(n === "asc"),
		className: "-ml-3 h-8 px-2",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
			className: "mr-2",
			children: e
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ArrowUpDown, { className: "h-4 w-4" })]
	});
}
const ConcreteEmissionsTable = ({ data: e, title: t = "Top 15 products by total emissions", emissionsStats: n, palette: i = "RdYlGn" }) => {
	let [a, o] = import_react.useState([{
		id: "total_emissions",
		desc: !1
	}]), s = import_react.useMemo(() => {
		let e = (e) => n && !n.empty ? colorForEmissionsValue(n.min, n.max, e, i) : void 0;
		return [
			{
				accessorKey: "total_emissions",
				header: ({ column: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SortableHeader, {
					title: "Total (kg COe)",
					column: e
				}),
				cell: ({ row: t }) => {
					let n = t.getValue("total_emissions"), i = e(n);
					return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-right font-semibold tabular-nums",
						style: i ? { color: i } : void 0,
						children: formatNumber(n)
					});
				},
				enableSorting: !0,
				meta: { align: "right" }
			},
			{
				accessorKey: "brand",
				header: ({ column: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SortableHeader, {
					title: "Brand",
					column: e
				}),
				cell: ({ row: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "font-medium",
					children: e.getValue("brand")
				}),
				enableSorting: !0
			},
			{
				accessorKey: "mpa",
				header: ({ column: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SortableHeader, {
					title: "MPa",
					column: e
				}),
				cell: ({ row: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "text-right tabular-nums",
					children: formatNumber(e.getValue("mpa"), 1)
				}),
				enableSorting: !0,
				meta: { align: "right" }
			},
			{
				accessorKey: "kg_co2e_per_m3",
				header: ({ column: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SortableHeader, {
					title: "kg COe / m",
					column: e
				}),
				cell: ({ row: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "text-right tabular-nums",
					children: formatNumber(e.getValue("kg_co2e_per_m3"))
				}),
				enableSorting: !0,
				meta: { align: "right" }
			},
			{
				accessorKey: "embodied_emissions",
				header: ({ column: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SortableHeader, {
					title: "Embodied (kg COe)",
					column: e
				}),
				cell: ({ row: e }) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "text-right tabular-nums",
					children: formatNumber(e.getValue("embodied_emissions"))
				}),
				enableSorting: !0,
				meta: { align: "right" }
			}
		];
	}, [n, i]), c = useReactTable({
		data: e,
		columns: s,
		state: { sorting: a },
		onSortingChange: o,
		getCoreRowModel: getCoreRowModel(),
		getSortedRowModel: getSortedRowModel()
	}), l = c.getRowModel().rows.slice(0, 15);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Card, {
		className: "w-full",
		children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardHeader, {
			className: "flex flex-row items-center justify-between space-y-0",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardTitle, {
				className: "text-xl",
				children: t
			}), a.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Button, {
				variant: "secondary",
				size: "sm",
				onClick: () => o([]),
				className: "gap-1",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(X, { className: "h-4 w-4" }), " Clear sort"]
			}) : null]
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(CardContent, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
			className: "rounded-md border",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(Table, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableHeader, { children: c.getHeaderGroups().map((e) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableRow, { children: e.headers.map((e) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableHead, {
				className: e.column.columnDef.meta?.align === "right" ? "text-right" : void 0,
				children: e.isPlaceholder ? null : flexRender(e.column.columnDef.header, e.getContext())
			}, e.id)) }, e.id)) }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableBody, { children: l.length ? l.map((e) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableRow, {
				"data-state": e.getIsSelected() && "selected",
				children: e.getVisibleCells().map((e) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, {
					className: e.column.columnDef.meta?.align === "right" ? "text-right" : void 0,
					children: flexRender(e.column.columnDef.cell, e.getContext())
				}, e.id))
			}, e.id)) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableRow, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TableCell, {
				colSpan: s.length,
				className: "h-24 text-center",
				children: "No data"
			}) }) })] })
		}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
			className: "mt-3 text-xs text-muted-foreground text-left",
			children: "We can add something here if needed!"
		})] })]
	});
};
function TownProductsDialog({ open: e, onOpenChange: t, town: n, products: i, emissionsStats: a, palette: o = "RdYlGn" }) {
	let s = i?.length ?? 0, c = (0, import_react.useMemo)(() => !i || i.length === 0 ? null : i.reduce((e, t) => t.total_emissions < e.total_emissions ? t : e, i[0]), [i]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Dialog, {
		open: e,
		onOpenChange: t,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DialogContent, {
			className: "max-w-5xl lg:max-w-7xl",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)(DialogHeader, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogTitle, { children: n ?? "Details" }), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DialogDescription, { children: s > 0 ? `${s} products available` : "No products available for this town." })] }), s === 0 ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "text-sm text-muted-foreground",
				children: "Try selecting a different town to view products."
			}) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "grid grid-cols-1 md:grid-cols-4 gap-4",
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "md:col-span-1",
					children: c ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(product_emissions_card_default, {
						product: c,
						emissionsStats: a,
						palette: o
					}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Card, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-sm text-muted-foreground",
						children: "No top product available."
					}) }) })
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
					className: "md:col-span-3",
					children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ConcreteEmissionsTable, {
						data: i,
						title: `Products in ${n ?? ""} (sorted by total emissions)`,
						emissionsStats: a,
						palette: o
					})
				})]
			})]
		})
	});
}
var town_products_dialog_default = TownProductsDialog;
function MapHoverTooltip({ pt: e, variant: t, data: n }) {
	let i = Number(n?.plant_to_site_transport_emissions)?.toLocaleString(void 0, { maximumFractionDigits: 0 }), a = Number(n?.total_emissions)?.toLocaleString(void 0, { maximumFractionDigits: 0 });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "pointer-events-none absolute z-10",
		style: {
			left: e.x + 12,
			top: e.y + 12
		},
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Card, {
			className: "pointer-events-none bg-white/95 backdrop-blur p-2 shadow-md",
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CardContent, {
				className: "p-0 text-xs",
				children: t === "product" ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "min-w-[220px] max-w-[280px]",
					children: [
						/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
							className: "font-medium text-[12px] leading-tight",
							children: n?.town
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "text-muted-foreground mb-2",
							children: [
								n?.brand,
								" - ",
								n?.product_name,
								" ",
								/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
									className: "text-[11px] opacity-70",
									children: [
										"(",
										n?.kg_co2e_per_m3,
										" kg COe/m)"
									]
								})
							]
						}),
						/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
							className: "grid grid-cols-2 gap-x-3 gap-y-1",
							children: [
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
									className: "text-muted-foreground text-left",
									children: "MPa"
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
									className: "text-right",
									children: n?.mpa
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
									className: "text-muted-foreground text-left",
									children: "Transport Emissions"
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
									className: "text-right",
									children: [i, /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
										className: "text-[11px] opacity-70",
										children: " kg COe"
									})]
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
									className: "text-muted-foreground text-left",
									children: "Total emissions"
								}),
								/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
									className: "text-right",
									children: [a, /* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
										className: "text-[11px] opacity-70",
										children: " kg COe"
									})]
								})
							]
						})
					]
				}) : /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
					className: "min-w-[160px]",
					children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "font-medium text-[11px] leading-tight",
						children: "Town"
					}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-muted-foreground",
						children: n?.town
					})]
				})
			})
		})
	});
}
const epsilon = 11102230246251565e-32, splitter = 134217729;
(3 + 8 * epsilon) * epsilon;
function sum(e, t, n, i, a) {
	let o, s, c, l, u = t[0], d = i[0], f = 0, p = 0;
	d > u == d > -u ? (o = u, u = t[++f]) : (o = d, d = i[++p]);
	let m = 0;
	if (f < e && p < n) for (d > u == d > -u ? (s = u + o, c = o - (s - u), u = t[++f]) : (s = d + o, c = o - (s - d), d = i[++p]), o = s, c !== 0 && (a[m++] = c); f < e && p < n;) d > u == d > -u ? (s = o + u, l = s - o, c = o - (s - l) + (u - l), u = t[++f]) : (s = o + d, l = s - o, c = o - (s - l) + (d - l), d = i[++p]), o = s, c !== 0 && (a[m++] = c);
	for (; f < e;) s = o + u, l = s - o, c = o - (s - l) + (u - l), u = t[++f], o = s, c !== 0 && (a[m++] = c);
	for (; p < n;) s = o + d, l = s - o, c = o - (s - l) + (d - l), d = i[++p], o = s, c !== 0 && (a[m++] = c);
	return (o !== 0 || m === 0) && (a[m++] = o), m;
}
function estimate(e, t) {
	let n = t[0];
	for (let i = 1; i < e; i++) n += t[i];
	return n;
}
function vec(e) {
	return new Float64Array(e);
}
var ccwerrboundA = (3 + 16 * epsilon) * epsilon, ccwerrboundB = (2 + 12 * epsilon) * epsilon, ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon, B = vec(4), C1 = vec(8), C2 = vec(12), D = vec(16), u$2 = vec(4);
function orient2dadapt(e, t, n, i, a, o, s) {
	let c, l, u, d, f, p, m, h, g, _, v, y, b, x, S, C, w, T, E = e - a, O = n - a, k = t - o, A = i - o;
	x = E * A, p = splitter * E, m = p - (p - E), h = E - m, p = splitter * A, g = p - (p - A), _ = A - g, S = h * _ - (x - m * g - h * g - m * _), C = k * O, p = splitter * k, m = p - (p - k), h = k - m, p = splitter * O, g = p - (p - O), _ = O - g, w = h * _ - (C - m * g - h * g - m * _), v = S - w, f = S - v, B[0] = S - (v + f) + (f - w), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - C, f = b - v, B[1] = b - (v + f) + (f - C), T = y + v, f = T - y, B[2] = y - (T - f) + (v - f), B[3] = T;
	let j = estimate(4, B), M = ccwerrboundB * s;
	if (j >= M || -j >= M || (f = e - E, c = e - (E + f) + (f - a), f = n - O, u = n - (O + f) + (f - a), f = t - k, l = t - (k + f) + (f - o), f = i - A, d = i - (A + f) + (f - o), c === 0 && l === 0 && u === 0 && d === 0) || (M = ccwerrboundC * s + 33306690738754706e-32 * Math.abs(j), j += E * d + A * c - (k * u + O * l), j >= M || -j >= M)) return j;
	x = c * A, p = splitter * c, m = p - (p - c), h = c - m, p = splitter * A, g = p - (p - A), _ = A - g, S = h * _ - (x - m * g - h * g - m * _), C = l * O, p = splitter * l, m = p - (p - l), h = l - m, p = splitter * O, g = p - (p - O), _ = O - g, w = h * _ - (C - m * g - h * g - m * _), v = S - w, f = S - v, u$2[0] = S - (v + f) + (f - w), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - C, f = b - v, u$2[1] = b - (v + f) + (f - C), T = y + v, f = T - y, u$2[2] = y - (T - f) + (v - f), u$2[3] = T;
	let N = sum(4, B, 4, u$2, C1);
	x = E * d, p = splitter * E, m = p - (p - E), h = E - m, p = splitter * d, g = p - (p - d), _ = d - g, S = h * _ - (x - m * g - h * g - m * _), C = k * u, p = splitter * k, m = p - (p - k), h = k - m, p = splitter * u, g = p - (p - u), _ = u - g, w = h * _ - (C - m * g - h * g - m * _), v = S - w, f = S - v, u$2[0] = S - (v + f) + (f - w), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - C, f = b - v, u$2[1] = b - (v + f) + (f - C), T = y + v, f = T - y, u$2[2] = y - (T - f) + (v - f), u$2[3] = T;
	let P = sum(N, C1, 4, u$2, C2);
	x = c * d, p = splitter * c, m = p - (p - c), h = c - m, p = splitter * d, g = p - (p - d), _ = d - g, S = h * _ - (x - m * g - h * g - m * _), C = l * u, p = splitter * l, m = p - (p - l), h = l - m, p = splitter * u, g = p - (p - u), _ = u - g, w = h * _ - (C - m * g - h * g - m * _), v = S - w, f = S - v, u$2[0] = S - (v + f) + (f - w), y = x + v, f = y - x, b = x - (y - f) + (v - f), v = b - C, f = b - v, u$2[1] = b - (v + f) + (f - C), T = y + v, f = T - y, u$2[2] = y - (T - f) + (v - f), u$2[3] = T;
	let F = sum(P, C2, 4, u$2, D);
	return D[F - 1];
}
function orient2d(e, t, n, i, a, o) {
	let s = (t - o) * (n - a), c = (e - a) * (i - o), l = s - c, u = Math.abs(s + c);
	return Math.abs(l) >= ccwerrboundA * u ? l : -orient2dadapt(e, t, n, i, a, o, u);
}
(7 + 56 * epsilon) * epsilon, (3 + 28 * epsilon) * epsilon, (26 + 288 * epsilon) * epsilon * epsilon, vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(8), vec(8), vec(8), vec(4), vec(8), vec(8), vec(8), vec(12), vec(192), vec(192), (10 + 96 * epsilon) * epsilon, (4 + 48 * epsilon) * epsilon, (44 + 576 * epsilon) * epsilon * epsilon, vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(8), vec(8), vec(8), vec(8), vec(8), vec(8), vec(8), vec(8), vec(8), vec(4), vec(4), vec(4), vec(8), vec(16), vec(16), vec(16), vec(32), vec(32), vec(48), vec(64), vec(1152), vec(1152), (16 + 224 * epsilon) * epsilon, (5 + 72 * epsilon) * epsilon, (71 + 1408 * epsilon) * epsilon * epsilon, vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(4), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(24), vec(1152), vec(1152), vec(1152), vec(1152), vec(1152), vec(2304), vec(2304), vec(3456), vec(5760), vec(8), vec(8), vec(8), vec(16), vec(24), vec(48), vec(48), vec(96), vec(192), vec(384), vec(384), vec(384), vec(768), vec(96), vec(96), vec(96), vec(1152);
function pointInPolygon(e, t) {
	var n, i, a = 0, o, s, c, l, u, d, f, p = e[0], m = e[1], h = t.length;
	for (n = 0; n < h; n++) {
		i = 0;
		var g = t[n], _ = g.length - 1;
		if (d = g[0], d[0] !== g[_][0] && d[1] !== g[_][1]) throw Error("First and last coordinates in a ring must be the same");
		for (s = d[0] - p, c = d[1] - m; i < _; i++) {
			if (f = g[i + 1], l = f[0] - p, u = f[1] - m, c === 0 && u === 0) {
				if (l <= 0 && s >= 0 || s <= 0 && l >= 0) return 0;
			} else if (u >= 0 && c <= 0 || u <= 0 && c >= 0) {
				if (o = orient2d(s, l, c, u, 0, 0), o === 0) return 0;
				(o > 0 && u > 0 && c <= 0 || o < 0 && u <= 0 && c > 0) && a++;
			}
			d = f, c = u, s = l;
		}
	}
	return a % 2 != 0;
}
function getCoord(e) {
	if (!e) throw Error("coord is required");
	if (!Array.isArray(e)) {
		if (e.type === "Feature" && e.geometry !== null && e.geometry.type === "Point") return [...e.geometry.coordinates];
		if (e.type === "Point") return [...e.coordinates];
	}
	if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1])) return [...e];
	throw Error("coord must be GeoJSON Point or an Array of numbers");
}
function getGeom(e) {
	return e.type === "Feature" ? e.geometry : e;
}
function booleanPointInPolygon(e, t, n = {}) {
	if (!e) throw Error("point is required");
	if (!t) throw Error("polygon is required");
	let i = getCoord(e), a = getGeom(t), o = a.type, s = t.bbox, c = a.coordinates;
	if (s && inBBox(i, s) === !1) return !1;
	o === "Polygon" && (c = [c]);
	let l = !1;
	for (var u = 0; u < c.length; ++u) {
		let e = pointInPolygon(i, c[u]);
		if (e === 0) return !n.ignoreBoundary;
		e && (l = !0);
	}
	return l;
}
function inBBox(e, t) {
	return t[0] <= e[0] && t[1] <= e[1] && t[2] >= e[0] && t[3] >= e[1];
}
var turf_boolean_point_in_polygon_default = booleanPointInPolygon, REGION_TO_ISLAND = {
	NZAUK: "north",
	NZBOP: "north",
	NZGIS: "north",
	NZHKB: "north",
	NZMWT: "north",
	NZNTL: "north",
	NZTKI: "north",
	NZWGN: "north",
	NZWKO: "north",
	NZWTC: "north",
	NZNSN: "south",
	NZMBH: "south",
	NZOTA: "south",
	NZSTL: "south",
	NZTAS: "south",
	NZCAN: "south"
};
function getRegion(e, t, n) {
	let i = [t, e];
	for (let e of n.features) if ((e.geometry?.type === "Polygon" || e.geometry?.type === "MultiPolygon") && turf_boolean_point_in_polygon_default(i, e)) return e.properties?.id ?? null;
	return null;
}
function getIsland(e, t, n) {
	let i = getRegion(e, t, n);
	return i ? REGION_TO_ISLAND[i] ?? null : null;
}
var DEFAULT_PALETTE = "RdYlGn", NZ_BOUNDS = [[162, -51], [185, -31]], LR_LOCATION = [174.74903888650806, -36.860029339559816], SOURCE_DATA_ID = "points-src", CIRCLES_LAYER_ID = "circles-src", LINES_SOURCE_ID = "lines-src", LINES_LAYER_ID = "lines-layer", OTHER_TOWNS_SOURCE_ID = "other-towns-src", OTHER_TOWNS_LAYER_ID = "other-towns-layer";
const LocationSelector = (0, import_react.forwardRef)(function({ location: e, setLocation: t, styleUrl: n = "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json", className: i, nzPolygon: a, townToLocations: o, concreteProductsWithEmissions: s, initialZoom: c = 5, topNProducts: l = 15, maxNBestTowns: u = 5, locationIsland: d, setLocationIsland: f }, p) {
	if (!a) return null;
	let m = (0, import_react.useRef)(null), h = (0, import_react.useRef)(null), g = (0, import_react.useRef)(null), _ = (0, import_react.useRef)(null), v = (0, import_react.useRef)(null), y = (0, import_react.useRef)(e), b = (0, import_react.useRef)(null), [x, C] = (0, import_react.useState)(!1), [w, T] = (0, import_react.useState)(null), [E, O] = (0, import_react.useState)(null), [A, j] = (0, import_react.useState)(!1), M = (0, import_react.useRef)(!1), N = (e) => {
		M.current = e, j(e);
	};
	(0, import_react.useEffect)(() => {
		y.current = e;
	}, [e]);
	let P = (0, import_react.useMemo)(() => {
		let e = s?.reduce((e, t) => (e[t.town] || (e[t.town] = []), e[t.town].push(t), e), {});
		for (let t in e) e[t].sort((e, t) => e.total_emissions - t.total_emissions);
		return e;
	}, [s, o]), F = (0, import_react.useMemo)(() => s?.filter((e) => !d || e.island === d).slice(0, l) ?? [], [
		s,
		l,
		u,
		d
	]), I = (0, import_react.useMemo)(() => {
		let e = (F ?? []).map((e) => e.total_emissions);
		return computeMinMax(e);
	}, [F]), ee = (0, import_react.useMemo)(() => Array.from(new Set(F?.map((e) => e.town) ?? [])), [F]), L = (e) => {
		let t = ee.indexOf(e);
		if (t >= 0) {
			O({
				town: e,
				id: t,
				layer: CIRCLES_LAYER_ID
			});
			return;
		}
		let n = Object.keys(P ?? {}).filter((e) => !ee.includes(e)).indexOf(e);
		n >= 0 && O({
			town: e,
			id: `other-${n}`,
			layer: OTHER_TOWNS_LAYER_ID
		});
	};
	(0, import_react.useImperativeHandle)(p, () => ({ openTownDialog: L }), [ee, P]);
	let R = (0, import_react.useMemo)(() => ({
		type: "FeatureCollection",
		features: ee?.map((e, t) => {
			let n = P?.[e]?.[0] ?? null;
			if (!n) return null;
			let i = o[e];
			return {
				type: "Feature",
				id: t,
				properties: { ...n },
				geometry: {
					type: "Point",
					coordinates: [i.lon, i.lat]
				}
			};
		}) ?? []
	}), [
		P,
		o,
		ee
	]), te = (0, import_react.useMemo)(() => ({
		type: "FeatureCollection",
		features: Object.keys(P ?? {}).filter((e) => !ee?.includes(e)).map((e, t) => {
			let n = o[e];
			return {
				type: "Feature",
				id: `other-${t}`,
				properties: { town: e },
				geometry: {
					type: "Point",
					coordinates: [n.lon, n.lat]
				}
			};
		}) ?? []
	}), [
		o,
		P,
		ee
	]), ne = (0, import_react.useMemo)(() => {
		if (!e || !R?.features?.length) return {
			type: "FeatureCollection",
			features: []
		};
		let t = [e.lon, e.lat];
		return {
			type: "FeatureCollection",
			features: R.features.map((e, n) => ({
				type: "Feature",
				id: `line-${n}`,
				properties: { ...e.properties ?? {} },
				geometry: {
					type: "LineString",
					coordinates: [t, e.geometry.coordinates]
				}
			}))
		};
	}, [e, R]);
	(0, import_react.useEffect)(() => {
		if (!m.current || h.current) return;
		let i = e ? [e.lon, e.lat] : LR_LOCATION, o = new import_maplibre_gl.default.Map({
			container: m.current,
			style: n,
			center: i,
			zoom: c,
			maxBounds: NZ_BOUNDS,
			attributionControl: !1
		});
		h.current = o, o.addControl(new import_maplibre_gl.default.NavigationControl({ visualizePitch: !0 }), "top-right");
		let s, l;
		return o.on("load", () => {
			C(!0), o.getSource(SOURCE_DATA_ID) || o.addSource(SOURCE_DATA_ID, {
				type: "geojson",
				data: R
			}), o.getLayer(CIRCLES_LAYER_ID) || o.addLayer({
				id: CIRCLES_LAYER_ID,
				type: "circle",
				source: SOURCE_DATA_ID,
				paint: {
					"circle-radius": 8,
					"circle-opacity": .8,
					"circle-color": "#3b82f6",
					"circle-stroke-width": [
						"case",
						[
							"boolean",
							["feature-state", "selected"],
							!1
						],
						4,
						[
							"boolean",
							["feature-state", "hover"],
							!1
						],
						3,
						2
					],
					"circle-stroke-color": "#111827"
				}
			}), o.getSource(LINES_SOURCE_ID) || o.addSource(LINES_SOURCE_ID, {
				type: "geojson",
				data: ne
			}), o.getLayer(LINES_LAYER_ID) || o.addLayer({
				id: LINES_LAYER_ID,
				type: "line",
				source: LINES_SOURCE_ID,
				paint: {
					"line-color": "#60a5fa",
					"line-width": 2,
					"line-opacity": .6
				}
			}, CIRCLES_LAYER_ID), o.getSource(OTHER_TOWNS_SOURCE_ID) || o.addSource(OTHER_TOWNS_SOURCE_ID, {
				type: "geojson",
				data: te
			}), o.getLayer(OTHER_TOWNS_LAYER_ID) || o.addLayer({
				id: OTHER_TOWNS_LAYER_ID,
				type: "circle",
				source: OTHER_TOWNS_SOURCE_ID,
				paint: {
					"circle-radius": 6,
					"circle-opacity": .7,
					"circle-color": "#3b82f6",
					"circle-stroke-width": [
						"case",
						[
							"boolean",
							["feature-state", "selected"],
							!1
						],
						3,
						[
							"boolean",
							["feature-state", "hover"],
							!1
						],
						2,
						.5
					],
					"circle-stroke-color": "#1f2937"
				}
			}, CIRCLES_LAYER_ID);
			let n = (e) => (t) => {
				let n = t.features && t.features[0];
				if (!n) return;
				let i = n.id;
				i != null && O({
					id: i,
					layer: e,
					town: n.properties?.town
				});
			};
			o.on("click", CIRCLES_LAYER_ID, n(CIRCLES_LAYER_ID)), o.on("click", OTHER_TOWNS_LAYER_ID, n(OTHER_TOWNS_LAYER_ID)), s = n(CIRCLES_LAYER_ID), l = n(OTHER_TOWNS_LAYER_ID), o.on("mousemove", CIRCLES_LAYER_ID, (e) => {
				if (M.current) return;
				let t = e.features && e.features[0];
				if (!t) return;
				let n = e.point, i = t.id, a = CIRCLES_LAYER_ID;
				(v.current?.id !== i || v.current?.layer !== a) && (v.current?.id != null && o.setFeatureState({
					source: SOURCE_DATA_ID,
					id: v.current.id
				}, { hover: !1 }), i != null && o.setFeatureState({
					source: SOURCE_DATA_ID,
					id: i
				}, { hover: !0 }), v.current = {
					id: i,
					layer: a
				}), o.getCanvas().style.cursor = "pointer", _.current && cancelAnimationFrame(_.current), _.current = requestAnimationFrame(() => {
					T({
						pt: {
							x: n.x,
							y: n.y
						},
						props: t.properties,
						id: i,
						layer: a
					});
				});
			}), o.on("mouseleave", CIRCLES_LAYER_ID, () => {
				o.getCanvas().style.cursor = "", v.current?.id != null && v.current?.layer === CIRCLES_LAYER_ID && (o.setFeatureState({
					source: SOURCE_DATA_ID,
					id: v.current.id
				}, { hover: !1 }), v.current = null), T(null);
			}), o.on("mousemove", OTHER_TOWNS_LAYER_ID, (e) => {
				if (M.current) return;
				let t = e.features && e.features[0];
				if (!t) return;
				let n = e.point, i = t.id, a = OTHER_TOWNS_LAYER_ID;
				if (v.current?.id !== i || v.current?.layer !== a) {
					if (v.current?.id != null) {
						let e = v.current.layer === OTHER_TOWNS_LAYER_ID ? OTHER_TOWNS_SOURCE_ID : SOURCE_DATA_ID;
						o.setFeatureState({
							source: e,
							id: v.current.id
						}, { hover: !1 });
					}
					i != null && o.setFeatureState({
						source: OTHER_TOWNS_SOURCE_ID,
						id: i
					}, { hover: !0 }), v.current = {
						id: i,
						layer: a
					};
				}
				o.getCanvas().style.cursor = "pointer", _.current && cancelAnimationFrame(_.current), _.current = requestAnimationFrame(() => {
					T({
						pt: {
							x: n.x,
							y: n.y
						},
						props: t.properties,
						id: i,
						layer: a
					});
				});
			}), o.on("mouseleave", OTHER_TOWNS_LAYER_ID, () => {
				o.getCanvas().style.cursor = "", v.current?.id != null && v.current?.layer === OTHER_TOWNS_LAYER_ID && (o.setFeatureState({
					source: OTHER_TOWNS_SOURCE_ID,
					id: v.current.id
				}, { hover: !1 }), v.current = null), T(null);
			});
			let i = e ? [e.lon, e.lat] : LR_LOCATION, c = new import_maplibre_gl.default.Marker({ draggable: !0 }).setLngLat(i).addTo(o);
			c.on("dragstart", () => {
				if (N(!0), v.current?.id != null) {
					let e = v.current.layer === OTHER_TOWNS_LAYER_ID ? OTHER_TOWNS_SOURCE_ID : SOURCE_DATA_ID;
					o.setFeatureState({
						source: e,
						id: v.current.id
					}, { hover: !1 }), v.current = null;
				}
				T(null);
			}), c.on("dragend", () => {
				N(!1);
				let e = c.getLngLat(), n = getIsland(e.lat, e.lng, a);
				if (n === null) {
					g.current?.setLngLat(y.current ? [y.current.lon, y.current.lat] : LR_LOCATION);
					return;
				}
				f(n), t({
					lon: e.lng,
					lat: e.lat
				});
			}), g.current = c;
		}), o.on("click", (e) => {
			if (!g.current) return;
			let n = o.queryRenderedFeatures(e.point, { layers: [CIRCLES_LAYER_ID, OTHER_TOWNS_LAYER_ID] });
			if (n && n.length > 0) return;
			let { lng: i, lat: s } = e.lngLat.wrap(), c = getIsland(s, i, a);
			c !== null && (f(c), t({
				lon: i,
				lat: s
			}), g.current.setLngLat([i, s]));
		}), () => {
			try {
				if (g.current?.remove(), o && v.current?.id != null) {
					let e = v.current.layer === OTHER_TOWNS_LAYER_ID ? OTHER_TOWNS_SOURCE_ID : SOURCE_DATA_ID;
					o.setFeatureState({
						source: e,
						id: v.current.id
					}, { hover: !1 });
				}
				if (o && b.current?.id != null) {
					let e = b.current.layer === OTHER_TOWNS_LAYER_ID ? OTHER_TOWNS_SOURCE_ID : SOURCE_DATA_ID;
					o.setFeatureState({
						source: e,
						id: b.current.id
					}, { selected: !1 });
				}
				s && o.off("click", CIRCLES_LAYER_ID, s), l && o.off("click", OTHER_TOWNS_LAYER_ID, l), o.remove();
			} catch {}
			g.current = null, h.current = null;
		};
	}, [
		m,
		h,
		g,
		n
	]), (0, import_react.useEffect)(() => {
		let e = h.current, t = e?.getSource(SOURCE_DATA_ID);
		e && t && t.setData(R);
	}, [R]), (0, import_react.useEffect)(() => {
		let e = h.current, t = e?.getSource(LINES_SOURCE_ID);
		e && t && t.setData(ne);
	}, [ne]), (0, import_react.useEffect)(() => {
		let e = h.current, t = e?.getSource(OTHER_TOWNS_SOURCE_ID);
		e && t && t.setData(te);
	}, [te]), (0, import_react.useEffect)(() => {
		let e = h.current;
		if (!e) return;
		let { min: t, max: n, empty: i } = I, a = i ? "#9ca3af" : buildColorStops(t, n, 7, DEFAULT_PALETTE), o = i ? .5 : buildOpacityStops(t, n, 1, WORST_OPACITY_FLOOR);
		e.getLayer(CIRCLES_LAYER_ID) && (e.setPaintProperty(CIRCLES_LAYER_ID, "circle-color", a), e.setPaintProperty(CIRCLES_LAYER_ID, "circle-opacity", o)), e.getLayer(LINES_LAYER_ID) && (e.setPaintProperty(LINES_LAYER_ID, "line-color", a), e.setPaintProperty(LINES_LAYER_ID, "line-opacity", i ? .6 : buildOpacityStops(t, n, 1, WORST_OPACITY_FLOOR)));
	}, [I, x]), (0, import_react.useEffect)(() => {
		let e = h.current;
		if (e) {
			if (!E && b.current) {
				let t = b.current.layer === OTHER_TOWNS_LAYER_ID ? OTHER_TOWNS_SOURCE_ID : SOURCE_DATA_ID;
				e.setFeatureState({
					source: t,
					id: b.current.id
				}, { selected: !1 }), b.current = null;
				return;
			}
			if (E) {
				if (b.current && (b.current.id !== E.id || b.current.layer !== E.layer)) {
					let t = b.current.layer === OTHER_TOWNS_LAYER_ID ? OTHER_TOWNS_SOURCE_ID : SOURCE_DATA_ID;
					e.setFeatureState({
						source: t,
						id: b.current.id
					}, { selected: !1 });
				}
				let t = E.layer === OTHER_TOWNS_LAYER_ID ? OTHER_TOWNS_SOURCE_ID : SOURCE_DATA_ID;
				e.setFeatureState({
					source: t,
					id: E.id
				}, { selected: !0 }), b.current = E;
			}
		}
	}, [E]);
	let ie = (0, import_react.useMemo)(() => E?.town ? P?.[E.town] ?? [] : [], [E, P]);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		className: "relative w-full h-[800px] rounded-2xl overflow-hidden" + (i ?? ""),
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				ref: m,
				className: "absolute inset-0 h-full w-full",
				id: "map"
			}),
			w && !A && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MapHoverTooltip, {
				pt: w.pt,
				variant: w.layer === CIRCLES_LAYER_ID ? "product" : "town",
				data: w.props
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)(town_products_dialog_default, {
				open: !!E,
				onOpenChange: (e) => {
					e || O(null);
				},
				town: E?.town ?? null,
				products: ie,
				emissionsStats: I,
				palette: DEFAULT_PALETTE
			}),
			e && /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "pointer-events-none absolute bottom-3 left-3 z-10 rounded-xl bg-white/90 px-3 py-1.5 text-xs shadow",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
						className: "font-medium",
						children: "Selected:"
					}),
					" ",
					e.lat.toFixed(5),
					",",
					" ",
					e.lon.toFixed(5),
					""
				]
			})
		]
	});
});
var cdnUrl = "https://cdn.jsdelivr.net/gh/TheLeverRoom/LRCarbonCrete@latest";
function App() {
	let [e, t] = (0, import_react.useState)([]), [n, i] = (0, import_react.useState)([]), [a, o] = (0, import_react.useState)(null), [s, c] = (0, import_react.useState)([]), [l, u] = (0, import_react.useState)("17.5"), [d, f] = (0, import_react.useState)(100), [p, m] = (0, import_react.useState)({
		lon: 174.74903888650806,
		lat: -36.860029339559816
	}), [h, g] = (0, import_react.useState)("north"), [_, v] = (0, import_react.useState)({}), [y, b] = (0, import_react.useState)([]), [x, C] = (0, import_react.useState)(null), w = (0, import_react.useRef)(null);
	return (0, import_react.useEffect)(() => {
		async function e() {
			try {
				let e = `${cdnUrl}/data/towns.json`, n = `${cdnUrl}/data/nz.json`, a = `${cdnUrl}/data/concrete.json`, [s, u, f] = await Promise.all([
					fetch(a),
					fetch(e),
					fetch(n)
				]);
				if (!s.ok || !u.ok) throw Error("Failed to load one or more JSON files");
				let [m, g, _] = await Promise.all([
					s.json(),
					u.json(),
					f.json()
				]);
				t(m), i(g), o(_);
				let y = g.reduce((e, t) => (e[t.name] = {
					lon: t.lon,
					lat: t.lat
				}, e), {}), x = m.filter((e) => e.mpa >= parseFloat(l));
				c(x);
				let S = calculateEmissions(x, y, d, p);
				b(S), v(y), C(S.filter((e) => h === null || e.island === h)[0]);
			} catch (e) {
				console.error(e);
			}
		}
		e();
	}, [p, d]), (0, import_react.useEffect)(() => {
		let t = e.filter((e) => e.mpa >= parseFloat(l));
		c(t);
	}, [e, l]), (0, import_react.useEffect)(() => {
		if (s.length > 0) {
			let e = calculateEmissions(s, _, d, p);
			b(e);
		}
	}, [
		s,
		d,
		p,
		_
	]), a !== null && n.length > 0 && e.length > 0 ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "mx-auto px-4 w-full",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
			className: "grid grid-cols-1 md:grid-cols-4 gap-4",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				className: "col-span-1",
				children: [
					/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
						className: "flex flex-row gap-4 mt-6 justify-between row-span-1 mb-4",
						children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(MpaSelect, {
							mpa: l,
							onMpaChange: u
						}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(QuantityRequired, {
							quantity: d,
							onQuantityChange: f
						})]
					}),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)(ProductEmissionsCard, { product: x }),
					/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
						className: "text-left ml-2",
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
							className: "text-sm text-muted-foreground italic",
							children: [
								"located",
								" ",
								/* @__PURE__ */ (0, import_jsx_runtime.jsx)("span", {
									onClick: () => {
										x?.town && w.current?.openTownDialog(x.town);
									},
									className: "underline cursor-pointer hover:text-blue-500",
									children: x?.town
								})
							]
						})
					})
				]
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
				className: "flex flex-row gap-4 mt-6 justify-between col-span-3",
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(LocationSelector, {
					ref: w,
					location: p,
					setLocation: m,
					nzPolygon: a,
					townToLocations: _,
					concreteProductsWithEmissions: y,
					topNProducts: 75,
					maxNBestTowns: 5,
					locationIsland: h,
					setLocationIsland: g
				})
			})]
		})
	}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", {
		className: "mx-auto px-4 w-full",
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("span", {
			className: "flex items-baseline space-x-2",
			children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("h1", {
				className: "text-left mb-0",
				children: "CarbonCrete"
			}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", {
				className: "text-sm text-muted-foreground",
				children: "by The Lever Room"
			})]
		})
	});
}
var App_default = App;
(0, import_client.createRoot)(document.getElementById("root")).render(/* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(App_default, {}) }));
